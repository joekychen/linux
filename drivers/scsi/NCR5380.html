<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › NCR5380.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>NCR5380.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* </span>
<span class="cm"> * NCR 5380 generic driver routines.  These should make it *trivial*</span>
<span class="cm"> *      to implement 5380 SCSI drivers under Linux with a non-trantor</span>
<span class="cm"> *      architecture.</span>
<span class="cm"> *</span>
<span class="cm"> *      Note that these routines also work with NR53c400 family chips.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1993, Drew Eckhardt</span>
<span class="cm"> *      Visionary Computing </span>
<span class="cm"> *      (Unix and Linux consulting and custom programming)</span>
<span class="cm"> *      drew@colorado.edu</span>
<span class="cm"> *      +1 (303) 666-5836</span>
<span class="cm"> *</span>
<span class="cm"> * DISTRIBUTION RELEASE 6. </span>
<span class="cm"> *</span>
<span class="cm"> * For more information, please consult </span>
<span class="cm"> *</span>
<span class="cm"> * NCR 5380 Family</span>
<span class="cm"> * SCSI Protocol Controller</span>
<span class="cm"> * Databook</span>
<span class="cm"> *</span>
<span class="cm"> * NCR Microelectronics</span>
<span class="cm"> * 1635 Aeroplaza Drive</span>
<span class="cm"> * Colorado Springs, CO 80916</span>
<span class="cm"> * 1+ (719) 578-3400</span>
<span class="cm"> * 1+ (800) 334-5454</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * $Log: NCR5380.c,v $</span>

<span class="cm"> * Revision 1.10 1998/9/2	Alan Cox</span>
<span class="cm"> *				(alan@lxorguk.ukuu.org.uk)</span>
<span class="cm"> * Fixed up the timer lockups reported so far. Things still suck. Looking </span>
<span class="cm"> * forward to 2.3 and per device request queues. Then it&#39;ll be possible to</span>
<span class="cm"> * SMP thread this beast and improve life no end.</span>
<span class="cm"> </span>
<span class="cm"> * Revision 1.9  1997/7/27	Ronald van Cuijlenborg</span>
<span class="cm"> *				(ronald.van.cuijlenborg@tip.nl or nutty@dds.nl)</span>
<span class="cm"> * (hopefully) fixed and enhanced USLEEP</span>
<span class="cm"> * added support for DTC3181E card (for Mustek scanner)</span>
<span class="cm"> *</span>

<span class="cm"> * Revision 1.8			Ingmar Baumgart</span>
<span class="cm"> *				(ingmar@gonzo.schwaben.de)</span>
<span class="cm"> * added support for NCR53C400a card</span>
<span class="cm"> *</span>

<span class="cm"> * Revision 1.7  1996/3/2       Ray Van Tassle (rayvt@comm.mot.com)</span>
<span class="cm"> * added proc_info</span>
<span class="cm"> * added support needed for DTC 3180/3280</span>
<span class="cm"> * fixed a couple of bugs</span>
<span class="cm"> *</span>

<span class="cm"> * Revision 1.5  1994/01/19  09:14:57  drew</span>
<span class="cm"> * Fixed udelay() hack that was being used on DATAOUT phases</span>
<span class="cm"> * instead of a proper wait for the final handshake.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 1.4  1994/01/19  06:44:25  drew</span>
<span class="cm"> * *** empty log message ***</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 1.3  1994/01/19  05:24:40  drew</span>
<span class="cm"> * Added support for TCR LAST_BYTE_SENT bit.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 1.2  1994/01/15  06:14:11  drew</span>
<span class="cm"> * REAL DMA support, bug fixes.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 1.1  1994/01/15  06:00:54  drew</span>
<span class="cm"> * Initial revision</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Further development / testing that should be done : </span>
<span class="cm"> * 1.  Cleanup the NCR5380_transfer_dma function and DMA operation complete</span>
<span class="cm"> *     code so that everything does the same thing that&#39;s done at the </span>
<span class="cm"> *     end of a pseudo-DMA read operation.</span>
<span class="cm"> *</span>
<span class="cm"> * 2.  Fix REAL_DMA (interrupt driven, polled works fine) -</span>
<span class="cm"> *     basically, transfer size needs to be reduced by one </span>
<span class="cm"> *     and the last byte read as is done with PSEUDO_DMA.</span>
<span class="cm"> * </span>
<span class="cm"> * 4.  Test SCSI-II tagged queueing (I have no devices which support </span>
<span class="cm"> *      tagged queueing)</span>
<span class="cm"> *</span>
<span class="cm"> * 5.  Test linked command handling code after Eric is ready with </span>
<span class="cm"> *      the high level code.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;scsi/scsi_dbg.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_spi.h&gt;</span>

<span class="cp">#ifndef NDEBUG</span>
<span class="cp">#define NDEBUG 0</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef NDEBUG_ABORT</span>
<span class="cp">#define NDEBUG_ABORT 0</span>
<span class="cp">#endif</span>

<span class="cp">#if (NDEBUG &amp; NDEBUG_LISTS)</span>
<span class="cp">#define LIST(x,y) {printk(&quot;LINE:%d   Adding %p to %p\n&quot;, __LINE__, (void*)(x), (void*)(y)); if ((x)==(y)) udelay(5); }</span>
<span class="cp">#define REMOVE(w,x,y,z) {printk(&quot;LINE:%d   Removing: %p-&gt;%p  %p-&gt;%p \n&quot;, __LINE__, (void*)(w), (void*)(x), (void*)(y), (void*)(z)); if ((x)==(y)) udelay(5); }</span>
<span class="cp">#else</span>
<span class="cp">#define LIST(x,y)</span>
<span class="cp">#define REMOVE(w,x,y,z)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef notyet</span>
<span class="cp">#undef LINKED</span>
<span class="cp">#undef REAL_DMA</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef REAL_DMA_POLL</span>
<span class="cp">#undef READ_OVERRUNS</span>
<span class="cp">#define READ_OVERRUNS</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef BOARD_REQUIRES_NO_DELAY</span>
<span class="cp">#define io_recovery_delay(x)</span>
<span class="cp">#else</span>
<span class="cp">#define io_recovery_delay(x)	udelay(x)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Design</span>
<span class="cm"> *</span>
<span class="cm"> * This is a generic 5380 driver.  To use it on a different platform, </span>
<span class="cm"> * one simply writes appropriate system specific macros (ie, data</span>
<span class="cm"> * transfer - some PC&#39;s will use the I/O bus, 68K&#39;s must use </span>
<span class="cm"> * memory mapped) and drops this file in their &#39;C&#39; wrapper.</span>
<span class="cm"> *</span>
<span class="cm"> * (Note from hch:  unfortunately it was not enough for the different</span>
<span class="cm"> * m68k folks and instead of improving this driver they copied it</span>
<span class="cm"> * and hacked it up for their needs.  As a consequence they lost</span>
<span class="cm"> * most updates to this driver.  Maybe someone will fix all these</span>
<span class="cm"> * drivers to use a common core one day..)</span>
<span class="cm"> *</span>
<span class="cm"> * As far as command queueing, two queues are maintained for </span>
<span class="cm"> * each 5380 in the system - commands that haven&#39;t been issued yet,</span>
<span class="cm"> * and commands that are currently executing.  This means that an </span>
<span class="cm"> * unlimited number of commands may be queued, letting </span>
<span class="cm"> * more commands propagate from the higher driver levels giving higher </span>
<span class="cm"> * throughput.  Note that both I_T_L and I_T_L_Q nexuses are supported, </span>
<span class="cm"> * allowing multiple commands to propagate all the way to a SCSI-II device </span>
<span class="cm"> * while a command is already executing.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Issues specific to the NCR5380 : </span>
<span class="cm"> *</span>
<span class="cm"> * When used in a PIO or pseudo-dma mode, the NCR5380 is a braindead </span>
<span class="cm"> * piece of hardware that requires you to sit in a loop polling for </span>
<span class="cm"> * the REQ signal as long as you are connected.  Some devices are </span>
<span class="cm"> * brain dead (ie, many TEXEL CD ROM drives) and won&#39;t disconnect </span>
<span class="cm"> * while doing long seek operations.</span>
<span class="cm"> * </span>
<span class="cm"> * The workaround for this is to keep track of devices that have</span>
<span class="cm"> * disconnected.  If the device hasn&#39;t disconnected, for commands that</span>
<span class="cm"> * should disconnect, we do something like </span>
<span class="cm"> *</span>
<span class="cm"> * while (!REQ is asserted) { sleep for N usecs; poll for M usecs }</span>
<span class="cm"> * </span>
<span class="cm"> * Some tweaking of N and M needs to be done.  An algorithm based </span>
<span class="cm"> * on &quot;time to data&quot; would give the best results as long as short time</span>
<span class="cm"> * to datas (ie, on the same track) were considered, however these </span>
<span class="cm"> * broken devices are the exception rather than the rule and I&#39;d rather</span>
<span class="cm"> * spend my time optimizing for the normal case.</span>
<span class="cm"> *</span>
<span class="cm"> * Architecture :</span>
<span class="cm"> *</span>
<span class="cm"> * At the heart of the design is a coroutine, NCR5380_main,</span>
<span class="cm"> * which is started from a workqueue for each NCR5380 host in the</span>
<span class="cm"> * system.  It attempts to establish I_T_L or I_T_L_Q nexuses by</span>
<span class="cm"> * removing the commands from the issue queue and calling</span>
<span class="cm"> * NCR5380_select() if a nexus is not established. </span>
<span class="cm"> *</span>
<span class="cm"> * Once a nexus is established, the NCR5380_information_transfer()</span>
<span class="cm"> * phase goes through the various phases as instructed by the target.</span>
<span class="cm"> * if the target goes into MSG IN and sends a DISCONNECT message,</span>
<span class="cm"> * the command structure is placed into the per instance disconnected</span>
<span class="cm"> * queue, and NCR5380_main tries to find more work.  If the target is </span>
<span class="cm"> * idle for too long, the system will try to sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * If a command has disconnected, eventually an interrupt will trigger,</span>
<span class="cm"> * calling NCR5380_intr()  which will in turn call NCR5380_reselect</span>
<span class="cm"> * to reestablish a nexus.  This will run main if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * On command termination, the done function will be called as </span>
<span class="cm"> * appropriate.</span>
<span class="cm"> *</span>
<span class="cm"> * SCSI pointers are maintained in the SCp field of SCSI command </span>
<span class="cm"> * structures, being initialized after the command is connected</span>
<span class="cm"> * in NCR5380_select, and set as appropriate in NCR5380_information_transfer.</span>
<span class="cm"> * Note that in violation of the standard, an implicit SAVE POINTERS operation</span>
<span class="cm"> * is done, since some BROKEN disks fail to issue an explicit SAVE POINTERS.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Using this file :</span>
<span class="cm"> * This file a skeleton Linux SCSI driver for the NCR 5380 series</span>
<span class="cm"> * of chips.  To use it, you write an architecture specific functions </span>
<span class="cm"> * and macros and include this file in your driver.</span>
<span class="cm"> *</span>
<span class="cm"> * These macros control options : </span>
<span class="cm"> * AUTOPROBE_IRQ - if defined, the NCR5380_probe_irq() function will be </span>
<span class="cm"> *      defined.</span>
<span class="cm"> * </span>
<span class="cm"> * AUTOSENSE - if defined, REQUEST SENSE will be performed automatically</span>
<span class="cm"> *      for commands that return with a CHECK CONDITION status. </span>
<span class="cm"> *</span>
<span class="cm"> * DIFFERENTIAL - if defined, NCR53c81 chips will use external differential</span>
<span class="cm"> *      transceivers. </span>
<span class="cm"> *</span>
<span class="cm"> * DONT_USE_INTR - if defined, never use interrupts, even if we probe or</span>
<span class="cm"> *      override-configure an IRQ.</span>
<span class="cm"> *</span>
<span class="cm"> * LIMIT_TRANSFERSIZE - if defined, limit the pseudo-dma transfers to 512</span>
<span class="cm"> *      bytes at a time.  Since interrupts are disabled by default during</span>
<span class="cm"> *      these transfers, we might need this to give reasonable interrupt</span>
<span class="cm"> *      service time if the transfer size gets too large.</span>
<span class="cm"> *</span>
<span class="cm"> * LINKED - if defined, linked commands are supported.</span>
<span class="cm"> *</span>
<span class="cm"> * PSEUDO_DMA - if defined, PSEUDO DMA is used during the data transfer phases.</span>
<span class="cm"> *</span>
<span class="cm"> * REAL_DMA - if defined, REAL DMA is used during the data transfer phases.</span>
<span class="cm"> *</span>
<span class="cm"> * REAL_DMA_POLL - if defined, REAL DMA is used but the driver doesn&#39;t</span>
<span class="cm"> *      rely on phase mismatch and EOP interrupts to determine end </span>
<span class="cm"> *      of phase.</span>
<span class="cm"> *</span>
<span class="cm"> * UNSAFE - leave interrupts enabled during pseudo-DMA transfers.  You</span>
<span class="cm"> *          only really want to use this if you&#39;re having a problem with</span>
<span class="cm"> *          dropped characters during high speed communications, and even</span>
<span class="cm"> *          then, you&#39;re going to be better off twiddling with transfersize</span>
<span class="cm"> *          in the high level code.</span>
<span class="cm"> *</span>
<span class="cm"> * Defaults for these will be provided although the user may want to adjust </span>
<span class="cm"> * these to allocate CPU resources to the SCSI driver or &quot;real&quot; code.</span>
<span class="cm"> * </span>
<span class="cm"> * USLEEP_SLEEP - amount of time, in jiffies, to sleep</span>
<span class="cm"> *</span>
<span class="cm"> * USLEEP_POLL - amount of time, in jiffies, to poll</span>
<span class="cm"> *</span>
<span class="cm"> * These macros MUST be defined :</span>
<span class="cm"> * NCR5380_local_declare() - declare any local variables needed for your</span>
<span class="cm"> *      transfer routines.</span>
<span class="cm"> *</span>
<span class="cm"> * NCR5380_setup(instance) - initialize any local variables needed from a given</span>
<span class="cm"> *      instance of the host adapter for NCR5380_{read,write,pread,pwrite}</span>
<span class="cm"> * </span>
<span class="cm"> * NCR5380_read(register)  - read from the specified register</span>
<span class="cm"> *</span>
<span class="cm"> * NCR5380_write(register, value) - write to the specific register </span>
<span class="cm"> *</span>
<span class="cm"> * NCR5380_implementation_fields  - additional fields needed for this </span>
<span class="cm"> *      specific implementation of the NCR5380</span>
<span class="cm"> *</span>
<span class="cm"> * Either real DMA *or* pseudo DMA may be implemented</span>
<span class="cm"> * REAL functions : </span>
<span class="cm"> * NCR5380_REAL_DMA should be defined if real DMA is to be used.</span>
<span class="cm"> * Note that the DMA setup functions should return the number of bytes </span>
<span class="cm"> *      that they were able to program the controller for.</span>
<span class="cm"> *</span>
<span class="cm"> * Also note that generic i386/PC versions of these macros are </span>
<span class="cm"> *      available as NCR5380_i386_dma_write_setup,</span>
<span class="cm"> *      NCR5380_i386_dma_read_setup, and NCR5380_i386_dma_residual.</span>
<span class="cm"> *</span>
<span class="cm"> * NCR5380_dma_write_setup(instance, src, count) - initialize</span>
<span class="cm"> * NCR5380_dma_read_setup(instance, dst, count) - initialize</span>
<span class="cm"> * NCR5380_dma_residual(instance); - residual count</span>
<span class="cm"> *</span>
<span class="cm"> * PSEUDO functions :</span>
<span class="cm"> * NCR5380_pwrite(instance, src, count)</span>
<span class="cm"> * NCR5380_pread(instance, dst, count);</span>
<span class="cm"> *</span>
<span class="cm"> * The generic driver is initialized by calling NCR5380_init(instance),</span>
<span class="cm"> * after setting the appropriate host specific fields and ID.  If the </span>
<span class="cm"> * driver wishes to autoprobe for an IRQ line, the NCR5380_probe_irq(instance,</span>
<span class="cm"> * possible) function may be used.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">do_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">do_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	initialize_SCp		-	init the scsi pointer field</span>
<span class="cm"> *	@cmd: command block to set up</span>
<span class="cm"> *</span>
<span class="cm"> *	Set up the internal fields in the SCSI command.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">initialize_SCp</span><span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* </span>
<span class="cm">	 * Initialize the Scsi Pointer field so that all of the commands in the </span>
<span class="cm">	 * various queues are valid.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span> <span class="o">=</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	NCR5380_poll_politely	-	wait for NCR5380 status bits</span>
<span class="cm"> *	@instance: controller to poll</span>
<span class="cm"> *	@reg: 5380 register to poll</span>
<span class="cm"> *	@bit: Bitmask to check</span>
<span class="cm"> *	@val: Value required to exit</span>
<span class="cm"> *</span>
<span class="cm"> *	Polls the NCR5380 in a reasonably efficient manner waiting for</span>
<span class="cm"> *	an event to occur, after a short quick poll we begin giving the</span>
<span class="cm"> *	CPU back in non IRQ contexts</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns the value of the register or a negative error code.</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kt">int</span> <span class="nf">NCR5380_poll_politely</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>		<span class="cm">/* At about 8uS a cycle for the cpu access */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	
	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span> <span class="n">n</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span><span class="p">((</span><span class="n">r</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>
	
	<span class="cm">/* t time yet ? */</span>
	<span class="k">while</span><span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span><span class="p">((</span><span class="n">r</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">in_interrupt</span><span class="p">())</span>
			<span class="n">cond_resched</span><span class="p">();</span>
		<span class="k">else</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">phases</span><span class="p">[]</span> <span class="n">__maybe_unused</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PHASE_DATAOUT</span><span class="p">,</span> <span class="s">&quot;DATAOUT&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">PHASE_DATAIN</span><span class="p">,</span> <span class="s">&quot;DATAIN&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">PHASE_CMDOUT</span><span class="p">,</span> <span class="s">&quot;CMDOUT&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">PHASE_STATIN</span><span class="p">,</span> <span class="s">&quot;STATIN&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">PHASE_MSGOUT</span><span class="p">,</span> <span class="s">&quot;MSGOUT&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">PHASE_MSGIN</span><span class="p">,</span> <span class="s">&quot;MSGIN&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">PHASE_UNKNOWN</span><span class="p">,</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">}</span>
<span class="p">};</span>

<span class="cp">#if NDEBUG</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">signals</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
	<span class="p">{</span><span class="n">SR_DBP</span><span class="p">,</span> <span class="s">&quot;PARITY&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">SR_RST</span><span class="p">,</span> <span class="s">&quot;RST&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">SR_BSY</span><span class="p">,</span> <span class="s">&quot;BSY&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">SR_REQ</span><span class="p">,</span> <span class="s">&quot;REQ&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">SR_MSG</span><span class="p">,</span> <span class="s">&quot;MSG&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">SR_CD</span><span class="p">,</span> <span class="s">&quot;CD&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">SR_IO</span><span class="p">,</span> <span class="s">&quot;IO&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">SR_SEL</span><span class="p">,</span> <span class="s">&quot;SEL&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>
<span class="p">},</span> 
<span class="n">basrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">BASR_ATN</span><span class="p">,</span> <span class="s">&quot;ATN&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">BASR_ACK</span><span class="p">,</span> <span class="s">&quot;ACK&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>
<span class="p">},</span> 
<span class="n">icrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
	<span class="p">{</span><span class="n">ICR_ASSERT_RST</span><span class="p">,</span> <span class="s">&quot;ASSERT RST&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">ICR_ASSERT_ACK</span><span class="p">,</span> <span class="s">&quot;ASSERT ACK&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">ICR_ASSERT_BSY</span><span class="p">,</span> <span class="s">&quot;ASSERT BSY&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">ICR_ASSERT_SEL</span><span class="p">,</span> <span class="s">&quot;ASSERT SEL&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">ICR_ASSERT_ATN</span><span class="p">,</span> <span class="s">&quot;ASSERT ATN&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">ICR_ASSERT_DATA</span><span class="p">,</span> <span class="s">&quot;ASSERT DATA&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>
<span class="p">},</span> 
<span class="n">mrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
	<span class="p">{</span><span class="n">MR_BLOCK_DMA_MODE</span><span class="p">,</span> <span class="s">&quot;MODE BLOCK DMA&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">MR_TARGET</span><span class="p">,</span> <span class="s">&quot;MODE TARGET&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">MR_ENABLE_PAR_CHECK</span><span class="p">,</span> <span class="s">&quot;MODE PARITY CHECK&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">MR_ENABLE_PAR_INTR</span><span class="p">,</span> <span class="s">&quot;MODE PARITY INTR&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">MR_MONITOR_BSY</span><span class="p">,</span> <span class="s">&quot;MODE MONITOR BSY&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">MR_DMA_MODE</span><span class="p">,</span> <span class="s">&quot;MODE DMA&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="n">MR_ARBITRATE</span><span class="p">,</span> <span class="s">&quot;MODE ARBITRATION&quot;</span><span class="p">},</span> 
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	NCR5380_print	-	print scsi bus signals</span>
<span class="cm"> *	@instance:	adapter state to dump</span>
<span class="cm"> *</span>
<span class="cm"> *	Print the SCSI bus signals for debugging purposes</span>
<span class="cm"> *</span>
<span class="cm"> *	Locks: caller holds hostdata lock (not essential)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">NCR5380_print</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">basr</span><span class="p">,</span> <span class="n">mr</span><span class="p">,</span> <span class="n">icr</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">CURRENT_SCSI_DATA_REG</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">);</span>
	<span class="n">mr</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">);</span>
	<span class="n">icr</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">);</span>
	<span class="n">basr</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;STATUS_REG: %02x &quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">signals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">signals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,%s&quot;</span><span class="p">,</span> <span class="n">signals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">BASR: %02x &quot;</span><span class="p">,</span> <span class="n">basr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">basrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">basr</span> <span class="o">&amp;</span> <span class="n">basrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,%s&quot;</span><span class="p">,</span> <span class="n">basrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">ICR: %02x &quot;</span><span class="p">,</span> <span class="n">icr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">icrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">icrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,%s&quot;</span><span class="p">,</span> <span class="n">icrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">MODE: %02x &quot;</span><span class="p">,</span> <span class="n">mr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mr</span> <span class="o">&amp;</span> <span class="n">mrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,%s&quot;</span><span class="p">,</span> <span class="n">mrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* </span>
<span class="cm"> *	NCR5380_print_phase	-	show SCSI phase</span>
<span class="cm"> *	@instance: adapter to dump</span>
<span class="cm"> *</span>
<span class="cm"> * 	Print the current SCSI phase for debugging purposes</span>
<span class="cm"> *</span>
<span class="cm"> *	Locks: none</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">NCR5380_print_phase</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d : REQ not asserted, phase unknown.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span> <span class="o">!=</span> <span class="n">PHASE_UNKNOWN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span> <span class="o">!=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">));</span> <span class="o">++</span><span class="n">i</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d : phase %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * These need tweaking, and would probably work best as per-device </span>
<span class="cm"> * flags initialized differently for disk, tape, cd, etc devices.</span>
<span class="cm"> * People with broken devices are free to experiment as to what gives</span>
<span class="cm"> * the best results for them.</span>
<span class="cm"> *</span>
<span class="cm"> * USLEEP_SLEEP should be a minimum seek time.</span>
<span class="cm"> *</span>
<span class="cm"> * USLEEP_POLL should be a maximum rotational latency.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef USLEEP_SLEEP</span>
<span class="cm">/* 20 ms (reasonable hard disk speed) */</span>
<span class="cp">#define USLEEP_SLEEP (20*HZ/1000)</span>
<span class="cp">#endif</span>
<span class="cm">/* 300 RPM (floppy speed) */</span>
<span class="cp">#ifndef USLEEP_POLL</span>
<span class="cp">#define USLEEP_POLL (200*HZ/1000)</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef USLEEP_WAITLONG</span>
<span class="cm">/* RvC: (reasonable time to wait on select error) */</span>
<span class="cp">#define USLEEP_WAITLONG USLEEP_SLEEP</span>
<span class="cp">#endif</span>

<span class="cm">/* </span>
<span class="cm"> * Function : int should_disconnect (unsigned char cmd)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : decide whether a command would normally disconnect or </span>
<span class="cm"> *      not, since if it won&#39;t disconnect we should go to sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * Input : cmd - opcode of SCSI command</span>
<span class="cm"> *</span>
<span class="cm"> * Returns : DISCONNECT_LONG if we should disconnect for a really long </span>
<span class="cm"> *      time (ie always, sleep, look for REQ active, sleep), </span>
<span class="cm"> *      DISCONNECT_TIME_TO_DATA if we would only disconnect for a normal</span>
<span class="cm"> *      time-to-data delay, DISCONNECT_NONE if this command would return</span>
<span class="cm"> *      immediately.</span>
<span class="cm"> *</span>
<span class="cm"> *      Future sleep algorithms based on time to data can exploit </span>
<span class="cm"> *      something like this so they can differentiate between &quot;normal&quot; </span>
<span class="cm"> *      (ie, read, write, seek) and unusual commands (ie, * format).</span>
<span class="cm"> *</span>
<span class="cm"> * Note : We don&#39;t deal with commands that handle an immediate disconnect,</span>
<span class="cm"> *        </span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">should_disconnect</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">READ_6</span>:
	<span class="k">case</span> <span class="n">WRITE_6</span>:
	<span class="k">case</span> <span class="n">SEEK_6</span>:
	<span class="k">case</span> <span class="n">READ_10</span>:
	<span class="k">case</span> <span class="n">WRITE_10</span>:
	<span class="k">case</span> <span class="n">SEEK_10</span>:
		<span class="k">return</span> <span class="n">DISCONNECT_TIME_TO_DATA</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FORMAT_UNIT</span>:
	<span class="k">case</span> <span class="n">SEARCH_HIGH</span>:
	<span class="k">case</span> <span class="n">SEARCH_LOW</span>:
	<span class="k">case</span> <span class="n">SEARCH_EQUAL</span>:
		<span class="k">return</span> <span class="n">DISCONNECT_LONG</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">DISCONNECT_NONE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">NCR5380_set_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">coroutine</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">probe_irq</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *	probe_intr	-	helper for IRQ autoprobe</span>
<span class="cm"> *	@irq: interrupt number</span>
<span class="cm"> *	@dev_id: unused</span>
<span class="cm"> *	@regs: unused</span>
<span class="cm"> *</span>
<span class="cm"> *	Set a flag to indicate the IRQ in question was received. This is</span>
<span class="cm"> *	used by the IRQ probe code.</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">__init</span> <span class="nf">probe_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">probe_irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	NCR5380_probe_irq	-	find the IRQ of an NCR5380</span>
<span class="cm"> *	@instance: NCR5380 controller</span>
<span class="cm"> *	@possible: bitmask of ISA IRQ lines</span>
<span class="cm"> *</span>
<span class="cm"> *	Autoprobe for the IRQ line used by the NCR5380 by triggering an IRQ</span>
<span class="cm"> *	and then looking to see what interrupt actually turned up.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locks: none, irqs must be enabled on entry</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">__maybe_unused</span> <span class="nf">NCR5380_probe_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">possible</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">trying_irqs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">trying_irqs</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">possible</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">probe_intr</span><span class="p">,</span> <span class="n">IRQF_DISABLED</span><span class="p">,</span> <span class="s">&quot;NCR-probe&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">trying_irqs</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="mi">250</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">probe_irq</span> <span class="o">=</span> <span class="n">SCSI_IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A interrupt is triggered whenever BSY = false, SEL = true</span>
<span class="cm">	 * and a bit set in the SELECT_ENABLE_REG is asserted on the </span>
<span class="cm">	 * SCSI bus.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that the bus is only driven when the phase control signals</span>
<span class="cm">	 * (I/O, C/D, and MSG) match those in the TCR, so we must reset that</span>
<span class="cm">	 * to zero.</span>
<span class="cm">	 */</span>

	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">OUTPUT_DATA_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_DATA</span> <span class="o">|</span> <span class="n">ICR_ASSERT_SEL</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">probe_irq</span> <span class="o">==</span> <span class="n">SCSI_IRQ_NONE</span> <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trying_irqs</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">probe_irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	NCR58380_print_options	-	show options</span>
<span class="cm"> *	@instance: unused for now</span>
<span class="cm"> *</span>
<span class="cm"> *	Called by probe code indicating the NCR5380 driver options that </span>
<span class="cm"> *	were selected. At some point this will switch to runtime options</span>
<span class="cm"> *	read from the adapter in question</span>
<span class="cm"> *</span>
<span class="cm"> *	Locks: none</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">__maybe_unused</span>
<span class="nf">NCR5380_print_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; generic options&quot;</span>
<span class="cp">#ifdef AUTOPROBE_IRQ</span>
	       <span class="s">&quot; AUTOPROBE_IRQ&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef AUTOSENSE</span>
	       <span class="s">&quot; AUTOSENSE&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef DIFFERENTIAL</span>
	       <span class="s">&quot; DIFFERENTIAL&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef REAL_DMA</span>
	       <span class="s">&quot; REAL DMA&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef REAL_DMA_POLL</span>
	       <span class="s">&quot; REAL DMA POLL&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PARITY</span>
	       <span class="s">&quot; PARITY&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PSEUDO_DMA</span>
	       <span class="s">&quot; PSEUDO DMA&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef UNSAFE</span>
	       <span class="s">&quot; UNSAFE &quot;</span>
<span class="cp">#endif</span>
	    <span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; USLEEP, USLEEP_POLL=%d USLEEP_SLEEP=%d&quot;</span><span class="p">,</span> <span class="n">USLEEP_POLL</span><span class="p">,</span> <span class="n">USLEEP_SLEEP</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; generic release=%d&quot;</span><span class="p">,</span> <span class="n">NCR5380_PUBLIC_RELEASE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_NCR53C400</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; ncr53c400 release=%d&quot;</span><span class="p">,</span> <span class="n">NCR53C400_PUBLIC_RELEASE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	NCR5380_print_status 	-	dump controller info</span>
<span class="cm"> *	@instance: controller to dump</span>
<span class="cm"> *</span>
<span class="cm"> *	Print commands in the various queues, called from NCR5380_abort </span>
<span class="cm"> *	and NCR5380_debug to aid debugging.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locks: called functions disable irqs</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">NCR5380_print_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">NCR5380_dprint</span><span class="p">(</span><span class="n">NDEBUG_ANY</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>
	<span class="n">NCR5380_dprint_phase</span><span class="p">(</span><span class="n">NDEBUG_ANY</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************************/</span>
<span class="cm">/*</span>
<span class="cm"> * /proc/scsi/[dtc pas16 t128 generic]/[0-ASC_NUM_BOARD_SUPPORTED]</span>
<span class="cm"> *</span>
<span class="cm"> * *buffer: I/O buffer</span>
<span class="cm"> * **start: if inout == FALSE pointer into buffer where user read should start</span>
<span class="cm"> * offset: current offset</span>
<span class="cm"> * length: length of buffer</span>
<span class="cm"> * hostno: Scsi_Host host_no</span>
<span class="cm"> * inout: TRUE - user is writing; FALSE - user is reading</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of bytes read from or written</span>
<span class="cm"> */</span>

<span class="cp">#undef SPRINTF</span>
<span class="cp">#define SPRINTF(args...) do { if(pos &lt; buffer + length-80) pos += sprintf(pos, ## args); } while(0)</span>
<span class="k">static</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">lprint_Scsi_Cmnd</span><span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>
<span class="k">static</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">lprint_command</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">lprint_opcode</span><span class="p">(</span><span class="kt">int</span> <span class="n">opcode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__maybe_unused</span> <span class="nf">NCR5380_proc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* Has data been written to the file ? */</span>
<span class="cp">#ifdef DTC_PUBLIC_RELEASE</span>
		<span class="n">dtc_wmaxi</span> <span class="o">=</span> <span class="n">dtc_maxi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PAS16_PUBLIC_RELEASE</span>
		<span class="n">pas_wmaxi</span> <span class="o">=</span> <span class="n">pas_maxi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">ENOSYS</span><span class="p">);</span>	<span class="cm">/* Currently this is a no-op */</span>
	<span class="p">}</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;NCR5380 core release=%d.   &quot;</span><span class="p">,</span> <span class="n">NCR5380_PUBLIC_RELEASE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_NCR53C400</span><span class="p">)</span>
		<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;ncr53c400 release=%d.  &quot;</span><span class="p">,</span> <span class="n">NCR53C400_PUBLIC_RELEASE</span><span class="p">);</span>
<span class="cp">#ifdef DTC_PUBLIC_RELEASE</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;DTC 3180/3280 release %d&quot;</span><span class="p">,</span> <span class="n">DTC_PUBLIC_RELEASE</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef T128_PUBLIC_RELEASE</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;T128 release %d&quot;</span><span class="p">,</span> <span class="n">T128_PUBLIC_RELEASE</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef GENERIC_NCR5380_PUBLIC_RELEASE</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;Generic5380 release %d&quot;</span><span class="p">,</span> <span class="n">GENERIC_NCR5380_PUBLIC_RELEASE</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PAS16_PUBLIC_RELEASE</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;PAS16 release=%d&quot;</span><span class="p">,</span> <span class="n">PAS16_PUBLIC_RELEASE</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Base Addr: 0x%05lX    &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;io_port: %04x      &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">io_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="n">SCSI_IRQ_NONE</span><span class="p">)</span>
		<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;IRQ: None.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;IRQ: %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

<span class="cp">#ifdef DTC_PUBLIC_RELEASE</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;Highwater I/O busy_spin_counts -- write: %d  read: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dtc_wmaxi</span><span class="p">,</span> <span class="n">dtc_maxi</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PAS16_PUBLIC_RELEASE</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;Highwater I/O busy_spin_counts -- write: %d  read: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pas_wmaxi</span><span class="p">,</span> <span class="n">pas_maxi</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span>
		<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;scsi%d: no currently connected command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">lprint_Scsi_Cmnd</span><span class="p">((</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;scsi%d: issue_queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">;</span> <span class="n">ptr</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">lprint_Scsi_Cmnd</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;scsi%d: disconnected_queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">;</span> <span class="n">ptr</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">lprint_Scsi_Cmnd</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	
	<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">lprint_Scsi_Cmnd</span><span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;scsi%d : destination target %d, lun %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;        command = &quot;</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">lprint_command</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">lprint_command</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">lprint_opcode</span><span class="p">(</span><span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">COMMAND_SIZE</span><span class="p">(</span><span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">command</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">lprint_opcode</span><span class="p">(</span><span class="kt">int</span> <span class="n">opcode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;%2d (0x%02x)&quot;</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">opcode</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	NCR5380_init	-	initialise an NCR5380</span>
<span class="cm"> *	@instance: adapter to configure</span>
<span class="cm"> *	@flags: control flags</span>
<span class="cm"> *</span>
<span class="cm"> *	Initializes *instance and corresponding 5380 chip,</span>
<span class="cm"> *      with flags OR&#39;d into the initial flags value.</span>
<span class="cm"> *</span>
<span class="cm"> *	Notes : I assume that the host, hostno, and id bits have been</span>
<span class="cm"> *      set correctly.  I don&#39;t care about the irq and other fields. </span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 for success</span>
<span class="cm"> *</span>
<span class="cm"> *	Locks: interrupts must be enabled when we are called </span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">NCR5380_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">pass</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">())</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NCR5380_init called with interrupts off!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* </span>
<span class="cm">	 * On NCR53C400 boards, NCR5380 registers are mapped 8 past </span>
<span class="cm">	 * the base address.</span>
<span class="cm">	 */</span>

<span class="cp">#ifdef NCR53C400</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_NCR53C400</span><span class="p">)</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">NCR5380_instance_name</span> <span class="o">+=</span> <span class="n">NCR53C400_address_adjust</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">aborted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">this_id</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">)</span>
			<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_higher_mask</span> <span class="o">|=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef REAL_DMA</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">dmalen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">targets_present</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">coroutine</span><span class="p">,</span> <span class="n">NCR5380_main</span><span class="p">);</span>
	
<span class="cp">#ifdef NCR5380_STATS</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_read</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_write</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">bytes_read</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">bytes_write</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">timebase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">pendingw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">pendingr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* The CHECK code seems to break the 53C400. Will check it later maybe */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_NCR53C400</span><span class="p">)</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">FLAG_HAS_LAST_BYTE_SENT</span> <span class="o">|</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">FLAG_CHECK_LAST_BYTE_SENT</span> <span class="o">|</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_expires</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifndef AUTOSENSE</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;scsi%d : WARNING : support for multiple outstanding commands enabled</span><span class="se">\n</span><span class="s">&quot;</span> <span class="s">&quot;         without AUTOSENSE option, contingent allegiance conditions may</span><span class="se">\n</span><span class="s">&quot;</span>
		    	   <span class="s">&quot;         be incorrectly cleared.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
<span class="cp">#endif				</span><span class="cm">/* def AUTOSENSE */</span><span class="cp"></span>

	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef NCR53C400</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_NCR53C400</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">C400_CONTROL_STATUS_REG</span><span class="p">,</span> <span class="n">CSR_BASE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* </span>
<span class="cm">	 * Detect and correct bus wedge problems.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the system crashed, it may have crashed in a state </span>
<span class="cm">	 * where a SCSI command was still executing, and the </span>
<span class="cm">	 * SCSI bus is not in a BUS FREE STATE.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If this is the case, we&#39;ll try to abort the currently</span>
<span class="cm">	 * established nexus which we know nothing about, and that</span>
<span class="cm">	 * failing, do a hard reset of the SCSI bus </span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_BSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pass</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">pass</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">pass</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">case</span> <span class="mi">3</span>:
		<span class="k">case</span> <span class="mi">5</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scsi%d: SCSI bus busy, waiting up to five seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
			<span class="n">NCR5380_poll_politely</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">STATUS_REG</span><span class="p">,</span> <span class="n">SR_BSY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;scsi%d: bus busy, attempting abort</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
			<span class="n">do_abort</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;scsi%d: bus busy, attempting reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
			<span class="n">do_reset</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">6</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;scsi%d: bus locked solid or invalid override</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	NCR5380_exit	-	remove an NCR5380</span>
<span class="cm"> *	@instance: adapter to remove</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">NCR5380_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">coroutine</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	NCR5380_queue_command 		-	queue a command</span>
<span class="cm"> *	@cmd: SCSI command</span>
<span class="cm"> *	@done: completion handler</span>
<span class="cm"> *</span>
<span class="cm"> *      cmd is added to the per instance issue_queue, with minor </span>
<span class="cm"> *      twiddling done to the host specific fields of cmd.  If the </span>
<span class="cm"> *      main coroutine is not running, it is restarted.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locks: host lock taken by caller</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">NCR5380_queue_command_lck</span><span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

<span class="cp">#if (NDEBUG &amp; NDEBUG_NO_WRITE)</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">WRITE_6</span>:
	<span class="k">case</span> <span class="n">WRITE_10</span>:
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d : WRITE attempted with NO_WRITE debugging flag set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* (NDEBUG &amp; NDEBUG_NO_WRITE) */</span><span class="cp"></span>

<span class="cp">#ifdef NCR5380_STATS</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">WRITE</span>:
		<span class="k">case</span> <span class="n">WRITE_6</span>:
		<span class="k">case</span> <span class="n">WRITE_10</span>:
			<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_write</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">timebase</span><span class="p">);</span>
			<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">bytes_write</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">pendingw</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">READ</span>:
		<span class="k">case</span> <span class="n">READ_6</span>:
		<span class="k">case</span> <span class="n">READ_10</span>:
			<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_read</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">timebase</span><span class="p">);</span>
			<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">bytes_read</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">pendingr</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* </span>
<span class="cm">	 * We use the host_scribble field as a pointer to the next command  </span>
<span class="cm">	 * in a queue </span>
<span class="cm">	 */</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* </span>
<span class="cm">	 * Insert the cmd into the issue queue. Note that REQUEST SENSE </span>
<span class="cm">	 * commands are added to the head of the queue since any command will</span>
<span class="cm">	 * clear the contingent allegiance condition that exists and the </span>
<span class="cm">	 * sense data is only guaranteed to be valid while the condition exists.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">LIST</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">;</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">);</span>
		<span class="n">LIST</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_QUEUES</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : command added to %s of queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;head&quot;</span> <span class="o">:</span> <span class="s">&quot;tail&quot;</span><span class="p">));</span>

	<span class="cm">/* Run the coroutine if it isn&#39;t already running. */</span>
	<span class="cm">/* Kick off command processing */</span>
	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">coroutine</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">NCR5380_queue_command</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> *	NCR5380_main	-	NCR state machines</span>
<span class="cm"> *</span>
<span class="cm"> *	NCR5380_main is a coroutine that runs as long as more work can </span>
<span class="cm"> *      be done on the NCR5380 host adapters in a system.  Both </span>
<span class="cm"> *      NCR5380_queue_command() and NCR5380_intr() will try to start it </span>
<span class="cm"> *      in case it is not running.</span>
<span class="cm"> * </span>
<span class="cm"> *	Locks: called as its own thread with no locks held. Takes the</span>
<span class="cm"> *	host lock and called routines may take the isa dma lock.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">NCR5380_main</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">NCR5380_hostdata</span><span class="p">,</span> <span class="n">coroutine</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done</span><span class="p">;</span>
	
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Lock held here */</span>
		<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">selecting</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_MAIN</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : not connected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
			<span class="cm">/*</span>
<span class="cm">			 * Search through the issue_queue for a command destined</span>
<span class="cm">			 * for a target that&#39;s not busy.</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">)</span> 
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">)</span>
					<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_LISTS</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;MAIN tmp=%p   target=%d   busy=%d lun=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">],</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">));</span>
				<span class="cm">/*  When we find one, remove it from the issue queue. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">)))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">REMOVE</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">);</span>
						<span class="n">prev</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">REMOVE</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">);</span>
						<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

					<span class="cm">/* </span>
<span class="cm">					 * Attempt to establish an I_T_L nexus here. </span>
<span class="cm">					 * On success, instance-&gt;hostdata-&gt;connected is set.</span>
<span class="cm">					 * On failure, we must add the command back to the</span>
<span class="cm">					 *   issue queue so we can keep trying. </span>
<span class="cm">					 */</span>
					<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_MAIN</span><span class="o">|</span><span class="n">NDEBUG_QUEUES</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : main() : command for target %d lun %d removed from issue_queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">));</span>
	
					<span class="cm">/*</span>
<span class="cm">					 * A successful selection is defined as one that </span>
<span class="cm">					 * leaves us with the command connected and </span>
<span class="cm">					 * in hostdata-&gt;connected, OR has terminated the</span>
<span class="cm">					 * command.</span>
<span class="cm">					 *</span>
<span class="cm">					 * With successful commands, we fall through</span>
<span class="cm">					 * and see if we can do an information transfer,</span>
<span class="cm">					 * with failures we will restart.</span>
<span class="cm">					 */</span>
					<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">selecting</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="cm">/* RvC: have to preset this to indicate a new command is being performed */</span>

					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NCR5380_select</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span>
							    <span class="cm">/* </span>
<span class="cm">							     * REQUEST SENSE commands are issued without tagged</span>
<span class="cm">							     * queueing, even on SCSI-II devices because the </span>
<span class="cm">							     * contingent allegiance condition exists for the </span>
<span class="cm">							     * entire unit.</span>
<span class="cm">							     */</span>
							    <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="o">?</span> <span class="n">TAG_NONE</span> <span class="o">:</span> <span class="n">TAG_NEXT</span><span class="p">))</span> <span class="p">{</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">LIST</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">);</span>
						<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">;</span>
						<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
						<span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_MAIN</span><span class="o">|</span><span class="n">NDEBUG_QUEUES</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : main(): select() failed, returned to issue_queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
					<span class="p">}</span>
					<span class="cm">/* lock held here still */</span>
				<span class="p">}</span>	<span class="cm">/* if target/lun is not busy */</span>
			<span class="p">}</span>	<span class="cm">/* for */</span>
			<span class="cm">/* exited locked */</span>
		<span class="p">}</span>	<span class="cm">/* if (!hostdata-&gt;connected) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">selecting</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">selecting</span><span class="p">;</span>
			<span class="cm">/* Selection will drop and retake the lock */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NCR5380_select</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="o">?</span> <span class="n">TAG_NONE</span> <span class="o">:</span> <span class="n">TAG_NEXT</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Ok ?? */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* RvC: device failed, so we wait a long time</span>
<span class="cm">				   this is needed for Mustek scanners, that</span>
<span class="cm">				   do not respond to commands immediately</span>
<span class="cm">				   after a scan */</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;scsi%d: device %d did not respond in time</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
				<span class="n">LIST</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">);</span>
				<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">;</span>
				<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
				<span class="n">NCR5380_set_timer</span><span class="p">(</span><span class="n">hostdata</span><span class="p">,</span> <span class="n">USLEEP_WAITLONG</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>	<span class="cm">/* if hostdata-&gt;selecting */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span>
<span class="cp">#ifdef REAL_DMA</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">dmalen</span>
<span class="cp">#endif</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_expires</span> <span class="o">||</span> <span class="n">time_before_eq</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_expires</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">))</span>
		    <span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_MAIN</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : main() : performing information transfer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
			<span class="n">NCR5380_information_transfer</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_MAIN</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : main() : done set false</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">);</span>
	
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef DONT_USE_INTR</span>

<span class="cm">/**</span>
<span class="cm"> * 	NCR5380_intr	-	generic NCR5380 irq handler</span>
<span class="cm"> *	@irq: interrupt number</span>
<span class="cm"> *	@dev_id: device info</span>
<span class="cm"> *</span>
<span class="cm"> *	Handle interrupts, reestablishing I_T_L or I_T_L_Q nexuses</span>
<span class="cm"> *      from the disconnected queue, and restarting NCR5380_main() </span>
<span class="cm"> *      as required.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locks: takes the needed instance locks</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">NCR5380_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">dummy</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">basr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_INTR</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi : NCR5380 irq %d triggered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">));</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* Look for pending interrupts */</span>
		<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
		<span class="n">basr</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">);</span>
		<span class="cm">/* XXX dispatch to appropriate routine if found and done=0 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">basr</span> <span class="o">&amp;</span> <span class="n">BASR_IRQ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NCR5380_dprint</span><span class="p">(</span><span class="n">NDEBUG_INTR</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SR_SEL</span> <span class="o">|</span> <span class="n">SR_IO</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">SR_SEL</span> <span class="o">|</span> <span class="n">SR_IO</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_INTR</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : SEL interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
				<span class="n">NCR5380_reselect</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
				<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">RESET_PARITY_INTERRUPT_REG</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">basr</span> <span class="o">&amp;</span> <span class="n">BASR_PARITY_ERROR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_INTR</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : PARITY interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
				<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">RESET_PARITY_INTERRUPT_REG</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_RST</span><span class="p">)</span> <span class="o">==</span> <span class="n">SR_RST</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_INTR</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : RESET interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
				<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">RESET_PARITY_INTERRUPT_REG</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#if defined(REAL_DMA)</span>
				<span class="cm">/*</span>
<span class="cm">				 * We should only get PHASE MISMATCH and EOP interrupts</span>
<span class="cm">				 * if we have DMA enabled, so do a sanity check based on</span>
<span class="cm">				 * the current setting of the MODE register.</span>
<span class="cm">				 */</span>

				<span class="k">if</span> <span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MR_DMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">basr</span> <span class="o">&amp;</span> <span class="n">BASR_END_DMA_TRANSFER</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">basr</span> <span class="o">&amp;</span> <span class="n">BASR_PHASE_MATCH</span><span class="p">)))</span> <span class="p">{</span>
					<span class="kt">int</span> <span class="n">transferred</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span>
						<span class="n">panic</span><span class="p">(</span><span class="s">&quot;scsi%d : received end of DMA interrupt with no connected cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostno</span><span class="p">);</span>

					<span class="n">transferred</span> <span class="o">=</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">dmalen</span> <span class="o">-</span> <span class="n">NCR5380_dma_residual</span><span class="p">(</span><span class="n">instance</span><span class="p">));</span>
					<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">-=</span> <span class="n">transferred</span><span class="p">;</span>
					<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">+=</span> <span class="n">transferred</span><span class="p">;</span>
					<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">dmalen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

					<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">RESET_PARITY_INTERRUPT_REG</span><span class="p">);</span>
							
					<span class="cm">/* FIXME: we need to poll briefly then defer a workqueue task ! */</span>
					<span class="n">NCR5380_poll_politely</span><span class="p">(</span><span class="n">hostdata</span><span class="p">,</span> <span class="n">BUS_AND_STATUS_REG</span><span class="p">,</span> <span class="n">BASR_ACK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>

					<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
					<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
				<span class="p">}</span>
<span class="cp">#else</span>
				<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_INTR</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi : unknown interrupt, BASR 0x%X, MR 0x%X, SR 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">basr</span><span class="p">,</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">),</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)));</span>
				<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">RESET_PARITY_INTERRUPT_REG</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="p">}</span>
		<span class="p">}</span>	<span class="cm">/* if BASR_IRQ */</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span>
			<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">coroutine</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span>

<span class="cm">/**</span>
<span class="cm"> *	collect_stats		-	collect stats on a scsi command</span>
<span class="cm"> *	@hostdata: adapter </span>
<span class="cm"> *	@cmd: command being issued</span>
<span class="cm"> *</span>
<span class="cm"> *	Update the statistical data by parsing the command in question</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kt">void</span> <span class="nf">collect_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span><span class="p">,</span> <span class="n">Scsi_Cmnd</span> <span class="o">*</span> <span class="n">cmd</span><span class="p">)</span> 
<span class="p">{</span>
<span class="cp">#ifdef NCR5380_STATS</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">WRITE</span>:
	<span class="k">case</span> <span class="n">WRITE_6</span>:
	<span class="k">case</span> <span class="n">WRITE_10</span>:
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_write</span><span class="p">[</span><span class="n">scmd_id</span><span class="p">(</span><span class="n">cmd</span><span class="p">)]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">timebase</span><span class="p">);</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">pendingw</span><span class="o">--</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">READ</span>:
	<span class="k">case</span> <span class="n">READ_6</span>:
	<span class="k">case</span> <span class="n">READ_10</span>:
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_read</span><span class="p">[</span><span class="n">scmd_id</span><span class="p">(</span><span class="n">cmd</span><span class="p">)]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">timebase</span><span class="p">);</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">pendingr</span><span class="o">--</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/* </span>
<span class="cm"> * Function : int NCR5380_select (struct Scsi_Host *instance, Scsi_Cmnd *cmd, </span>
<span class="cm"> *      int tag);</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : establishes I_T_L or I_T_L_Q nexus for new or existing command,</span>
<span class="cm"> *      including ARBITRATION, SELECTION, and initial message out for </span>
<span class="cm"> *      IDENTIFY and queue messages. </span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : instance - instantiation of the 5380 driver on which this </span>
<span class="cm"> *      target lives, cmd - SCSI command to execute, tag - set to TAG_NEXT for </span>
<span class="cm"> *      new tag, TAG_NONE for untagged queueing, otherwise set to the tag for </span>
<span class="cm"> *      the command that is presently connected.</span>
<span class="cm"> * </span>
<span class="cm"> * Returns : -1 if selection could not execute for some reason,</span>
<span class="cm"> *      0 if selection succeeded or failed because the target </span>
<span class="cm"> *      did not respond.</span>
<span class="cm"> *</span>
<span class="cm"> * Side effects : </span>
<span class="cm"> *      If bus busy, arbitration failed, etc, NCR5380_select() will exit </span>
<span class="cm"> *              with registers as they should have been on entry - ie</span>
<span class="cm"> *              SELECT_ENABLE will be set appropriately, the NCR5380</span>
<span class="cm"> *              will cease to drive any SCSI bus signals.</span>
<span class="cm"> *</span>
<span class="cm"> *      If successful : I_T_L or I_T_L_Q nexus will be established, </span>
<span class="cm"> *              instance-&gt;connected will be set to cmd.  </span>
<span class="cm"> *              SELECT interrupt will be disabled.</span>
<span class="cm"> *</span>
<span class="cm"> *      If failed (no target) : cmd-&gt;scsi_done() will be called, and the </span>
<span class="cm"> *              cmd-&gt;result host byte set to DID_BAD_TARGET.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locks: caller holds hostdata lock in IRQ mode</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kt">int</span> <span class="nf">NCR5380_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">Scsi_Cmnd</span> <span class="o">*</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">phase</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">selecting</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">part2</span><span class="p">;</span>

	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">restart_select</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">NCR5380_dprint</span><span class="p">(</span><span class="n">NDEBUG_ARBITRATION</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_ARBITRATION</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : starting arbitration, id = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">this_id</span><span class="p">));</span>

	<span class="cm">/* </span>
<span class="cm">	 * Set the phase bits to 0, otherwise the NCR5380 won&#39;t drive the </span>
<span class="cm">	 * data bus during SELECTION.</span>
<span class="cm">	 */</span>

	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * Start arbitration.</span>
<span class="cm">	 */</span>

	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">OUTPUT_DATA_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_ARBITRATE</span><span class="p">);</span>


	<span class="cm">/* We can be relaxed here, interrupts are on, we are</span>
<span class="cm">	   in workqueue context, the birds are singing in the trees */</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">NCR5380_poll_politely</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_ARBITRATION_PROGRESS</span><span class="p">,</span> <span class="n">ICR_ARBITRATION_PROGRESS</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;scsi: arbitration timeout at %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_ARBITRATION</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : arbitration complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>

	<span class="cm">/* </span>
<span class="cm">	 * The arbitration delay is 2.2us, but this is a minimum and there is </span>
<span class="cm">	 * no maximum so we can safely sleep for ceil(2.2) usecs to accommodate</span>
<span class="cm">	 * the integral nature of udelay().</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

	<span class="cm">/* Check for lost arbitration */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ICR_ARBITRATION_LOST</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">CURRENT_SCSI_DATA_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_higher_mask</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ICR_ARBITRATION_LOST</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_ARBITRATION</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : lost arbitration, deasserting MR_ARBITRATE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_SEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_DTC3181E</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="cm">/* RvC: DTC3181E has some trouble with this</span>
<span class="cm">	     *      so we simply removed it. Seems to work with</span>
<span class="cm">	     *      only Mustek scanner attached</span>
<span class="cm">	     */</span>
	    <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ICR_ARBITRATION_LOST</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_ARBITRATION</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : lost arbitration, deasserting ICR_ASSERT_SEL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* </span>
<span class="cm">	 * Again, bus clear + bus settle time is 1.2us, however, this is </span>
<span class="cm">	 * a minimum so we&#39;ll udelay ceil(1.2)</span>
<span class="cm">	 */</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_ARBITRATION</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : won arbitration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>

	<span class="cm">/* </span>
<span class="cm">	 * Now that we have won arbitration, start Selection process, asserting </span>
<span class="cm">	 * the host and target ID&#39;s on the SCSI bus.</span>
<span class="cm">	 */</span>

	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">OUTPUT_DATA_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">scmd_id</span><span class="p">(</span><span class="n">cmd</span><span class="p">))));</span>

	<span class="cm">/* </span>
<span class="cm">	 * Raise ATN while SEL is true before BSY goes false from arbitration,</span>
<span class="cm">	 * since this is the only way to guarantee that we&#39;ll get a MESSAGE OUT</span>
<span class="cm">	 * phase immediately after selection.</span>
<span class="cm">	 */</span>

	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_BSY</span> <span class="o">|</span> <span class="n">ICR_ASSERT_DATA</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span> <span class="o">|</span> <span class="n">ICR_ASSERT_SEL</span><span class="p">));</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * Reselect interrupts must be turned off prior to the dropping of BSY,</span>
<span class="cm">	 * otherwise we will trigger an interrupt.</span>
<span class="cm">	 */</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The initiator shall then wait at least two deskew delays and release </span>
<span class="cm">	 * the BSY signal.</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>		<span class="cm">/* wingel -- wait two bus deskew delay &gt;2*45ns */</span>

	<span class="cm">/* Reset BSY */</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_DATA</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span> <span class="o">|</span> <span class="n">ICR_ASSERT_SEL</span><span class="p">));</span>

	<span class="cm">/* </span>
<span class="cm">	 * Something weird happens when we cease to drive BSY - looks</span>
<span class="cm">	 * like the board/chip is letting us do another read before the </span>
<span class="cm">	 * appropriate propagation delay has expired, and we&#39;re confusing</span>
<span class="cm">	 * a BSY signal from ourselves as the target&#39;s response to SELECTION.</span>
<span class="cm">	 *</span>
<span class="cm">	 * A small delay (the &#39;C++&#39; frontend breaks the pipeline with an</span>
<span class="cm">	 * unnecessary jump, making it work on my 386-33/Trantor T128, the</span>
<span class="cm">	 * tighter &#39;C&#39; code breaks and requires this) solves the problem - </span>
<span class="cm">	 * the 1 us delay is arbitrary, and only used because this delay will </span>
<span class="cm">	 * be the same on other platforms and since it works here, it should </span>
<span class="cm">	 * work there.</span>
<span class="cm">	 *</span>
<span class="cm">	 * wingel suggests that this could be due to failing to wait</span>
<span class="cm">	 * one deskew delay.</span>
<span class="cm">	 */</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_SELECTION</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : selecting target %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">scmd_id</span><span class="p">(</span><span class="n">cmd</span><span class="p">)));</span>

	<span class="cm">/* </span>
<span class="cm">	 * The SCSI specification calls for a 250 ms timeout for the actual </span>
<span class="cm">	 * selection.</span>
<span class="cm">	 */</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="mi">250</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * XXX very interesting - we&#39;re seeing a bounce where the BSY we </span>
<span class="cm">	 * asserted is being reflected / still asserted (propagation delay?)</span>
<span class="cm">	 * and it&#39;s detecting as true.  Sigh.</span>
<span class="cm">	 */</span>

	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">select_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* we count the clock ticks at which we polled */</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">selecting</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>

<span class="nl">part2:</span>
	<span class="cm">/* RvC: here we enter after a sleeping period, or immediately after</span>
<span class="cm">	   execution of part 1</span>
<span class="cm">	   we poll only once ech clock tick */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SR_BSY</span> <span class="o">|</span> <span class="n">SR_IO</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">select_time</span> <span class="o">&lt;</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* RvC: we still must wait for a device response */</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">select_time</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* after 25 ticks the device has failed */</span>
		<span class="n">NCR5380_set_timer</span><span class="p">(</span><span class="n">hostdata</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* RvC: we return here with hostdata-&gt;selecting set,</span>
<span class="cm">				   to go to sleep */</span>
	<span class="p">}</span>

	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">selecting</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="cm">/* clear this pointer, because we passed the</span>
<span class="cm">					   waiting period */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SR_SEL</span> <span class="o">|</span> <span class="n">SR_IO</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">SR_SEL</span> <span class="o">|</span> <span class="n">SR_IO</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
		<span class="n">NCR5380_reselect</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d : reselection after won arbitration?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* </span>
<span class="cm">	 * No less than two deskew delays after the initiator detects the </span>
<span class="cm">	 * BSY signal is true, it shall release the SEL signal and may </span>
<span class="cm">	 * change the DATA BUS.                                     -wingel</span>
<span class="cm">	 */</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_BSY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">targets_present</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">scmd_id</span><span class="p">(</span><span class="n">cmd</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;scsi%d : weirdness</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">restart_select</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">restart select</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">NCR5380_dprint</span><span class="p">(</span><span class="n">NDEBUG_SELECTION</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>
			<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">collect_stats</span><span class="p">(</span><span class="n">hostdata</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_SELECTION</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : target did not respond within 250ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">targets_present</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">scmd_id</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we followed the SCSI spec, and raised ATN while SEL </span>
<span class="cm">	 * was true but before BSY was false during selection, the information</span>
<span class="cm">	 * transfer phase should be a MESSAGE OUT phase so that we can send the</span>
<span class="cm">	 * IDENTIFY message.</span>
<span class="cm">	 * </span>
<span class="cm">	 * If SCSI-II tagged queuing is enabled, we also send a SIMPLE_QUEUE_TAG</span>
<span class="cm">	 * message (2 bytes) with a tag ID that we increment with every command</span>
<span class="cm">	 * until it wraps back to 0.</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX - it turns out that there are some broken SCSI-II devices,</span>
<span class="cm">	 *       which claim to support tagged queuing but fail when more than</span>
<span class="cm">	 *       some number of commands are issued at once.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Wait for start of REQ/ACK handshake */</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">NCR5380_poll_politely</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">STATUS_REG</span><span class="p">,</span> <span class="n">SR_REQ</span><span class="p">,</span> <span class="n">SR_REQ</span><span class="p">,</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;scsi%d: timeout at NCR5380.c:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_SELECTION</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : target %d selected, going into MESSAGE OUT phase.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">));</span>
	<span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">IDENTIFY</span><span class="p">(((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="n">SCSI_IRQ_NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Send message(s) */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">phase</span> <span class="o">=</span> <span class="n">PHASE_MSGOUT</span><span class="p">;</span>
	<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_SELECTION</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : nexus established.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
	<span class="cm">/* XXX need to handle errors here */</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="n">initialize_SCp</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Selection failed */</span>
<span class="nl">failed:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> * Function : int NCR5380_transfer_pio (struct Scsi_Host *instance, </span>
<span class="cm"> *      unsigned char *phase, int *count, unsigned char **data)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : transfers data in given phase using polled I/O</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : instance - instance of driver, *phase - pointer to </span>
<span class="cm"> *      what phase is expected, *count - pointer to number of </span>
<span class="cm"> *      bytes to transfer, **data - pointer to data pointer.</span>
<span class="cm"> * </span>
<span class="cm"> * Returns : -1 when different phase is entered without transferring</span>
<span class="cm"> *      maximum number of bytes, 0 if all bytes or transferred or exit</span>
<span class="cm"> *      is in same phase.</span>
<span class="cm"> *</span>
<span class="cm"> *      Also, *phase, *count, *data are modified in place.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX Note : handling for bus free may be useful.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Note : this code is not as quick as it could be, however it </span>
<span class="cm"> * IS 100% reliable, and for the actual data transfer where speed</span>
<span class="cm"> * counts, we will always do a pseudo DMA or DMA transfer.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">NCR5380_transfer_pio</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">phase</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">phase</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *      RvC: some administrative data to process polling time</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">break_allowed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">))</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_PIO</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : pio write %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">c</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_PIO</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : pio read %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">c</span><span class="p">));</span>

	<span class="cm">/* </span>
<span class="cm">	 * The NCR5380 chip will only drive the SCSI bus when the </span>
<span class="cm">	 * phase specified in the appropriate bits of the TARGET COMMAND</span>
<span class="cm">	 * REGISTER match the STATUS REGISTER</span>
<span class="cm">	 */</span>

	 <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="n">PHASE_SR_TO_TCR</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>

	<span class="cm">/* RvC: don&#39;t know if this is necessary, but other SCSI I/O is short</span>
<span class="cm">	 *      so breaks are not necessary there</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">==</span> <span class="n">PHASE_DATAIN</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">PHASE_DATAOUT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">break_allowed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* </span>
<span class="cm">		 * Wait for assertion of REQ, after which the phase bits will be </span>
<span class="cm">		 * valid </span>
<span class="cm">		 */</span>

		<span class="cm">/* RvC: we simply poll once, after that we stop temporarily</span>
<span class="cm">		 *      and let the device buffer fill up</span>
<span class="cm">		 *      if breaking is not allowed, we keep polling as long as needed</span>
<span class="cm">		 */</span>

		<span class="cm">/* FIXME */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">break_allowed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* timeout condition */</span>
			<span class="n">NCR5380_set_timer</span><span class="p">(</span><span class="n">hostdata</span><span class="p">,</span> <span class="n">USLEEP_SLEEP</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_HANDSHAKE</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : REQ detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>

		<span class="cm">/* Check for phase mismatch */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_HANDSHAKE</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : phase mismatch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
			<span class="n">NCR5380_dprint_phase</span><span class="p">(</span><span class="n">NDEBUG_HANDSHAKE</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Do actual transfer from SCSI bus to / from memory */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">))</span>
			<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">OUTPUT_DATA_REG</span><span class="p">,</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">CURRENT_SCSI_DATA_REG</span><span class="p">);</span>

		<span class="o">++</span><span class="n">d</span><span class="p">;</span>

		<span class="cm">/* </span>
<span class="cm">		 * The SCSI standard suggests that in MSGOUT phase, the initiator</span>
<span class="cm">		 * should drop ATN on the last byte of the message phase</span>
<span class="cm">		 * after REQ has been asserted for the handshake but before</span>
<span class="cm">		 * the initiator raises ACK.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_MSG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_DATA</span><span class="p">);</span>
				<span class="n">NCR5380_dprint</span><span class="p">(</span><span class="n">NDEBUG_PIO</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>
				<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_DATA</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ACK</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_DATA</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>
				<span class="n">NCR5380_dprint</span><span class="p">(</span><span class="n">NDEBUG_PIO</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>
				<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_DATA</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ACK</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">NCR5380_dprint</span><span class="p">(</span><span class="n">NDEBUG_PIO</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>
			<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ACK</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* FIXME - if this fails bus reset ?? */</span>
		<span class="n">NCR5380_poll_politely</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">STATUS_REG</span><span class="p">,</span> <span class="n">SR_REQ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_HANDSHAKE</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : req false, handshake complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm"> * We have several special cases to consider during REQ/ACK handshaking : </span>
<span class="cm"> * 1.  We were in MSGOUT phase, and we are on the last byte of the </span>
<span class="cm"> *      message.  ATN must be dropped as ACK is dropped.</span>
<span class="cm"> *</span>
<span class="cm"> * 2.  We are in a MSGIN phase, and we are on the last byte of the  </span>
<span class="cm"> *      message.  We must exit with ACK asserted, so that the calling</span>
<span class="cm"> *      code may raise ATN before dropping ACK to reject the message.</span>
<span class="cm"> *</span>
<span class="cm"> * 3.  ACK and ATN are clear and the target may proceed as normal.</span>
<span class="cm"> */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">PHASE_MSGIN</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">PHASE_MSGOUT</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">c</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_PIO</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : residual %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">c</span><span class="p">));</span>

	<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">)</span>
		<span class="o">*</span><span class="n">phase</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">phase</span> <span class="o">=</span> <span class="n">PHASE_UNKNOWN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">phase</span> <span class="o">==</span> <span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	do_reset	-	issue a reset command</span>
<span class="cm"> *	@host: adapter to reset</span>
<span class="cm"> *</span>
<span class="cm"> *	Issue a reset sequence to the NCR5380 and try and get the bus</span>
<span class="cm"> *	back into sane shape.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locks: caller holds queue lock</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="n">PHASE_SR_TO_TCR</span><span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">));</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_RST</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function : do_abort (Scsi_Host *host)</span>
<span class="cm"> * </span>
<span class="cm"> * Purpose : abort the currently established nexus.  Should only be </span>
<span class="cm"> *      called from a routine which can drop into a </span>
<span class="cm"> * </span>
<span class="cm"> * Returns : 0 on success, -1 on failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Locks: queue lock held by caller</span>
<span class="cm"> *	FIXME: sort this out and get new_eh running</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msgptr</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>


	<span class="cm">/* Request message out phase */</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * Wait for the target to indicate a valid phase by asserting </span>
<span class="cm">	 * REQ.  Once this happens, we&#39;ll have either a MSGOUT phase </span>
<span class="cm">	 * and can immediately send the ABORT message, or we&#39;ll have some </span>
<span class="cm">	 * other phase and will have to source/sink data.</span>
<span class="cm">	 * </span>
<span class="cm">	 * We really don&#39;t care what value was on the bus or what value</span>
<span class="cm">	 * the target sees, so we just handshake.</span>
<span class="cm">	 */</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">NCR5380_poll_politely</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">STATUS_REG</span><span class="p">,</span> <span class="n">SR_REQ</span><span class="p">,</span> <span class="n">SR_REQ</span><span class="p">,</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">rc</span><span class="p">;</span>
	
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="n">PHASE_SR_TO_TCR</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PHASE_MSGOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ACK</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">NCR5380_poll_politely</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">STATUS_REG</span><span class="p">,</span> <span class="n">SR_REQ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ABORT</span><span class="p">;</span>
	<span class="n">msgptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">phase</span> <span class="o">=</span> <span class="n">PHASE_MSGOUT</span><span class="p">;</span>
	<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msgptr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we got here, and the command completed successfully,</span>
<span class="cm">	 * we&#39;re about to go into bus free state.</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="n">len</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(REAL_DMA) || defined(PSEUDO_DMA) || defined (REAL_DMA_POLL)</span>
<span class="cm">/* </span>
<span class="cm"> * Function : int NCR5380_transfer_dma (struct Scsi_Host *instance, </span>
<span class="cm"> *      unsigned char *phase, int *count, unsigned char **data)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : transfers data in given phase using either real</span>
<span class="cm"> *      or pseudo DMA.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : instance - instance of driver, *phase - pointer to </span>
<span class="cm"> *      what phase is expected, *count - pointer to number of </span>
<span class="cm"> *      bytes to transfer, **data - pointer to data pointer.</span>
<span class="cm"> * </span>
<span class="cm"> * Returns : -1 when different phase is entered without transferring</span>
<span class="cm"> *      maximum number of bytes, 0 if all bytes or transferred or exit</span>
<span class="cm"> *      is in same phase.</span>
<span class="cm"> *</span>
<span class="cm"> *      Also, *phase, *count, *data are modified in place.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locks: io_request lock held by caller</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">NCR5380_transfer_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">phase</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">phase</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">foo</span><span class="p">;</span>
<span class="cp">#if defined(REAL_DMA_POLL)</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">toPIO</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">saved_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">overrun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">residue</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">))</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">phase</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if defined(REAL_DMA) || defined(REAL_DMA_POLL)</span>
<span class="cp">#ifdef READ_OVERRUNS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_DMA</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : initializing DMA channel %d for %s, %d bytes %s %0x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">dma_channel</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;reading&quot;</span> <span class="o">:</span> <span class="s">&quot;writing&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;to&quot;</span> <span class="o">:</span> <span class="s">&quot;from&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">d</span><span class="p">));</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">dma_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">)</span> <span class="o">?</span> <span class="n">NCR5380_dma_read_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">NCR5380_dma_write_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="n">PHASE_SR_TO_TCR</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>

<span class="cp">#ifdef REAL_DMA</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span> <span class="o">|</span> <span class="n">MR_DMA_MODE</span> <span class="o">|</span> <span class="n">MR_ENABLE_EOP_INTR</span> <span class="o">|</span> <span class="n">MR_MONITOR_BSY</span><span class="p">);</span>
<span class="cp">#elif defined(REAL_DMA_POLL)</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span> <span class="o">|</span> <span class="n">MR_DMA_MODE</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note : on my sample board, watch-dog timeouts occurred when interrupts</span>
<span class="cm">	 * were not disabled for the duration of a single DMA transfer, from </span>
<span class="cm">	 * before the setting of DMA mode to after transfer of the last byte.</span>
<span class="cm">	 */</span>

<span class="cp">#if defined(PSEUDO_DMA) &amp;&amp; defined(UNSAFE)</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/* KLL May need eop and parity in 53c400 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_NCR53C400</span><span class="p">)</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span> <span class="o">|</span> <span class="n">MR_DMA_MODE</span> <span class="o">|</span>
				<span class="n">MR_ENABLE_PAR_CHECK</span> <span class="o">|</span> <span class="n">MR_ENABLE_PAR_INTR</span> <span class="o">|</span>
				<span class="n">MR_ENABLE_EOP_INTR</span> <span class="o">|</span> <span class="n">MR_MONITOR_BSY</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span> <span class="o">|</span> <span class="n">MR_DMA_MODE</span><span class="p">);</span>
<span class="cp">#endif				</span><span class="cm">/* def REAL_DMA */</span><span class="cp"></span>

	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_DMA</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : mode reg = 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">)));</span>

	<span class="cm">/* </span>
<span class="cm">	 *	On the PAS16 at least I/O recovery delays are not needed here.</span>
<span class="cm">	 *	Everyone else seems to want them.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">io_recovery_delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">START_DMA_INITIATOR_RECEIVE_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">io_recovery_delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_DATA</span><span class="p">);</span>
		<span class="n">io_recovery_delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">START_DMA_SEND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">io_recovery_delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#if defined(REAL_DMA_POLL)</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">BASR_PHASE_MATCH</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BASR_BUSY_ERROR</span> <span class="o">|</span> <span class="n">BASR_END_DMA_TRANSFER</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm">   At this point, either we&#39;ve completed DMA, or we have a phase mismatch,</span>
<span class="cm">   or we&#39;ve unexpectedly lost BUSY (which is a real error).</span>

<span class="cm">   For write DMAs, we want to wait until the last byte has been</span>
<span class="cm">   transferred out over the bus before we turn off DMA mode.  Alas, there</span>
<span class="cm">   seems to be no terribly good way of doing this on a 5380 under all</span>
<span class="cm">   conditions.  For non-scatter-gather operations, we can wait until REQ</span>
<span class="cm">   and ACK both go false, or until a phase mismatch occurs.  Gather-writes</span>
<span class="cm">   are nastier, since the device will be expecting more data than we</span>
<span class="cm">   are prepared to send it, and REQ will remain asserted.  On a 53C8[01] we</span>
<span class="cm">   could test LAST BIT SENT to assure transfer (I imagine this is precisely</span>
<span class="cm">   why this signal was added to the newer chips) but on the older 538[01]</span>
<span class="cm">   this signal does not exist.  The workaround for this lack is a watchdog;</span>
<span class="cm">   we bail out of the wait-loop after a modest amount of wait-time if</span>
<span class="cm">   the usual exit conditions are not met.  Not a terribly clean or</span>
<span class="cm">   correct solution :-%</span>

<span class="cm">   Reads are equally tricky due to a nasty characteristic of the NCR5380.</span>
<span class="cm">   If the chip is in DMA mode for an READ, it will respond to a target&#39;s</span>
<span class="cm">   REQ by latching the SCSI data into the INPUT DATA register and asserting</span>
<span class="cm">   ACK, even if it has _already_ been notified by the DMA controller that</span>
<span class="cm">   the current DMA transfer has completed!  If the NCR5380 is then taken</span>
<span class="cm">   out of DMA mode, this already-acknowledged byte is lost.</span>

<span class="cm">   This is not a problem for &quot;one DMA transfer per command&quot; reads, because</span>
<span class="cm">   the situation will never arise... either all of the data is DMA&#39;ed</span>
<span class="cm">   properly, or the target switches to MESSAGE IN phase to signal a</span>
<span class="cm">   disconnection (either operation bringing the DMA to a clean halt).</span>
<span class="cm">   However, in order to handle scatter-reads, we must work around the</span>
<span class="cm">   problem.  The chosen fix is to DMA N-2 bytes, then check for the</span>
<span class="cm">   condition before taking the NCR5380 out of DMA mode.  One or two extra</span>
<span class="cm">   bytes are transferred via PIO as necessary to fill out the original</span>
<span class="cm">   request.</span>
<span class="cm"> */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef READ_OVERRUNS</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BASR_PHASE_MATCH</span> <span class="o">|</span> <span class="n">BASR_ACK</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">BASR_PHASE_MATCH</span> <span class="o">|</span> <span class="n">BASR_ACK</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">saved_data</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">INPUT_DATA_REGISTER</span><span class="p">);</span>
			<span class="n">overrun</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">BASR_ACK</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">BASR_PHASE_MATCH</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">limit</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_DMA</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : polled DMA transfer complete, basr 0x%X, sr 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)));</span>

	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>

	<span class="n">residue</span> <span class="o">=</span> <span class="n">NCR5380_dma_residual</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">-=</span> <span class="n">residue</span><span class="p">;</span>
	<span class="o">*</span><span class="n">count</span> <span class="o">-=</span> <span class="n">c</span><span class="p">;</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
	<span class="o">*</span><span class="n">phase</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">;</span>

<span class="cp">#ifdef READ_OVERRUNS</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">phase</span> <span class="o">==</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">residue</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">overrun</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_DMA</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Got an input overrun, using saved byte</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="o">**</span><span class="n">data</span> <span class="o">=</span> <span class="n">saved_data</span><span class="p">;</span>
			<span class="o">*</span><span class="n">data</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="o">*</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">cnt</span> <span class="o">=</span> <span class="n">toPIO</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;No overrun??</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">cnt</span> <span class="o">=</span> <span class="n">toPIO</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_DMA</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Doing %d-byte PIO to 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
		<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="o">*</span><span class="n">count</span> <span class="o">-=</span> <span class="n">toPIO</span> <span class="o">-</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_DMA</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Return with data ptr = 0x%X, count %d, last 0x%X, next 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">data</span> <span class="o">+</span> <span class="o">*</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">data</span> <span class="o">+</span> <span class="o">*</span><span class="n">count</span><span class="p">)));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#elif defined(REAL_DMA)</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else				</span><span class="cm">/* defined(REAL_DMA_POLL) */</span><span class="cp"></span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DMA_WORKS_RIGHT</span>
		<span class="n">foo</span> <span class="o">=</span> <span class="n">NCR5380_pread</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_NCR53C400</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">foo</span> <span class="o">=</span> <span class="n">NCR5380_pread</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="n">diff</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We can&#39;t disable DMA mode after successfully transferring </span>
<span class="cm">			 * what we plan to be the last byte, since that would open up</span>
<span class="cm">			 * a race condition where if the target asserted REQ before </span>
<span class="cm">			 * we got the DMA mode reset, the NCR5380 would have latched</span>
<span class="cm">			 * an additional byte into the INPUT DATA register and we&#39;d</span>
<span class="cm">			 * have dropped it.</span>
<span class="cm">			 * </span>
<span class="cm">			 * The workaround was to transfer one fewer bytes than we </span>
<span class="cm">			 * intended to with the pseudo-DMA read function, wait for </span>
<span class="cm">			 * the chip to latch the last byte, read it, and then disable</span>
<span class="cm">			 * pseudo-DMA mode.</span>
<span class="cm">			 * </span>
<span class="cm">			 * After REQ is asserted, the NCR5380 asserts DRQ and ACK.</span>
<span class="cm">			 * REQ is deasserted when ACK is asserted, and not reasserted</span>
<span class="cm">			 * until ACK goes false.  Since the NCR5380 won&#39;t lower ACK</span>
<span class="cm">			 * until DACK is asserted, which won&#39;t happen unless we twiddle</span>
<span class="cm">			 * the DMA port or we take the NCR5380 out of DMA mode, we </span>
<span class="cm">			 * can guarantee that we won&#39;t handshake another extra </span>
<span class="cm">			 * byte.</span>
<span class="cm">			 */</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_NCR53C400</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BASR_DRQ</span><span class="p">));</span>
				<span class="cm">/* Wait for clean handshake */</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">);</span>
				<span class="n">d</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">INPUT_DATA_REG</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef DMA_WORKS_RIGHT</span>
		<span class="n">foo</span> <span class="o">=</span> <span class="n">NCR5380_pwrite</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_C400_PWRITE</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;About to pwrite %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">foo</span> <span class="o">=</span> <span class="n">NCR5380_pwrite</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Wait for the last byte to be sent.  If REQ is being asserted for </span>
<span class="cm">			 * the byte we&#39;re interested, we&#39;ll ACK it and it will go false.  </span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_LAST_BYTE_SENT</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">timeout</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">;</span>
				<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BASR_DRQ</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BASR_PHASE_MATCH</span><span class="p">));</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeout</span><span class="p">)</span>
					<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_LAST_BYTE_SENT</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : timed out on last byte</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_CHECK_LAST_BYTE_SENT</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG_CHECK_LAST_BYTE_SENT</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TCR_LAST_BYTE_SENT</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FLAG_HAS_LAST_BYTE_SENT</span><span class="p">;</span>
						<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_LAST_WRITE_SENT</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : last bit sent works</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_C400_PWRITE</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Waiting for LASTBYTE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
				<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TCR_LAST_BYTE_SENT</span><span class="p">));</span>
				<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_C400_PWRITE</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Got LASTBYTE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_NCR53C400</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_C400_PWRITE</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;53C400w: Checking for IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BASR_IRQ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_C400_PWRITE</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;53C400w:    got it, reading reset interrupt reg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="n">NCR5380_read</span><span class="p">(</span><span class="n">RESET_PARITY_INTERRUPT_REG</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;53C400w:    IRQ NOT THERE!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
	<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">phase</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">;</span>
<span class="cp">#if defined(PSEUDO_DMA) &amp;&amp; defined(UNSAFE)</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
<span class="cp">#endif				</span><span class="cm">/* defined(REAL_DMA_POLL) */</span><span class="cp"></span>
	<span class="k">return</span> <span class="n">foo</span><span class="p">;</span>
<span class="cp">#endif				</span><span class="cm">/* def REAL_DMA */</span><span class="cp"></span>
<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* defined(REAL_DMA) | defined(PSEUDO_DMA) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Function : NCR5380_information_transfer (struct Scsi_Host *instance)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : run through the various SCSI phases and do as the target </span>
<span class="cm"> *      directs us to.  Operates on the currently connected command, </span>
<span class="cm"> *      instance-&gt;connected.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : instance, instance for which we are doing commands</span>
<span class="cm"> *</span>
<span class="cm"> * Side effects : SCSI things happen, the disconnected queue will be </span>
<span class="cm"> *      modified if a command disconnects, *instance-&gt;connected will</span>
<span class="cm"> *      change.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX Note : we need to watch for bus free or a reset condition here </span>
<span class="cm"> *      to recover from an unexpected bus free condition.</span>
<span class="cm"> *</span>
<span class="cm"> * Locks: io_request_lock held by caller in IRQ mode</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">NCR5380_information_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msgout</span> <span class="o">=</span> <span class="n">NOP</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="cp">#if defined(PSEUDO_DMA) || defined(REAL_DMA_POLL)</span>
	<span class="kt">int</span> <span class="n">transfersize</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">phase</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">old_phase</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">;</span>
	<span class="cm">/* RvC: we need to set the end of the polling time */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">poll_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">USLEEP_POLL</span><span class="p">;</span>

	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">);</span>
		<span class="cm">/* We only have a valid SCSI phase when REQ is asserted */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phase</span> <span class="o">!=</span> <span class="n">old_phase</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">old_phase</span> <span class="o">=</span> <span class="n">phase</span><span class="p">;</span>
				<span class="n">NCR5380_dprint_phase</span><span class="p">(</span><span class="n">NDEBUG_INFORMATION</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sink</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">phase</span> <span class="o">!=</span> <span class="n">PHASE_MSGOUT</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="n">PHASE_SR_TO_TCR</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>

				<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ACK</span><span class="p">);</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">);</span>
				<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>
				<span class="n">sink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">PHASE_DATAIN</span>:
			<span class="k">case</span> <span class="n">PHASE_DATAOUT</span>:
<span class="cp">#if (NDEBUG &amp; NDEBUG_NO_DATAOUT)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d : NDEBUG_NO_DATAOUT set, attempted DATAOUT aborted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
				<span class="n">sink</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">do_abort</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
				<span class="cm">/* </span>
<span class="cm">				 * If there is no room left in the current buffer in the</span>
<span class="cm">				 * scatter-gather list, move onto the next one.</span>
<span class="cm">				 */</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span><span class="p">)</span> <span class="p">{</span>
					<span class="o">++</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span>
					<span class="o">--</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span><span class="p">;</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
					<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_INFORMATION</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : %d bytes and %d buffers left</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="cm">/*</span>
<span class="cm">				 * The preferred transfer method is going to be </span>
<span class="cm">				 * PSEUDO-DMA for systems that are strictly PIO,</span>
<span class="cm">				 * since we can let the hardware do the handshaking.</span>
<span class="cm">				 *</span>
<span class="cm">				 * For this to work, we need to know the transfersize</span>
<span class="cm">				 * ahead of time, since the pseudo-DMA code will sit</span>
<span class="cm">				 * in an unconditional loop.</span>
<span class="cm">				 */</span>

<span class="cp">#if defined(PSEUDO_DMA) || defined(REAL_DMA_POLL)</span>
				<span class="cm">/* KLL</span>
<span class="cm">				 * PSEUDO_DMA is defined here. If this is the g_NCR5380</span>
<span class="cm">				 * driver then it will always be defined, so the</span>
<span class="cm">				 * FLAG_NO_PSEUDO_DMA is used to inhibit PDMA in the base</span>
<span class="cm">				 * NCR5380 case.  I think this is a fairly clean solution.</span>
<span class="cm">				 * We supplement these 2 if&#39;s with the flag.</span>
<span class="cm">				 */</span>
<span class="cp">#ifdef NCR5380_dma_xfer_len</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">borken</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_NO_PSEUDO_DMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">transfersize</span> <span class="o">=</span> <span class="n">NCR5380_dma_xfer_len</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#else</span>
				<span class="n">transfersize</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transfersize</span><span class="p">;</span>

<span class="cp">#ifdef LIMIT_TRANSFERSIZE	</span><span class="cm">/* If we have problems with interrupt service */</span><span class="cp"></span>
				<span class="k">if</span> <span class="p">(</span><span class="n">transfersize</span> <span class="o">&gt;</span> <span class="mi">512</span><span class="p">)</span>
					<span class="n">transfersize</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
<span class="cp">#endif				</span><span class="cm">/* LIMIT_TRANSFERSIZE */</span><span class="cp"></span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">borken</span> <span class="o">&amp;&amp;</span> <span class="n">transfersize</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_NO_PSEUDO_DMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">%</span> <span class="n">transfersize</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* Limit transfers to 32K, for xx400 &amp; xx406</span>
<span class="cm">					 * pseudoDMA that transfers in 128 bytes blocks. */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">transfersize</span> <span class="o">&gt;</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
						<span class="n">transfersize</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
<span class="cp">#endif</span>
					<span class="n">len</span> <span class="o">=</span> <span class="n">transfersize</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">NCR5380_transfer_dma</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="p">))</span> <span class="p">{</span>
						<span class="cm">/*</span>
<span class="cm">						 * If the watchdog timer fires, all future accesses to this</span>
<span class="cm">						 * device will use the polled-IO.</span>
<span class="cm">						 */</span>
						<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
							    <span class="s">&quot;switching to slow handshake</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">borken</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
						<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>
						<span class="n">sink</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
						<span class="n">do_abort</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
						<span class="cm">/* XXX - need to source or sink data here, as appropriate */</span>
					<span class="p">}</span> <span class="k">else</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">-=</span> <span class="n">transfersize</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif				</span><span class="cm">/* defined(PSEUDO_DMA) || defined(REAL_DMA_POLL) */</span><span class="cp"></span>
					<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="p">)</span>
							     <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">PHASE_MSGIN</span>:
				<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">;</span>
				<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Message</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>

				<span class="k">switch</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * Linking lets us reduce the time required to get the </span>
<span class="cm">					 * next command out to the device, hopefully this will</span>
<span class="cm">					 * mean we don&#39;t waste another revolution due to the delays</span>
<span class="cm">					 * required by ARBITRATION and another SELECTION.</span>
<span class="cm">					 *</span>
<span class="cm">					 * In the current implementation proposal, low level drivers</span>
<span class="cm">					 * merely have to start the next command, pointed to by </span>
<span class="cm">					 * next_link, done() is called as with unlinked commands.</span>
<span class="cm">					 */</span>
<span class="cp">#ifdef LINKED</span>
				<span class="k">case</span> <span class="n">LINKED_CMD_COMPLETE</span>:
				<span class="k">case</span> <span class="n">LINKED_FLG_CMD_COMPLETE</span>:
					<span class="cm">/* Accept message by clearing ACK */</span>
					<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
					<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_LINKED</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : target %d lun %d linked command complete.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">));</span>
					<span class="cm">/* </span>
<span class="cm">					 * Sanity check : A linked command should only terminate with</span>
<span class="cm">					 * one of these messages if there are more linked commands</span>
<span class="cm">					 * available.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">next_link</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d : target %d lun %d linked command complete, no next_link</span><span class="se">\n</span><span class="s">&quot;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
						<span class="n">sink</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
						<span class="n">do_abort</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
						<span class="k">return</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">initialize_SCp</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">next_link</span><span class="p">);</span>
					<span class="cm">/* The next command is still part of this process */</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">next_link</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span> <span class="o">|</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Message</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
					<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_LINKED</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : target %d lun %d linked request done, calling scsi_done().</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">));</span>
					<span class="n">collect_stats</span><span class="p">(</span><span class="n">hostdata</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
					<span class="n">cmd</span> <span class="o">=</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif				</span><span class="cm">/* def LINKED */</span><span class="cp"></span>
				<span class="k">case</span> <span class="n">ABORT</span>:
				<span class="k">case</span> <span class="n">COMMAND_COMPLETE</span>:
					<span class="cm">/* Accept message by clearing ACK */</span>
					<span class="n">sink</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
					<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_QUEUES</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : command for target %d, lun %d completed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">));</span>
					<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

					<span class="cm">/* </span>
<span class="cm">					 * I&#39;m not sure what the correct thing to do here is : </span>
<span class="cm">					 * </span>
<span class="cm">					 * If the command that just executed is NOT a request </span>
<span class="cm">					 * sense, the obvious thing to do is to set the result</span>
<span class="cm">					 * code to the values of the stored parameters.</span>
<span class="cm">					 * </span>
<span class="cm">					 * If it was a REQUEST SENSE command, we need some way </span>
<span class="cm">					 * to differentiate between the failure code of the original</span>
<span class="cm">					 * and the failure code of the REQUEST sense - the obvious</span>
<span class="cm">					 * case is success, where we fall through and leave the result</span>
<span class="cm">					 * code unchanged.</span>
<span class="cm">					 * </span>
<span class="cm">					 * The non-obvious place is where the REQUEST SENSE failed </span>
<span class="cm">					 */</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span> <span class="o">|</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Message</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
					<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status_byte</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GOOD</span><span class="p">)</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">&amp;</span> <span class="mh">0x00ffff</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

<span class="cp">#ifdef AUTOSENSE</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
						<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">ses</span><span class="p">.</span><span class="n">cmd_len</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">scsi_eh_restore_cmnd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">ses</span><span class="p">);</span>
						<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">ses</span><span class="p">.</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
					<span class="p">}</span>

					<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status_byte</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span><span class="p">)</span> <span class="o">==</span> <span class="n">CHECK_CONDITION</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">scsi_eh_prep_cmnd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">ses</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>

						<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_AUTOSENSE</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : performing request sense</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>

						<span class="n">LIST</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">);</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span>
						    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">;</span>
						<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmd</span><span class="p">;</span>
						<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_QUEUES</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : REQUEST SENSE added to head of issue queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
					<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif				</span><span class="cm">/* def AUTOSENSE */</span><span class="cp"></span>
					<span class="p">{</span>
						<span class="n">collect_stats</span><span class="p">(</span><span class="n">hostdata</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
					<span class="p">}</span>

					<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
					<span class="cm">/* </span>
<span class="cm">					 * Restore phase bits to 0 so an interrupted selection, </span>
<span class="cm">					 * arbitration can resume.</span>
<span class="cm">					 */</span>
					<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

					<span class="k">while</span> <span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_BSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span>
						<span class="n">barrier</span><span class="p">();</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">MESSAGE_REJECT</span>:
					<span class="cm">/* Accept message by clearing ACK */</span>
					<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
					<span class="k">switch</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">last_message</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">case</span> <span class="n">HEAD_OF_QUEUE_TAG</span>:
					<span class="k">case</span> <span class="n">ORDERED_QUEUE_TAG</span>:
					<span class="k">case</span> <span class="n">SIMPLE_QUEUE_TAG</span>:
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">simple_tags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="nl">default:</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="k">case</span> <span class="n">DISCONNECT</span>:<span class="p">{</span>
						<span class="cm">/* Accept message by clearing ACK */</span>
						<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">disconnect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
						<span class="n">LIST</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">);</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span>
						    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">;</span>
						<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
						<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
						<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_QUEUES</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : command for target %d lun %d was moved from connected to&quot;</span> <span class="s">&quot;  the disconnected_queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">));</span>
						<span class="cm">/* </span>
<span class="cm">						 * Restore phase bits to 0 so an interrupted selection, </span>
<span class="cm">						 * arbitration can resume.</span>
<span class="cm">						 */</span>
						<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

						<span class="cm">/* Enable reselect interrupts */</span>
						<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
						<span class="cm">/* Wait for bus free to avoid nasty timeouts - FIXME timeout !*/</span>
						<span class="cm">/* NCR538_poll_politely(instance, STATUS_REG, SR_BSY, 0, 30 * HZ); */</span>
						<span class="k">while</span> <span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_BSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span>
							<span class="n">barrier</span><span class="p">();</span>
						<span class="k">return</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="cm">/* </span>
<span class="cm">					 * The SCSI data pointer is *IMPLICITLY* saved on a disconnect</span>
<span class="cm">					 * operation, in violation of the SCSI spec so we can safely </span>
<span class="cm">					 * ignore SAVE/RESTORE pointers calls.</span>
<span class="cm">					 *</span>
<span class="cm">					 * Unfortunately, some disks violate the SCSI spec and </span>
<span class="cm">					 * don&#39;t issue the required SAVE_POINTERS message before</span>
<span class="cm">					 * disconnecting, and we have to break spec to remain </span>
<span class="cm">					 * compatible.</span>
<span class="cm">					 */</span>
				<span class="k">case</span> <span class="n">SAVE_POINTERS</span>:
				<span class="k">case</span> <span class="n">RESTORE_POINTERS</span>:
					<span class="cm">/* Accept message by clearing ACK */</span>
					<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">EXTENDED_MESSAGE</span>:
<span class="cm">/* </span>
<span class="cm"> * Extended messages are sent in the following format :</span>
<span class="cm"> * Byte         </span>
<span class="cm"> * 0            EXTENDED_MESSAGE == 1</span>
<span class="cm"> * 1            length (includes one byte for code, doesn&#39;t </span>
<span class="cm"> *              include first two bytes)</span>
<span class="cm"> * 2            code</span>
<span class="cm"> * 3..length+1  arguments</span>
<span class="cm"> *</span>
<span class="cm"> * Start the extended message buffer with the EXTENDED_MESSAGE</span>
<span class="cm"> * byte, since spi_print_msg() wants the whole thing.  </span>
<span class="cm"> */</span>
					<span class="n">extended_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXTENDED_MESSAGE</span><span class="p">;</span>
					<span class="cm">/* Accept first byte by clearing ACK */</span>
					<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
					<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_EXTENDED</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : receiving extended message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>

					<span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
					<span class="n">data</span> <span class="o">=</span> <span class="n">extended_msg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">phase</span> <span class="o">=</span> <span class="n">PHASE_MSGIN</span><span class="p">;</span>
					<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>

					<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_EXTENDED</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : length=%d, code=0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>

					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">extended_msg</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
						<span class="cm">/* Accept third byte by clearing ACK */</span>
						<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
						<span class="n">len</span> <span class="o">=</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
						<span class="n">data</span> <span class="o">=</span> <span class="n">extended_msg</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
						<span class="n">phase</span> <span class="o">=</span> <span class="n">PHASE_MSGIN</span><span class="p">;</span>

						<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
						<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_EXTENDED</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : message received, residual %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>

						<span class="k">switch</span> <span class="p">(</span><span class="n">extended_msg</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
						<span class="k">case</span> <span class="n">EXTENDED_SDTR</span>:
						<span class="k">case</span> <span class="n">EXTENDED_WDTR</span>:
						<span class="k">case</span> <span class="n">EXTENDED_MODIFY_DATA_POINTER</span>:
						<span class="k">case</span> <span class="n">EXTENDED_EXTENDED_IDENTIFY</span>:
							<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="p">}</span>
					<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d: error receiving extended message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
						<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d: extended message code %02x length %d is too long</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
						<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="cm">/* Fall through to reject message */</span>

					<span class="cm">/* </span>
<span class="cm">					 * If we get something weird that we aren&#39;t expecting, </span>
<span class="cm">					 * reject it.</span>
<span class="cm">					 */</span>
				<span class="nl">default:</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d: rejecting message &quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
						<span class="n">spi_print_msg</span><span class="p">(</span><span class="n">extended_msg</span><span class="p">);</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">EXTENDED_MESSAGE</span><span class="p">)</span>
						<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
							<span class="s">&quot;rejecting unknown message %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">tmp</span><span class="p">);</span>
					<span class="k">else</span>
						<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
							<span class="s">&quot;rejecting unknown extended message code %02x, length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

					<span class="n">msgout</span> <span class="o">=</span> <span class="n">MESSAGE_REJECT</span><span class="p">;</span>
					<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>	<span class="cm">/* switch (tmp) */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">PHASE_MSGOUT</span>:
				<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msgout</span><span class="p">;</span>
				<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">last_message</span> <span class="o">=</span> <span class="n">msgout</span><span class="p">;</span>
				<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">msgout</span> <span class="o">==</span> <span class="n">ABORT</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
					<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
					<span class="n">collect_stats</span><span class="p">(</span><span class="n">hostdata</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
					<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">msgout</span> <span class="o">=</span> <span class="n">NOP</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">PHASE_CMDOUT</span>:
				<span class="n">len</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
				<span class="n">data</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">;</span>
				<span class="cm">/* </span>
<span class="cm">				 * XXX for performance reasons, on machines with a </span>
<span class="cm">				 * PSEUDO-DMA architecture we should probably </span>
<span class="cm">				 * use the dma transfer function.  </span>
<span class="cm">				 */</span>
				<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">disconnect</span> <span class="o">&amp;&amp;</span> <span class="n">should_disconnect</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
					<span class="n">NCR5380_set_timer</span><span class="p">(</span><span class="n">hostdata</span><span class="p">,</span> <span class="n">USLEEP_SLEEP</span><span class="p">);</span>
					<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_USLEEP</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : issued command, sleeping until %ul</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_expires</span><span class="p">));</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">PHASE_STATIN</span>:
				<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">;</span>
				<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d : unknown phase</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
				<span class="n">NCR5380_dprint</span><span class="p">(</span><span class="n">NDEBUG_ALL</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>
			<span class="p">}</span>	<span class="cm">/* switch(phase) */</span>
		<span class="p">}</span>		<span class="cm">/* if (tmp * SR_REQ) */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* RvC: go to sleep if polling time expired</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">disconnect</span> <span class="o">&amp;&amp;</span> <span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">poll_time</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">NCR5380_set_timer</span><span class="p">(</span><span class="n">hostdata</span><span class="p">,</span> <span class="n">USLEEP_SLEEP</span><span class="p">);</span>
				<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_USLEEP</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : poll timed out, sleeping until %ul</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_expires</span><span class="p">));</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>			<span class="cm">/* while (1) */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function : void NCR5380_reselect (struct Scsi_Host *instance)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : does reselection, initializing the instance-&gt;connected </span>
<span class="cm"> *      field to point to the Scsi_Cmnd for which the I_T_L or I_T_L_Q </span>
<span class="cm"> *      nexus has been reestablished,</span>
<span class="cm"> *      </span>
<span class="cm"> * Inputs : instance - this instance of the NCR5380.</span>
<span class="cm"> *</span>
<span class="cm"> * Locks: io_request_lock held by caller if IRQ driven</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">NCR5380_reselect</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span>
	 <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">target_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lun</span><span class="p">,</span> <span class="n">phase</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">abort</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable arbitration, etc. since the host adapter obviously</span>
<span class="cm">	 * lost, and tell an interrupted NCR5380_select() to restart.</span>
<span class="cm">	 */</span>

	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">restart_select</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">target_mask</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">CURRENT_SCSI_DATA_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_SELECTION</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : reselect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>

	<span class="cm">/* </span>
<span class="cm">	 * At this point, we have detected that our SCSI ID is on the bus,</span>
<span class="cm">	 * SEL is true and BSY was false for at least one bus settle delay</span>
<span class="cm">	 * (400 ns).</span>
<span class="cm">	 *</span>
<span class="cm">	 * We must assert BSY ourselves, until the target drops the SEL</span>
<span class="cm">	 * signal.</span>
<span class="cm">	 */</span>

	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_BSY</span><span class="p">);</span>

	<span class="cm">/* FIXME: timeout too long, must fail to workqueue */</span>	
	<span class="k">if</span><span class="p">(</span><span class="n">NCR5380_poll_politely</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">STATUS_REG</span><span class="p">,</span> <span class="n">SR_SEL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">HZ</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">abort</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for target to go into MSGIN.</span>
<span class="cm">	 * FIXME: timeout needed and fail to work queeu</span>
<span class="cm">	 */</span>

	<span class="k">if</span><span class="p">(</span><span class="n">NCR5380_poll_politely</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">STATUS_REG</span><span class="p">,</span> <span class="n">SR_REQ</span><span class="p">,</span> <span class="n">SR_REQ</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">HZ</span><span class="p">))</span>
		<span class="n">abort</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
	<span class="n">phase</span> <span class="o">=</span> <span class="n">PHASE_MSGIN</span><span class="p">;</span>
	<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;scsi%d : expecting IDENTIFY message, got &quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
		<span class="n">spi_print_msg</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="n">abort</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Accept message by clearing ACK */</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
		<span class="n">lun</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">);</span>

		<span class="cm">/* </span>
<span class="cm">		 * We need to add code for SCSI-II to track which devices have</span>
<span class="cm">		 * I_T_L_Q nexuses established, and which have simple I_T_L</span>
<span class="cm">		 * nexuses so we can chose to do additional data transfer.</span>
<span class="cm">		 */</span>

		<span class="cm">/* </span>
<span class="cm">		 * Find the command corresponding to the I_T_L or I_T_L_Q  nexus we </span>
<span class="cm">		 * just reestablished, and remove it from the disconnected queue.</span>
<span class="cm">		 */</span>


		<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">target_mask</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lun</span> <span class="o">==</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">)</span>
			    <span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">REMOVE</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">);</span>
					<span class="n">prev</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">REMOVE</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">);</span>
					<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;scsi%d : warning : target bitmask %02x lun %d not in disconnect_queue.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">target_mask</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
			<span class="cm">/* </span>
<span class="cm">			 * Since we have an established nexus that we can&#39;t do anything with,</span>
<span class="cm">			 * we must abort it.  </span>
<span class="cm">			 */</span>
			<span class="n">abort</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">abort</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_abort</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_RESELECTION</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : nexus established, target = %d, lun = %d, tag = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function : void NCR5380_dma_complete (struct Scsi_Host *instance)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : called by interrupt handler when DMA finishes or a phase</span>
<span class="cm"> *      mismatch occurs (which would finish the DMA transfer).  </span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : instance - this instance of the NCR5380.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns : pointer to the Scsi_Cmnd structure for which the I_T_L</span>
<span class="cm"> *      nexus has been reestablished, on failure NULL is returned.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef REAL_DMA</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">NCR5380_dma_complete</span><span class="p">(</span><span class="n">NCR5380_instance</span> <span class="o">*</span> <span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">transferred</span><span class="p">;</span>
	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX this might not be right.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Wait for final byte to transfer, ie wait for ACK to go false.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We should use the Last Byte Sent bit, unfortunately this is </span>
<span class="cm">	 * not available on the 5380/5381 (only the various CMOS chips)</span>
<span class="cm">	 *</span>
<span class="cm">	 * FIXME: timeout, and need to handle long timeout/irq case</span>
<span class="cm">	 */</span>

	<span class="n">NCR5380_poll_politely</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">BUS_AND_STATUS_REG</span><span class="p">,</span> <span class="n">BASR_ACK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>

	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The only places we should see a phase mismatch and have to send</span>
<span class="cm">	 * data from the same set of pointers will be the data transfer</span>
<span class="cm">	 * phases.  So, residual, requested length are only important here.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">&amp;</span> <span class="n">SR_CD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">transferred</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">dmalen</span> <span class="o">-</span> <span class="n">NCR5380_dma_residual</span><span class="p">();</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">-=</span> <span class="n">transferred</span><span class="p">;</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">+=</span> <span class="n">transferred</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* def REAL_DMA */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Function : int NCR5380_abort (Scsi_Cmnd *cmd)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : abort a command</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : cmd - the Scsi_Cmnd to abort, code - code to set the </span>
<span class="cm"> *      host byte of the result field to, if zero DID_ABORTED is </span>
<span class="cm"> *      used.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns : 0 - success, -1 on failure.</span>
<span class="cm"> *</span>
<span class="cm"> *	XXX - there is no way to abort the command that is currently </span>
<span class="cm"> *	connected, you have to wait for it to complete.  If this is </span>
<span class="cm"> *	a problem, we could implement longjmp() / setjmp(), setjmp()</span>
<span class="cm"> *	called where the loop started in NCR5380_main().</span>
<span class="cm"> *</span>
<span class="cm"> * Locks: host lock taken by caller</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">NCR5380_abort</span><span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">**</span><span class="n">prev</span><span class="p">;</span>
	
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;scsi%d : aborting command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="n">scsi_print_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">NCR5380_print_status</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_ABORT</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : abort called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_ABORT</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;        basr 0x%X, sr 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">),</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)));</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/*</span>
<span class="c"> * Case 1 : If the command is the currently executing command, </span>
<span class="c"> * we&#39;ll set the aborted flag and return control so that </span>
<span class="c"> * information transfer routine can exit cleanly.</span>
<span class="c"> */</span>

<span class="c">	if (hostdata-&gt;connected == cmd) {</span>
<span class="c">		dprintk(NDEBUG_ABORT, (&quot;scsi%d : aborting connected command\n&quot;, instance-&gt;host_no));</span>
<span class="c">		hostdata-&gt;aborted = 1;</span>
<span class="c">/*</span>
<span class="c"> * We should perform BSY checking, and make sure we haven&#39;t slipped</span>
<span class="c"> * into BUS FREE.</span>
<span class="c"> */</span>

<span class="c">		NCR5380_write(INITIATOR_COMMAND_REG, ICR_ASSERT_ATN);</span>
<span class="c">/* </span>
<span class="c"> * Since we can&#39;t change phases until we&#39;ve completed the current </span>
<span class="c"> * handshake, we have to source or sink a byte of data if the current</span>
<span class="c"> * phase is not MSGOUT.</span>
<span class="c"> */</span>

<span class="c">/* </span>
<span class="c"> * Return control to the executing NCR drive so we can clear the</span>
<span class="c"> * aborted flag and get back into our main loop.</span>
<span class="c"> */</span>

<span class="c">		return 0;</span>
<span class="c">	}</span>
<span class="cp">#endif</span>

<span class="cm">/* </span>
<span class="cm"> * Case 2 : If the command hasn&#39;t been issued yet, we simply remove it </span>
<span class="cm"> *          from the issue queue.</span>
<span class="cm"> */</span>
 
	<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_ABORT</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : abort going into loop.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">),</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">;</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">),</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">REMOVE</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">);</span>
			<span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">;</span>
			<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_ABORT</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : abort removed command from issue queue.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
			<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#if (NDEBUG  &amp; NDEBUG_ABORT)</span>
	<span class="cm">/* KLL */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;scsi%d : LOOP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* </span>
<span class="cm"> * Case 3 : If any commands are connected, we&#39;re going to fail the abort</span>
<span class="cm"> *          and let the high level SCSI driver retry at a later time or </span>
<span class="cm"> *          issue a reset.</span>
<span class="cm"> *</span>
<span class="cm"> *          Timeouts, and therefore aborted commands, will be highly unlikely</span>
<span class="cm"> *          and handling them cleanly in this situation would make the common</span>
<span class="cm"> *          case of noresets less efficient, and would pollute our code.  So,</span>
<span class="cm"> *          we fail.</span>
<span class="cm"> */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_ABORT</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : abort failed, command connected.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Case 4: If the command is currently disconnected from the bus, and </span>
<span class="cm"> *      there are no connected commands, we reconnect the I_T_L or </span>
<span class="cm"> *      I_T_L_Q nexus associated with it, go into message out, and send </span>
<span class="cm"> *      an abort message.</span>
<span class="cm"> *</span>
<span class="cm"> * This case is especially ugly. In order to reestablish the nexus, we</span>
<span class="cm"> * need to call NCR5380_select().  The easiest way to implement this </span>
<span class="cm"> * function was to abort if the bus was busy, and let the interrupt</span>
<span class="cm"> * handler triggered on the SEL for reselect take care of lost arbitrations</span>
<span class="cm"> * where necessary, meaning interrupts need to be enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * When interrupts are enabled, the queues may change - so we </span>
<span class="cm"> * can&#39;t remove it from the disconnected queue before selecting it</span>
<span class="cm"> * because that could cause a failure in hashing the nexus if that </span>
<span class="cm"> * device reselected.</span>
<span class="cm"> * </span>
<span class="cm"> * Since the queues may change, we can&#39;t use the pointers from when we</span>
<span class="cm"> * first locate it.</span>
<span class="cm"> *</span>
<span class="cm"> * So, we must first locate the command, and if NCR5380_select()</span>
<span class="cm"> * succeeds, then issue the abort, relocate the command and remove</span>
<span class="cm"> * it from the disconnected queue.</span>
<span class="cm"> */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">;</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_ABORT</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : aborting disconnected command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">NCR5380_select</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="n">NDEBUG_ABORT</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;scsi%d : nexus reestablished.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>

			<span class="n">do_abort</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">),</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">;</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">),</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">REMOVE</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">);</span>
					<span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">;</span>
					<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
					<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
				<span class="p">}</span>
		<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Case 5 : If we reached this point, the command was not found in any of </span>
<span class="cm"> *          the queues.</span>
<span class="cm"> *</span>
<span class="cm"> * We probably reached this point because of an unlikely race condition</span>
<span class="cm"> * between the command completing successfully and the abortion code,</span>
<span class="cm"> * so we won&#39;t panic, but we will notify the user in case something really</span>
<span class="cm"> * broke.</span>
<span class="cm"> */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;scsi%d : warning : SCSI command probably completed successfully</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;         before abortion</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* </span>
<span class="cm"> * Function : int NCR5380_bus_reset (Scsi_Cmnd *cmd)</span>
<span class="cm"> * </span>
<span class="cm"> * Purpose : reset the SCSI bus.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns : SUCCESS</span>
<span class="cm"> *</span>
<span class="cm"> * Locks: host lock taken by caller</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">NCR5380_bus_reset</span><span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="n">NCR5380_local_declare</span><span class="p">();</span>
	<span class="n">NCR5380_setup</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="n">NCR5380_print_status</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">do_reset</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
