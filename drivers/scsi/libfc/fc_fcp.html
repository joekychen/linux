<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › libfc › fc_fcp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fc_fcp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright(c) 2007 Intel Corporation. All rights reserved.</span>
<span class="cm"> * Copyright(c) 2008 Red Hat, Inc.  All rights reserved.</span>
<span class="cm"> * Copyright(c) 2008 Mike Christie</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintained at www.Open-FCoE.org</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>

<span class="cp">#include &lt;scsi/fc/fc_fc2.h&gt;</span>

<span class="cp">#include &lt;scsi/libfc.h&gt;</span>
<span class="cp">#include &lt;scsi/fc_encode.h&gt;</span>

<span class="cp">#include &quot;fc_libfc.h&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">scsi_pkt_cachep</span><span class="p">;</span>

<span class="cm">/* SRB state definitions */</span>
<span class="cp">#define FC_SRB_FREE		0		</span><span class="cm">/* cmd is free */</span><span class="cp"></span>
<span class="cp">#define FC_SRB_CMD_SENT		(1 &lt;&lt; 0)	</span><span class="cm">/* cmd has been sent */</span><span class="cp"></span>
<span class="cp">#define FC_SRB_RCV_STATUS	(1 &lt;&lt; 1)	</span><span class="cm">/* response has arrived */</span><span class="cp"></span>
<span class="cp">#define FC_SRB_ABORT_PENDING	(1 &lt;&lt; 2)	</span><span class="cm">/* cmd abort sent to device */</span><span class="cp"></span>
<span class="cp">#define FC_SRB_ABORTED		(1 &lt;&lt; 3)	</span><span class="cm">/* abort acknowledged */</span><span class="cp"></span>
<span class="cp">#define FC_SRB_DISCONTIG	(1 &lt;&lt; 4)	</span><span class="cm">/* non-sequential data recvd */</span><span class="cp"></span>
<span class="cp">#define FC_SRB_COMPL		(1 &lt;&lt; 5)	</span><span class="cm">/* fc_io_compl has been run */</span><span class="cp"></span>
<span class="cp">#define FC_SRB_FCP_PROCESSING_TMO (1 &lt;&lt; 6)	</span><span class="cm">/* timer function processing */</span><span class="cp"></span>

<span class="cp">#define FC_SRB_READ		(1 &lt;&lt; 1)</span>
<span class="cp">#define FC_SRB_WRITE		(1 &lt;&lt; 0)</span>

<span class="cm">/*</span>
<span class="cm"> * The SCp.ptr should be tested and set under the scsi_pkt_queue lock</span>
<span class="cm"> */</span>
<span class="cp">#define CMD_SP(Cmnd)		    ((struct fc_fcp_pkt *)(Cmnd)-&gt;SCp.ptr)</span>
<span class="cp">#define CMD_ENTRY_STATUS(Cmnd)	    ((Cmnd)-&gt;SCp.have_data_in)</span>
<span class="cp">#define CMD_COMPL_STATUS(Cmnd)	    ((Cmnd)-&gt;SCp.this_residual)</span>
<span class="cp">#define CMD_SCSI_STATUS(Cmnd)	    ((Cmnd)-&gt;SCp.Status)</span>
<span class="cp">#define CMD_RESID_LEN(Cmnd)	    ((Cmnd)-&gt;SCp.buffers_residual)</span>

<span class="cm">/**</span>
<span class="cm"> * struct fc_fcp_internal - FCP layer internal data</span>
<span class="cm"> * @scsi_pkt_pool: Memory pool to draw FCP packets from</span>
<span class="cm"> * @scsi_queue_lock: Protects the scsi_pkt_queue</span>
<span class="cm"> * @scsi_pkt_queue: Current FCP packets</span>
<span class="cm"> * @last_can_queue_ramp_down_time: ramp down time</span>
<span class="cm"> * @last_can_queue_ramp_up_time: ramp up time</span>
<span class="cm"> * @max_can_queue: max can_queue size</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_fcp_internal</span> <span class="p">{</span>
	<span class="n">mempool_t</span>		<span class="o">*</span><span class="n">scsi_pkt_pool</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">scsi_queue_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">scsi_pkt_queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">last_can_queue_ramp_down_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">last_can_queue_ramp_up_time</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_can_queue</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define fc_get_scsi_internal(x)	((struct fc_fcp_internal *)(x)-&gt;scsi_priv)</span>

<span class="cm">/*</span>
<span class="cm"> * function prototypes</span>
<span class="cm"> * FC scsi I/O related functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_fcp_recv_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_fcp_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_fcp_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_fcp_complete_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_tm_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_fcp_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_fcp_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">code</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_fcp_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_fcp_rec</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_fcp_rec_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_fcp_rec_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_io_compl</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_fcp_srr</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fc_rctl</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_fcp_srr_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_fcp_srr_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * command status codes</span>
<span class="cm"> */</span>
<span class="cp">#define FC_COMPLETE		0</span>
<span class="cp">#define FC_CMD_ABORTED		1</span>
<span class="cp">#define FC_CMD_RESET		2</span>
<span class="cp">#define FC_CMD_PLOGO		3</span>
<span class="cp">#define FC_SNS_RCV		4</span>
<span class="cp">#define FC_TRANS_ERR		5</span>
<span class="cp">#define FC_DATA_OVRRUN		6</span>
<span class="cp">#define FC_DATA_UNDRUN		7</span>
<span class="cp">#define FC_ERROR		8</span>
<span class="cp">#define FC_HRD_ERROR		9</span>
<span class="cp">#define FC_CRC_ERROR		10</span>
<span class="cp">#define FC_TIMED_OUT		11</span>

<span class="cm">/*</span>
<span class="cm"> * Error recovery timeout values.</span>
<span class="cm"> */</span>
<span class="cp">#define FC_SCSI_TM_TOV		(10 * HZ)</span>
<span class="cp">#define FC_HOST_RESET_TIMEOUT	(30 * HZ)</span>
<span class="cp">#define FC_CAN_QUEUE_PERIOD	(60 * HZ)</span>

<span class="cp">#define FC_MAX_ERROR_CNT	5</span>
<span class="cp">#define FC_MAX_RECOV_RETRY	3</span>

<span class="cp">#define FC_FCP_DFLT_QUEUE_DEPTH 32</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_pkt_alloc() - Allocate a fcp_pkt</span>
<span class="cm"> * @lport: The local port that the FCP packet is for</span>
<span class="cm"> * @gfp:   GFP flags for allocation</span>
<span class="cm"> *</span>
<span class="cm"> * Return value: fcp_pkt structure or null on allocation failure.</span>
<span class="cm"> * Context:	 Can be called from process context, no lock is required.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="nf">fc_fcp_pkt_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_fcp_internal</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">fc_get_scsi_internal</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">;</span>

	<span class="n">fsp</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_pkt_pool</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fsp</span><span class="p">));</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span> <span class="o">=</span> <span class="n">lport</span><span class="p">;</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_ddp</span> <span class="o">=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">;</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fsp</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_pkt_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">fsp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_pkt_release() - Release hold on a fcp_pkt</span>
<span class="cm"> * @fsp: The FCP packet to be released</span>
<span class="cm"> *</span>
<span class="cm"> * Context: Can be called from process or interrupt context,</span>
<span class="cm"> *	    no lock is required.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_pkt_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fc_fcp_internal</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">fc_get_scsi_internal</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">);</span>

		<span class="n">mempool_free</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_pkt_pool</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_pkt_hold() - Hold a fcp_pkt</span>
<span class="cm"> * @fsp: The FCP packet to be held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_pkt_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_pkt_destory() - Release hold on a fcp_pkt</span>
<span class="cm"> * @seq: The sequence that the FCP packet is on (required by destructor API)</span>
<span class="cm"> * @fsp: The FCP packet to be released</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called by a destructor callback in the exch_seq_send()</span>
<span class="cm"> * routine of the libfc Transport Template. The &#39;struct fc_seq&#39; is a required</span>
<span class="cm"> * argument even though it is not used by this routine.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: No locking required.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_pkt_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fc_fcp_pkt_release</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_lock_pkt() - Lock a fcp_pkt and increase its reference count</span>
<span class="cm"> * @fsp: The FCP packet to be locked and incremented</span>
<span class="cm"> *</span>
<span class="cm"> * We should only return error if we return a command to SCSI-ml before</span>
<span class="cm"> * getting a response. This can happen in cases where we send a abort, but</span>
<span class="cm"> * do not wait for the response and the abort and command can be passing</span>
<span class="cm"> * each other on the wire/network-layer.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: this function locks the packet and gets a reference to allow</span>
<span class="cm"> * callers to call the completion function while the lock is held and</span>
<span class="cm"> * not have to worry about the packets refcount.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: Maybe we should just have callers grab/release the lock and</span>
<span class="cm"> * have a function that they call to verify the fsp and grab a ref if</span>
<span class="cm"> * needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fc_fcp_lock_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_pkt_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">FC_SRB_COMPL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_pkt_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fc_fcp_pkt_hold</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_unlock_pkt() - Release a fcp_pkt&#39;s lock and decrement its</span>
<span class="cm"> *			 reference count</span>
<span class="cm"> * @fsp: The FCP packet to be unlocked and decremented</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fc_fcp_unlock_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_pkt_lock</span><span class="p">);</span>
	<span class="n">fc_fcp_pkt_release</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_timer_set() - Start a timer for a fcp_pkt</span>
<span class="cm"> * @fsp:   The FCP packet to start a timer for</span>
<span class="cm"> * @delay: The timeout period in jiffies</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_timer_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">FC_SRB_COMPL</span><span class="p">))</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_send_abort() - Send an abort for exchanges associated with a</span>
<span class="cm"> *			 fcp_pkt</span>
<span class="cm"> * @fsp: The FCP packet to abort exchanges on</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_fcp_send_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">FC_SRB_ABORT_PENDING</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_exch_abort</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_retry_cmd() - Retry a fcp_pkt</span>
<span class="cm"> * @fsp: The FCP packet to be retried</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the status code to be FC_ERROR and then calls</span>
<span class="cm"> * fc_fcp_complete_locked() which in turn calls fc_io_compl().</span>
<span class="cm"> * fc_io_compl() will notify the SCSI-ml that the I/O is done.</span>
<span class="cm"> * The SCSI-ml will retry the command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_retry_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_done</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span><span class="p">);</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_SRB_ABORT_PENDING</span><span class="p">;</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">io_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">status_code</span> <span class="o">=</span> <span class="n">FC_ERROR</span><span class="p">;</span>
	<span class="n">fc_fcp_complete_locked</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_ddp_setup() - Calls a LLD&#39;s ddp_setup routine to set up DDP context</span>
<span class="cm"> * @fsp: The FCP packet that will manage the DDP frames</span>
<span class="cm"> * @xid: The XID that will be used for the DDP exchange</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fc_fcp_ddp_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">,</span> <span class="n">u16</span> <span class="n">xid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>

	<span class="n">lport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">req_flags</span> <span class="o">&amp;</span> <span class="n">FC_SRB_READ</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_enabled</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">ddp_setup</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">ddp_setup</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">),</span>
					<span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)))</span>
			<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_ddp</span> <span class="o">=</span> <span class="n">xid</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_ddp_done() - Calls a LLD&#39;s ddp_done routine to release any</span>
<span class="cm"> *		       DDP related resources for a fcp_pkt</span>
<span class="cm"> * @fsp: The FCP packet that DDP had been used on</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fc_fcp_ddp_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_ddp</span> <span class="o">==</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">lport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">ddp_done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span> <span class="o">=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">ddp_done</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_ddp</span><span class="p">);</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_ddp</span> <span class="o">=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_can_queue_ramp_up() - increases can_queue</span>
<span class="cm"> * @lport: lport to ramp up can_queue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_can_queue_ramp_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_fcp_internal</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">fc_get_scsi_internal</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">can_queue</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">last_can_queue_ramp_up_time</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">last_can_queue_ramp_up_time</span> <span class="o">+</span>
			 <span class="n">FC_CAN_QUEUE_PERIOD</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">last_can_queue_ramp_down_time</span> <span class="o">+</span>
			<span class="n">FC_CAN_QUEUE_PERIOD</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">si</span><span class="o">-&gt;</span><span class="n">last_can_queue_ramp_up_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">can_queue</span> <span class="o">=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">can_queue</span> <span class="o">&gt;=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">max_can_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">can_queue</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">max_can_queue</span><span class="p">;</span>
		<span class="n">si</span><span class="o">-&gt;</span><span class="n">last_can_queue_ramp_down_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">can_queue</span><span class="p">;</span>
	<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="s">&quot;libfc: increased &quot;</span>
		     <span class="s">&quot;can_queue to %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">can_queue</span><span class="p">);</span>

<span class="nl">unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_can_queue_ramp_down() - reduces can_queue</span>
<span class="cm"> * @lport: lport to reduce can_queue</span>
<span class="cm"> *</span>
<span class="cm"> * If we are getting memory allocation failures, then we may</span>
<span class="cm"> * be trying to execute too many commands. We let the running</span>
<span class="cm"> * commands complete or timeout, then try again with a reduced</span>
<span class="cm"> * can_queue. Eventually we will hit the point where we run</span>
<span class="cm"> * on all reserved structs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_can_queue_ramp_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_fcp_internal</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">fc_get_scsi_internal</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">can_queue</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">last_can_queue_ramp_down_time</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">last_can_queue_ramp_down_time</span> <span class="o">+</span>
			 <span class="n">FC_CAN_QUEUE_PERIOD</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">si</span><span class="o">-&gt;</span><span class="n">last_can_queue_ramp_down_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">can_queue</span> <span class="o">=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span><span class="p">;</span>
	<span class="n">can_queue</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_queue</span><span class="p">)</span>
		<span class="n">can_queue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">can_queue</span><span class="p">;</span>
	<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="s">&quot;libfc: Could not allocate frame.</span><span class="se">\n</span><span class="s">&quot;</span>
		     <span class="s">&quot;Reducing can_queue to %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">can_queue</span><span class="p">);</span>

<span class="nl">unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fc_fcp_frame_alloc() -  Allocates fc_frame structure and buffer.</span>
<span class="cm"> * @lport:	fc lport struct</span>
<span class="cm"> * @len:	payload length</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates fc_frame structure and buffer but if fails to allocate</span>
<span class="cm"> * then reduce can_queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="nf">fc_fcp_frame_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
						  <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">fc_frame_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">fp</span><span class="p">;</span>

	<span class="cm">/* error case */</span>
	<span class="n">fc_fcp_can_queue_ramp_down</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_recv_data() - Handler for receiving SCSI-FCP data from a target</span>
<span class="cm"> * @fsp: The FCP packet the data is on</span>
<span class="cm"> * @fp:	 The data frame</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_recv_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_dev_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">start_offset</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">crc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">copy_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nents</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">host_bcode</span> <span class="o">=</span> <span class="n">FC_COMPLETE</span><span class="p">;</span>

	<span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_parm_offset</span><span class="p">);</span>
	<span class="n">start_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">fr_len</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fh</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if this I/O is ddped then clear it and initiate recovery since data</span>
<span class="cm">	 * frames are expected to be placed directly in that case.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Indicate error to scsi-ml because something went wrong with the</span>
<span class="cm">	 * ddp handling to get us here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_ddp</span> <span class="o">!=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc_fcp_ddp_done</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;DDP I/O in fc_fcp_recv_data set ERROR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">host_bcode</span> <span class="o">=</span> <span class="n">FC_ERROR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this should never happen */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fr_flags</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FCPHF_CRC_UNCHECKED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">fc_frame_crc_check</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">crc_err</span><span class="p">;</span>
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;data received past end. len %zx offset %zx &quot;</span>
			   <span class="s">&quot;data_len %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>

		<span class="cm">/* Data is corrupted indicate scsi-ml should retry */</span>
		<span class="n">host_bcode</span> <span class="o">=</span> <span class="n">FC_DATA_OVRRUN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span><span class="p">)</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">FC_SRB_DISCONTIG</span><span class="p">;</span>

	<span class="n">sg</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">nents</span> <span class="o">=</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fr_flags</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FCPHF_CRC_UNCHECKED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">copy_len</span> <span class="o">=</span> <span class="n">fc_copy_buffer_to_sglist</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nents</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">fh</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fh</span><span class="p">));</span>
		<span class="n">copy_len</span> <span class="o">=</span> <span class="n">fc_copy_buffer_to_sglist</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nents</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">crc</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">crc</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="n">len</span> <span class="o">%</span> <span class="mi">4</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">crc</span> <span class="o">!=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">fr_crc</span><span class="p">(</span><span class="n">fp</span><span class="p">)))</span> <span class="p">{</span>
<span class="nl">crc_err:</span>
			<span class="n">stats</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">dev_stats</span><span class="p">,</span> <span class="n">get_cpu</span><span class="p">());</span>
			<span class="n">stats</span><span class="o">-&gt;</span><span class="n">ErrorFrames</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* per cpu count, not total count, but OK for limit */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">InvalidCRCCount</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">FC_MAX_ERROR_CNT</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;libfc: CRC error on data &quot;</span>
				       <span class="s">&quot;frame for port (%6.6x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">lport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">);</span>
			<span class="n">put_cpu</span><span class="p">();</span>
			<span class="cm">/*</span>
<span class="cm">			 * Assume the frame is total garbage.</span>
<span class="cm">			 * We may have copied it over the good part</span>
<span class="cm">			 * of the buffer.</span>
<span class="cm">			 * If so, we need to retry the entire operation.</span>
<span class="cm">			 * Otherwise, ignore it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">FC_SRB_DISCONTIG</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">host_bcode</span> <span class="o">=</span> <span class="n">FC_CRC_ERROR</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_contig_end</span> <span class="o">==</span> <span class="n">start_offset</span><span class="p">)</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_contig_end</span> <span class="o">+=</span> <span class="n">copy_len</span><span class="p">;</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span> <span class="o">+=</span> <span class="n">copy_len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In the very rare event that this data arrived after the response</span>
<span class="cm">	 * and completes the transfer, call the completion handler.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">FC_SRB_RCV_STATUS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span> <span class="o">==</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">-</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_resid</span><span class="p">)</span>
		<span class="n">fc_fcp_complete_locked</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">fc_fcp_recovery</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">host_bcode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_send_data() - Send SCSI data to a target</span>
<span class="cm"> * @fsp:      The FCP packet the data is on</span>
<span class="cm"> * @sp:	      The sequence the data is to be sent on</span>
<span class="cm"> * @offset:   The starting offset for this data request</span>
<span class="cm"> * @seq_blen: The burst length for this data request</span>
<span class="cm"> *</span>
<span class="cm"> * Called after receiving a Transfer Ready data descriptor.</span>
<span class="cm"> * If the LLD is capable of sequence offload then send down the</span>
<span class="cm"> * seq_blen amount of data in single frame, otherwise send</span>
<span class="cm"> * multiple frames of the maximum frame payload supported by</span>
<span class="cm"> * the target port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_fcp_send_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">seq_blen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">remaining</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">t_blen</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">tlen</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">sg_bytes</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">frame_offset</span><span class="p">,</span> <span class="n">fh_parm_offset</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">off</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">page_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">using_sg</span> <span class="o">=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">sg_supp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">f_ctl</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">seq_blen</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">seq_blen</span> <span class="o">&gt;</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* this should never happen */</span>
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;xfer-ready past end. seq_blen %zx &quot;</span>
			   <span class="s">&quot;offset %zx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">seq_blen</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">fc_fcp_send_abort</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Out of Order Data Request - no problem, but unexpected. */</span>
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;xfer-ready non-contiguous. &quot;</span>
			   <span class="s">&quot;seq_blen %zx offset %zx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">seq_blen</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * if LLD is capable of seq_offload then set transport</span>
<span class="cm">	 * burst length (t_blen) to seq_blen, otherwise set t_blen</span>
<span class="cm">	 * to max FC frame payload previously set in fsp-&gt;max_payload.</span>
<span class="cm">	 */</span>
	<span class="n">t_blen</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">max_payload</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">seq_offload</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t_blen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">seq_blen</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">lso_max</span><span class="p">);</span>
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;fsp=%p:lso:blen=%zx lso_max=0x%x t_blen=%zx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">fsp</span><span class="p">,</span> <span class="n">seq_blen</span><span class="p">,</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">lso_max</span><span class="p">,</span> <span class="n">t_blen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t_blen</span> <span class="o">&gt;</span> <span class="mi">512</span><span class="p">)</span>
		<span class="n">t_blen</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">512</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* round down to block size */</span>
	<span class="n">sc</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>

	<span class="n">remaining</span> <span class="o">=</span> <span class="n">seq_blen</span><span class="p">;</span>
	<span class="n">fh_parm_offset</span> <span class="o">=</span> <span class="n">frame_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">tlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_start_next</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
	<span class="n">f_ctl</span> <span class="o">=</span> <span class="n">FC_FC_REL_OFF</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">seq</span><span class="p">);</span>

	<span class="n">sg</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">-=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
			<span class="n">sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tlen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">t_blen</span><span class="p">,</span> <span class="n">remaining</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * TODO.  Temporary workaround.	 fc_seq_send() can&#39;t</span>
<span class="cm">			 * handle odd lengths in non-linear skbs.</span>
<span class="cm">			 * This will be the final fragment only.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tlen</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span>
				<span class="n">using_sg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">fp</span> <span class="o">=</span> <span class="n">fc_frame_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">using_sg</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">tlen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="n">data</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">fh_parm_offset</span> <span class="o">=</span> <span class="n">frame_offset</span><span class="p">;</span>
			<span class="n">fr_max_payload</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">max_payload</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">off</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">sg_bytes</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tlen</span><span class="p">,</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">sg_bytes</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sg_bytes</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">off</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)));</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">using_sg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">fp_skb</span><span class="p">(</span><span class="n">fp</span><span class="p">),</span>
					   <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">fp_skb</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">,</span>
					   <span class="n">page</span><span class="p">,</span> <span class="n">off</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">,</span> <span class="n">sg_bytes</span><span class="p">);</span>
			<span class="n">fp_skb</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">sg_bytes</span><span class="p">;</span>
			<span class="n">fr_len</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">+=</span> <span class="n">sg_bytes</span><span class="p">;</span>
			<span class="n">fp_skb</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The scatterlist item may be bigger than PAGE_SIZE,</span>
<span class="cm">			 * but we must not cross pages inside the kmap.</span>
<span class="cm">			 */</span>
			<span class="n">page_addr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">page_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">off</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">),</span>
			       <span class="n">sg_bytes</span><span class="p">);</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">page_addr</span><span class="p">);</span>
			<span class="n">data</span> <span class="o">+=</span> <span class="n">sg_bytes</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">sg_bytes</span><span class="p">;</span>
		<span class="n">frame_offset</span> <span class="o">+=</span> <span class="n">sg_bytes</span><span class="p">;</span>
		<span class="n">tlen</span> <span class="o">-=</span> <span class="n">sg_bytes</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="n">sg_bytes</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">fp_skb</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">&lt;</span> <span class="n">FC_FRAME_SG_LEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">tlen</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Send sequence with transfer sequence initiative in case</span>
<span class="cm">		 * this is last FCP frame of the sequence.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">f_ctl</span> <span class="o">|=</span> <span class="n">FC_FC_SEQ_INIT</span> <span class="o">|</span> <span class="n">FC_FC_END_SEQ</span><span class="p">;</span>

		<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
		<span class="n">fc_fill_fc_hdr</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">FC_RCTL_DD_SOL_DATA</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">did</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
			       <span class="n">FC_TYPE_FCP</span><span class="p">,</span> <span class="n">f_ctl</span><span class="p">,</span> <span class="n">fh_parm_offset</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * send fragment using for a sequence.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>		<span class="cm">/* send error should be rare */</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span> <span class="o">+=</span> <span class="n">seq_blen</span><span class="p">;</span>	<span class="cm">/* premature count? */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_abts_resp() - Receive an ABTS response</span>
<span class="cm"> * @fsp: The FCP packet that is being aborted</span>
<span class="cm"> * @fp:	 The response frame</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_abts_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ba_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_ba_rjt</span> <span class="o">*</span><span class="n">brp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>

	<span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FC_RCTL_BA_ACC</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FC_RCTL_BA_RJT</span>:
		<span class="n">brp</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">brp</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">brp</span> <span class="o">&amp;&amp;</span> <span class="n">brp</span><span class="o">-&gt;</span><span class="n">br_reason</span> <span class="o">==</span> <span class="n">FC_BA_RJT_LOG_ERR</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* fall thru */</span>
	<span class="nl">default:</span>
		<span class="cm">/*</span>
<span class="cm">		 * we will let the command timeout</span>
<span class="cm">		 * and scsi-ml recover in this case,</span>
<span class="cm">		 * therefore cleared the ba_done flag.</span>
<span class="cm">		 */</span>
		<span class="n">ba_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ba_done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">FC_SRB_ABORTED</span><span class="p">;</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_SRB_ABORT_PENDING</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">wait_for_comp</span><span class="p">)</span>
			<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">tm_done</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">fc_fcp_complete_locked</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_recv() - Receive an FCP frame</span>
<span class="cm"> * @seq: The sequence the frame is on</span>
<span class="cm"> * @fp:	 The received frame</span>
<span class="cm"> * @arg: The related FCP packet</span>
<span class="cm"> *</span>
<span class="cm"> * Context: Called from Soft IRQ context. Can not be called</span>
<span class="cm"> *	    holding the FCP packet list lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_txrdy</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">r_ctl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fc_fcp_error</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">r_ctl</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">LPORT_ST_READY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fc_fcp_lock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_type</span> <span class="o">==</span> <span class="n">FC_TYPE_BLS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc_fcp_abts_resp</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FC_SRB_ABORTED</span> <span class="o">|</span> <span class="n">FC_SRB_ABORT_PENDING</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r_ctl</span> <span class="o">==</span> <span class="n">FC_RCTL_DD_DATA_DESC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * received XFER RDY from the target</span>
<span class="cm">		 * need to send data to the target</span>
<span class="cm">		 */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fr_flags</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FCPHF_CRC_UNCHECKED</span><span class="p">);</span>
		<span class="n">dd</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dd</span><span class="p">));</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">fc_fcp_send_data</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span>
				      <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ft_data_ro</span><span class="p">),</span>
				      <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ft_burst_len</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">seq</span><span class="o">-&gt;</span><span class="n">rec_data</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_ctl</span> <span class="o">==</span> <span class="n">FC_RCTL_DD_SOL_DATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * received a DATA frame</span>
<span class="cm">		 * next we will copy the data to the system buffer</span>
<span class="cm">		 */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fr_len</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fh</span><span class="p">));</span>	<span class="cm">/* len may be 0 */</span>
		<span class="n">fc_fcp_recv_data</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="n">seq</span><span class="o">-&gt;</span><span class="n">rec_data</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_contig_end</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_ctl</span> <span class="o">==</span> <span class="n">FC_RCTL_DD_CMD_STATUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fr_flags</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FCPHF_CRC_UNCHECKED</span><span class="p">);</span>

		<span class="n">fc_fcp_resp</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;unexpected frame.  r_ctl %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r_ctl</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">unlock:</span>
	<span class="n">fc_fcp_unlock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_resp() - Handler for FCP responses</span>
<span class="cm"> * @fsp: The FCP packet the response is for</span>
<span class="cm"> * @fp:	 The response frame</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_resp</span> <span class="o">*</span><span class="n">fc_rp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_resp_ext</span> <span class="o">*</span><span class="n">rp_ex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_resp_rsp_info</span> <span class="o">*</span><span class="n">fc_rp_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">plen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">expected_len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">respl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">snsl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">plen</span> <span class="o">=</span> <span class="n">fr_len</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">fh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="p">)</span><span class="n">fr_hdr</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">plen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fh</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fc_rp</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">len_err</span><span class="p">;</span>
	<span class="n">plen</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fh</span><span class="p">);</span>
	<span class="n">fc_rp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fcp_resp</span> <span class="o">*</span><span class="p">)(</span><span class="n">fh</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_status</span> <span class="o">=</span> <span class="n">fc_rp</span><span class="o">-&gt;</span><span class="n">fr_status</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">fc_rp</span><span class="o">-&gt;</span><span class="n">fr_flags</span><span class="p">;</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_comp_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">expected_len</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>

	<span class="cm">/* if ddp, update xfer len */</span>
	<span class="n">fc_fcp_ddp_done</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FCP_CONF_REQ</span><span class="p">)</span> <span class="o">||</span> <span class="n">fc_rp</span><span class="o">-&gt;</span><span class="n">fr_status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rp_ex</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">fc_rp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FCP_RSP_LEN_VAL</span> <span class="o">|</span> <span class="n">FCP_SNS_LEN_VAL</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fc_rp</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rp_ex</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">len_err</span><span class="p">;</span>
			<span class="n">fc_rp_info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fcp_resp_rsp_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">rp_ex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCP_RSP_LEN_VAL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">respl</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">rp_ex</span><span class="o">-&gt;</span><span class="n">fr_rsp_len</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">respl</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fc_rp_info</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">len_err</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">wait_for_comp</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Abuse cdb_status for rsp code */</span>
					<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_status</span> <span class="o">=</span> <span class="n">fc_rp_info</span><span class="o">-&gt;</span><span class="n">rsp_code</span><span class="p">;</span>
					<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">tm_done</span><span class="p">);</span>
					<span class="cm">/*</span>
<span class="cm">					 * tmfs will not have any scsi cmd so</span>
<span class="cm">					 * exit here</span>
<span class="cm">					 */</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCP_SNS_LEN_VAL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">snsl</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">rp_ex</span><span class="o">-&gt;</span><span class="n">fr_sns_len</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">snsl</span> <span class="o">&gt;</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">)</span>
					<span class="n">snsl</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">fc_rp_info</span> <span class="o">+</span> <span class="n">respl</span><span class="p">,</span> <span class="n">snsl</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FCP_RESID_UNDER</span> <span class="o">|</span> <span class="n">FCP_RESID_OVER</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fc_rp</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rp_ex</span><span class="o">-&gt;</span><span class="n">fr_resid</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">len_err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCP_RESID_UNDER</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_resid</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">rp_ex</span><span class="o">-&gt;</span><span class="n">fr_resid</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * The cmnd-&gt;underflow is the minimum number of</span>
<span class="cm">				 * bytes that must be transferred for this</span>
<span class="cm">				 * command.  Provided a sense condition is not</span>
<span class="cm">				 * present, make sure the actual amount</span>
<span class="cm">				 * transferred is at least the underflow value</span>
<span class="cm">				 * or fail.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCP_SNS_LEN_VAL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">fc_rp</span><span class="o">-&gt;</span><span class="n">fr_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="o">-</span>
				     <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_resid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">underflow</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
				<span class="n">expected_len</span> <span class="o">-=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_resid</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">status_code</span> <span class="o">=</span> <span class="n">FC_ERROR</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">FC_SRB_RCV_STATUS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for missing or extra data frames.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span> <span class="o">!=</span> <span class="n">expected_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span> <span class="o">&lt;</span> <span class="n">expected_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Some data may be queued locally,</span>
<span class="cm">			 * Wait a at least one jiffy to see if it is delivered.</span>
<span class="cm">			 * If this expires without data, we may do SRR.</span>
<span class="cm">			 */</span>
			<span class="n">fc_fcp_timer_set</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">status_code</span> <span class="o">=</span> <span class="n">FC_DATA_OVRRUN</span><span class="p">;</span>
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;tgt %6.6x xfer len %zx greater than expected, &quot;</span>
			   <span class="s">&quot;len %x, data len %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span>
			   <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span><span class="p">,</span> <span class="n">expected_len</span><span class="p">,</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">fc_fcp_complete_locked</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">len_err:</span>
	<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;short FCP response. flags 0x%x len %u respl %u &quot;</span>
		   <span class="s">&quot;snsl %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">fr_len</span><span class="p">(</span><span class="n">fp</span><span class="p">),</span> <span class="n">respl</span><span class="p">,</span> <span class="n">snsl</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">status_code</span> <span class="o">=</span> <span class="n">FC_ERROR</span><span class="p">;</span>
	<span class="n">fc_fcp_complete_locked</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_complete_locked() - Complete processing of a fcp_pkt with the</span>
<span class="cm"> *			      fcp_pkt lock held</span>
<span class="cm"> * @fsp: The FCP packet to be completed</span>
<span class="cm"> *</span>
<span class="cm"> * This function may sleep if a timer is pending. The packet lock must be</span>
<span class="cm"> * held, and the host lock must not be held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_complete_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">f_ctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">FC_SRB_ABORT_PENDING</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">FC_SRB_ABORTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">status_code</span><span class="p">)</span>
			<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">status_code</span> <span class="o">=</span> <span class="n">FC_CMD_ABORTED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Test for transport underrun, independent of response</span>
<span class="cm">		 * underrun status.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span> <span class="o">&lt;</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">io_status</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_comp_flags</span> <span class="o">&amp;</span> <span class="n">FCP_RESID_UNDER</span><span class="p">)</span> <span class="o">||</span>
		     <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span> <span class="o">&lt;</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">-</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_resid</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">status_code</span> <span class="o">=</span> <span class="n">FC_DATA_UNDRUN</span><span class="p">;</span>
			<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">io_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_comp_flags</span> <span class="o">&amp;</span> <span class="n">FCP_CONF_REQ</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">conf_frame</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">csp</span><span class="p">;</span>

			<span class="n">csp</span> <span class="o">=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_start_next</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
			<span class="n">conf_frame</span> <span class="o">=</span> <span class="n">fc_fcp_frame_alloc</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">conf_frame</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">f_ctl</span> <span class="o">=</span> <span class="n">FC_FC_SEQ_INIT</span><span class="p">;</span>
				<span class="n">f_ctl</span> <span class="o">|=</span> <span class="n">FC_FC_LAST_SEQ</span> <span class="o">|</span> <span class="n">FC_FC_END_SEQ</span><span class="p">;</span>
				<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
				<span class="n">fc_fill_fc_hdr</span><span class="p">(</span><span class="n">conf_frame</span><span class="p">,</span> <span class="n">FC_RCTL_DD_SOL_CTL</span><span class="p">,</span>
					       <span class="n">ep</span><span class="o">-&gt;</span><span class="n">did</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
					       <span class="n">FC_TYPE_FCP</span><span class="p">,</span> <span class="n">f_ctl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">csp</span><span class="p">,</span> <span class="n">conf_frame</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_done</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Some resets driven by SCSI are not I/Os and do not have</span>
<span class="cm">	 * SCSI commands associated with the requests. We should not</span>
<span class="cm">	 * call I/O completion if we do not have a SCSI command.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span>
		<span class="n">fc_io_compl</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_cleanup_cmd() - Cancel the active exchange on a fcp_pkt</span>
<span class="cm"> * @fsp:   The FCP packet whose exchanges should be canceled</span>
<span class="cm"> * @error: The reason for the cancellation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_cleanup_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_done</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span><span class="p">);</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">status_code</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_cleanup_each_cmd() - Cancel all exchanges on a local port</span>
<span class="cm"> * @lport: The local port whose exchanges should be canceled</span>
<span class="cm"> * @id:	   The target&#39;s ID</span>
<span class="cm"> * @lun:   The LUN</span>
<span class="cm"> * @error: The reason for cancellation</span>
<span class="cm"> *</span>
<span class="cm"> * If lun or id is -1, they are ignored.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_cleanup_each_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_fcp_internal</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">fc_get_scsi_internal</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc_cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">restart:</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_pkt_queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sc_cmd</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">scmd_id</span><span class="p">(</span><span class="n">sc_cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">id</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lun</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">!=</span> <span class="n">lun</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">fc_fcp_pkt_hold</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fc_fcp_lock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fc_fcp_cleanup_cmd</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="n">fc_io_compl</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
			<span class="n">fc_fcp_unlock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">fc_fcp_pkt_release</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * while we dropped the lock multiple pkts could</span>
<span class="cm">		 * have been released, so we have to start over.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_abort_io() - Abort all FCP-SCSI exchanges on a local port</span>
<span class="cm"> * @lport: The local port whose exchanges are to be aborted</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_abort_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fc_fcp_cleanup_each_cmd</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">FC_HRD_ERROR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_pkt_send() - Send a fcp_pkt</span>
<span class="cm"> * @lport: The local port to send the FCP packet on</span>
<span class="cm"> * @fsp:   The FCP packet to send</span>
<span class="cm"> *</span>
<span class="cm"> * Return:  Zero for success and -1 for failure</span>
<span class="cm"> * Locks:   Called without locks held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_fcp_pkt_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_fcp_internal</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">fc_get_scsi_internal</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">fsp</span><span class="p">;</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_cmd</span><span class="p">.</span><span class="n">fc_dl</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_cmd</span><span class="p">.</span><span class="n">fc_flags</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">req_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FCP_CFL_LEN_MASK</span><span class="p">;</span>

	<span class="n">int_to_scsilun</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_cmd</span><span class="p">.</span><span class="n">fc_lun</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_cmd</span><span class="p">.</span><span class="n">fc_cdb</span><span class="p">,</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_pkt_queue</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">fcp_cmd_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fsp</span><span class="p">,</span> <span class="n">fc_fcp_recv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_fsp_rec_tov() - Helper function to get REC_TOV</span>
<span class="cm"> * @fsp: the FCP packet</span>
<span class="cm"> *</span>
<span class="cm"> * Returns rec tov in jiffies as rpriv-&gt;e_d_tov + 1 second</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_fsp_rec_tov</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport_libfc_priv</span> <span class="o">*</span><span class="n">rpriv</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">rpriv</span><span class="o">-&gt;</span><span class="n">e_d_tov</span><span class="p">)</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_cmd_send() - Send a FCP command</span>
<span class="cm"> * @lport: The local port to send the command on</span>
<span class="cm"> * @fsp:   The FCP packet the command is on</span>
<span class="cm"> * @resp:  The handler for the response</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_fcp_cmd_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport_libfc_priv</span> <span class="o">*</span><span class="n">rpriv</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_cmd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_fcp_lock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">fc_fcp_frame_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_cmd</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_cmd</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">fr_fsp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">fsp</span><span class="p">;</span>
	<span class="n">rport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">;</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">max_payload</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">maxframe_size</span><span class="p">;</span>
	<span class="n">rpriv</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="n">fc_fill_fc_hdr</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">FC_RCTL_DD_UNSOL_CMD</span><span class="p">,</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span>
		       <span class="n">rpriv</span><span class="o">-&gt;</span><span class="n">local_port</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="n">FC_TYPE_FCP</span><span class="p">,</span>
		       <span class="n">FC_FCTL_REQ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_seq_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">resp</span><span class="p">,</span> <span class="n">fc_fcp_pkt_destroy</span><span class="p">,</span>
				      <span class="n">fsp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">fc_fcp_pkt_hold</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>	<span class="cm">/* hold for fc_fcp_pkt_destroy */</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">fc_fcp_timeout</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fsp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FC_RP_FLAGS_REC_SUPPORTED</span><span class="p">)</span>
		<span class="n">fc_fcp_timer_set</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">get_fsp_rec_tov</span><span class="p">(</span><span class="n">fsp</span><span class="p">));</span>

<span class="nl">unlock:</span>
	<span class="n">fc_fcp_unlock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_error() - Handler for FCP layer errors</span>
<span class="cm"> * @fsp: The FCP packet the error is on</span>
<span class="cm"> * @fp:	 The frame that has errored</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_fcp_lock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">FC_EX_CLOSED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc_fcp_retry_cmd</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * clear abort pending, because the lower layer</span>
<span class="cm">	 * decided to force completion.</span>
<span class="cm">	 */</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_SRB_ABORT_PENDING</span><span class="p">;</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">status_code</span> <span class="o">=</span> <span class="n">FC_CMD_PLOGO</span><span class="p">;</span>
	<span class="n">fc_fcp_complete_locked</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">fc_fcp_unlock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_pkt_abort() - Abort a fcp_pkt</span>
<span class="cm"> * @fsp:   The FCP packet to abort on</span>
<span class="cm"> *</span>
<span class="cm"> * Called to send an abort and then wait for abort completion</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_fcp_pkt_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ticks_left</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_fcp_send_abort</span><span class="p">(</span><span class="n">fsp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">tm_done</span><span class="p">);</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">wait_for_comp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_pkt_lock</span><span class="p">);</span>
	<span class="n">ticks_left</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">tm_done</span><span class="p">,</span>
							<span class="n">FC_SCSI_TM_TOV</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_pkt_lock</span><span class="p">);</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">wait_for_comp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ticks_left</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;target abort cmd  failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">FC_SRB_ABORTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;target abort cmd  passed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>
		<span class="n">fc_fcp_complete_locked</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_lun_reset_send() - Send LUN reset command</span>
<span class="cm"> * @data: The FCP packet that identifies the LUN to be reset</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_lun_reset_send</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">fcp_cmd_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fsp</span><span class="p">,</span> <span class="n">fc_tm_done</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">recov_retry</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="n">FC_MAX_RECOV_RETRY</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fc_fcp_lock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">fc_lun_reset_send</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fsp</span><span class="p">);</span>
		<span class="n">fc_fcp_timer_set</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">get_fsp_rec_tov</span><span class="p">(</span><span class="n">fsp</span><span class="p">));</span>
		<span class="n">fc_fcp_unlock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_lun_reset() - Send a LUN RESET command to a device</span>
<span class="cm"> *		    and wait for the reply</span>
<span class="cm"> * @lport: The local port to sent the command on</span>
<span class="cm"> * @fsp:   The FCP packet that identifies the LUN to be reset</span>
<span class="cm"> * @id:	   The SCSI command ID</span>
<span class="cm"> * @lun:   The LUN ID to be reset</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_lun_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_cmd</span><span class="p">.</span><span class="n">fc_dl</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_cmd</span><span class="p">.</span><span class="n">fc_tm_flags</span> <span class="o">=</span> <span class="n">FCP_TMF_LUN_RESET</span><span class="p">;</span>
	<span class="n">int_to_scsilun</span><span class="p">(</span><span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_cmd</span><span class="p">.</span><span class="n">fc_lun</span><span class="p">);</span>

	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">wait_for_comp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">tm_done</span><span class="p">);</span>

	<span class="n">fc_lun_reset_send</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fsp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * wait for completion of reset</span>
<span class="cm">	 * after that make sure all commands are terminated</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">tm_done</span><span class="p">,</span> <span class="n">FC_SCSI_TM_TOV</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_pkt_lock</span><span class="p">);</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">FC_SRB_COMPL</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_pkt_lock</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_pkt_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_done</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span><span class="p">);</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">wait_for_comp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_pkt_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FC_SCSI_DBG</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="s">&quot;lun reset failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* cdb_status holds the tmf&#39;s rsp code */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_status</span> <span class="o">!=</span> <span class="n">FCP_TMF_CMPL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>

	<span class="n">FC_SCSI_DBG</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="s">&quot;lun reset to lun %u completed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
	<span class="n">fc_fcp_cleanup_each_cmd</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">FC_CMD_ABORTED</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_tm_done() - Task Management response handler</span>
<span class="cm"> * @seq: The sequence that the response is on</span>
<span class="cm"> * @fp:	 The response frame</span>
<span class="cm"> * @arg: The FCP packet the response is for</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_tm_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there is an error just let it timeout or wait</span>
<span class="cm">		 * for TMF to be aborted if it timedout.</span>
<span class="cm">		 *</span>
<span class="cm">		 * scsi-eh will escalate for when either happens.</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_fcp_lock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * raced with eh timeout handler.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span> <span class="o">||</span> <span class="o">!</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">wait_for_comp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_type</span> <span class="o">!=</span> <span class="n">FC_TYPE_BLS</span><span class="p">)</span>
		<span class="n">fc_fcp_resp</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_done</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">fc_fcp_unlock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_cleanup() - Cleanup all FCP exchanges on a local port</span>
<span class="cm"> * @lport: The local port to be cleaned up</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fc_fcp_cleanup_each_cmd</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">FC_ERROR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_timeout() - Handler for fcp_pkt timeouts</span>
<span class="cm"> * @data: The FCP packet that has timed out</span>
<span class="cm"> *</span>
<span class="cm"> * If REC is supported then just issue it and return. The REC exchange will</span>
<span class="cm"> * complete or time out and recovery can continue at that point. Otherwise,</span>
<span class="cm"> * if the response has been received without all the data it has been</span>
<span class="cm"> * ER_TIMEOUT since the response was received. If the response has not been</span>
<span class="cm"> * received we see if data was received recently. If it has been then we</span>
<span class="cm"> * continue waiting, otherwise, we abort the command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport_libfc_priv</span> <span class="o">*</span><span class="n">rpriv</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_fcp_lock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_cmd</span><span class="p">.</span><span class="n">fc_tm_flags</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">FC_SRB_FCP_PROCESSING_TMO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FC_RP_FLAGS_REC_SUPPORTED</span><span class="p">)</span>
		<span class="n">fc_fcp_rec</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">FC_SRB_RCV_STATUS</span><span class="p">)</span>
		<span class="n">fc_fcp_complete_locked</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">fc_fcp_recovery</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">FC_TIMED_OUT</span><span class="p">);</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_SRB_FCP_PROCESSING_TMO</span><span class="p">;</span>
<span class="nl">unlock:</span>
	<span class="n">fc_fcp_unlock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_rec() - Send a REC ELS request</span>
<span class="cm"> * @fsp: The FCP packet to send the REC request on</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_rec</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport_libfc_priv</span> <span class="o">*</span><span class="n">rpriv</span><span class="p">;</span>

	<span class="n">lport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
	<span class="n">rport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">;</span>
	<span class="n">rpriv</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span> <span class="o">||</span> <span class="n">rpriv</span><span class="o">-&gt;</span><span class="n">rp_state</span> <span class="o">!=</span> <span class="n">RPORT_ST_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">status_code</span> <span class="o">=</span> <span class="n">FC_HRD_ERROR</span><span class="p">;</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">io_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">fc_fcp_complete_locked</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">fc_fcp_frame_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_els_rec</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="n">fr_seq</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span><span class="p">;</span>
	<span class="n">fc_fill_fc_hdr</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">FC_RCTL_ELS_REQ</span><span class="p">,</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span>
		       <span class="n">rpriv</span><span class="o">-&gt;</span><span class="n">local_port</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="n">FC_TYPE_ELS</span><span class="p">,</span>
		       <span class="n">FC_FCTL_REQ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">elsct_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ELS_REC</span><span class="p">,</span>
				 <span class="n">fc_fcp_rec_resp</span><span class="p">,</span> <span class="n">fsp</span><span class="p">,</span>
				 <span class="mi">2</span> <span class="o">*</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">r_a_tov</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fc_fcp_pkt_hold</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>		<span class="cm">/* hold while REC outstanding */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">recov_retry</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">FC_MAX_RECOV_RETRY</span><span class="p">)</span>
		<span class="n">fc_fcp_timer_set</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">get_fsp_rec_tov</span><span class="p">(</span><span class="n">fsp</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">fc_fcp_recovery</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">FC_TIMED_OUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_rec_resp() - Handler for REC ELS responses</span>
<span class="cm"> * @seq: The sequence the response is on</span>
<span class="cm"> * @fp:	 The response frame</span>
<span class="cm"> * @arg: The FCP packet the response is on</span>
<span class="cm"> *</span>
<span class="cm"> * If the response is a reject then the scsi layer will handle</span>
<span class="cm"> * the timeout. If the response is a LS_ACC then if the I/O was not completed</span>
<span class="cm"> * set the timeout and return. If the I/O was completed then complete the</span>
<span class="cm"> * exchange and tell the SCSI layer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_rec_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_els_rec_acc</span> <span class="o">*</span><span class="n">recp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_els_ls_rjt</span> <span class="o">*</span><span class="n">rjt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">e_stat</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">opcode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">data_dir</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_rctl</span> <span class="n">r_ctl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport_libfc_priv</span> <span class="o">*</span><span class="n">rpriv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fc_fcp_rec_error</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_fcp_lock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">recov_retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">opcode</span> <span class="o">=</span> <span class="n">fc_frame_payload_op</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">ELS_LS_RJT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rjt</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rjt</span><span class="p">));</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">rjt</span><span class="o">-&gt;</span><span class="n">er_reason</span><span class="p">)</span> <span class="p">{</span>
		<span class="nl">default:</span>
			<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;device %x unexpected REC reject &quot;</span>
				   <span class="s">&quot;reason %d expl %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="n">rjt</span><span class="o">-&gt;</span><span class="n">er_reason</span><span class="p">,</span>
				   <span class="n">rjt</span><span class="o">-&gt;</span><span class="n">er_explan</span><span class="p">);</span>
			<span class="cm">/* fall through */</span>
		<span class="k">case</span> <span class="n">ELS_RJT_UNSUP</span>:
			<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;device does not support REC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rpriv</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * if we do not spport RECs or got some bogus</span>
<span class="cm">			 * reason then resetup timer so we check for</span>
<span class="cm">			 * making progress.</span>
<span class="cm">			 */</span>
			<span class="n">rpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_RP_FLAGS_REC_SUPPORTED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ELS_RJT_LOGIC</span>:
		<span class="k">case</span> <span class="n">ELS_RJT_UNAB</span>:
			<span class="cm">/*</span>
<span class="cm">			 * If no data transfer, the command frame got dropped</span>
<span class="cm">			 * so we just retry.  If data was transferred, we</span>
<span class="cm">			 * lost the response but the target has no record,</span>
<span class="cm">			 * so we abort and retry.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rjt</span><span class="o">-&gt;</span><span class="n">er_explan</span> <span class="o">==</span> <span class="n">ELS_EXPL_OXID_RXID</span> <span class="o">&amp;&amp;</span>
			    <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">fc_fcp_retry_cmd</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">fc_fcp_recovery</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">FC_ERROR</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">ELS_LS_ACC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">FC_SRB_ABORTED</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock_out</span><span class="p">;</span>

		<span class="n">data_dir</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>
		<span class="n">recp</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">recp</span><span class="p">));</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">recp</span><span class="o">-&gt;</span><span class="n">reca_fc4value</span><span class="p">);</span>
		<span class="n">e_stat</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">recp</span><span class="o">-&gt;</span><span class="n">reca_e_stat</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">e_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_COMPLETE</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * The exchange is complete.</span>
<span class="cm">			 *</span>
<span class="cm">			 * For output, we must&#39;ve lost the response.</span>
<span class="cm">			 * For input, all data must&#39;ve been sent.</span>
<span class="cm">			 * We lost may have lost the response</span>
<span class="cm">			 * (and a confirmation was requested) and maybe</span>
<span class="cm">			 * some data.</span>
<span class="cm">			 *</span>
<span class="cm">			 * If all data received, send SRR</span>
<span class="cm">			 * asking for response.	 If partial data received,</span>
<span class="cm">			 * or gaps, SRR requests data at start of gap.</span>
<span class="cm">			 * Recovery via SRR relies on in-order-delivery.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data_dir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">r_ctl</span> <span class="o">=</span> <span class="n">FC_RCTL_DD_CMD_STATUS</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_contig_end</span> <span class="o">==</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">r_ctl</span> <span class="o">=</span> <span class="n">FC_RCTL_DD_CMD_STATUS</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">offset</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_contig_end</span><span class="p">;</span>
				<span class="n">r_ctl</span> <span class="o">=</span> <span class="n">FC_RCTL_DD_SOL_DATA</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">fc_fcp_srr</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">r_ctl</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_SEQ_INIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The remote port has the initiative, so just</span>
<span class="cm">			 * keep waiting for it to complete.</span>
<span class="cm">			 */</span>
			<span class="n">fc_fcp_timer_set</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span>  <span class="n">get_fsp_rec_tov</span><span class="p">(</span><span class="n">fsp</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * The exchange is incomplete, we have seq. initiative.</span>
<span class="cm">			 * Lost response with requested confirmation,</span>
<span class="cm">			 * lost confirmation, lost transfer ready or</span>
<span class="cm">			 * lost write data.</span>
<span class="cm">			 *</span>
<span class="cm">			 * For output, if not all data was received, ask</span>
<span class="cm">			 * for transfer ready to be repeated.</span>
<span class="cm">			 *</span>
<span class="cm">			 * If we received or sent all the data, send SRR to</span>
<span class="cm">			 * request response.</span>
<span class="cm">			 *</span>
<span class="cm">			 * If we lost a response, we may have lost some read</span>
<span class="cm">			 * data as well.</span>
<span class="cm">			 */</span>
			<span class="n">r_ctl</span> <span class="o">=</span> <span class="n">FC_RCTL_DD_SOL_DATA</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data_dir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">r_ctl</span> <span class="o">=</span> <span class="n">FC_RCTL_DD_CMD_STATUS</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span>
					<span class="n">r_ctl</span> <span class="o">=</span> <span class="n">FC_RCTL_DD_DATA_DESC</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_contig_end</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">r_ctl</span> <span class="o">=</span> <span class="n">FC_RCTL_DD_CMD_STATUS</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_contig_end</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">offset</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_contig_end</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">fc_fcp_srr</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">r_ctl</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">unlock_out:</span>
	<span class="n">fc_fcp_unlock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">fc_fcp_pkt_release</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>	<span class="cm">/* drop hold for outstanding REC */</span>
	<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_rec_error() - Handler for REC errors</span>
<span class="cm"> * @fsp: The FCP packet the error is on</span>
<span class="cm"> * @fp:	 The REC frame</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_rec_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_fcp_lock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">FC_EX_CLOSED</span>:
		<span class="n">fc_fcp_retry_cmd</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;REC %p fid %6.6x error unexpected error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">fsp</span><span class="p">,</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">status_code</span> <span class="o">=</span> <span class="n">FC_CMD_PLOGO</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">FC_EX_TIMEOUT</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Assume REC or LS_ACC was lost.</span>
<span class="cm">		 * The exchange manager will have aborted REC, so retry.</span>
<span class="cm">		 */</span>
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;REC fid %6.6x error error %d retry %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">recov_retry</span><span class="p">,</span>
			   <span class="n">FC_MAX_RECOV_RETRY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">recov_retry</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">FC_MAX_RECOV_RETRY</span><span class="p">)</span>
			<span class="n">fc_fcp_rec</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">fc_fcp_recovery</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">FC_ERROR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fc_fcp_unlock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">fc_fcp_pkt_release</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>	<span class="cm">/* drop hold for outstanding REC */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_recovery() - Handler for fcp_pkt recovery</span>
<span class="cm"> * @fsp: The FCP pkt that needs to be aborted</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">,</span> <span class="n">u8</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">status_code</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">io_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * if this fails then we let the scsi command timer fire and</span>
<span class="cm">	 * scsi-ml escalate.</span>
<span class="cm">	 */</span>
	<span class="n">fc_fcp_send_abort</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_srr() - Send a SRR request (Sequence Retransmission Request)</span>
<span class="cm"> * @fsp:   The FCP packet the SRR is to be sent on</span>
<span class="cm"> * @r_ctl: The R_CTL field for the SRR request</span>
<span class="cm"> * This is called after receiving status but insufficient data, or</span>
<span class="cm"> * when expecting status but the request has timed out.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_srr</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fc_rctl</span> <span class="n">r_ctl</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport_libfc_priv</span> <span class="o">*</span><span class="n">rpriv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">seq_ptr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_srr</span> <span class="o">*</span><span class="n">srr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rec_tov</span><span class="p">;</span>

	<span class="n">rport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">;</span>
	<span class="n">rpriv</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FC_RP_FLAGS_RETRY</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">rpriv</span><span class="o">-&gt;</span><span class="n">rp_state</span> <span class="o">!=</span> <span class="n">RPORT_ST_READY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>			<span class="cm">/* shouldn&#39;t happen */</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="n">fc_fcp_frame_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">srr</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="n">srr</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">srr</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">srr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">srr</span><span class="p">));</span>
	<span class="n">srr</span><span class="o">-&gt;</span><span class="n">srr_op</span> <span class="o">=</span> <span class="n">ELS_SRR</span><span class="p">;</span>
	<span class="n">srr</span><span class="o">-&gt;</span><span class="n">srr_ox_id</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">oxid</span><span class="p">);</span>
	<span class="n">srr</span><span class="o">-&gt;</span><span class="n">srr_rx_id</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span><span class="p">);</span>
	<span class="n">srr</span><span class="o">-&gt;</span><span class="n">srr_r_ctl</span> <span class="o">=</span> <span class="n">r_ctl</span><span class="p">;</span>
	<span class="n">srr</span><span class="o">-&gt;</span><span class="n">srr_rel_off</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>

	<span class="n">fc_fill_fc_hdr</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">FC_RCTL_ELS4_REQ</span><span class="p">,</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span>
		       <span class="n">rpriv</span><span class="o">-&gt;</span><span class="n">local_port</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="n">FC_TYPE_FCP</span><span class="p">,</span>
		       <span class="n">FC_FCTL_REQ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">rec_tov</span> <span class="o">=</span> <span class="n">get_fsp_rec_tov</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_seq_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fc_fcp_srr_resp</span><span class="p">,</span>
				      <span class="n">fc_fcp_pkt_destroy</span><span class="p">,</span>
				      <span class="n">fsp</span><span class="p">,</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">rec_tov</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">recov_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_contig_end</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_SRB_RCV_STATUS</span><span class="p">;</span>
	<span class="n">fc_fcp_pkt_hold</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>		<span class="cm">/* hold for outstanding SRR */</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">retry:</span>
	<span class="n">fc_fcp_retry_cmd</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_srr_resp() - Handler for SRR response</span>
<span class="cm"> * @seq: The sequence the SRR is on</span>
<span class="cm"> * @fp:	 The SRR frame</span>
<span class="cm"> * @arg: The FCP packet the SRR is on</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_srr_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fc_fcp_srr_error</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_fcp_lock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * BUG? fc_fcp_srr_error calls exch_done which would release</span>
<span class="cm">	 * the ep. But if fc_fcp_srr_error had got -FC_EX_TIMEOUT,</span>
<span class="cm">	 * then fc_exch_timeout would be sending an abort. The exch_done</span>
<span class="cm">	 * call by fc_fcp_srr_error would prevent fc_exch.c from seeing</span>
<span class="cm">	 * an abort response though.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_type</span> <span class="o">==</span> <span class="n">FC_TYPE_BLS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc_fcp_unlock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">fc_frame_payload_op</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ELS_LS_ACC</span>:
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">recov_retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">fc_fcp_timer_set</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">get_fsp_rec_tov</span><span class="p">(</span><span class="n">fsp</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_LS_RJT</span>:
	<span class="nl">default:</span>
		<span class="n">fc_fcp_recovery</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">FC_ERROR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fc_fcp_unlock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_done</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
	<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_srr_error() - Handler for SRR errors</span>
<span class="cm"> * @fsp: The FCP packet that the SRR error is on</span>
<span class="cm"> * @fp:	 The SRR frame</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_fcp_srr_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fc_fcp_lock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">FC_EX_TIMEOUT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">recov_retry</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">FC_MAX_RECOV_RETRY</span><span class="p">)</span>
			<span class="n">fc_fcp_rec</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">fc_fcp_recovery</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="n">FC_TIMED_OUT</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">FC_EX_CLOSED</span>:			<span class="cm">/* e.g., link failure */</span>
		<span class="cm">/* fall through */</span>
	<span class="nl">default:</span>
		<span class="n">fc_fcp_retry_cmd</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fc_fcp_unlock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_done</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">recov_seq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_lport_queue_ready() - Determine if the lport and it&#39;s queue is ready</span>
<span class="cm"> * @lport: The local port to be checked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fc_fcp_lport_queue_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* lock ? */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">LPORT_ST_READY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">link_up</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">qfull</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_queuecommand() - The queuecommand function of the SCSI template</span>
<span class="cm"> * @shost: The Scsi_Host that the command was issued to</span>
<span class="cm"> * @cmd:   The scsi_cmnd to be executed</span>
<span class="cm"> *</span>
<span class="cm"> * This is the i/o strategy routine, called by the SCSI layer.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fc_queuecommand</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">starget_to_rport</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport_libfc_priv</span> <span class="o">*</span><span class="n">rpriv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_dev_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">fc_remote_port_chkready</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">rval</span><span class="p">;</span>
		<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">sc_cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_remote_port</span> <span class="o">**</span><span class="p">)</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * rport is transitioning from blocked/deleted to</span>
<span class="cm">		 * online</span>
<span class="cm">		 */</span>
		<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_IMM_RETRY</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">sc_cmd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rpriv</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fc_fcp_lport_queue_ready</span><span class="p">(</span><span class="n">lport</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">qfull</span><span class="p">)</span>
			<span class="n">fc_fcp_can_queue_ramp_down</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fsp</span> <span class="o">=</span> <span class="n">fc_fcp_pkt_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * build the libfc request pkt</span>
<span class="cm">	 */</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">sc_cmd</span><span class="p">;</span>	<span class="cm">/* save the cmd */</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">=</span> <span class="n">rport</span><span class="p">;</span>	<span class="cm">/* set the remote port ptr */</span>

	<span class="cm">/*</span>
<span class="cm">	 * set up the transfer length</span>
<span class="cm">	 */</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">sc_cmd</span><span class="p">);</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">xfer_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * setup the data direction</span>
<span class="cm">	 */</span>
	<span class="n">stats</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">dev_stats</span><span class="p">,</span> <span class="n">get_cpu</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">req_flags</span> <span class="o">=</span> <span class="n">FC_SRB_READ</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">InputRequests</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">InputBytes</span> <span class="o">+=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">req_flags</span> <span class="o">=</span> <span class="n">FC_SRB_WRITE</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">OutputRequests</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">OutputBytes</span> <span class="o">+=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">req_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">ControlRequests</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">put_cpu</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * send it to the lower layer</span>
<span class="cm">	 * if we get -1 return then put the request in the pending</span>
<span class="cm">	 * queue.</span>
<span class="cm">	 */</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">fc_fcp_pkt_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fsp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FC_SRB_FREE</span><span class="p">;</span>
		<span class="n">fc_fcp_pkt_release</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_queuecommand</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_io_compl() - Handle responses for completed commands</span>
<span class="cm"> * @fsp: The FCP packet that is complete</span>
<span class="cm"> *</span>
<span class="cm"> * Translates fcp_pkt errors to a Linux SCSI errors.</span>
<span class="cm"> * The fcp packet lock must be held when calling.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_io_compl</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_fcp_internal</span> <span class="o">*</span><span class="n">si</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* release outstanding ddp context */</span>
	<span class="n">fc_fcp_ddp_done</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>

	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">FC_SRB_COMPL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">FC_SRB_FCP_PROCESSING_TMO</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_pkt_lock</span><span class="p">);</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_pkt_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">lport</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
	<span class="n">si</span> <span class="o">=</span> <span class="n">fc_get_scsi_internal</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if can_queue ramp down is done then try can_queue ramp up</span>
<span class="cm">	 * since commands are completing now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">last_can_queue_ramp_down_time</span><span class="p">)</span>
		<span class="n">fc_fcp_can_queue_ramp_up</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="n">sc_cmd</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">CMD_SCSI_STATUS</span><span class="p">(</span><span class="n">sc_cmd</span><span class="p">)</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_status</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">status_code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FC_COMPLETE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * good I/O status</span>
<span class="cm">			 */</span>
			<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_resid</span><span class="p">)</span>
				<span class="n">CMD_RESID_LEN</span><span class="p">(</span><span class="n">sc_cmd</span><span class="p">)</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_resid</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * transport level I/O was ok but scsi</span>
<span class="cm">			 * has non zero status</span>
<span class="cm">			 */</span>
			<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_status</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FC_ERROR</span>:
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;Returning DID_ERROR to scsi-ml &quot;</span>
			   <span class="s">&quot;due to FC_ERROR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FC_DATA_UNDRUN</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">req_flags</span> <span class="o">&amp;</span> <span class="n">FC_SRB_READ</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * scsi status is good but transport level</span>
<span class="cm">			 * underrun.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">FC_SRB_RCV_STATUS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;Returning DID_ERROR to scsi-ml&quot;</span>
					   <span class="s">&quot; due to FC_DATA_UNDRUN (trans)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * scsi got underrun, this is an error</span>
<span class="cm">			 */</span>
			<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;Returning DID_ERROR to scsi-ml &quot;</span>
				   <span class="s">&quot;due to FC_DATA_UNDRUN (scsi)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">CMD_RESID_LEN</span><span class="p">(</span><span class="n">sc_cmd</span><span class="p">)</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">scsi_resid</span><span class="p">;</span>
			<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_status</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FC_DATA_OVRRUN</span>:
		<span class="cm">/*</span>
<span class="cm">		 * overrun is an error</span>
<span class="cm">		 */</span>
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;Returning DID_ERROR to scsi-ml &quot;</span>
			   <span class="s">&quot;due to FC_DATA_OVRRUN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cdb_status</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FC_CMD_ABORTED</span>:
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;Returning DID_ERROR to scsi-ml &quot;</span>
			  <span class="s">&quot;due to FC_CMD_ABORTED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">io_status</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FC_CMD_RESET</span>:
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;Returning DID_RESET to scsi-ml &quot;</span>
			   <span class="s">&quot;due to FC_CMD_RESET</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FC_HRD_ERROR</span>:
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;Returning DID_NO_CONNECT to scsi-ml &quot;</span>
			   <span class="s">&quot;due to FC_HRD_ERROR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FC_CRC_ERROR</span>:
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;Returning DID_PARITY to scsi-ml &quot;</span>
			   <span class="s">&quot;due to FC_CRC_ERROR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_PARITY</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FC_TIMED_OUT</span>:
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;Returning DID_BUS_BUSY to scsi-ml &quot;</span>
			   <span class="s">&quot;due to FC_TIMED_OUT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BUS_BUSY</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">io_status</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">FC_FCP_DBG</span><span class="p">(</span><span class="n">fsp</span><span class="p">,</span> <span class="s">&quot;Returning DID_ERROR to scsi-ml &quot;</span>
			   <span class="s">&quot;due to unknown error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">LPORT_ST_READY</span> <span class="o">&amp;&amp;</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">status_code</span> <span class="o">!=</span> <span class="n">FC_COMPLETE</span><span class="p">)</span>
		<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_TRANSPORT_DISRUPTED</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">sc_cmd</span><span class="p">);</span>

	<span class="cm">/* release ref from initial allocation in queue command */</span>
	<span class="n">fc_fcp_pkt_release</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_eh_abort() - Abort a command</span>
<span class="cm"> * @sc_cmd: The SCSI command to abort</span>
<span class="cm"> *</span>
<span class="cm"> * From SCSI host template.</span>
<span class="cm"> * Send an ABTS to the target device and wait for the response.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fc_eh_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_fcp_internal</span> <span class="o">*</span><span class="n">si</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">fc_block_scsi_eh</span><span class="p">(</span><span class="n">sc_cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">lport</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">LPORT_ST_READY</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">link_up</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">si</span> <span class="o">=</span> <span class="n">fc_get_scsi_internal</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">fsp</span> <span class="o">=</span> <span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc_cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* command completed while scsi eh was setting up */</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* grab a ref so the fsp and sc_cmd cannot be relased from under us */</span>
	<span class="n">fc_fcp_pkt_hold</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_fcp_lock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* completed while we were waiting for timer to be deleted */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">release_pkt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fc_fcp_pkt_abort</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
	<span class="n">fc_fcp_unlock_pkt</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>

<span class="nl">release_pkt:</span>
	<span class="n">fc_fcp_pkt_release</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_eh_abort</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_eh_device_reset() - Reset a single LUN</span>
<span class="cm"> * @sc_cmd: The SCSI command which identifies the device whose</span>
<span class="cm"> *	    LUN is to be reset</span>
<span class="cm"> *</span>
<span class="cm"> * Set from SCSI host template.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fc_eh_device_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">starget_to_rport</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">fc_block_scsi_eh</span><span class="p">(</span><span class="n">sc_cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">lport</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">LPORT_ST_READY</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">FC_SCSI_DBG</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="s">&quot;Resetting rport (%6.6x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">);</span>

	<span class="n">fsp</span> <span class="o">=</span> <span class="n">fc_fcp_pkt_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;libfc: could not allocate scsi_pkt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build the libfc request pkt. Do not set the scsi cmnd, because</span>
<span class="cm">	 * the sc passed in is not setup for execution like when sent</span>
<span class="cm">	 * through the queuecommand callout.</span>
<span class="cm">	 */</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">=</span> <span class="n">rport</span><span class="p">;</span>	<span class="cm">/* set the remote port ptr */</span>

	<span class="cm">/*</span>
<span class="cm">	 * flush outstanding commands</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fc_lun_reset</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fsp</span><span class="p">,</span> <span class="n">scmd_id</span><span class="p">(</span><span class="n">sc_cmd</span><span class="p">),</span> <span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FC_SRB_FREE</span><span class="p">;</span>
	<span class="n">fc_fcp_pkt_release</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_eh_device_reset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_eh_host_reset() - Reset a Scsi_Host.</span>
<span class="cm"> * @sc_cmd: The SCSI command that identifies the SCSI host to be reset</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fc_eh_host_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">sc_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wait_tmo</span><span class="p">;</span>

	<span class="n">FC_SCSI_DBG</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="s">&quot;Resetting host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">fc_block_scsi_eh</span><span class="p">(</span><span class="n">sc_cmd</span><span class="p">);</span>

	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">lport_reset</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="n">wait_tmo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">FC_HOST_RESET_TIMEOUT</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">fc_fcp_lport_queue_ready</span><span class="p">(</span><span class="n">lport</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
							       <span class="n">wait_tmo</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_fcp_lport_queue_ready</span><span class="p">(</span><span class="n">lport</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;libfc: Host reset succeeded &quot;</span>
			     <span class="s">&quot;on port (%6.6x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;libfc: Host reset failed, &quot;</span>
			     <span class="s">&quot;port (%6.6x) is not ready.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">lport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_eh_host_reset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_slave_alloc() - Configure the queue depth of a Scsi_Host</span>
<span class="cm"> * @sdev: The SCSI device that identifies the SCSI host</span>
<span class="cm"> *</span>
<span class="cm"> * Configures queue depth based on host&#39;s cmd_per_len. If not set</span>
<span class="cm"> * then we use the libfc default.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fc_slave_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">starget_to_rport</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sdev</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rport</span> <span class="o">||</span> <span class="n">fc_remote_port_chkready</span><span class="p">(</span><span class="n">rport</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span><span class="p">)</span>
		<span class="n">scsi_activate_tcq</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">FC_FCP_DFLT_QUEUE_DEPTH</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">scsi_get_tag_type</span><span class="p">(</span><span class="n">sdev</span><span class="p">),</span>
					<span class="n">FC_FCP_DFLT_QUEUE_DEPTH</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_slave_alloc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_change_queue_depth() - Change a device&#39;s queue depth</span>
<span class="cm"> * @sdev:   The SCSI device whose queue depth is to change</span>
<span class="cm"> * @qdepth: The new queue depth</span>
<span class="cm"> * @reason: The resason for the change</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fc_change_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qdepth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCSI_QDEPTH_DEFAULT</span>:
		<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">scsi_get_tag_type</span><span class="p">(</span><span class="n">sdev</span><span class="p">),</span> <span class="n">qdepth</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCSI_QDEPTH_QFULL</span>:
		<span class="n">scsi_track_queue_full</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">qdepth</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCSI_QDEPTH_RAMP_UP</span>:
		<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">scsi_get_tag_type</span><span class="p">(</span><span class="n">sdev</span><span class="p">),</span> <span class="n">qdepth</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_change_queue_depth</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_change_queue_type() - Change a device&#39;s queue type</span>
<span class="cm"> * @sdev:     The SCSI device whose queue depth is to change</span>
<span class="cm"> * @tag_type: Identifier for queue type</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fc_change_queue_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tag_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_set_tag_type</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">tag_type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tag_type</span><span class="p">)</span>
			<span class="n">scsi_activate_tcq</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">scsi_deactivate_tcq</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">tag_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tag_type</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_change_queue_type</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_destory() - Tear down the FCP layer for a given local port</span>
<span class="cm"> * @lport: The local port that no longer needs the FCP layer</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fc_fcp_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_fcp_internal</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">fc_get_scsi_internal</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_pkt_queue</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;libfc: Leaked SCSI packets when destroying &quot;</span>
		       <span class="s">&quot;port (%6.6x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">);</span>

	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_pkt_pool</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">si</span><span class="p">);</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">scsi_priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_fcp_destroy</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">fc_setup_fcp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">scsi_pkt_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;libfc_fcp_pkt&quot;</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_pkt</span><span class="p">),</span>
					    <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_pkt_cachep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;libfc: Unable to allocate SRB cache, &quot;</span>
		       <span class="s">&quot;module load failed!&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">fc_destroy_fcp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_pkt_cachep</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">scsi_pkt_cachep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_fcp_init() - Initialize the FCP layer for a local port</span>
<span class="cm"> * @lport: The local port to initialize the exchange layer for</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fc_fcp_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_fcp_internal</span> <span class="o">*</span><span class="n">si</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">fcp_cmd_send</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">fcp_cmd_send</span> <span class="o">=</span> <span class="n">fc_fcp_cmd_send</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">fcp_cleanup</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">fcp_cleanup</span> <span class="o">=</span> <span class="n">fc_fcp_cleanup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">fcp_abort_io</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">fcp_abort_io</span> <span class="o">=</span> <span class="n">fc_fcp_abort_io</span><span class="p">;</span>

	<span class="n">si</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_fcp_internal</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">si</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">scsi_priv</span> <span class="o">=</span> <span class="n">si</span><span class="p">;</span>
	<span class="n">si</span><span class="o">-&gt;</span><span class="n">max_can_queue</span> <span class="o">=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_pkt_queue</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_queue_lock</span><span class="p">);</span>

	<span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_pkt_pool</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">scsi_pkt_cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">scsi_pkt_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_internal</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">free_internal:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">si</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_fcp_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
