<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › libfc › fc_exch.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fc_exch.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright(c) 2007 Intel Corporation. All rights reserved.</span>
<span class="cm"> * Copyright(c) 2008 Red Hat, Inc.  All rights reserved.</span>
<span class="cm"> * Copyright(c) 2008 Mike Christie</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintained at www.Open-FCoE.org</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Fibre Channel exchange and sequence handling.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cp">#include &lt;scsi/fc/fc_fc2.h&gt;</span>

<span class="cp">#include &lt;scsi/libfc.h&gt;</span>
<span class="cp">#include &lt;scsi/fc_encode.h&gt;</span>

<span class="cp">#include &quot;fc_libfc.h&quot;</span>

<span class="n">u16</span>	<span class="n">fc_cpu_mask</span><span class="p">;</span>		<span class="cm">/* cpu mask for possible cpus */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_cpu_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u16</span>	<span class="n">fc_cpu_order</span><span class="p">;</span>	<span class="cm">/* 2&#39;s power to represent total possible cpus */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">fc_em_cachep</span><span class="p">;</span>	       <span class="cm">/* cache for exchanges */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">fc_exch_workqueue</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Structure and function definitions for managing Fibre Channel Exchanges</span>
<span class="cm"> * and Sequences.</span>
<span class="cm"> *</span>
<span class="cm"> * The three primary structures used here are fc_exch_mgr, fc_exch, and fc_seq.</span>
<span class="cm"> *</span>
<span class="cm"> * fc_exch_mgr holds the exchange state for an N port</span>
<span class="cm"> *</span>
<span class="cm"> * fc_exch holds state for one exchange and links to its active sequence.</span>
<span class="cm"> *</span>
<span class="cm"> * fc_seq holds the state for an individual sequence.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct fc_exch_pool - Per cpu exchange pool</span>
<span class="cm"> * @next_index:	  Next possible free exchange index</span>
<span class="cm"> * @total_exches: Total allocated exchanges</span>
<span class="cm"> * @lock:	  Exch pool lock</span>
<span class="cm"> * @ex_list:	  List of exchanges</span>
<span class="cm"> *</span>
<span class="cm"> * This structure manages per cpu exchanges in array of exchange pointers.</span>
<span class="cm"> * This array is allocated followed by struct fc_exch_pool memory for</span>
<span class="cm"> * assigned range of exchanges to per cpu pool.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_exch_pool</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>	 <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ex_list</span><span class="p">;</span>
	<span class="n">u16</span>		 <span class="n">next_index</span><span class="p">;</span>
	<span class="n">u16</span>		 <span class="n">total_exches</span><span class="p">;</span>

	<span class="cm">/* two cache of free slot in exch array */</span>
	<span class="n">u16</span>		 <span class="n">left</span><span class="p">;</span>
	<span class="n">u16</span>		 <span class="n">right</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct fc_exch_mgr - The Exchange Manager (EM).</span>
<span class="cm"> * @class:	    Default class for new sequences</span>
<span class="cm"> * @kref:	    Reference counter</span>
<span class="cm"> * @min_xid:	    Minimum exchange ID</span>
<span class="cm"> * @max_xid:	    Maximum exchange ID</span>
<span class="cm"> * @ep_pool:	    Reserved exchange pointers</span>
<span class="cm"> * @pool_max_index: Max exch array index in exch pool</span>
<span class="cm"> * @pool:	    Per cpu exch pool</span>
<span class="cm"> * @stats:	    Statistics structure</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is the center for creating exchanges and sequences.</span>
<span class="cm"> * It manages the allocation of exchange IDs.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch_pool</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="n">mempool_t</span>	<span class="o">*</span><span class="n">ep_pool</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_class</span>	<span class="n">class</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span>	<span class="n">kref</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">min_xid</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">max_xid</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">pool_max_index</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * currently exchange mgr stats are updated but not used.</span>
<span class="cm">	 * either stats can be expose via sysfs or remove them</span>
<span class="cm">	 * all together if not used XXX</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">atomic_t</span> <span class="n">no_free_exch</span><span class="p">;</span>
		<span class="n">atomic_t</span> <span class="n">no_free_exch_xid</span><span class="p">;</span>
		<span class="n">atomic_t</span> <span class="n">xid_not_found</span><span class="p">;</span>
		<span class="n">atomic_t</span> <span class="n">xid_busy</span><span class="p">;</span>
		<span class="n">atomic_t</span> <span class="n">seq_not_found</span><span class="p">;</span>
		<span class="n">atomic_t</span> <span class="n">non_bls_resp</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fc_exch_mgr_anchor - primary structure for list of EMs</span>
<span class="cm"> * @ema_list: Exchange Manager Anchor list</span>
<span class="cm"> * @mp:	      Exchange Manager associated with this anchor</span>
<span class="cm"> * @match:    Routine to determine if this anchor&#39;s EM should be used</span>
<span class="cm"> *</span>
<span class="cm"> * When walking the list of anchors the match routine will be called</span>
<span class="cm"> * for each anchor to determine if that EM should be used. The last</span>
<span class="cm"> * anchor in the list will always match to handle any exchanges not</span>
<span class="cm"> * handled by other EMs. The non-default EMs would be added to the</span>
<span class="cm"> * anchor list by HW that provides FCoE offloads.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ema_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_exch_rrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_seq_ls_acc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_seq_ls_rjt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fc_els_rjt_reason</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">fc_els_rjt_explan</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_exch_els_rec</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_exch_els_rrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Internal implementation notes.</span>
<span class="cm"> *</span>
<span class="cm"> * The exchange manager is one by default in libfc but LLD may choose</span>
<span class="cm"> * to have one per CPU. The sequence manager is one per exchange manager</span>
<span class="cm"> * and currently never separated.</span>
<span class="cm"> *</span>
<span class="cm"> * Section 9.8 in FC-FS-2 specifies:  &quot;The SEQ_ID is a one-byte field</span>
<span class="cm"> * assigned by the Sequence Initiator that shall be unique for a specific</span>
<span class="cm"> * D_ID and S_ID pair while the Sequence is open.&quot;   Note that it isn&#39;t</span>
<span class="cm"> * qualified by exchange ID, which one might think it would be.</span>
<span class="cm"> * In practice this limits the number of open sequences and exchanges to 256</span>
<span class="cm"> * per session.	 For most targets we could treat this limit as per exchange.</span>
<span class="cm"> *</span>
<span class="cm"> * The exchange and its sequence are freed when the last sequence is received.</span>
<span class="cm"> * It&#39;s possible for the remote port to leave an exchange open without</span>
<span class="cm"> * sending any sequences.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes on reference counts:</span>
<span class="cm"> *</span>
<span class="cm"> * Exchanges are reference counted and exchange gets freed when the reference</span>
<span class="cm"> * count becomes zero.</span>
<span class="cm"> *</span>
<span class="cm"> * Timeouts:</span>
<span class="cm"> * Sequences are timed out for E_D_TOV and R_A_TOV.</span>
<span class="cm"> *</span>
<span class="cm"> * Sequence event handling:</span>
<span class="cm"> *</span>
<span class="cm"> * The following events may occur on initiator sequences:</span>
<span class="cm"> *</span>
<span class="cm"> *	Send.</span>
<span class="cm"> *	    For now, the whole thing is sent.</span>
<span class="cm"> *	Receive ACK</span>
<span class="cm"> *	    This applies only to class F.</span>
<span class="cm"> *	    The sequence is marked complete.</span>
<span class="cm"> *	ULP completion.</span>
<span class="cm"> *	    The upper layer calls fc_exch_done() when done</span>
<span class="cm"> *	    with exchange and sequence tuple.</span>
<span class="cm"> *	RX-inferred completion.</span>
<span class="cm"> *	    When we receive the next sequence on the same exchange, we can</span>
<span class="cm"> *	    retire the previous sequence ID.  (XXX not implemented).</span>
<span class="cm"> *	Timeout.</span>
<span class="cm"> *	    R_A_TOV frees the sequence ID.  If we&#39;re waiting for ACK,</span>
<span class="cm"> *	    E_D_TOV causes abort and calls upper layer response handler</span>
<span class="cm"> *	    with FC_EX_TIMEOUT error.</span>
<span class="cm"> *	Receive RJT</span>
<span class="cm"> *	    XXX defer.</span>
<span class="cm"> *	Send ABTS</span>
<span class="cm"> *	    On timeout.</span>
<span class="cm"> *</span>
<span class="cm"> * The following events may occur on recipient sequences:</span>
<span class="cm"> *</span>
<span class="cm"> *	Receive</span>
<span class="cm"> *	    Allocate sequence for first frame received.</span>
<span class="cm"> *	    Hold during receive handler.</span>
<span class="cm"> *	    Release when final frame received.</span>
<span class="cm"> *	    Keep status of last N of these for the ELS RES command.  XXX TBD.</span>
<span class="cm"> *	Receive ABTS</span>
<span class="cm"> *	    Deallocate sequence</span>
<span class="cm"> *	Send RJT</span>
<span class="cm"> *	    Deallocate</span>
<span class="cm"> *</span>
<span class="cm"> * For now, we neglect conditions where only part of a sequence was</span>
<span class="cm"> * received or transmitted, or where out-of-order receipt is detected.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Locking notes:</span>
<span class="cm"> *</span>
<span class="cm"> * The EM code run in a per-CPU worker thread.</span>
<span class="cm"> *</span>
<span class="cm"> * To protect against concurrency between a worker thread code and timers,</span>
<span class="cm"> * sequence allocation and deallocation must be locked.</span>
<span class="cm"> *  - exchange refcnt can be done atomicly without locks.</span>
<span class="cm"> *  - sequence allocation must be locked by exch lock.</span>
<span class="cm"> *  - If the EM pool lock and ex_lock must be taken at the same time, then the</span>
<span class="cm"> *    EM pool lock must be taken before the ex_lock.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * opcode names for debugging.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fc_exch_rctl_names</span><span class="p">[]</span> <span class="o">=</span> <span class="n">FC_RCTL_NAMES_INIT</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_name_lookup() - Lookup name by opcode</span>
<span class="cm"> * @op:	       Opcode to be looked up</span>
<span class="cm"> * @table:     Opcode/name table</span>
<span class="cm"> * @max_index: Index not to be exceeded</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to determine a human-readable string identifying</span>
<span class="cm"> * a R_CTL opcode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">fc_exch_name_lookup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">table</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">&lt;</span> <span class="n">max_index</span><span class="p">)</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">op</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_rctl_name() - Wrapper routine for fc_exch_name_lookup()</span>
<span class="cm"> * @op: The opcode to be looked up</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">fc_exch_rctl_name</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">fc_exch_name_lookup</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">fc_exch_rctl_names</span><span class="p">,</span>
				   <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">fc_exch_rctl_names</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_hold() - Increment an exchange&#39;s reference count</span>
<span class="cm"> * @ep: Echange to be held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fc_exch_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_setup_hdr() - Initialize a FC header by initializing some fields</span>
<span class="cm"> *			 and determine SOF and EOF.</span>
<span class="cm"> * @ep:	   The exchange to that will use the header</span>
<span class="cm"> * @fp:	   The frame whose header is to be modified</span>
<span class="cm"> * @f_ctl: F_CTL bits that will be used for the frame header</span>
<span class="cm"> *</span>
<span class="cm"> * The fields initialized by this routine are: fh_ox_id, fh_rx_id,</span>
<span class="cm"> * fh_seq_id, fh_seq_cnt and the SOF and EOF.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_setup_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">f_ctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">fill</span><span class="p">;</span>

	<span class="n">fr_sof</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">cnt</span><span class="p">)</span>
		<span class="n">fr_sof</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">fc_sof_normal</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_END_SEQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fr_eof</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_EOF_T</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fc_sof_needs_ack</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">))</span>
			<span class="n">fr_eof</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_EOF_N</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * From F_CTL.</span>
<span class="cm">		 * The number of fill bytes to make the length a 4-byte</span>
<span class="cm">		 * multiple is the low order 2-bits of the f_ctl.</span>
<span class="cm">		 * The fill itself will have been cleared by the frame</span>
<span class="cm">		 * allocation.</span>
<span class="cm">		 * After this, the length will be even, as expected by</span>
<span class="cm">		 * the transport.</span>
<span class="cm">		 */</span>
		<span class="n">fill</span> <span class="o">=</span> <span class="n">fr_len</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fill</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fill</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">fill</span><span class="p">;</span>
			<span class="cm">/* TODO, this may be a problem with fragmented skb */</span>
			<span class="n">skb_put</span><span class="p">(</span><span class="n">fp_skb</span><span class="p">(</span><span class="n">fp</span><span class="p">),</span> <span class="n">fill</span><span class="p">);</span>
			<span class="n">hton24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">,</span> <span class="n">f_ctl</span> <span class="o">|</span> <span class="n">fill</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fr_len</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* no pad to non last frame */</span>
		<span class="n">fr_eof</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_EOF_N</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize remainig fh fields</span>
<span class="cm">	 * from fc_fill_fc_hdr</span>
<span class="cm">	 */</span>
	<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">oxid</span><span class="p">);</span>
	<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span><span class="p">);</span>
	<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_seq_id</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
	<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_seq_cnt</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">cnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_release() - Decrement an exchange&#39;s reference count</span>
<span class="cm"> * @ep: Exchange to be released</span>
<span class="cm"> *</span>
<span class="cm"> * If the reference count reaches zero and the exchange is complete,</span>
<span class="cm"> * it is freed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_refcnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">em</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">)</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_COMPLETE</span><span class="p">));</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">ep_pool</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_done_locked() - Complete an exchange with the exchange lock held</span>
<span class="cm"> * @ep: The exchange that is complete</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_exch_done_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must check for completion in case there are two threads</span>
<span class="cm">	 * tyring to complete this. But the rrq code will reuse the</span>
<span class="cm">	 * ep, and in that case we only clear the resp and set it as</span>
<span class="cm">	 * complete, so it can be reused by the timer to send the rrq.</span>
<span class="cm">	 */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">resp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">FC_EX_DONE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">|=</span> <span class="n">ESB_ST_COMPLETE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_REC_QUAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">FC_EX_DONE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">timeout_work</span><span class="p">))</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_refcnt</span><span class="p">);</span> <span class="cm">/* drop hold for timer */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_ptr_get() - Return an exchange from an exchange pool</span>
<span class="cm"> * @pool:  Exchange Pool to get an exchange from</span>
<span class="cm"> * @index: Index of the exchange within the pool</span>
<span class="cm"> *</span>
<span class="cm"> * Use the index to get an exchange from within an exchange pool. exches</span>
<span class="cm"> * will point to an array of exchange pointers. The index will select</span>
<span class="cm"> * the exchange within the array.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="nf">fc_exch_ptr_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span>
					      <span class="n">u16</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">**</span><span class="n">exches</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">**</span><span class="p">)(</span><span class="n">pool</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">exches</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_ptr_set() - Assign an exchange to a slot in an exchange pool</span>
<span class="cm"> * @pool:  The pool to assign the exchange to</span>
<span class="cm"> * @index: The index in the pool where the exchange will be assigned</span>
<span class="cm"> * @ep:	   The exchange to assign to the pool</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fc_exch_ptr_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">**</span><span class="p">)(</span><span class="n">pool</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_delete() - Delete an exchange</span>
<span class="cm"> * @ep: The exchange to be deleted</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">pool</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">total_exches</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">total_exches</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* update cache of free slot */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">xid</span> <span class="o">-</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">min_xid</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">fc_cpu_order</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">)</span>
		<span class="n">pool</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">)</span>
		<span class="n">pool</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">fc_exch_ptr_set</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_list</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>	<span class="cm">/* drop hold for exch in mp */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_timer_set_locked() - Start a timer for an exchange w/ the</span>
<span class="cm"> *				the exchange lock held</span>
<span class="cm"> * @ep:		The exchange whose timer will start</span>
<span class="cm"> * @timer_msec: The timeout period</span>
<span class="cm"> *</span>
<span class="cm"> * Used for upper level protocols to time out the exchange.</span>
<span class="cm"> * The timer is cancelled when it fires or when the exchange completes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fc_exch_timer_set_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer_msec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FC_EX_RST_CLEANUP</span> <span class="o">|</span> <span class="n">FC_EX_DONE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">FC_EXCH_DBG</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;Exchange timer armed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">fc_exch_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">timeout_work</span><span class="p">,</span>
			       <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">timer_msec</span><span class="p">)))</span>
		<span class="n">fc_exch_hold</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>		<span class="cm">/* hold for timer */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_timer_set() - Lock the exchange and set the timer</span>
<span class="cm"> * @ep:		The exchange whose timer will start</span>
<span class="cm"> * @timer_msec: The timeout period</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_timer_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer_msec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="n">fc_exch_timer_set_locked</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">timer_msec</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_seq_send() - Send a frame using existing sequence/exchange pair</span>
<span class="cm"> * @lport: The local port that the exchange will be sent on</span>
<span class="cm"> * @sp:	   The sequence to be sent</span>
<span class="cm"> * @fp:	   The frame to be sent on the exchange</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_seq_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">f_ctl</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">fh_type</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_type</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_SEQ_INIT</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ESB_ST_SEQ_INIT</span><span class="p">);</span>

	<span class="n">f_ctl</span> <span class="o">=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">);</span>
	<span class="n">fc_exch_setup_hdr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">f_ctl</span><span class="p">);</span>
	<span class="n">fr_encaps</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">encaps</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * update sequence count if this frame is carrying</span>
<span class="cm">	 * multiple FC frames when sequence offload is enabled</span>
<span class="cm">	 * by LLD.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fr_max_payload</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">+=</span> <span class="n">DIV_ROUND_UP</span><span class="p">((</span><span class="n">fr_len</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fh</span><span class="p">)),</span>
					<span class="n">fr_max_payload</span><span class="p">(</span><span class="n">fp</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send the frame.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">frame_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fh_type</span> <span class="o">==</span> <span class="n">FC_TYPE_BLS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the exchange and sequence flags,</span>
<span class="cm">	 * assuming all frames for the sequence have been sent.</span>
<span class="cm">	 * We can only be called to send once for each sequence.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">f_ctl</span> <span class="o">=</span> <span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FC_FC_FIRST_SEQ</span><span class="p">;</span>	<span class="cm">/* not first seq */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_SEQ_INIT</span><span class="p">)</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ESB_ST_SEQ_INIT</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_seq_alloc() - Allocate a sequence for a given exchange</span>
<span class="cm"> * @ep:	    The exchange to allocate a new sequence for</span>
<span class="cm"> * @seq_id: The sequence ID to be used</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t support multiple originated sequences on the same exchange.</span>
<span class="cm"> * By implication, any previously originated sequence on this exchange</span>
<span class="cm"> * is complete, and we reallocate the same sequence.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="nf">fc_seq_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="n">u8</span> <span class="n">seq_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">ssb_stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">seq_id</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_seq_start_next_locked() - Allocate a new sequence on the same</span>
<span class="cm"> *				exchange as the supplied sequence</span>
<span class="cm"> * @sp: The sequence/exchange to get a new sequence for</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="nf">fc_seq_start_next_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">fc_seq_alloc</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="o">++</span><span class="p">);</span>
	<span class="n">FC_EXCH_DBG</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;f_ctl %6x seq %2x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">ep</span><span class="o">-&gt;</span><span class="n">f_ctl</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_seq_start_next() - Lock the exchange and get a new sequence</span>
<span class="cm"> *			 for a given sequence/exchange pair</span>
<span class="cm"> * @sp: The sequence/exchange to get a new exchange for</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="nf">fc_seq_start_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">fc_seq_start_next_locked</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the response handler for the exchange associated with a sequence.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_seq_set_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">resp</span> <span class="o">=</span> <span class="n">resp</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_abort_locked() - Abort an exchange</span>
<span class="cm"> * @ep:	The exchange to be aborted</span>
<span class="cm"> * @timer_msec: The period of time to wait before aborting</span>
<span class="cm"> *</span>
<span class="cm"> * Locking notes:  Called with exch lock held</span>
<span class="cm"> *</span>
<span class="cm"> * Return value: 0 on success else error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_exch_abort_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer_msec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ESB_ST_COMPLETE</span> <span class="o">|</span> <span class="n">ESB_ST_ABNORMAL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">ep</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FC_EX_DONE</span> <span class="o">|</span> <span class="n">FC_EX_RST_CLEANUP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send the abort on a new sequence if possible.</span>
<span class="cm">	 */</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">fc_seq_start_next_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">|=</span> <span class="n">ESB_ST_SEQ_INIT</span> <span class="o">|</span> <span class="n">ESB_ST_ABNORMAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer_msec</span><span class="p">)</span>
		<span class="n">fc_exch_timer_set_locked</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">timer_msec</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If not logged into the fabric, don&#39;t send ABTS but leave</span>
<span class="cm">	 * sequence active until next timeout.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send an abort for the sequence that timed out.</span>
<span class="cm">	 */</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="n">fc_frame_alloc</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc_fill_fc_hdr</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">FC_RCTL_BA_ABTS</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">did</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
			       <span class="n">FC_TYPE_BLS</span><span class="p">,</span> <span class="n">FC_FC_END_SEQ</span> <span class="o">|</span> <span class="n">FC_FC_SEQ_INIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">fc_seq_send</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_seq_exch_abort() - Abort an exchange and sequence</span>
<span class="cm"> * @req_sp:	The sequence to be aborted</span>
<span class="cm"> * @timer_msec: The period of time to wait before aborting</span>
<span class="cm"> *</span>
<span class="cm"> * Generally called because of a timeout or an abort from the upper layer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value: 0 on success else error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_seq_exch_abort</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">req_sp</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer_msec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">req_sp</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">fc_exch_abort_locked</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">timer_msec</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_timeout() - Handle exchange timer expiration</span>
<span class="cm"> * @work: The work_struct identifying the exchange that timed out</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_exch</span><span class="p">,</span>
					  <span class="n">timeout_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">e_stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">FC_EXCH_DBG</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;Exchange timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FC_EX_RST_CLEANUP</span> <span class="o">|</span> <span class="n">FC_EX_DONE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">e_stat</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">=</span> <span class="n">e_stat</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ESB_ST_REC_QUAL</span><span class="p">;</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_REC_QUAL</span><span class="p">)</span>
			<span class="n">fc_exch_rrq</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">resp</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">;</span>
		<span class="n">arg</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">resp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_ABNORMAL</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">fc_exch_done_locked</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">fc_exch_delete</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">resp</span><span class="p">)</span>
			<span class="n">resp</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">FC_EX_TIMEOUT</span><span class="p">),</span> <span class="n">arg</span><span class="p">);</span>
		<span class="n">fc_seq_exch_abort</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">r_a_tov</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">unlock:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="cm">/*</span>
<span class="cm">	 * This release matches the hold taken when the timer was set.</span>
<span class="cm">	 */</span>
	<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_em_alloc() - Allocate an exchange from a specified EM.</span>
<span class="cm"> * @lport: The local port that the exchange is for</span>
<span class="cm"> * @mp:	   The exchange manager that will allocate the exchange</span>
<span class="cm"> *</span>
<span class="cm"> * Returns pointer to allocated fc_exch with exch lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="nf">fc_exch_em_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>

	<span class="cm">/* allocate memory for exchange */</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">ep_pool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">no_free_exch</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ep</span><span class="p">));</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="n">pool</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">put_cpu</span><span class="p">();</span>

	<span class="cm">/* peek cache of free slot */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
		<span class="n">pool</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">hit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
		<span class="n">pool</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">hit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_index</span><span class="p">;</span>
	<span class="cm">/* allocate new exch from pool */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">fc_exch_ptr_get</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">==</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">pool_max_index</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_index</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">==</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">pool_max_index</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">hit:</span>
	<span class="n">fc_exch_hold</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>	<span class="cm">/* hold for exch in mp */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Hold exch lock for caller to prevent fc_exch_reset()</span>
<span class="cm">	 * from releasing exch	while fc_exch_alloc() caller is</span>
<span class="cm">	 * still working on exch.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>

	<span class="n">fc_exch_ptr_set</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">ex_list</span><span class="p">);</span>
	<span class="n">fc_seq_alloc</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="o">++</span><span class="p">);</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">total_exches</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  update exchange</span>
<span class="cm">	 */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">oxid</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">xid</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">fc_cpu_order</span> <span class="o">|</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">min_xid</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">em</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pool</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">lp</span> <span class="o">=</span> <span class="n">lport</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">f_ctl</span> <span class="o">=</span> <span class="n">FC_FC_FIRST_SEQ</span><span class="p">;</span>	<span class="cm">/* next seq is first seq */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span> <span class="o">=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">timeout_work</span><span class="p">,</span> <span class="n">fc_exch_timeout</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ep</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">no_free_exch_xid</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">ep_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_alloc() - Allocate an exchange from an EM on a</span>
<span class="cm"> *		     local port&#39;s list of EMs.</span>
<span class="cm"> * @lport: The local port that will own the exchange</span>
<span class="cm"> * @fp:	   The FC frame that the exchange will be for</span>
<span class="cm"> *</span>
<span class="cm"> * This function walks the list of exchange manager(EM)</span>
<span class="cm"> * anchors to select an EM for a new exchange allocation. The</span>
<span class="cm"> * EM is selected when a NULL match function pointer is encountered</span>
<span class="cm"> * or when a call to a match function returns true.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="nf">fc_exch_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="o">*</span><span class="n">ema</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ema</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">ema_list</span><span class="p">,</span> <span class="n">ema_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ema</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">||</span> <span class="n">ema</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">fc_exch_em_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_find() - Lookup and hold an exchange</span>
<span class="cm"> * @mp:	 The exchange manager to lookup the exchange from</span>
<span class="cm"> * @xid: The XID of the exchange to look up</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="nf">fc_exch_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="n">u16</span> <span class="n">xid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">xid</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">min_xid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">xid</span> <span class="o">&lt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">max_xid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pool</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">,</span> <span class="n">xid</span> <span class="o">&amp;</span> <span class="n">fc_cpu_mask</span><span class="p">);</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_exch_ptr_get</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="p">(</span><span class="n">xid</span> <span class="o">-</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">min_xid</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">fc_cpu_order</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">&amp;&amp;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">xid</span> <span class="o">==</span> <span class="n">xid</span><span class="p">)</span>
			<span class="n">fc_exch_hold</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ep</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fc_exch_done() - Indicate that an exchange/sequence tuple is complete and</span>
<span class="cm"> *		    the memory allocated for the related objects may be freed.</span>
<span class="cm"> * @sp: The sequence that has completed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fc_exch_done_locked</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">fc_exch_delete</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_resp() - Allocate a new exchange for a response frame</span>
<span class="cm"> * @lport: The local port that the exchange was for</span>
<span class="cm"> * @mp:	   The exchange manager to allocate the exchange from</span>
<span class="cm"> * @fp:	   The response frame</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the responder ID in the frame header.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="nf">fc_exch_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_exch_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="n">fc_frame_class</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set EX_CTX indicating we&#39;re responding on this exchange.</span>
<span class="cm">		 */</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">f_ctl</span> <span class="o">|=</span> <span class="n">FC_FC_EX_CTX</span><span class="p">;</span>	<span class="cm">/* we&#39;re responding */</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">f_ctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_FC_FIRST_SEQ</span><span class="p">;</span>	<span class="cm">/* not new */</span>
		<span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_d_id</span><span class="p">);</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">did</span> <span class="o">=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_s_id</span><span class="p">);</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">oid</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">did</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Allocated exchange has placed the XID in the</span>
<span class="cm">		 * originator field. Move it to the responder field,</span>
<span class="cm">		 * and set the originator XID from the frame.</span>
<span class="cm">		 */</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">xid</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">oxid</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span><span class="p">);</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">|=</span> <span class="n">ESB_ST_RESP</span> <span class="o">|</span> <span class="n">ESB_ST_SEQ_INIT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FC_FC_SEQ_INIT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ESB_ST_SEQ_INIT</span><span class="p">;</span>

		<span class="n">fc_exch_hold</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>	<span class="cm">/* hold for caller */</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>	<span class="cm">/* lock from fc_exch_alloc */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ep</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_seq_lookup_recip() - Find a sequence where the other end</span>
<span class="cm"> *			   originated the sequence</span>
<span class="cm"> * @lport: The local port that the frame was sent to</span>
<span class="cm"> * @mp:	   The Exchange Manager to lookup the exchange from</span>
<span class="cm"> * @fp:	   The frame associated with the sequence we&#39;re looking for</span>
<span class="cm"> *</span>
<span class="cm"> * If fc_pf_rjt_reason is FC_RJT_NONE then this function will have a hold</span>
<span class="cm"> * on the ep that should be released by the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">fc_pf_rjt_reason</span> <span class="nf">fc_seq_lookup_recip</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_pf_rjt_reason</span> <span class="n">reject</span> <span class="o">=</span> <span class="n">FC_RJT_NONE</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">f_ctl</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">xid</span><span class="p">;</span>

	<span class="n">f_ctl</span> <span class="o">=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_SEQ_CTX</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lookup or create the exchange if we will be creating the sequence.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_EX_CTX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xid</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span><span class="p">);</span>	<span class="cm">/* we originated exch */</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_exch_find</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xid_not_found</span><span class="p">);</span>
			<span class="n">reject</span> <span class="o">=</span> <span class="n">FC_RJT_OX_ID</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span> <span class="o">==</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">)</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span> <span class="o">!=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reject</span> <span class="o">=</span> <span class="n">FC_RJT_OX_ID</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">rel</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xid</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span><span class="p">);</span>	<span class="cm">/* we are the responder */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Special case for MDS issuing an ELS TEST with a</span>
<span class="cm">		 * bad rxid of 0.</span>
<span class="cm">		 * XXX take this out once we do the proper reject.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xid</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span> <span class="o">==</span> <span class="n">FC_RCTL_ELS_REQ</span> <span class="o">&amp;&amp;</span>
		    <span class="n">fc_frame_payload_op</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">ELS_TEST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">FC_XID_UNKNOWN</span><span class="p">);</span>
			<span class="n">xid</span> <span class="o">=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * new sequence - find the exchange</span>
<span class="cm">		 */</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_exch_find</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_FIRST_SEQ</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fc_sof_is_init</span><span class="p">(</span><span class="n">fr_sof</span><span class="p">(</span><span class="n">fp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xid_busy</span><span class="p">);</span>
				<span class="n">reject</span> <span class="o">=</span> <span class="n">FC_RJT_RX_ID</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">rel</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_exch_resp</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reject</span> <span class="o">=</span> <span class="n">FC_RJT_EXCH_EST</span><span class="p">;</span>	<span class="cm">/* XXX */</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">xid</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">xid</span><span class="p">;</span>	<span class="cm">/* get our XID */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xid_not_found</span><span class="p">);</span>
			<span class="n">reject</span> <span class="o">=</span> <span class="n">FC_RJT_RX_ID</span><span class="p">;</span>	<span class="cm">/* XID not found */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point, we have the exchange held.</span>
<span class="cm">	 * Find or create the sequence.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fc_sof_is_init</span><span class="p">(</span><span class="n">fr_sof</span><span class="p">(</span><span class="n">fp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">ssb_stat</span> <span class="o">|=</span> <span class="n">SSB_ST_RESP</span><span class="p">;</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_seq_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_seq_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">seq_not_found</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_END_SEQ</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Update sequence_id based on incoming last</span>
<span class="cm">				 * frame of sequence exchange. This is needed</span>
<span class="cm">				 * for FCoE target where DDP has been used</span>
<span class="cm">				 * on target where, stack is indicated only</span>
<span class="cm">				 * about last frame&#39;s (payload _header) header.</span>
<span class="cm">				 * Whereas &quot;seq_id&quot; which is part of</span>
<span class="cm">				 * frame_header is allocated by initiator</span>
<span class="cm">				 * which is totally different from &quot;seq_id&quot;</span>
<span class="cm">				 * allocated when XFER_RDY was sent by target.</span>
<span class="cm">				 * To avoid false -ve which results into not</span>
<span class="cm">				 * sending RSP, hence write request on other</span>
<span class="cm">				 * end never finishes.</span>
<span class="cm">				 */</span>
				<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
				<span class="n">sp</span><span class="o">-&gt;</span><span class="n">ssb_stat</span> <span class="o">|=</span> <span class="n">SSB_ST_RESP</span><span class="p">;</span>
				<span class="n">sp</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_seq_id</span><span class="p">;</span>
				<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* sequence/exch should exist */</span>
				<span class="n">reject</span> <span class="o">=</span> <span class="n">FC_RJT_SEQ_ID</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">rel</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ep</span> <span class="o">!=</span> <span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">sp</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_SEQ_INIT</span><span class="p">)</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">|=</span> <span class="n">ESB_ST_SEQ_INIT</span><span class="p">;</span>

	<span class="n">fr_seq</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">reject</span><span class="p">;</span>
<span class="nl">rel:</span>
	<span class="n">fc_exch_done</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
	<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>	<span class="cm">/* hold from fc_exch_find/fc_exch_resp */</span>
	<span class="k">return</span> <span class="n">reject</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_seq_lookup_orig() - Find a sequence where this end</span>
<span class="cm"> *			  originated the sequence</span>
<span class="cm"> * @mp:	   The Exchange Manager to lookup the exchange from</span>
<span class="cm"> * @fp:	   The frame associated with the sequence we&#39;re looking for</span>
<span class="cm"> *</span>
<span class="cm"> * Does not hold the sequence for the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="nf">fc_seq_lookup_orig</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">f_ctl</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">xid</span><span class="p">;</span>

	<span class="n">f_ctl</span> <span class="o">=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_SEQ_CTX</span><span class="p">)</span> <span class="o">!=</span> <span class="n">FC_FC_SEQ_CTX</span><span class="p">);</span>
	<span class="n">xid</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">((</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_EX_CTX</span><span class="p">)</span> <span class="o">?</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span> <span class="o">:</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_exch_find</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_seq_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Save the RX_ID if we didn&#39;t previously know it.</span>
<span class="cm">		 */</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_EX_CTX</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span> <span class="o">==</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_set_addr() - Set the source and destination IDs for an exchange</span>
<span class="cm"> * @ep:	     The exchange to set the addresses for</span>
<span class="cm"> * @orig_id: The originator&#39;s ID</span>
<span class="cm"> * @resp_id: The responder&#39;s ID</span>
<span class="cm"> *</span>
<span class="cm"> * Note this must be done before the first sequence of the exchange is sent.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_set_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">orig_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">resp_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">oid</span> <span class="o">=</span> <span class="n">orig_id</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_RESP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">resp_id</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">did</span> <span class="o">=</span> <span class="n">orig_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">orig_id</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">did</span> <span class="o">=</span> <span class="n">resp_id</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_seq_els_rsp_send() - Send an ELS response using information from</span>
<span class="cm"> *			   the existing sequence/exchange.</span>
<span class="cm"> * @fp:	      The received frame</span>
<span class="cm"> * @els_cmd:  The ELS command to be sent</span>
<span class="cm"> * @els_data: The ELS data to be sent</span>
<span class="cm"> *</span>
<span class="cm"> * The received frame is not freed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_seq_els_rsp_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fc_els_cmd</span> <span class="n">els_cmd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">fc_seq_els_data</span> <span class="o">*</span><span class="n">els_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">els_cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ELS_LS_RJT</span>:
		<span class="n">fc_seq_ls_rjt</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">els_data</span><span class="o">-&gt;</span><span class="n">reason</span><span class="p">,</span> <span class="n">els_data</span><span class="o">-&gt;</span><span class="n">explan</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_LS_ACC</span>:
		<span class="n">fc_seq_ls_acc</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_RRQ</span>:
		<span class="n">fc_exch_els_rrq</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_REC</span>:
		<span class="n">fc_exch_els_rec</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">FC_LPORT_DBG</span><span class="p">(</span><span class="n">fr_dev</span><span class="p">(</span><span class="n">fp</span><span class="p">),</span> <span class="s">&quot;Invalid ELS CMD:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">els_cmd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_seq_send_last() - Send a sequence that is the last in the exchange</span>
<span class="cm"> * @sp:	     The sequence that is to be sent</span>
<span class="cm"> * @fp:	     The frame that will be sent on the sequence</span>
<span class="cm"> * @rctl:    The R_CTL information to be sent</span>
<span class="cm"> * @fh_type: The frame header type</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_seq_send_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">fc_rctl</span> <span class="n">rctl</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fc_fh_type</span> <span class="n">fh_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">f_ctl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>

	<span class="n">f_ctl</span> <span class="o">=</span> <span class="n">FC_FC_LAST_SEQ</span> <span class="o">|</span> <span class="n">FC_FC_END_SEQ</span> <span class="o">|</span> <span class="n">FC_FC_SEQ_INIT</span><span class="p">;</span>
	<span class="n">f_ctl</span> <span class="o">|=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">f_ctl</span><span class="p">;</span>
	<span class="n">fc_fill_fc_hdr</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">rctl</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">did</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">fh_type</span><span class="p">,</span> <span class="n">f_ctl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">fc_seq_send</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_seq_send_ack() - Send an acknowledgement that we&#39;ve received a frame</span>
<span class="cm"> * @sp:	   The sequence to send the ACK on</span>
<span class="cm"> * @rx_fp: The received frame that is being acknoledged</span>
<span class="cm"> *</span>
<span class="cm"> * Send ACK_1 (or equiv.) indicating we received something.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_seq_send_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">rx_fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">rx_fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f_ctl</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t send ACKs for class 3.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fc_sof_needs_ack</span><span class="p">(</span><span class="n">fr_sof</span><span class="p">(</span><span class="n">rx_fp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">fc_frame_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span> <span class="o">=</span> <span class="n">FC_RCTL_ACK_1</span><span class="p">;</span>
		<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_type</span> <span class="o">=</span> <span class="n">FC_TYPE_BLS</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Form f_ctl by inverting EX_CTX and SEQ_CTX (bits 23, 22).</span>
<span class="cm">		 * Echo FIRST_SEQ, LAST_SEQ, END_SEQ, END_CONN, SEQ_INIT.</span>
<span class="cm">		 * Bits 9-8 are meaningful (retransmitted or unidirectional).</span>
<span class="cm">		 * Last ACK uses bits 7-6 (continue sequence),</span>
<span class="cm">		 * bits 5-4 are meaningful (what kind of ACK to use).</span>
<span class="cm">		 */</span>
		<span class="n">rx_fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">rx_fp</span><span class="p">);</span>
		<span class="n">f_ctl</span> <span class="o">=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">rx_fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">);</span>
		<span class="n">f_ctl</span> <span class="o">&amp;=</span> <span class="n">FC_FC_EX_CTX</span> <span class="o">|</span> <span class="n">FC_FC_SEQ_CTX</span> <span class="o">|</span>
			<span class="n">FC_FC_FIRST_SEQ</span> <span class="o">|</span> <span class="n">FC_FC_LAST_SEQ</span> <span class="o">|</span>
			<span class="n">FC_FC_END_SEQ</span> <span class="o">|</span> <span class="n">FC_FC_END_CONN</span> <span class="o">|</span> <span class="n">FC_FC_SEQ_INIT</span> <span class="o">|</span>
			<span class="n">FC_FC_RETX_SEQ</span> <span class="o">|</span> <span class="n">FC_FC_UNI_TX</span><span class="p">;</span>
		<span class="n">f_ctl</span> <span class="o">^=</span> <span class="n">FC_FC_EX_CTX</span> <span class="o">|</span> <span class="n">FC_FC_SEQ_CTX</span><span class="p">;</span>
		<span class="n">hton24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">,</span> <span class="n">f_ctl</span><span class="p">);</span>

		<span class="n">fc_exch_setup_hdr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">f_ctl</span><span class="p">);</span>
		<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_seq_id</span> <span class="o">=</span> <span class="n">rx_fh</span><span class="o">-&gt;</span><span class="n">fh_seq_id</span><span class="p">;</span>
		<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_seq_cnt</span> <span class="o">=</span> <span class="n">rx_fh</span><span class="o">-&gt;</span><span class="n">fh_seq_cnt</span><span class="p">;</span>
		<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_parm_offset</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>	<span class="cm">/* ack single frame */</span>

		<span class="n">fr_sof</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">fr_sof</span><span class="p">(</span><span class="n">rx_fp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_END_SEQ</span><span class="p">)</span>
			<span class="n">fr_eof</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_EOF_T</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">fr_eof</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_EOF_N</span><span class="p">;</span>

		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">frame_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_send_ba_rjt() - Send BLS Reject</span>
<span class="cm"> * @rx_fp:  The frame being rejected</span>
<span class="cm"> * @reason: The reason the frame is being rejected</span>
<span class="cm"> * @explan: The explanation for the rejection</span>
<span class="cm"> *</span>
<span class="cm"> * This is for rejecting BA_ABTS only.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_send_ba_rjt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">rx_fp</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">fc_ba_rjt_reason</span> <span class="n">reason</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">fc_ba_rjt_explan</span> <span class="n">explan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">rx_fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_ba_rjt</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f_ctl</span><span class="p">;</span>

	<span class="n">lport</span> <span class="o">=</span> <span class="n">fr_dev</span><span class="p">(</span><span class="n">rx_fp</span><span class="p">);</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="n">fc_frame_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rp</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">rx_fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">rx_fp</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">fh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fh</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rp</span><span class="p">));</span>

	<span class="n">rp</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rp</span><span class="p">));</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">br_reason</span> <span class="o">=</span> <span class="n">reason</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">br_explan</span> <span class="o">=</span> <span class="n">explan</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * seq_id, cs_ctl, df_ctl and param/offset are zero.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_s_id</span><span class="p">,</span> <span class="n">rx_fh</span><span class="o">-&gt;</span><span class="n">fh_d_id</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_d_id</span><span class="p">,</span> <span class="n">rx_fh</span><span class="o">-&gt;</span><span class="n">fh_s_id</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span> <span class="o">=</span> <span class="n">rx_fh</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span><span class="p">;</span>
	<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span> <span class="o">=</span> <span class="n">rx_fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span><span class="p">;</span>
	<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_seq_cnt</span> <span class="o">=</span> <span class="n">rx_fh</span><span class="o">-&gt;</span><span class="n">fh_seq_cnt</span><span class="p">;</span>
	<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span> <span class="o">=</span> <span class="n">FC_RCTL_BA_RJT</span><span class="p">;</span>
	<span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_type</span> <span class="o">=</span> <span class="n">FC_TYPE_BLS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Form f_ctl by inverting EX_CTX and SEQ_CTX (bits 23, 22).</span>
<span class="cm">	 * Echo FIRST_SEQ, LAST_SEQ, END_SEQ, END_CONN, SEQ_INIT.</span>
<span class="cm">	 * Bits 9-8 are meaningful (retransmitted or unidirectional).</span>
<span class="cm">	 * Last ACK uses bits 7-6 (continue sequence),</span>
<span class="cm">	 * bits 5-4 are meaningful (what kind of ACK to use).</span>
<span class="cm">	 * Always set LAST_SEQ, END_SEQ.</span>
<span class="cm">	 */</span>
	<span class="n">f_ctl</span> <span class="o">=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">rx_fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">);</span>
	<span class="n">f_ctl</span> <span class="o">&amp;=</span> <span class="n">FC_FC_EX_CTX</span> <span class="o">|</span> <span class="n">FC_FC_SEQ_CTX</span> <span class="o">|</span>
		<span class="n">FC_FC_END_CONN</span> <span class="o">|</span> <span class="n">FC_FC_SEQ_INIT</span> <span class="o">|</span>
		<span class="n">FC_FC_RETX_SEQ</span> <span class="o">|</span> <span class="n">FC_FC_UNI_TX</span><span class="p">;</span>
	<span class="n">f_ctl</span> <span class="o">^=</span> <span class="n">FC_FC_EX_CTX</span> <span class="o">|</span> <span class="n">FC_FC_SEQ_CTX</span><span class="p">;</span>
	<span class="n">f_ctl</span> <span class="o">|=</span> <span class="n">FC_FC_LAST_SEQ</span> <span class="o">|</span> <span class="n">FC_FC_END_SEQ</span><span class="p">;</span>
	<span class="n">f_ctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_FC_FIRST_SEQ</span><span class="p">;</span>
	<span class="n">hton24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">,</span> <span class="n">f_ctl</span><span class="p">);</span>

	<span class="n">fr_sof</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">fc_sof_class</span><span class="p">(</span><span class="n">fr_sof</span><span class="p">(</span><span class="n">rx_fp</span><span class="p">));</span>
	<span class="n">fr_eof</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_EOF_T</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fc_sof_needs_ack</span><span class="p">(</span><span class="n">fr_sof</span><span class="p">(</span><span class="n">fp</span><span class="p">)))</span>
		<span class="n">fr_eof</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_EOF_N</span><span class="p">;</span>

	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">frame_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_recv_abts() - Handle an incoming ABTS</span>
<span class="cm"> * @ep:	   The exchange the abort was on</span>
<span class="cm"> * @rx_fp: The ABTS frame</span>
<span class="cm"> *</span>
<span class="cm"> * This would be for target mode usually, but could be due to lost</span>
<span class="cm"> * FCP transfer ready, confirm or RRQ. We always handle this as an</span>
<span class="cm"> * exchange abort, ignoring the parameter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_recv_abts</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">rx_fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_ba_acc</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reject</span><span class="p">;</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">reject</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_REC_QUAL</span><span class="p">))</span>
		<span class="n">fc_exch_hold</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>		<span class="cm">/* hold for REC_QUAL */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">|=</span> <span class="n">ESB_ST_ABNORMAL</span> <span class="o">|</span> <span class="n">ESB_ST_REC_QUAL</span><span class="p">;</span>
	<span class="n">fc_exch_timer_set_locked</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">r_a_tov</span><span class="p">);</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">fc_frame_alloc</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ap</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">ap</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ap</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ap</span><span class="p">));</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ba_high_seq_cnt</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">ssb_stat</span> <span class="o">&amp;</span> <span class="n">SSB_ST_RESP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ba_seq_id</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ba_seq_id_val</span> <span class="o">=</span> <span class="n">FC_BA_SEQ_ID_VAL</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ba_high_seq_cnt</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_seq_cnt</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ba_low_seq_cnt</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">fc_seq_start_next_locked</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="n">fc_seq_send_last</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">FC_RCTL_BA_ACC</span><span class="p">,</span> <span class="n">FC_TYPE_BLS</span><span class="p">);</span>
	<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">rx_fp</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">reject:</span>
	<span class="n">fc_exch_send_ba_rjt</span><span class="p">(</span><span class="n">rx_fp</span><span class="p">,</span> <span class="n">FC_BA_RJT_UNABLE</span><span class="p">,</span> <span class="n">FC_BA_RJT_INV_XID</span><span class="p">);</span>
<span class="nl">free:</span>
	<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">rx_fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_seq_assign() - Assign exchange and sequence for incoming request</span>
<span class="cm"> * @lport: The local port that received the request</span>
<span class="cm"> * @fp:    The request frame</span>
<span class="cm"> *</span>
<span class="cm"> * On success, the sequence pointer will be returned and also in fr_seq(@fp).</span>
<span class="cm"> * A reference will be held on the exchange/sequence for the caller, which</span>
<span class="cm"> * must call fc_seq_release().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="nf">fc_seq_assign</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="o">*</span><span class="n">ema</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">lport</span> <span class="o">!=</span> <span class="n">fr_dev</span><span class="p">(</span><span class="n">fp</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fr_seq</span><span class="p">(</span><span class="n">fp</span><span class="p">));</span>
	<span class="n">fr_seq</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ema</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">ema_list</span><span class="p">,</span> <span class="n">ema_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">ema</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">||</span> <span class="n">ema</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">fc_seq_lookup_recip</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">FC_RJT_NONE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">fr_seq</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_seq_release() - Release the hold</span>
<span class="cm"> * @sp:    The sequence.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_seq_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">sp</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_recv_req() - Handler for an incoming request</span>
<span class="cm"> * @lport: The local port that received the request</span>
<span class="cm"> * @mp:	   The EM that the exchange is on</span>
<span class="cm"> * @fp:	   The request frame</span>
<span class="cm"> *</span>
<span class="cm"> * This is used when the other end is originating the exchange</span>
<span class="cm"> * and the sequence.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_recv_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_pf_rjt_reason</span> <span class="n">reject</span><span class="p">;</span>

	<span class="cm">/* We can have the wrong fc_lport at this point with NPIV, which is a</span>
<span class="cm">	 * problem now that we know a new exchange needs to be allocated</span>
<span class="cm">	 */</span>
	<span class="n">lport</span> <span class="o">=</span> <span class="n">fc_vport_id_lookup</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_d_id</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fr_dev</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">lport</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">fr_seq</span><span class="p">(</span><span class="n">fp</span><span class="p">));</span>		<span class="cm">/* XXX remove later */</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the RX_ID is 0xffff, don&#39;t allocate an exchange.</span>
<span class="cm">	 * The upper-level protocol may request one later, if needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">FC_XID_UNKNOWN</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">lport_recv</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>

	<span class="n">reject</span> <span class="o">=</span> <span class="n">fc_seq_lookup_recip</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reject</span> <span class="o">==</span> <span class="n">FC_RJT_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="n">fr_seq</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>	<span class="cm">/* sequence will be held */</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
		<span class="n">fc_seq_send_ack</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">encaps</span> <span class="o">=</span> <span class="n">fr_encaps</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Call the receive function.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The receive function may allocate a new sequence</span>
<span class="cm">		 * over the old one, so we shouldn&#39;t change the</span>
<span class="cm">		 * sequence after this.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The frame will be freed by the receive function.</span>
<span class="cm">		 * If new exch resp handler is valid then call that</span>
<span class="cm">		 * first.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">)</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">lport_recv</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>	<span class="cm">/* release from lookup */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">FC_LPORT_DBG</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="s">&quot;exch/seq lookup failed: reject %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">reject</span><span class="p">);</span>
		<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_recv_seq_resp() - Handler for an incoming response where the other</span>
<span class="cm"> *			     end is the originator of the sequence that is a</span>
<span class="cm"> *			     response to our initial exchange</span>
<span class="cm"> * @mp: The EM that the exchange is on</span>
<span class="cm"> * @fp: The response frame</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_recv_seq_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_sof</span> <span class="n">sof</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">f_ctl</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ex_resp_arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_exch_find</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xid_not_found</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xid_not_found</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rel</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span> <span class="o">==</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">)</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">!=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_d_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xid_not_found</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rel</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">did</span> <span class="o">!=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_s_id</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ep</span><span class="o">-&gt;</span><span class="n">did</span> <span class="o">!=</span> <span class="n">FC_FID_FLOGI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xid_not_found</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rel</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sof</span> <span class="o">=</span> <span class="n">fr_sof</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fc_sof_is_init</span><span class="p">(</span><span class="n">sof</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">ssb_stat</span> <span class="o">|=</span> <span class="n">SSB_ST_RESP</span><span class="p">;</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_seq_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_seq_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">seq_not_found</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">f_ctl</span> <span class="o">=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">);</span>
	<span class="n">fr_seq</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_SEQ_INIT</span><span class="p">)</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">|=</span> <span class="n">ESB_ST_SEQ_INIT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_sof_needs_ack</span><span class="p">(</span><span class="n">sof</span><span class="p">))</span>
		<span class="n">fc_seq_send_ack</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="n">resp</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">;</span>
	<span class="n">ex_resp_arg</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_type</span> <span class="o">!=</span> <span class="n">FC_TYPE_FCP</span> <span class="o">&amp;&amp;</span> <span class="n">fr_eof</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">FC_EOF_T</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FC_FC_LAST_SEQ</span> <span class="o">|</span> <span class="n">FC_FC_END_SEQ</span><span class="p">))</span> <span class="o">==</span>
	    <span class="p">(</span><span class="n">FC_FC_LAST_SEQ</span> <span class="o">|</span> <span class="n">FC_FC_END_SEQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
		<span class="n">resp</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">fc_exch_done_locked</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ep</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">fc_exch_delete</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call the receive function.</span>
<span class="cm">	 * The sequence is held (has a refcnt) for us,</span>
<span class="cm">	 * but not for the receive function.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The receive function may allocate a new sequence</span>
<span class="cm">	 * over the old one, so we shouldn&#39;t change the</span>
<span class="cm">	 * sequence after this.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The frame will be freed by the receive function.</span>
<span class="cm">	 * If new exch resp handler is valid then call that</span>
<span class="cm">	 * first.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">resp</span><span class="p">)</span>
		<span class="n">resp</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ex_resp_arg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">rel:</span>
	<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_recv_resp() - Handler for a sequence where other end is</span>
<span class="cm"> *			 responding to our sequence</span>
<span class="cm"> * @mp: The EM that the exchange is on</span>
<span class="cm"> * @fp: The response frame</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_recv_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">fc_seq_lookup_orig</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>	<span class="cm">/* doesn&#39;t hold sequence */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xid_not_found</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">non_bls_resp</span><span class="p">);</span>

	<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_abts_resp() - Handler for a response to an ABT</span>
<span class="cm"> * @ep: The exchange that the frame is on</span>
<span class="cm"> * @fp: The response frame</span>
<span class="cm"> *</span>
<span class="cm"> * This response would be to an ABTS cancelling an exchange or sequence.</span>
<span class="cm"> * The response can be either BA_ACC or BA_RJT</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_abts_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ex_resp_arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_ba_acc</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">low</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">high</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">has_rec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">FC_EXCH_DBG</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;exch: BLS rctl %x - %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">,</span>
		    <span class="n">fc_exch_rctl_name</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">timeout_work</span><span class="p">))</span>
		<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>	<span class="cm">/* release from pending timer hold */</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FC_RCTL_BA_ACC</span>:
		<span class="n">ap</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ap</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Decide whether to establish a Recovery Qualifier.</span>
<span class="cm">		 * We do this if there is a non-empty SEQ_CNT range and</span>
<span class="cm">		 * SEQ_ID is the same as the one we aborted.</span>
<span class="cm">		 */</span>
		<span class="n">low</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ba_low_seq_cnt</span><span class="p">);</span>
		<span class="n">high</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ba_high_seq_cnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_REC_QUAL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ba_seq_id_val</span> <span class="o">!=</span> <span class="n">FC_BA_SEQ_ID_VAL</span> <span class="o">||</span>
		     <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ba_seq_id</span> <span class="o">==</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">low</span> <span class="o">!=</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">|=</span> <span class="n">ESB_ST_REC_QUAL</span><span class="p">;</span>
			<span class="n">fc_exch_hold</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>  <span class="cm">/* hold for recovery qualifier */</span>
			<span class="n">has_rec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FC_RCTL_BA_RJT</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">resp</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">;</span>
	<span class="n">ex_resp_arg</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>

	<span class="cm">/* do we need to do some other checks here. Can we reuse more of</span>
<span class="cm">	 * fc_exch_recv_seq_resp</span>
<span class="cm">	 */</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * do we want to check END_SEQ as well as LAST_SEQ here?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">fh_type</span> <span class="o">!=</span> <span class="n">FC_TYPE_FCP</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FC_FC_LAST_SEQ</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">fc_exch_done_locked</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">fc_exch_delete</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">resp</span><span class="p">)</span>
		<span class="n">resp</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ex_resp_arg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_rec</span><span class="p">)</span>
		<span class="n">fc_exch_timer_set</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">r_a_tov</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_recv_bls() - Handler for a BLS sequence</span>
<span class="cm"> * @mp: The EM that the exchange is on</span>
<span class="cm"> * @fp: The request frame</span>
<span class="cm"> *</span>
<span class="cm"> * The BLS frame is always a sequence initiated by the remote side.</span>
<span class="cm"> * We may be either the originator or recipient of the exchange.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_recv_bls</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">f_ctl</span><span class="p">;</span>

	<span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">f_ctl</span> <span class="o">=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">);</span>
	<span class="n">fr_seq</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_exch_find</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_EX_CTX</span><span class="p">)</span> <span class="o">?</span>
			  <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span><span class="p">)</span> <span class="o">:</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_SEQ_INIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">|=</span> <span class="n">ESB_ST_SEQ_INIT</span><span class="p">;</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_SEQ_CTX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * A response to a sequence we initiated.</span>
<span class="cm">		 * This should only be ACKs for class 2 or F.</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FC_RCTL_ACK_1</span>:
		<span class="k">case</span> <span class="n">FC_RCTL_ACK_0</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="p">)</span>
				<span class="n">FC_EXCH_DBG</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;BLS rctl %x - %s received&quot;</span><span class="p">,</span>
					    <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">,</span>
					    <span class="n">fc_exch_rctl_name</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FC_RCTL_BA_RJT</span>:
		<span class="k">case</span> <span class="n">FC_RCTL_BA_ACC</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="p">)</span>
				<span class="n">fc_exch_abts_resp</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FC_RCTL_BA_ABTS</span>:
			<span class="n">fc_exch_recv_abts</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>			<span class="cm">/* ignore junk */</span>
			<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="p">)</span>
		<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>	<span class="cm">/* release hold taken by fc_exch_find */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_seq_ls_acc() - Accept sequence with LS_ACC</span>
<span class="cm"> * @rx_fp: The received frame, not freed here.</span>
<span class="cm"> *</span>
<span class="cm"> * If this fails due to allocation or transmit congestion, assume the</span>
<span class="cm"> * originator will repeat the sequence.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_seq_ls_acc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">rx_fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_els_ls_acc</span> <span class="o">*</span><span class="n">acc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

	<span class="n">lport</span> <span class="o">=</span> <span class="n">fr_dev</span><span class="p">(</span><span class="n">rx_fp</span><span class="p">);</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="n">fc_frame_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">acc</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">acc</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">acc</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">acc</span><span class="p">));</span>
	<span class="n">acc</span><span class="o">-&gt;</span><span class="n">la_cmd</span> <span class="o">=</span> <span class="n">ELS_LS_ACC</span><span class="p">;</span>
	<span class="n">fc_fill_reply_hdr</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">rx_fp</span><span class="p">,</span> <span class="n">FC_RCTL_ELS_REP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">frame_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_seq_ls_rjt() - Reject a sequence with ELS LS_RJT</span>
<span class="cm"> * @rx_fp: The received frame, not freed here.</span>
<span class="cm"> * @reason: The reason the sequence is being rejected</span>
<span class="cm"> * @explan: The explanation for the rejection</span>
<span class="cm"> *</span>
<span class="cm"> * If this fails due to allocation or transmit congestion, assume the</span>
<span class="cm"> * originator will repeat the sequence.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_seq_ls_rjt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">rx_fp</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fc_els_rjt_reason</span> <span class="n">reason</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">fc_els_rjt_explan</span> <span class="n">explan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_els_ls_rjt</span> <span class="o">*</span><span class="n">rjt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

	<span class="n">lport</span> <span class="o">=</span> <span class="n">fr_dev</span><span class="p">(</span><span class="n">rx_fp</span><span class="p">);</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="n">fc_frame_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rjt</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">rjt</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rjt</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rjt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rjt</span><span class="p">));</span>
	<span class="n">rjt</span><span class="o">-&gt;</span><span class="n">er_cmd</span> <span class="o">=</span> <span class="n">ELS_LS_RJT</span><span class="p">;</span>
	<span class="n">rjt</span><span class="o">-&gt;</span><span class="n">er_reason</span> <span class="o">=</span> <span class="n">reason</span><span class="p">;</span>
	<span class="n">rjt</span><span class="o">-&gt;</span><span class="n">er_explan</span> <span class="o">=</span> <span class="n">explan</span><span class="p">;</span>
	<span class="n">fc_fill_reply_hdr</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">rx_fp</span><span class="p">,</span> <span class="n">FC_RCTL_ELS_REP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">frame_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_reset() - Reset an exchange</span>
<span class="cm"> * @ep: The exchange to be reset</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="n">fc_exch_abort_locked</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">FC_EX_RST_CLEANUP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">timeout_work</span><span class="p">))</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_refcnt</span><span class="p">);</span>	<span class="cm">/* drop hold for timer */</span>
	<span class="n">resp</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">resp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_REC_QUAL</span><span class="p">)</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_refcnt</span><span class="p">);</span>	<span class="cm">/* drop hold for rec_qual */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ESB_ST_REC_QUAL</span><span class="p">;</span>
	<span class="n">arg</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fc_exch_done_locked</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">fc_exch_delete</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">resp</span><span class="p">)</span>
		<span class="n">resp</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">FC_EX_CLOSED</span><span class="p">),</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_pool_reset() - Reset a per cpu exchange pool</span>
<span class="cm"> * @lport: The local port that the exchange pool is on</span>
<span class="cm"> * @pool:  The exchange pool to be reset</span>
<span class="cm"> * @sid:   The source ID</span>
<span class="cm"> * @did:   The destination ID</span>
<span class="cm"> *</span>
<span class="cm"> * Resets a per cpu exches pool, releasing all of its sequences</span>
<span class="cm"> * and exchanges. If sid is non-zero then reset only exchanges</span>
<span class="cm"> * we sourced from the local port&#39;s FID. If did is non-zero then</span>
<span class="cm"> * only reset exchanges destined for the local port&#39;s FID.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_pool_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">fc_exch_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">did</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">restart:</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">ex_list</span><span class="p">,</span> <span class="n">ex_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">lport</span> <span class="o">==</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">sid</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">sid</span> <span class="o">==</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">did</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">did</span> <span class="o">==</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">did</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fc_exch_hold</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

			<span class="n">fc_exch_reset</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

			<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * must restart loop incase while lock</span>
<span class="cm">			 * was down multiple eps were released.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_mgr_reset() - Reset all EMs of a local port</span>
<span class="cm"> * @lport: The local port whose EMs are to be reset</span>
<span class="cm"> * @sid:   The source ID</span>
<span class="cm"> * @did:   The destination ID</span>
<span class="cm"> *</span>
<span class="cm"> * Reset all EMs associated with a given local port. Release all</span>
<span class="cm"> * sequences and exchanges. If sid is non-zero then reset only the</span>
<span class="cm"> * exchanges sent from the local port&#39;s FID. If did is non-zero then</span>
<span class="cm"> * reset only exchanges destined for the local port&#39;s FID.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fc_exch_mgr_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">did</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="o">*</span><span class="n">ema</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ema</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">ema_list</span><span class="p">,</span> <span class="n">ema_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
			<span class="n">fc_exch_pool_reset</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span>
					   <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span>
					   <span class="n">sid</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_exch_mgr_reset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_lookup() - find an exchange</span>
<span class="cm"> * @lport: The local port</span>
<span class="cm"> * @xid: The exchange ID</span>
<span class="cm"> *</span>
<span class="cm"> * Returns exchange pointer with hold for caller, or NULL if not found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="nf">fc_exch_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="n">u32</span> <span class="n">xid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="o">*</span><span class="n">ema</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ema</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">ema_list</span><span class="p">,</span> <span class="n">ema_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">min_xid</span> <span class="o">&lt;=</span> <span class="n">xid</span> <span class="o">&amp;&amp;</span> <span class="n">xid</span> <span class="o">&lt;=</span> <span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">max_xid</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">fc_exch_find</span><span class="p">(</span><span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_els_rec() - Handler for ELS REC (Read Exchange Concise) requests</span>
<span class="cm"> * @rfp: The REC frame, not freed here.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the requesting port may be different than the S_ID in the request.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_els_rec</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">rfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_els_rec</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_els_rec_acc</span> <span class="o">*</span><span class="n">acc</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_els_rjt_reason</span> <span class="n">reason</span> <span class="o">=</span> <span class="n">ELS_RJT_LOGIC</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_els_rjt_explan</span> <span class="n">explan</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">rxid</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">oxid</span><span class="p">;</span>

	<span class="n">lport</span> <span class="o">=</span> <span class="n">fr_dev</span><span class="p">(</span><span class="n">rfp</span><span class="p">);</span>
	<span class="n">rp</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">rfp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rp</span><span class="p">));</span>
	<span class="n">explan</span> <span class="o">=</span> <span class="n">ELS_EXPL_INV_LEN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reject</span><span class="p">;</span>
	<span class="n">sid</span> <span class="o">=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rec_s_id</span><span class="p">);</span>
	<span class="n">rxid</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rec_rx_id</span><span class="p">);</span>
	<span class="n">oxid</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rec_ox_id</span><span class="p">);</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_exch_lookup</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span>
			    <span class="n">sid</span> <span class="o">==</span> <span class="n">fc_host_port_id</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span> <span class="o">?</span> <span class="n">oxid</span> <span class="o">:</span> <span class="n">rxid</span><span class="p">);</span>
	<span class="n">explan</span> <span class="o">=</span> <span class="n">ELS_EXPL_OXID_RXID</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reject</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">oid</span> <span class="o">!=</span> <span class="n">sid</span> <span class="o">||</span> <span class="n">oxid</span> <span class="o">!=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">oxid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">rel</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rxid</span> <span class="o">!=</span> <span class="n">FC_XID_UNKNOWN</span> <span class="o">&amp;&amp;</span> <span class="n">rxid</span> <span class="o">!=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">rel</span><span class="p">;</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="n">fc_frame_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">acc</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">acc</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">acc</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">acc</span><span class="p">));</span>
	<span class="n">acc</span><span class="o">-&gt;</span><span class="n">reca_cmd</span> <span class="o">=</span> <span class="n">ELS_LS_ACC</span><span class="p">;</span>
	<span class="n">acc</span><span class="o">-&gt;</span><span class="n">reca_ox_id</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rec_ox_id</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">acc</span><span class="o">-&gt;</span><span class="n">reca_ofid</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rec_s_id</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">acc</span><span class="o">-&gt;</span><span class="n">reca_rx_id</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">==</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">oid</span><span class="p">)</span>
		<span class="n">hton24</span><span class="p">(</span><span class="n">acc</span><span class="o">-&gt;</span><span class="n">reca_rfid</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">did</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">hton24</span><span class="p">(</span><span class="n">acc</span><span class="o">-&gt;</span><span class="n">reca_rfid</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">);</span>
	<span class="n">acc</span><span class="o">-&gt;</span><span class="n">reca_fc4value</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">rec_data</span><span class="p">);</span>
	<span class="n">acc</span><span class="o">-&gt;</span><span class="n">reca_e_stat</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ESB_ST_RESP</span> <span class="o">|</span>
						 <span class="n">ESB_ST_SEQ_INIT</span> <span class="o">|</span>
						 <span class="n">ESB_ST_COMPLETE</span><span class="p">));</span>
	<span class="n">fc_fill_reply_hdr</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">rfp</span><span class="p">,</span> <span class="n">FC_RCTL_ELS_REP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">frame_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">rel:</span>
	<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="nl">reject:</span>
	<span class="n">fc_seq_ls_rjt</span><span class="p">(</span><span class="n">rfp</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="n">explan</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_rrq_resp() - Handler for RRQ responses</span>
<span class="cm"> * @sp:	 The sequence that the RRQ is on</span>
<span class="cm"> * @fp:	 The RRQ frame</span>
<span class="cm"> * @arg: The exchange that the RRQ is on</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: fix error handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_rrq_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">aborted_ep</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">FC_EX_CLOSED</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">FC_EX_TIMEOUT</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="n">FC_EXCH_DBG</span><span class="p">(</span><span class="n">aborted_ep</span><span class="p">,</span> <span class="s">&quot;Cannot process RRQ, &quot;</span>
			    <span class="s">&quot;frame error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">op</span> <span class="o">=</span> <span class="n">fc_frame_payload_op</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ELS_LS_RJT</span>:
		<span class="n">FC_EXCH_DBG</span><span class="p">(</span><span class="n">aborted_ep</span><span class="p">,</span> <span class="s">&quot;LS_RJT for RRQ&quot;</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">ELS_LS_ACC</span>:
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">FC_EXCH_DBG</span><span class="p">(</span><span class="n">aborted_ep</span><span class="p">,</span> <span class="s">&quot;unexpected response op %x &quot;</span>
			    <span class="s">&quot;for RRQ&quot;</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">cleanup:</span>
	<span class="n">fc_exch_done</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aborted_ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
	<span class="cm">/* drop hold for rec qual */</span>
	<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">aborted_ep</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fc_exch_seq_send() - Send a frame using a new exchange and sequence</span>
<span class="cm"> * @lport:	The local port to send the frame on</span>
<span class="cm"> * @fp:		The frame to be sent</span>
<span class="cm"> * @resp:	The response handler for this request</span>
<span class="cm"> * @destructor: The destructor for the exchange</span>
<span class="cm"> * @arg:	The argument to be passed to the response handler</span>
<span class="cm"> * @timer_msec: The timeout period for the exchange</span>
<span class="cm"> *</span>
<span class="cm"> * The frame pointer with some of the header&#39;s fields must be</span>
<span class="cm"> * filled before calling this routine, those fields are:</span>
<span class="cm"> *</span>
<span class="cm"> * - routing control</span>
<span class="cm"> * - FC port did</span>
<span class="cm"> * - FC port sid</span>
<span class="cm"> * - FC header type</span>
<span class="cm"> * - frame control</span>
<span class="cm"> * - parameter or relative offset</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="nf">fc_exch_seq_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
						    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">),</span>
				       <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span>
							  <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timer_msec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_exch_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">|=</span> <span class="n">ESB_ST_SEQ_INIT</span><span class="p">;</span>
	<span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">fc_exch_set_addr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_s_id</span><span class="p">),</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_d_id</span><span class="p">));</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">resp</span> <span class="o">=</span> <span class="n">resp</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">destructor</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">r_a_tov</span> <span class="o">=</span> <span class="n">FC_DEF_R_A_TOV</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">lp</span> <span class="o">=</span> <span class="n">lport</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">fh_type</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_type</span><span class="p">;</span> <span class="cm">/* save for possbile timeout handling */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">f_ctl</span> <span class="o">=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">);</span>
	<span class="n">fc_exch_setup_hdr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">f_ctl</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">xid</span> <span class="o">&lt;=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_xid</span> <span class="o">&amp;&amp;</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span> <span class="o">==</span> <span class="n">FC_RCTL_DD_UNSOL_CMD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsp</span> <span class="o">=</span> <span class="n">fr_fsp</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="n">fc_fcp_ddp_setup</span><span class="p">(</span><span class="n">fr_fsp</span><span class="p">(</span><span class="n">fp</span><span class="p">),</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">xid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">frame_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timer_msec</span><span class="p">)</span>
		<span class="n">fc_exch_timer_set_locked</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">timer_msec</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">f_ctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_FC_FIRST_SEQ</span><span class="p">;</span>	<span class="cm">/* not first seq */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_SEQ_INIT</span><span class="p">)</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ESB_ST_SEQ_INIT</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="p">)</span>
		<span class="n">fc_fcp_ddp_done</span><span class="p">(</span><span class="n">fsp</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fc_exch_done_locked</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">fc_exch_delete</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_rrq() - Send an ELS RRQ (Reinstate Recovery Qualifier) command</span>
<span class="cm"> * @ep: The exchange to send the RRQ on</span>
<span class="cm"> *</span>
<span class="cm"> * This tells the remote port to stop blocking the use of</span>
<span class="cm"> * the exchange and the seq_cnt range.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_rrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_els_rrq</span> <span class="o">*</span><span class="n">rrq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">did</span><span class="p">;</span>

	<span class="n">lport</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">fc_frame_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rrq</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="n">rrq</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rrq</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rrq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rrq</span><span class="p">));</span>
	<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rrq_cmd</span> <span class="o">=</span> <span class="n">ELS_RRQ</span><span class="p">;</span>
	<span class="n">hton24</span><span class="p">(</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rrq_s_id</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">);</span>
	<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rrq_ox_id</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">oxid</span><span class="p">);</span>
	<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rrq_rx_id</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span><span class="p">);</span>

	<span class="n">did</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">did</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_RESP</span><span class="p">)</span>
		<span class="n">did</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>

	<span class="n">fc_fill_fc_hdr</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">FC_RCTL_ELS_REQ</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span>
		       <span class="n">lport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="n">FC_TYPE_ELS</span><span class="p">,</span>
		       <span class="n">FC_FC_FIRST_SEQ</span> <span class="o">|</span> <span class="n">FC_FC_END_SEQ</span> <span class="o">|</span> <span class="n">FC_FC_SEQ_INIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_exch_seq_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fc_exch_rrq_resp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span>
			     <span class="n">lport</span><span class="o">-&gt;</span><span class="n">e_d_tov</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FC_EX_RST_CLEANUP</span> <span class="o">|</span> <span class="n">FC_EX_DONE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
		<span class="cm">/* drop hold for rec qual */</span>
		<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">|=</span> <span class="n">ESB_ST_REC_QUAL</span><span class="p">;</span>
	<span class="n">fc_exch_timer_set_locked</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">r_a_tov</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_els_rrq() - Handler for ELS RRQ (Reset Recovery Qualifier) requests</span>
<span class="cm"> * @fp: The RRQ frame, not freed here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_els_rrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* request or subject exchange */</span>
	<span class="k">struct</span> <span class="n">fc_els_rrq</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">xid</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_els_rjt_explan</span> <span class="n">explan</span><span class="p">;</span>

	<span class="n">lport</span> <span class="o">=</span> <span class="n">fr_dev</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">rp</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rp</span><span class="p">));</span>
	<span class="n">explan</span> <span class="o">=</span> <span class="n">ELS_EXPL_INV_LEN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reject</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * lookup subject exchange.</span>
<span class="cm">	 */</span>
	<span class="n">sid</span> <span class="o">=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rrq_s_id</span><span class="p">);</span>		<span class="cm">/* subject source */</span>
	<span class="n">xid</span> <span class="o">=</span> <span class="n">fc_host_port_id</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span> <span class="o">==</span> <span class="n">sid</span> <span class="o">?</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rrq_ox_id</span><span class="p">)</span> <span class="o">:</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rrq_rx_id</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">fc_exch_lookup</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
	<span class="n">explan</span> <span class="o">=</span> <span class="n">ELS_EXPL_OXID_RXID</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reject</span><span class="p">;</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">oxid</span> <span class="o">!=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rrq_ox_id</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock_reject</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span> <span class="o">!=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rrq_rx_id</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ep</span><span class="o">-&gt;</span><span class="n">rxid</span> <span class="o">!=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock_reject</span><span class="p">;</span>
	<span class="n">explan</span> <span class="o">=</span> <span class="n">ELS_EXPL_SID</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">!=</span> <span class="n">sid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock_reject</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear Recovery Qualifier state, and cancel timer if complete.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_REC_QUAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ESB_ST_REC_QUAL</span><span class="p">;</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_refcnt</span><span class="p">);</span>	<span class="cm">/* drop hold for rec qual */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">esb_stat</span> <span class="o">&amp;</span> <span class="n">ESB_ST_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">timeout_work</span><span class="p">))</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_refcnt</span><span class="p">);</span>	<span class="cm">/* drop timer hold */</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send LS_ACC.</span>
<span class="cm">	 */</span>
	<span class="n">fc_seq_ls_acc</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">unlock_reject:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ex_lock</span><span class="p">);</span>
<span class="nl">reject:</span>
	<span class="n">fc_seq_ls_rjt</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">ELS_RJT_LOGIC</span><span class="p">,</span> <span class="n">explan</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="p">)</span>
		<span class="n">fc_exch_release</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>	<span class="cm">/* drop hold from fc_exch_find */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_mgr_add() - Add an exchange manager to a local port&#39;s list of EMs</span>
<span class="cm"> * @lport: The local port to add the exchange manager to</span>
<span class="cm"> * @mp:	   The exchange manager to be added to the local port</span>
<span class="cm"> * @match: The match routine that indicates when this EM should be used</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="o">*</span><span class="nf">fc_exch_mgr_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span>
					   <span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="o">*</span><span class="n">ema</span><span class="p">;</span>

	<span class="n">ema</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ema</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ema</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ema</span><span class="p">;</span>

	<span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
	<span class="n">ema</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="n">match</span><span class="p">;</span>
	<span class="cm">/* add EM anchor to EM anchors list */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ema</span><span class="o">-&gt;</span><span class="n">ema_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">ema_list</span><span class="p">);</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ema</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_exch_mgr_add</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_mgr_destroy() - Destroy an exchange manager</span>
<span class="cm"> * @kref: The reference to the EM to be destroyed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_exch_mgr_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_exch_mgr</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>

	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">ep_pool</span><span class="p">);</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_mgr_del() - Delete an EM from a local port&#39;s list</span>
<span class="cm"> * @ema: The exchange manager anchor identifying the EM to be deleted</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fc_exch_mgr_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="o">*</span><span class="n">ema</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* remove EM anchor from EM anchors list */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ema</span><span class="o">-&gt;</span><span class="n">ema_list</span><span class="p">);</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">fc_exch_mgr_destroy</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ema</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_exch_mgr_del</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_mgr_list_clone() - Share all exchange manager objects</span>
<span class="cm"> * @src: Source lport to clone exchange managers from</span>
<span class="cm"> * @dst: New lport that takes references to all the exchange managers</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fc_exch_mgr_list_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="o">*</span><span class="n">ema</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ema</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">ema_list</span><span class="p">,</span> <span class="n">ema_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fc_exch_mgr_add</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">ema</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ema</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">ema_list</span><span class="p">,</span> <span class="n">ema_list</span><span class="p">)</span>
		<span class="n">fc_exch_mgr_del</span><span class="p">(</span><span class="n">ema</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_exch_mgr_list_clone</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_mgr_alloc() - Allocate an exchange manager</span>
<span class="cm"> * @lport:   The local port that the new EM will be associated with</span>
<span class="cm"> * @class:   The default FC class for new exchanges</span>
<span class="cm"> * @min_xid: The minimum XID for exchanges from the new EM</span>
<span class="cm"> * @max_xid: The maximum XID for exchanges from the new EM</span>
<span class="cm"> * @match:   The match routine for the new EM</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="nf">fc_exch_mgr_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
				      <span class="k">enum</span> <span class="n">fc_class</span> <span class="n">class</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">min_xid</span><span class="p">,</span> <span class="n">u16</span> <span class="n">max_xid</span><span class="p">,</span>
				      <span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pool_exch_range</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">pool_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_xid</span> <span class="o">&lt;=</span> <span class="n">min_xid</span> <span class="o">||</span> <span class="n">max_xid</span> <span class="o">==</span> <span class="n">FC_XID_UNKNOWN</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">min_xid</span> <span class="o">&amp;</span> <span class="n">fc_cpu_mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FC_LPORT_DBG</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="s">&quot;Invalid min_xid 0x:%x and max_xid 0x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">min_xid</span><span class="p">,</span> <span class="n">max_xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate memory for EM</span>
<span class="cm">	 */</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch_mgr</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="n">class</span><span class="p">;</span>
	<span class="cm">/* adjust em exch xid range for offload */</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">min_xid</span> <span class="o">=</span> <span class="n">min_xid</span><span class="p">;</span>

       <span class="cm">/* reduce range so per cpu pool fits into PCPU_MIN_UNIT_SIZE pool */</span>
	<span class="n">pool_exch_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCPU_MIN_UNIT_SIZE</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pool</span><span class="p">))</span> <span class="o">/</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">max_xid</span> <span class="o">-</span> <span class="n">min_xid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fc_cpu_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">pool_exch_range</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">max_xid</span> <span class="o">=</span> <span class="n">pool_exch_range</span> <span class="o">*</span> <span class="p">(</span><span class="n">fc_cpu_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">min_xid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">max_xid</span> <span class="o">=</span> <span class="n">max_xid</span><span class="p">;</span>
		<span class="n">pool_exch_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">max_xid</span> <span class="o">-</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">min_xid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
			<span class="p">(</span><span class="n">fc_cpu_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">ep_pool</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">fc_em_cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">ep_pool</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_mp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup per cpu exch pool with entire exchange id range equally</span>
<span class="cm">	 * divided across all cpus. The exch pointers array memory is</span>
<span class="cm">	 * allocated for exch range per pool.</span>
<span class="cm">	 */</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">pool_max_index</span> <span class="o">=</span> <span class="n">pool_exch_range</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate and initialize per cpu exch pool</span>
<span class="cm">	 */</span>
	<span class="n">pool_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pool</span><span class="p">)</span> <span class="o">+</span> <span class="n">pool_exch_range</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">pool</span> <span class="o">=</span> <span class="n">__alloc_percpu</span><span class="p">(</span><span class="n">pool_size</span><span class="p">,</span> <span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch_pool</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_mempool</span><span class="p">;</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pool</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pool</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">;</span>
		<span class="n">pool</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">;</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">ex_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fc_exch_mgr_add</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">match</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free_percpu</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_mempool</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Above kref_init() sets mp-&gt;kref to 1 and then</span>
<span class="cm">	 * call to fc_exch_mgr_add incremented mp-&gt;kref again,</span>
<span class="cm">	 * so adjust that extra increment.</span>
<span class="cm">	 */</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">fc_exch_mgr_destroy</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mp</span><span class="p">;</span>

<span class="nl">free_mempool:</span>
	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">ep_pool</span><span class="p">);</span>
<span class="nl">free_mp:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_exch_mgr_alloc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_mgr_free() - Free all exchange managers on a local port</span>
<span class="cm"> * @lport: The local port whose EMs are to be freed</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fc_exch_mgr_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="o">*</span><span class="n">ema</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">fc_exch_workqueue</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ema</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">ema_list</span><span class="p">,</span> <span class="n">ema_list</span><span class="p">)</span>
		<span class="n">fc_exch_mgr_del</span><span class="p">(</span><span class="n">ema</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_exch_mgr_free</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_find_ema() - Lookup and return appropriate Exchange Manager Anchor depending</span>
<span class="cm"> * upon &#39;xid&#39;.</span>
<span class="cm"> * @f_ctl: f_ctl</span>
<span class="cm"> * @lport: The local port the frame was received on</span>
<span class="cm"> * @fh: The received frame header</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="o">*</span><span class="nf">fc_find_ema</span><span class="p">(</span><span class="n">u32</span> <span class="n">f_ctl</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="o">*</span><span class="n">ema</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">xid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_EX_CTX</span><span class="p">)</span>
		<span class="n">xid</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">xid</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xid</span> <span class="o">==</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">ema_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
					  <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ema</span><span class="p">),</span> <span class="n">ema_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ema</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">ema_list</span><span class="p">,</span> <span class="n">ema_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">xid</span> <span class="o">&gt;=</span> <span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">min_xid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">xid</span> <span class="o">&lt;=</span> <span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">max_xid</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ema</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * fc_exch_recv() - Handler for received frames</span>
<span class="cm"> * @lport: The local port the frame was received on</span>
<span class="cm"> * @fp:	The received frame</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fc_exch_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="o">*</span><span class="n">ema</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">f_ctl</span><span class="p">;</span>

	<span class="cm">/* lport lock ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span> <span class="o">||</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">LPORT_ST_DISABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FC_LPORT_DBG</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="s">&quot;Receiving frames for an lport that &quot;</span>
			     <span class="s">&quot;has not been initialized correctly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">f_ctl</span> <span class="o">=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">);</span>
	<span class="n">ema</span> <span class="o">=</span> <span class="n">fc_find_ema</span><span class="p">(</span><span class="n">f_ctl</span><span class="p">,</span> <span class="n">lport</span><span class="p">,</span> <span class="n">fh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ema</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FC_LPORT_DBG</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="s">&quot;Unable to find Exchange Manager Anchor,&quot;</span>
				    <span class="s">&quot;fc_ctl &lt;0x%x&gt;, xid &lt;0x%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">f_ctl</span><span class="p">,</span>
				     <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_EX_CTX</span><span class="p">)</span> <span class="o">?</span>
				     <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span><span class="p">)</span> <span class="o">:</span>
				     <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span><span class="p">));</span>
		<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If frame is marked invalid, just drop it.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fr_eof</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FC_EOF_T</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_END_SEQ</span><span class="p">)</span>
			<span class="n">skb_trim</span><span class="p">(</span><span class="n">fp_skb</span><span class="p">(</span><span class="n">fp</span><span class="p">),</span> <span class="n">fr_len</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">-</span> <span class="n">FC_FC_FILL</span><span class="p">(</span><span class="n">f_ctl</span><span class="p">));</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">FC_EOF_N</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_type</span> <span class="o">==</span> <span class="n">FC_TYPE_BLS</span><span class="p">)</span>
			<span class="n">fc_exch_recv_bls</span><span class="p">(</span><span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FC_FC_EX_CTX</span> <span class="o">|</span> <span class="n">FC_FC_SEQ_CTX</span><span class="p">))</span> <span class="o">==</span>
			 <span class="n">FC_FC_EX_CTX</span><span class="p">)</span>
			<span class="n">fc_exch_recv_seq_resp</span><span class="p">(</span><span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">f_ctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_SEQ_CTX</span><span class="p">)</span>
			<span class="n">fc_exch_recv_resp</span><span class="p">(</span><span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="k">else</span>	<span class="cm">/* no EX_CTX and no SEQ_CTX */</span>
			<span class="n">fc_exch_recv_req</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">ema</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">FC_LPORT_DBG</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="s">&quot;dropping invalid frame (eof %x)&quot;</span><span class="p">,</span>
			     <span class="n">fr_eof</span><span class="p">(</span><span class="n">fp</span><span class="p">));</span>
		<span class="n">fc_frame_free</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_exch_recv</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_exch_init() - Initialize the exchange layer for a local port</span>
<span class="cm"> * @lport: The local port to initialize the exchange layer for</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fc_exch_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_start_next</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_start_next</span> <span class="o">=</span> <span class="n">fc_seq_start_next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_set_resp</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_set_resp</span> <span class="o">=</span> <span class="n">fc_seq_set_resp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_seq_send</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_seq_send</span> <span class="o">=</span> <span class="n">fc_exch_seq_send</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_send</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_send</span> <span class="o">=</span> <span class="n">fc_seq_send</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_els_rsp_send</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_els_rsp_send</span> <span class="o">=</span> <span class="n">fc_seq_els_rsp_send</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_done</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_done</span> <span class="o">=</span> <span class="n">fc_exch_done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_mgr_reset</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">exch_mgr_reset</span> <span class="o">=</span> <span class="n">fc_exch_mgr_reset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_exch_abort</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_exch_abort</span> <span class="o">=</span> <span class="n">fc_seq_exch_abort</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_assign</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_assign</span> <span class="o">=</span> <span class="n">fc_seq_assign</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_release</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">seq_release</span> <span class="o">=</span> <span class="n">fc_seq_release</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_exch_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_setup_exch_mgr() - Setup an exchange manager</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fc_setup_exch_mgr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fc_em_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;libfc_em&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch</span><span class="p">),</span>
					 <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fc_em_cachep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize fc_cpu_mask and fc_cpu_order. The</span>
<span class="cm">	 * fc_cpu_mask is set for nr_cpu_ids rounded up</span>
<span class="cm">	 * to order of 2&#39;s * power and order is stored</span>
<span class="cm">	 * in fc_cpu_order as this is later required in</span>
<span class="cm">	 * mapping between an exch id and exch array index</span>
<span class="cm">	 * in per cpu exch pool.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This round up is required to align fc_cpu_mask</span>
<span class="cm">	 * to exchange id&#39;s lower bits such that all incoming</span>
<span class="cm">	 * frames of an exchange gets delivered to the same</span>
<span class="cm">	 * cpu on which exchange originated by simple bitwise</span>
<span class="cm">	 * AND operation between fc_cpu_mask and exchange id.</span>
<span class="cm">	 */</span>
	<span class="n">fc_cpu_mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">fc_cpu_order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">fc_cpu_mask</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc_cpu_mask</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">fc_cpu_order</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fc_cpu_mask</span><span class="o">--</span><span class="p">;</span>

	<span class="n">fc_exch_workqueue</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;fc_exch_workqueue&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fc_exch_workqueue</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">fc_em_cachep</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_destroy_exch_mgr() - Destroy an exchange manager</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fc_destroy_exch_mgr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">fc_exch_workqueue</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">fc_em_cachep</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
