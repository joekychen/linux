<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › sun3_NCR5380.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sun3_NCR5380.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* sun3_NCR5380.c -- adapted from atari_NCR5380.c for the sun3 by </span>
<span class="cm">   Sam Creasey. */</span> 
<span class="cm">/* </span>
<span class="cm"> * NCR 5380 generic driver routines.  These should make it *trivial*</span>
<span class="cm"> * 	to implement 5380 SCSI drivers under Linux with a non-trantor</span>
<span class="cm"> *	architecture.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note that these routines also work with NR53c400 family chips.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1993, Drew Eckhardt</span>
<span class="cm"> *	Visionary Computing </span>
<span class="cm"> *	(Unix and Linux consulting and custom programming)</span>
<span class="cm"> * 	drew@colorado.edu</span>
<span class="cm"> *	+1 (303) 666-5836</span>
<span class="cm"> *</span>
<span class="cm"> * DISTRIBUTION RELEASE 6. </span>
<span class="cm"> *</span>
<span class="cm"> * For more information, please consult </span>
<span class="cm"> *</span>
<span class="cm"> * NCR 5380 Family</span>
<span class="cm"> * SCSI Protocol Controller</span>
<span class="cm"> * Databook</span>
<span class="cm"> *</span>
<span class="cm"> * NCR Microelectronics</span>
<span class="cm"> * 1635 Aeroplaza Drive</span>
<span class="cm"> * Colorado Springs, CO 80916</span>
<span class="cm"> * 1+ (719) 578-3400</span>
<span class="cm"> * 1+ (800) 334-5454</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * ++roman: To port the 5380 driver to the Atari, I had to do some changes in</span>
<span class="cm"> * this file, too:</span>
<span class="cm"> *</span>
<span class="cm"> *  - Some of the debug statements were incorrect (undefined variables and the</span>
<span class="cm"> *    like). I fixed that.</span>
<span class="cm"> *</span>
<span class="cm"> *  - In information_transfer(), I think a #ifdef was wrong. Looking at the</span>
<span class="cm"> *    possible DMA transfer size should also happen for REAL_DMA. I added this</span>
<span class="cm"> *    in the #if statement.</span>
<span class="cm"> *</span>
<span class="cm"> *  - When using real DMA, information_transfer() should return in a DATAOUT</span>
<span class="cm"> *    phase after starting the DMA. It has nothing more to do.</span>
<span class="cm"> *</span>
<span class="cm"> *  - The interrupt service routine should run main after end of DMA, too (not</span>
<span class="cm"> *    only after RESELECTION interrupts). Additionally, it should _not_ test</span>
<span class="cm"> *    for more interrupts after running main, since a DMA process may have</span>
<span class="cm"> *    been started and interrupts are turned on now. The new int could happen</span>
<span class="cm"> *    inside the execution of NCR5380_intr(), leading to recursive</span>
<span class="cm"> *    calls.</span>
<span class="cm"> *</span>
<span class="cm"> * - I&#39;ve deleted all the stuff for AUTOPROBE_IRQ, REAL_DMA_POLL, PSEUDO_DMA</span>
<span class="cm"> *    and USLEEP, because these were messing up readability and will never be</span>
<span class="cm"> *    needed for Atari SCSI.</span>
<span class="cm"> * </span>
<span class="cm"> * - I&#39;ve revised the NCR5380_main() calling scheme (relax the &#39;main_running&#39;</span>
<span class="cm"> *   stuff), and &#39;main&#39; is executed in a bottom half if awoken by an</span>
<span class="cm"> *   interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * - The code was quite cluttered up by &quot;#if (NDEBUG &amp; NDEBUG_*) printk...&quot;</span>
<span class="cm"> *   constructs. In my eyes, this made the source rather unreadable, so I</span>
<span class="cm"> *   finally replaced that by the *_PRINTK() macros.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;scsi/scsi_dbg.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_spi.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Further development / testing that should be done : </span>
<span class="cm"> * 1.  Test linked command handling code after Eric is ready with </span>
<span class="cm"> *     the high level code.</span>
<span class="cm"> */</span>

<span class="cp">#if (NDEBUG &amp; NDEBUG_LISTS)</span>
<span class="cp">#define LIST(x,y) \</span>
<span class="cp">  { printk(&quot;LINE:%d   Adding %p to %p\n&quot;, __LINE__, (void*)(x), (void*)(y)); \</span>
<span class="cp">    if ((x)==(y)) udelay(5); }</span>
<span class="cp">#define REMOVE(w,x,y,z) \</span>
<span class="cp">  { printk(&quot;LINE:%d   Removing: %p-&gt;%p  %p-&gt;%p \n&quot;, __LINE__, \</span>
<span class="cp">	   (void*)(w), (void*)(x), (void*)(y), (void*)(z)); \</span>
<span class="cp">    if ((x)==(y)) udelay(5); }</span>
<span class="cp">#else</span>
<span class="cp">#define LIST(x,y)</span>
<span class="cp">#define REMOVE(w,x,y,z)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef notyet</span>
<span class="cp">#undef LINKED</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Design</span>
<span class="cm"> * Issues :</span>
<span class="cm"> *</span>
<span class="cm"> * The other Linux SCSI drivers were written when Linux was Intel PC-only,</span>
<span class="cm"> * and specifically for each board rather than each chip.  This makes their</span>
<span class="cm"> * adaptation to platforms like the Mac (Some of which use NCR5380&#39;s)</span>
<span class="cm"> * more difficult than it has to be.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, many of the SCSI drivers were written before the command queuing</span>
<span class="cm"> * routines were implemented, meaning their implementations of queued </span>
<span class="cm"> * commands were hacked on rather than designed in from the start.</span>
<span class="cm"> *</span>
<span class="cm"> * When I designed the Linux SCSI drivers I figured that </span>
<span class="cm"> * while having two different SCSI boards in a system might be useful</span>
<span class="cm"> * for debugging things, two of the same type wouldn&#39;t be used.</span>
<span class="cm"> * Well, I was wrong and a number of users have mailed me about running</span>
<span class="cm"> * multiple high-performance SCSI boards in a server.</span>
<span class="cm"> *</span>
<span class="cm"> * Finally, when I get questions from users, I have no idea what </span>
<span class="cm"> * revision of my driver they are running.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver attempts to address these problems :</span>
<span class="cm"> * This is a generic 5380 driver.  To use it on a different platform, </span>
<span class="cm"> * one simply writes appropriate system specific macros (ie, data</span>
<span class="cm"> * transfer - some PC&#39;s will use the I/O bus, 68K&#39;s must use </span>
<span class="cm"> * memory mapped) and drops this file in their &#39;C&#39; wrapper.</span>
<span class="cm"> *</span>
<span class="cm"> * As far as command queueing, two queues are maintained for </span>
<span class="cm"> * each 5380 in the system - commands that haven&#39;t been issued yet,</span>
<span class="cm"> * and commands that are currently executing.  This means that an </span>
<span class="cm"> * unlimited number of commands may be queued, letting </span>
<span class="cm"> * more commands propagate from the higher driver levels giving higher </span>
<span class="cm"> * throughput.  Note that both I_T_L and I_T_L_Q nexuses are supported, </span>
<span class="cm"> * allowing multiple commands to propagate all the way to a SCSI-II device </span>
<span class="cm"> * while a command is already executing.</span>
<span class="cm"> *</span>
<span class="cm"> * To solve the multiple-boards-in-the-same-system problem, </span>
<span class="cm"> * there is a separate instance structure for each instance</span>
<span class="cm"> * of a 5380 in the system.  So, multiple NCR5380 drivers will</span>
<span class="cm"> * be able to coexist with appropriate changes to the high level</span>
<span class="cm"> * SCSI code.  </span>
<span class="cm"> *</span>
<span class="cm"> * A NCR5380_PUBLIC_REVISION macro is provided, with the release</span>
<span class="cm"> * number (updated for each public release) printed by the </span>
<span class="cm"> * NCR5380_print_options command, which should be called from the </span>
<span class="cm"> * wrapper detect function, so that I know what release of the driver</span>
<span class="cm"> * users are using.</span>
<span class="cm"> *</span>
<span class="cm"> * Issues specific to the NCR5380 : </span>
<span class="cm"> *</span>
<span class="cm"> * When used in a PIO or pseudo-dma mode, the NCR5380 is a braindead </span>
<span class="cm"> * piece of hardware that requires you to sit in a loop polling for </span>
<span class="cm"> * the REQ signal as long as you are connected.  Some devices are </span>
<span class="cm"> * brain dead (ie, many TEXEL CD ROM drives) and won&#39;t disconnect </span>
<span class="cm"> * while doing long seek operations.</span>
<span class="cm"> * </span>
<span class="cm"> * The workaround for this is to keep track of devices that have</span>
<span class="cm"> * disconnected.  If the device hasn&#39;t disconnected, for commands that</span>
<span class="cm"> * should disconnect, we do something like </span>
<span class="cm"> *</span>
<span class="cm"> * while (!REQ is asserted) { sleep for N usecs; poll for M usecs }</span>
<span class="cm"> * </span>
<span class="cm"> * Some tweaking of N and M needs to be done.  An algorithm based </span>
<span class="cm"> * on &quot;time to data&quot; would give the best results as long as short time</span>
<span class="cm"> * to datas (ie, on the same track) were considered, however these </span>
<span class="cm"> * broken devices are the exception rather than the rule and I&#39;d rather</span>
<span class="cm"> * spend my time optimizing for the normal case.</span>
<span class="cm"> *</span>
<span class="cm"> * Architecture :</span>
<span class="cm"> *</span>
<span class="cm"> * At the heart of the design is a coroutine, NCR5380_main,</span>
<span class="cm"> * which is started when not running by the interrupt handler,</span>
<span class="cm"> * timer, and queue command function.  It attempts to establish</span>
<span class="cm"> * I_T_L or I_T_L_Q nexuses by removing the commands from the </span>
<span class="cm"> * issue queue and calling NCR5380_select() if a nexus </span>
<span class="cm"> * is not established. </span>
<span class="cm"> *</span>
<span class="cm"> * Once a nexus is established, the NCR5380_information_transfer()</span>
<span class="cm"> * phase goes through the various phases as instructed by the target.</span>
<span class="cm"> * if the target goes into MSG IN and sends a DISCONNECT message,</span>
<span class="cm"> * the command structure is placed into the per instance disconnected</span>
<span class="cm"> * queue, and NCR5380_main tries to find more work.  If USLEEP</span>
<span class="cm"> * was defined, and the target is idle for too long, the system</span>
<span class="cm"> * will try to sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * If a command has disconnected, eventually an interrupt will trigger,</span>
<span class="cm"> * calling NCR5380_intr()  which will in turn call NCR5380_reselect</span>
<span class="cm"> * to reestablish a nexus.  This will run main if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * On command termination, the done function will be called as </span>
<span class="cm"> * appropriate.</span>
<span class="cm"> *</span>
<span class="cm"> * SCSI pointers are maintained in the SCp field of SCSI command </span>
<span class="cm"> * structures, being initialized after the command is connected</span>
<span class="cm"> * in NCR5380_select, and set as appropriate in NCR5380_information_transfer.</span>
<span class="cm"> * Note that in violation of the standard, an implicit SAVE POINTERS operation</span>
<span class="cm"> * is done, since some BROKEN disks fail to issue an explicit SAVE POINTERS.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Using this file :</span>
<span class="cm"> * This file a skeleton Linux SCSI driver for the NCR 5380 series</span>
<span class="cm"> * of chips.  To use it, you write an architecture specific functions </span>
<span class="cm"> * and macros and include this file in your driver.</span>
<span class="cm"> *</span>
<span class="cm"> * These macros control options : </span>
<span class="cm"> * AUTOSENSE - if defined, REQUEST SENSE will be performed automatically</span>
<span class="cm"> *	for commands that return with a CHECK CONDITION status. </span>
<span class="cm"> *</span>
<span class="cm"> * LINKED - if defined, linked commands are supported.</span>
<span class="cm"> *</span>
<span class="cm"> * REAL_DMA - if defined, REAL DMA is used during the data transfer phases.</span>
<span class="cm"> *</span>
<span class="cm"> * SUPPORT_TAGS - if defined, SCSI-2 tagged queuing is used where possible</span>
<span class="cm"> *</span>
<span class="cm"> * These macros MUST be defined :</span>
<span class="cm"> * </span>
<span class="cm"> * NCR5380_read(register)  - read from the specified register</span>
<span class="cm"> *</span>
<span class="cm"> * NCR5380_write(register, value) - write to the specific register </span>
<span class="cm"> *</span>
<span class="cm"> * Either real DMA *or* pseudo DMA may be implemented</span>
<span class="cm"> * REAL functions : </span>
<span class="cm"> * NCR5380_REAL_DMA should be defined if real DMA is to be used.</span>
<span class="cm"> * Note that the DMA setup functions should return the number of bytes </span>
<span class="cm"> *	that they were able to program the controller for.</span>
<span class="cm"> *</span>
<span class="cm"> * Also note that generic i386/PC versions of these macros are </span>
<span class="cm"> *	available as NCR5380_i386_dma_write_setup,</span>
<span class="cm"> *	NCR5380_i386_dma_read_setup, and NCR5380_i386_dma_residual.</span>
<span class="cm"> *</span>
<span class="cm"> * NCR5380_dma_write_setup(instance, src, count) - initialize</span>
<span class="cm"> * NCR5380_dma_read_setup(instance, dst, count) - initialize</span>
<span class="cm"> * NCR5380_dma_residual(instance); - residual count</span>
<span class="cm"> *</span>
<span class="cm"> * PSEUDO functions :</span>
<span class="cm"> * NCR5380_pwrite(instance, src, count)</span>
<span class="cm"> * NCR5380_pread(instance, dst, count);</span>
<span class="cm"> *</span>
<span class="cm"> * If nothing specific to this implementation needs doing (ie, with external</span>
<span class="cm"> * hardware), you must also define </span>
<span class="cm"> *  </span>
<span class="cm"> * NCR5380_queue_command</span>
<span class="cm"> * NCR5380_reset</span>
<span class="cm"> * NCR5380_abort</span>
<span class="cm"> * NCR5380_proc_info</span>
<span class="cm"> *</span>
<span class="cm"> * to be the global entry points into the specific driver, ie </span>
<span class="cm"> * #define NCR5380_queue_command t128_queue_command.</span>
<span class="cm"> *</span>
<span class="cm"> * If this is not done, the routines will be defined as static functions</span>
<span class="cm"> * with the NCR5380* names and the user must provide a globally</span>
<span class="cm"> * accessible wrapper function.</span>
<span class="cm"> *</span>
<span class="cm"> * The generic driver is initialized by calling NCR5380_init(instance),</span>
<span class="cm"> * after setting the appropriate host specific fields and ID.  If the </span>
<span class="cm"> * driver wishes to autoprobe for an IRQ line, the NCR5380_probe_irq(instance,</span>
<span class="cm"> * possible) function may be used.  Before the specific driver initialization</span>
<span class="cm"> * code finishes, NCR5380_print_options should be called.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">first_instance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">the_template</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/* Macros ease life... :-) */</span>
<span class="cp">#define	SETUP_HOSTDATA(in)				\</span>
<span class="cp">    struct NCR5380_hostdata *hostdata =			\</span>
<span class="cp">	(struct NCR5380_hostdata *)(in)-&gt;hostdata</span>
<span class="cp">#define	HOSTDATA(in) ((struct NCR5380_hostdata *)(in)-&gt;hostdata)</span>

<span class="cp">#define	NEXT(cmd)		((struct scsi_cmnd *)(cmd)-&gt;host_scribble)</span>
<span class="cp">#define	SET_NEXT(cmd, next)	((cmd)-&gt;host_scribble = (void *)(next))</span>
<span class="cp">#define	NEXTADDR(cmd)		((struct scsi_cmnd **)&amp;((cmd)-&gt;host_scribble))</span>

<span class="cp">#define	HOSTNO		instance-&gt;host_no</span>
<span class="cp">#define	H_NO(cmd)	(cmd)-&gt;device-&gt;host-&gt;host_no</span>

<span class="cp">#define SGADDR(buffer) (void *)(((unsigned long)sg_virt(((buffer)))))</span>

<span class="cp">#ifdef SUPPORT_TAGS</span>

<span class="cm">/*</span>
<span class="cm"> * Functions for handling tagged queuing</span>
<span class="cm"> * =====================================</span>
<span class="cm"> *</span>
<span class="cm"> * ++roman (01/96): Now I&#39;ve implemented SCSI-2 tagged queuing. Some notes:</span>
<span class="cm"> *</span>
<span class="cm"> * Using consecutive numbers for the tags is no good idea in my eyes. There</span>
<span class="cm"> * could be wrong re-usings if the counter (8 bit!) wraps and some early</span>
<span class="cm"> * command has been preempted for a long time. My solution: a bitfield for</span>
<span class="cm"> * remembering used tags.</span>
<span class="cm"> *</span>
<span class="cm"> * There&#39;s also the problem that each target has a certain queue size, but we</span>
<span class="cm"> * cannot know it in advance :-( We just see a QUEUE_FULL status being</span>
<span class="cm"> * returned. So, in this case, the driver internal queue size assumption is</span>
<span class="cm"> * reduced to the number of active tags if QUEUE_FULL is returned by the</span>
<span class="cm"> * target. The command is returned to the mid-level, but with status changed</span>
<span class="cm"> * to BUSY, since --as I&#39;ve seen-- the mid-level can&#39;t handle QUEUE_FULL</span>
<span class="cm"> * correctly.</span>
<span class="cm"> *</span>
<span class="cm"> * We&#39;re also not allowed running tagged commands as long as an untagged</span>
<span class="cm"> * command is active. And REQUEST SENSE commands after a contingent allegiance</span>
<span class="cm"> * condition _must_ be untagged. To keep track whether an untagged command has</span>
<span class="cm"> * been issued, the host-&gt;busy array is still employed, as it is without</span>
<span class="cm"> * support for tagged queuing.</span>
<span class="cm"> *</span>
<span class="cm"> * One could suspect that there are possible race conditions between</span>
<span class="cm"> * is_lun_busy(), cmd_get_tag() and cmd_free_tag(). But I think this isn&#39;t the</span>
<span class="cm"> * case: is_lun_busy() and cmd_get_tag() are both called from NCR5380_main(),</span>
<span class="cm"> * which already guaranteed to be running at most once. It is also the only</span>
<span class="cm"> * place where tags/LUNs are allocated. So no other allocation can slip</span>
<span class="cm"> * between that pair, there could only happen a reselection, which can free a</span>
<span class="cm"> * tag, but that doesn&#39;t hurt. Only the sequence in cmd_free_tag() becomes</span>
<span class="cm"> * important: the tag bit must be cleared before &#39;nr_allocated&#39; is decreased.</span>
<span class="cm"> */</span>

<span class="cm">/* -1 for TAG_NONE is not possible with unsigned char cmd-&gt;tag */</span>
<span class="cp">#undef TAG_NONE</span>
<span class="cp">#define TAG_NONE 0xff</span>

<span class="cm">/* For the m68k, the number of bits in &#39;allocated&#39; must be a multiple of 32! */</span>
<span class="cp">#if (MAX_TAGS % 32) != 0</span>
<span class="cp">#error &quot;MAX_TAGS must be a multiple of 32!&quot;</span>
<span class="cp">#endif</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">char</span>	<span class="n">allocated</span><span class="p">[</span><span class="n">MAX_TAGS</span><span class="o">/</span><span class="mi">8</span><span class="p">];</span>
    <span class="kt">int</span>		<span class="n">nr_allocated</span><span class="p">;</span>
    <span class="kt">int</span>		<span class="n">queue_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">TAG_ALLOC</span><span class="p">;</span>

<span class="k">static</span> <span class="n">TAG_ALLOC</span> <span class="n">TagAlloc</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* 8 targets and 8 LUNs */</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_tags</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">lun</span><span class="p">;</span>
    <span class="n">TAG_ALLOC</span> <span class="o">*</span><span class="n">ta</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">setup_use_tagged_queuing</span><span class="p">)</span>
	<span class="k">return</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">target</span> <span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span><span class="p">(</span> <span class="n">lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lun</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">lun</span> <span class="p">)</span> <span class="p">{</span>
	    <span class="n">ta</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">TagAlloc</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">lun</span><span class="p">];</span>
	    <span class="n">memset</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAX_TAGS</span><span class="o">/</span><span class="mi">8</span> <span class="p">);</span>
	    <span class="n">ta</span><span class="o">-&gt;</span><span class="n">nr_allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	    <span class="cm">/* At the beginning, assume the maximum queue size we could</span>
<span class="cm">	     * support (MAX_TAGS). This value will be decreased if the target</span>
<span class="cm">	     * returns QUEUE_FULL status.</span>
<span class="cm">	     */</span>
	    <span class="n">ta</span><span class="o">-&gt;</span><span class="n">queue_size</span> <span class="o">=</span> <span class="n">MAX_TAGS</span><span class="p">;</span>
	<span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* Check if we can issue a command to this LUN: First see if the LUN is marked</span>
<span class="cm"> * busy by an untagged command. If the command should use tagged queuing, also</span>
<span class="cm"> * check that there is a free tag and the target&#39;s queue won&#39;t overflow. This</span>
<span class="cm"> * function should be called with interrupts disabled to avoid race</span>
<span class="cm"> * conditions.</span>
<span class="cm"> */</span> 

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_lun_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">should_be_tagged</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SETUP_HOSTDATA</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">))</span>
	<span class="k">return</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">should_be_tagged</span> <span class="o">||</span>
	<span class="o">!</span><span class="n">setup_use_tagged_queuing</span> <span class="o">||</span> <span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">tagged_supported</span><span class="p">)</span>
	<span class="k">return</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TagAlloc</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">][</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">].</span><span class="n">nr_allocated</span> <span class="o">&gt;=</span>
	<span class="n">TagAlloc</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">][</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">].</span><span class="n">queue_size</span> <span class="p">)</span> <span class="p">{</span>
	<span class="n">TAG_PRINTK</span><span class="p">(</span> <span class="s">&quot;scsi%d: target %d lun %d: no free tags</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">H_NO</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="p">);</span>
	<span class="k">return</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Allocate a tag for a command (there are no checks anymore, check_lun_busy()</span>
<span class="cm"> * must be called before!), or reserve the LUN in &#39;busy&#39; if the command is</span>
<span class="cm"> * untagged.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cmd_get_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">should_be_tagged</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SETUP_HOSTDATA</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

    <span class="cm">/* If we or the target don&#39;t support tagged queuing, allocate the LUN for</span>
<span class="cm">     * an untagged command.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">should_be_tagged</span> <span class="o">||</span>
	<span class="o">!</span><span class="n">setup_use_tagged_queuing</span> <span class="o">||</span> <span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">tagged_supported</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">TAG_NONE</span><span class="p">;</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="n">TAG_PRINTK</span><span class="p">(</span> <span class="s">&quot;scsi%d: target %d lun %d now allocated by untagged &quot;</span>
		    <span class="s">&quot;command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">H_NO</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
	<span class="n">TAG_ALLOC</span> <span class="o">*</span><span class="n">ta</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">TagAlloc</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">][</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">];</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">,</span> <span class="n">MAX_TAGS</span> <span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">allocated</span> <span class="p">);</span>
	<span class="n">ta</span><span class="o">-&gt;</span><span class="n">nr_allocated</span><span class="o">++</span><span class="p">;</span>
	<span class="n">TAG_PRINTK</span><span class="p">(</span> <span class="s">&quot;scsi%d: using tag %d for target %d lun %d &quot;</span>
		    <span class="s">&quot;(now %d tags in use)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">H_NO</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span>
		    <span class="n">ta</span><span class="o">-&gt;</span><span class="n">nr_allocated</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* Mark the tag of command &#39;cmd&#39; as free, or in case of an untagged command,</span>
<span class="cm"> * unlock the LUN.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cmd_free_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SETUP_HOSTDATA</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TAG_NONE</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="n">TAG_PRINTK</span><span class="p">(</span> <span class="s">&quot;scsi%d: target %d lun %d untagged cmd finished</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">H_NO</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">&gt;=</span> <span class="n">MAX_TAGS</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;scsi%d: trying to free bad tag %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">H_NO</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
	<span class="n">TAG_ALLOC</span> <span class="o">*</span><span class="n">ta</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">TagAlloc</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">][</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">];</span>
	<span class="n">clear_bit</span><span class="p">(</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">allocated</span> <span class="p">);</span>
	<span class="n">ta</span><span class="o">-&gt;</span><span class="n">nr_allocated</span><span class="o">--</span><span class="p">;</span>
	<span class="n">TAG_PRINTK</span><span class="p">(</span> <span class="s">&quot;scsi%d: freed tag %d for target %d lun %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">H_NO</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_all_tags</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">lun</span><span class="p">;</span>
    <span class="n">TAG_ALLOC</span> <span class="o">*</span><span class="n">ta</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">setup_use_tagged_queuing</span><span class="p">)</span>
	<span class="k">return</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">target</span> <span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span><span class="p">(</span> <span class="n">lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lun</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">lun</span> <span class="p">)</span> <span class="p">{</span>
	    <span class="n">ta</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">TagAlloc</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">lun</span><span class="p">];</span>
	    <span class="n">memset</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAX_TAGS</span><span class="o">/</span><span class="mi">8</span> <span class="p">);</span>
	    <span class="n">ta</span><span class="o">-&gt;</span><span class="n">nr_allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* SUPPORT_TAGS */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * Function : void initialize_SCp(struct scsi_cmnd *cmd)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : initialize the saved data pointers for cmd to point to the </span>
<span class="cm"> *	start of the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : cmd - struct scsi_cmnd structure to have pointers reset.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">initialize_SCp</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* </span>
<span class="cm">     * Initialize the Scsi Pointer field so that all of the commands in the </span>
<span class="cm">     * various queues are valid.</span>
<span class="cm">     */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span> <span class="o">=</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">SGADDR</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">}</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>

<span class="cp">#if 1</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span><span class="p">;}</span> 
<span class="n">signals</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{{</span> <span class="n">SR_DBP</span><span class="p">,</span> <span class="s">&quot;PARITY&quot;</span><span class="p">},</span> <span class="p">{</span> <span class="n">SR_RST</span><span class="p">,</span> <span class="s">&quot;RST&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="n">SR_BSY</span><span class="p">,</span> <span class="s">&quot;BSY&quot;</span> <span class="p">},</span> 
    <span class="p">{</span> <span class="n">SR_REQ</span><span class="p">,</span> <span class="s">&quot;REQ&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="n">SR_MSG</span><span class="p">,</span> <span class="s">&quot;MSG&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="n">SR_CD</span><span class="p">,</span>  <span class="s">&quot;CD&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="n">SR_IO</span><span class="p">,</span> <span class="s">&quot;IO&quot;</span> <span class="p">},</span> 
    <span class="p">{</span> <span class="n">SR_SEL</span><span class="p">,</span> <span class="s">&quot;SEL&quot;</span> <span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}},</span> 
<span class="n">basrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{{</span><span class="n">BASR_ATN</span><span class="p">,</span> <span class="s">&quot;ATN&quot;</span><span class="p">},</span> <span class="p">{</span><span class="n">BASR_ACK</span><span class="p">,</span> <span class="s">&quot;ACK&quot;</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}},</span>
<span class="n">icrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{{</span><span class="n">ICR_ASSERT_RST</span><span class="p">,</span> <span class="s">&quot;ASSERT RST&quot;</span><span class="p">},{</span><span class="n">ICR_ASSERT_ACK</span><span class="p">,</span> <span class="s">&quot;ASSERT ACK&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="n">ICR_ASSERT_BSY</span><span class="p">,</span> <span class="s">&quot;ASSERT BSY&quot;</span><span class="p">},</span> <span class="p">{</span><span class="n">ICR_ASSERT_SEL</span><span class="p">,</span> <span class="s">&quot;ASSERT SEL&quot;</span><span class="p">},</span> 
    <span class="p">{</span><span class="n">ICR_ASSERT_ATN</span><span class="p">,</span> <span class="s">&quot;ASSERT ATN&quot;</span><span class="p">},</span> <span class="p">{</span><span class="n">ICR_ASSERT_DATA</span><span class="p">,</span> <span class="s">&quot;ASSERT DATA&quot;</span><span class="p">},</span> 
    <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}},</span>
<span class="n">mrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{{</span><span class="n">MR_BLOCK_DMA_MODE</span><span class="p">,</span> <span class="s">&quot;MODE BLOCK DMA&quot;</span><span class="p">},</span> <span class="p">{</span><span class="n">MR_TARGET</span><span class="p">,</span> <span class="s">&quot;MODE TARGET&quot;</span><span class="p">},</span> 
    <span class="p">{</span><span class="n">MR_ENABLE_PAR_CHECK</span><span class="p">,</span> <span class="s">&quot;MODE PARITY CHECK&quot;</span><span class="p">},</span> <span class="p">{</span><span class="n">MR_ENABLE_PAR_INTR</span><span class="p">,</span> 
    <span class="s">&quot;MODE PARITY INTR&quot;</span><span class="p">},</span> <span class="p">{</span><span class="n">MR_ENABLE_EOP_INTR</span><span class="p">,</span><span class="s">&quot;MODE EOP INTR&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="n">MR_MONITOR_BSY</span><span class="p">,</span> <span class="s">&quot;MODE MONITOR BSY&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="n">MR_DMA_MODE</span><span class="p">,</span> <span class="s">&quot;MODE DMA&quot;</span><span class="p">},</span> <span class="p">{</span><span class="n">MR_ARBITRATE</span><span class="p">,</span> <span class="s">&quot;MODE ARBITRATION&quot;</span><span class="p">},</span> 
    <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}};</span>

<span class="cm">/*</span>
<span class="cm"> * Function : void NCR5380_print(struct Scsi_Host *instance)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : print the SCSI bus signals for debugging purposes</span>
<span class="cm"> *</span>
<span class="cm"> * Input : instance - which NCR5380</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">NCR5380_print</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">basr</span><span class="p">,</span> <span class="n">mr</span><span class="p">,</span> <span class="n">icr</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

    <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">CURRENT_SCSI_DATA_REG</span><span class="p">);</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">);</span>
    <span class="n">mr</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">);</span>
    <span class="n">icr</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">);</span>
    <span class="n">basr</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">);</span>
    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;STATUS_REG: %02x &quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">signals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">signals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">)</span>
	    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;,%s&quot;</span><span class="p">,</span> <span class="n">signals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">BASR: %02x &quot;</span><span class="p">,</span> <span class="n">basr</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">basrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
	<span class="k">if</span> <span class="p">(</span><span class="n">basr</span> <span class="o">&amp;</span> <span class="n">basrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">)</span>
	    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;,%s&quot;</span><span class="p">,</span> <span class="n">basrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">ICR: %02x &quot;</span><span class="p">,</span> <span class="n">icr</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">icrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">icrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">)</span>
	    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;,%s&quot;</span><span class="p">,</span> <span class="n">icrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">MODE: %02x &quot;</span><span class="p">,</span> <span class="n">mr</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
	<span class="k">if</span> <span class="p">(</span><span class="n">mr</span> <span class="o">&amp;</span> <span class="n">mrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">)</span>
	    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;,%s&quot;</span><span class="p">,</span> <span class="n">mrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">phases</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="n">PHASE_DATAOUT</span><span class="p">,</span> <span class="s">&quot;DATAOUT&quot;</span><span class="p">},</span> <span class="p">{</span><span class="n">PHASE_DATAIN</span><span class="p">,</span> <span class="s">&quot;DATAIN&quot;</span><span class="p">},</span> <span class="p">{</span><span class="n">PHASE_CMDOUT</span><span class="p">,</span> <span class="s">&quot;CMDOUT&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="n">PHASE_STATIN</span><span class="p">,</span> <span class="s">&quot;STATIN&quot;</span><span class="p">},</span> <span class="p">{</span><span class="n">PHASE_MSGOUT</span><span class="p">,</span> <span class="s">&quot;MSGOUT&quot;</span><span class="p">},</span> <span class="p">{</span><span class="n">PHASE_MSGIN</span><span class="p">,</span> <span class="s">&quot;MSGIN&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="n">PHASE_UNKNOWN</span><span class="p">,</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">}};</span>

<span class="cm">/* </span>
<span class="cm"> * Function : void NCR5380_print_phase(struct Scsi_Host *instance)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : print the current SCSI phase for debugging purposes</span>
<span class="cm"> *</span>
<span class="cm"> * Input : instance - which NCR5380</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">NCR5380_print_phase</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">))</span> 
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;scsi%d: REQ not asserted, phase unknown.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
    <span class="k">else</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span> <span class="o">!=</span> <span class="n">PHASE_UNKNOWN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
	    <span class="p">(</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span> <span class="o">!=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">));</span> <span class="o">++</span><span class="n">i</span><span class="p">);</span> 
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;scsi%d: phase %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !NDEBUG */</span><span class="cp"></span>

<span class="cm">/* dummies... */</span>
<span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">NCR5380_print</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span> <span class="p">{</span> <span class="p">};</span>
<span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">NCR5380_print_phase</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span> <span class="p">{</span> <span class="p">};</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * ++roman: New scheme of calling NCR5380_main()</span>
<span class="cm"> * </span>
<span class="cm"> * If we&#39;re not in an interrupt, we can call our main directly, it cannot be</span>
<span class="cm"> * already running. Else, we queue it on a task queue, if not &#39;main_running&#39;</span>
<span class="cm"> * tells us that a lower level is already executing it. This way,</span>
<span class="cm"> * &#39;main_running&#39; needs not be protected in a special way.</span>
<span class="cm"> *</span>
<span class="cm"> * queue_main() is a utility function for putting our main onto the task</span>
<span class="cm"> * queue, if main_running is false. It should be called only from a</span>
<span class="cm"> * interrupt or bottom half.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>

<span class="k">static</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">main_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">NCR5380_tqueue</span><span class="p">,</span> <span class="n">NCR5380_main</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">queue_main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">main_running</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* If in interrupt and NCR5380_main() not already running,</span>
<span class="cm">	   queue it on the &#39;immediate&#39; task queue, to be processed</span>
<span class="cm">	   immediately after the current interrupt processing has</span>
<span class="cm">	   finished. */</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NCR5380_tqueue</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* else: nothing to do: the running NCR5380_main() will pick up</span>
<span class="cm">       any newly queued command. */</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">NCR5380_all_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">INI_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi : NCR5380_all_init()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

 
<span class="cm">/*</span>
<span class="cm"> * Function : void NCR58380_print_options (struct Scsi_Host *instance)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : called by probe code indicating the NCR5380 driver</span>
<span class="cm"> *	     options that were selected.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : instance, pointer to this instance.  Unused.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">NCR5380_print_options</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="s">&quot; generic options&quot;</span>
<span class="cp">#ifdef AUTOSENSE </span>
    <span class="s">&quot; AUTOSENSE&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef REAL_DMA</span>
    <span class="s">&quot; REAL DMA&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PARITY</span>
    <span class="s">&quot; PARITY&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
    <span class="s">&quot; SCSI-2 TAGGED QUEUING&quot;</span>
<span class="cp">#endif</span>
    <span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="s">&quot; generic release=%d&quot;</span><span class="p">,</span> <span class="n">NCR5380_PUBLIC_RELEASE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function : void NCR5380_print_status (struct Scsi_Host *instance)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : print commands in the various queues, called from</span>
<span class="cm"> *	NCR5380_abort and NCR5380_debug to aid debugging.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : instance, pointer to this instance.  </span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">NCR5380_print_status</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">pr_bfr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

    <span class="n">NCR_PRINT</span><span class="p">(</span><span class="n">NDEBUG_ANY</span><span class="p">);</span>
    <span class="n">NCR_PRINT_PHASE</span><span class="p">(</span><span class="n">NDEBUG_ANY</span><span class="p">);</span>

    <span class="n">pr_bfr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr_bfr</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;NCR5380_print_status: no memory for print buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">len</span> <span class="o">=</span> <span class="n">NCR5380_proc_info</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">pr_bfr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">pr_bfr</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pr_bfr</span><span class="p">);</span>
    <span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pr_bfr</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/******************************************/</span>
<span class="cm">/*</span>
<span class="cm"> * /proc/scsi/[dtc pas16 t128 generic]/[0-ASC_NUM_BOARD_SUPPORTED]</span>
<span class="cm"> *</span>
<span class="cm"> * *buffer: I/O buffer</span>
<span class="cm"> * **start: if inout == FALSE pointer into buffer where user read should start</span>
<span class="cm"> * offset: current offset</span>
<span class="cm"> * length: length of buffer</span>
<span class="cm"> * hostno: Scsi_Host host_no</span>
<span class="cm"> * inout: TRUE - user is writing; FALSE - user is reading</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of bytes read from or written</span>
<span class="cm">*/</span>

<span class="cp">#undef SPRINTF</span>
<span class="cp">#define SPRINTF(fmt,args...) \</span>
<span class="cp">  do { if (pos + strlen(fmt) + 20 </span><span class="cm">/* slop */</span><span class="cp"> &lt; buffer + length) \</span>
<span class="cp">	 pos += sprintf(pos, fmt , ## args); } while(0)</span>
<span class="k">static</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">lprint_Scsi_Cmnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">NCR5380_proc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">off_t</span> <span class="n">begin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#define check_offset()				\</span>
<span class="cp">    do {					\</span>
<span class="cp">	if (pos - buffer &lt; offset - begin) {	\</span>
<span class="cp">	    begin += pos - buffer;		\</span>
<span class="cp">	    pos = buffer;			\</span>
<span class="cp">	}					\</span>
<span class="cp">    } while (0)</span>

    <span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="p">)</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Has data been written to the file ? */</span>
	<span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="n">ENOSYS</span><span class="p">);</span>  <span class="cm">/* Currently this is a no-op */</span>
    <span class="p">}</span>
    <span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;NCR5380 core release=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">NCR5380_PUBLIC_RELEASE</span><span class="p">);</span>
    <span class="n">check_offset</span><span class="p">();</span>
    <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    <span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;NCR5380: coroutine is%s running.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">main_running</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;n&#39;t&quot;</span><span class="p">);</span>
    <span class="n">check_offset</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;scsi%d: no currently connected command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
    <span class="k">else</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">lprint_Scsi_Cmnd</span> <span class="p">((</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">,</span>
				<span class="n">pos</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
    <span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;scsi%d: issue_queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
    <span class="n">check_offset</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">;</span> <span class="n">ptr</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
    <span class="p">{</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">lprint_Scsi_Cmnd</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">check_offset</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;scsi%d: disconnected_queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
    <span class="n">check_offset</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">;</span> <span class="n">ptr</span><span class="p">;</span>
	 <span class="n">ptr</span> <span class="o">=</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">lprint_Scsi_Cmnd</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">check_offset</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="n">begin</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span> <span class="o">-</span> <span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span> <span class="o">-</span> <span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="n">begin</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">lprint_Scsi_Cmnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span><span class="p">;</span>
    <span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;scsi%d: destination target %d, lun %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">H_NO</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
    <span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;        command = &quot;</span><span class="p">);</span>
    <span class="n">command</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">;</span>
    <span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;%2d (0x%02x)&quot;</span><span class="p">,</span> <span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">COMMAND_SIZE</span><span class="p">(</span><span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot; %02x&quot;</span><span class="p">,</span> <span class="n">command</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* </span>
<span class="cm"> * Function : void NCR5380_init (struct Scsi_Host *instance)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : initializes *instance and corresponding 5380 chip.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : instance - instantiation of the 5380 driver.  </span>
<span class="cm"> *</span>
<span class="cm"> * Notes : I assume that the host, hostno, and id bits have been</span>
<span class="cm"> * 	set correctly.  I don&#39;t care about the irq and other fields. </span>
<span class="cm"> * </span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">NCR5380_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">SETUP_HOSTDATA</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

    <span class="n">NCR5380_all_init</span><span class="p">();</span>

    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">aborted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">this_id</span><span class="p">;</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_higher_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">)</span>
	    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_higher_mask</span> <span class="o">|=</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
    <span class="n">init_tags</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="cp">#if defined (REAL_DMA)</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">dma_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">targets_present</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">FLAG_CHECK_LAST_BYTE_SENT</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">the_template</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">the_template</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="p">;</span>
	<span class="n">first_instance</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
    <span class="p">}</span>
	

<span class="cp">#ifndef AUTOSENSE</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>
	 <span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d: WARNING : support for multiple outstanding commands enabled</span><span class="se">\n</span><span class="s">&quot;</span>
	        <span class="s">&quot;        without AUTOSENSE option, contingent allegiance conditions may</span><span class="se">\n</span><span class="s">&quot;</span>
	        <span class="s">&quot;        be incorrectly cleared.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* def AUTOSENSE */</span><span class="cp"></span>

    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">NCR5380_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Empty, as we didn&#39;t schedule any delayed work */</span>
<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> * Function : int NCR5380_queue_command (struct scsi_cmnd *cmd,</span>
<span class="cm"> *	void (*done)(struct scsi_cmnd *))</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose :  enqueues a SCSI command</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : cmd - SCSI command, done - function called on completion, with</span>
<span class="cm"> *	a pointer to the command descriptor.</span>
<span class="cm"> * </span>
<span class="cm"> * Returns : 0</span>
<span class="cm"> *</span>
<span class="cm"> * Side effects : </span>
<span class="cm"> *      cmd is added to the per instance issue_queue, with minor </span>
<span class="cm"> *	twiddling done to the host specific fields of cmd.  If the </span>
<span class="cm"> *	main coroutine is not running, it is restarted.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/* Only make static if a wrapper function is used */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">NCR5380_queue_command_lck</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">SETUP_HOSTDATA</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

<span class="cp">#if (NDEBUG &amp; NDEBUG_NO_WRITE)</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">WRITE_6</span>:
    <span class="k">case</span> <span class="n">WRITE_10</span>:
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;scsi%d: WRITE attempted with NO_WRITE debugging flag set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">H_NO</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* (NDEBUG &amp; NDEBUG_NO_WRITE) */</span><span class="cp"></span>


<span class="cp">#ifdef NCR5380_STATS</span>
<span class="cp"># if 0</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span> <span class="o">&amp;&amp;</span>
	<span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">timebase</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp"># endif</span>
<span class="cp"># ifdef NCR5380_STAT_LIMIT</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">NCR5380_STAT_LIMIT</span><span class="p">)</span>
<span class="cp"># endif</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">{</span>
	    <span class="k">case</span> <span class="n">WRITE</span>:
	    <span class="k">case</span> <span class="n">WRITE_6</span>:
	    <span class="k">case</span> <span class="n">WRITE_10</span>:
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_write</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">timebase</span><span class="p">);</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">bytes_write</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">pendingw</span><span class="o">++</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	    <span class="k">case</span> <span class="n">READ</span>:
	    <span class="k">case</span> <span class="n">READ_6</span>:
	    <span class="k">case</span> <span class="n">READ_10</span>:
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_read</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">timebase</span><span class="p">);</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">bytes_read</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">pendingr</span><span class="o">++</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

    <span class="cm">/* </span>
<span class="cm">     * We use the host_scribble field as a pointer to the next command  </span>
<span class="cm">     * in a queue </span>
<span class="cm">     */</span>

    <span class="n">SET_NEXT</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>

    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


    <span class="cm">/* </span>
<span class="cm">     * Insert the cmd into the issue queue. Note that REQUEST SENSE </span>
<span class="cm">     * commands are added to the head of the queue since any command will</span>
<span class="cm">     * clear the contingent allegiance condition that exists and the </span>
<span class="cm">     * sense data is only guaranteed to be valid while the condition exists.</span>
<span class="cm">     */</span>

    <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    <span class="cm">/* ++guenther: now that the issue queue is being set up, we can lock ST-DMA.</span>
<span class="cm">     * Otherwise a running NCR5380_main may steal the lock.</span>
<span class="cm">     * Lock before actually inserting due to fairness reasons explained in</span>
<span class="cm">     * atari_scsi.c. If we insert first, then it&#39;s impossible for this driver</span>
<span class="cm">     * to release the lock.</span>
<span class="cm">     * Stop timer for this command while waiting for the lock, or timeouts</span>
<span class="cm">     * may happen (and they really do), and it&#39;s no good if the command doesn&#39;t</span>
<span class="cm">     * appear in any of the queues.</span>
<span class="cm">     * ++roman: Just disabling the NCR interrupt isn&#39;t sufficient here,</span>
<span class="cm">     * because also a timer int can trigger an abort or reset, which would</span>
<span class="cm">     * alter queues and touch the lock.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">LIST</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">);</span>
	<span class="n">SET_NEXT</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">);</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">;</span>
	     <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
	    <span class="p">;</span>
	<span class="n">LIST</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="n">SET_NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

    <span class="n">QU_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: command added to %s of queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">H_NO</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
	      <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;head&quot;</span> <span class="o">:</span> <span class="s">&quot;tail&quot;</span><span class="p">);</span>

    <span class="cm">/* If queue_command() is called from an interrupt (real one or bottom</span>
<span class="cm">     * half), we let queue_main() do the job of taking care about main. If it</span>
<span class="cm">     * is already running, this is a no-op, else main will be queued.</span>
<span class="cm">     *</span>
<span class="cm">     * If we&#39;re not in an interrupt, we can call NCR5380_main()</span>
<span class="cm">     * unconditionally, because it cannot be already running.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">()</span> <span class="o">||</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span>
	<span class="n">queue_main</span><span class="p">();</span>
    <span class="k">else</span>
	<span class="n">NCR5380_main</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">NCR5380_queue_command</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm"> * Function : NCR5380_main (void) </span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : NCR5380_main is a coroutine that runs as long as more work can </span>
<span class="cm"> *	be done on the NCR5380 host adapters in a system.  Both </span>
<span class="cm"> *	NCR5380_queue_command() and NCR5380_intr() will try to start it </span>
<span class="cm"> *	in case it is not running.</span>
<span class="cm"> * </span>
<span class="cm"> * NOTE : NCR5380_main exits with interrupts *disabled*, the caller should </span>
<span class="cm"> *  reenable them.  This prevents reentrancy and kernel stack overflow.</span>
<span class="cm"> */</span> 	
    
<span class="k">static</span> <span class="kt">void</span> <span class="n">NCR5380_main</span> <span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">bl</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">first_instance</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span> <span class="o">=</span> <span class="n">HOSTDATA</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">done</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    
    <span class="cm">/*</span>
<span class="cm">     * We run (with interrupts disabled) until we&#39;re sure that none of </span>
<span class="cm">     * the host adapters have anything that can be done, at which point </span>
<span class="cm">     * we set main_running to 0 and exit.</span>
<span class="cm">     *</span>
<span class="cm">     * Interrupts are enabled before doing various other internal </span>
<span class="cm">     * instructions, after we&#39;ve decided that we need to run through</span>
<span class="cm">     * the loop again.</span>
<span class="cm">     *</span>
<span class="cm">     * this should prevent any race conditions.</span>
<span class="cm">     * </span>
<span class="cm">     * ++roman: Just disabling the NCR interrupt isn&#39;t sufficient here,</span>
<span class="cm">     * because also a timer int can trigger an abort or reset, which can</span>
<span class="cm">     * alter queues and touch the Falcon lock.</span>
<span class="cm">     */</span>

    <span class="cm">/* Tell int handlers main() is now already executing.  Note that</span>
<span class="cm">       no races are possible here. If an int comes in before</span>
<span class="cm">       &#39;main_running&#39; is set here, and queues/executes main via the</span>
<span class="cm">       task queue, it doesn&#39;t do any harm, just this instance of main</span>
<span class="cm">       won&#39;t find any work left to do. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">main_running</span><span class="p">)</span>
    	<span class="k">return</span><span class="p">;</span>
    <span class="n">main_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">local_save_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    <span class="k">do</span> <span class="p">{</span>
	<span class="n">local_irq_disable</span><span class="p">();</span> <span class="cm">/* Freeze request queues */</span>
	<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">MAIN_PRINTK</span><span class="p">(</span> <span class="s">&quot;scsi%d: not connected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span> <span class="p">);</span>
	    <span class="cm">/*</span>
<span class="cm">	     * Search through the issue_queue for a command destined</span>
<span class="cm">	     * for a target that&#39;s not busy.</span>
<span class="cm">	     */</span>
<span class="cp">#if (NDEBUG &amp; NDEBUG_LISTS)</span>
	    <span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		 <span class="n">tmp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">);</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
		<span class="p">;</span>
	    <span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">prev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot; LOOP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="cm">/* else printk(&quot;\n&quot;);*/</span>
<span class="cp">#endif</span>
	    <span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">,</span>
		 <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>

<span class="cp">#if (NDEBUG &amp; NDEBUG_LISTS)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">)</span>
		    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;MAIN tmp=%p   target=%d   busy=%d lun=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">],</span>
			   <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="cm">/*  When we find one, remove it from the issue queue. */</span>
		<span class="cm">/* ++guenther: possible race with Falcon locking */</span>
		<span class="k">if</span> <span class="p">(</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
		    <span class="o">!</span><span class="n">is_lun_busy</span><span class="p">(</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span>
<span class="cp">#else</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">))</span>
<span class="cp">#endif</span>
		    <span class="p">)</span> <span class="p">{</span>
		    <span class="cm">/* ++guenther: just to be sure, this must be atomic */</span>
		    <span class="n">local_irq_disable</span><span class="p">();</span>
		    <span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
		        <span class="n">REMOVE</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">prev</span><span class="p">),</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
			<span class="n">SET_NEXT</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
		    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		        <span class="n">REMOVE</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
			<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span> <span class="o">=</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		    <span class="p">}</span>
		    <span class="n">SET_NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		    
		    <span class="cm">/* reenable interrupts after finding one */</span>
		    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		    
		    <span class="cm">/* </span>
<span class="cm">		     * Attempt to establish an I_T_L nexus here. </span>
<span class="cm">		     * On success, instance-&gt;hostdata-&gt;connected is set.</span>
<span class="cm">		     * On failure, we must add the command back to the</span>
<span class="cm">		     *   issue queue so we can keep trying.	</span>
<span class="cm">		     */</span>
		    <span class="n">MAIN_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: main(): command for target %d &quot;</span>
				<span class="s">&quot;lun %d removed from issue_queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">HOSTNO</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
		    <span class="cm">/* </span>
<span class="cm">		     * REQUEST SENSE commands are issued without tagged</span>
<span class="cm">		     * queueing, even on SCSI-II devices because the </span>
<span class="cm">		     * contingent allegiance condition exists for the </span>
<span class="cm">		     * entire unit.</span>
<span class="cm">		     */</span>
		    <span class="cm">/* ++roman: ...and the standard also requires that</span>
<span class="cm">		     * REQUEST SENSE command are untagged.</span>
<span class="cm">		     */</span>
		    
<span class="cp">#ifdef SUPPORT_TAGS</span>
		    <span class="n">cmd_get_tag</span><span class="p">(</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">REQUEST_SENSE</span> <span class="p">);</span>
<span class="cp">#endif</span>
		    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NCR5380_select</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> 
			    <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="o">?</span> <span class="n">TAG_NONE</span> <span class="o">:</span> 
			    <span class="n">TAG_NEXT</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">local_irq_disable</span><span class="p">();</span>
			<span class="n">LIST</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">);</span>
			<span class="n">SET_NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">);</span>
			<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
			<span class="n">cmd_free_tag</span><span class="p">(</span> <span class="n">tmp</span> <span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">MAIN_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: main(): select() failed, &quot;</span>
				    <span class="s">&quot;returned to issue_queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span>
			    <span class="k">break</span><span class="p">;</span>
		    <span class="p">}</span>
		<span class="p">}</span> <span class="cm">/* if target/lun/target queue is not busy */</span>
	    <span class="p">}</span> <span class="cm">/* for issue_queue */</span>
	<span class="p">}</span> <span class="cm">/* if (!hostdata-&gt;connected) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> 
<span class="cp">#ifdef REAL_DMA</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">dma_len</span>
<span class="cp">#endif</span>
	    <span class="p">)</span> <span class="p">{</span>
	    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	    <span class="n">MAIN_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: main: performing information transfer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">HOSTNO</span><span class="p">);</span>
	    <span class="n">NCR5380_information_transfer</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	    <span class="n">MAIN_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: main: done set false</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
	    <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">);</span>

    <span class="cm">/* Better allow ints _after_ &#39;main_running&#39; has been cleared, else</span>
<span class="cm">       an interrupt could believe we&#39;ll pick up the work it left for</span>
<span class="cm">       us, but we won&#39;t see it anymore here... */</span>
    <span class="n">main_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#ifdef REAL_DMA</span>
<span class="cm">/*</span>
<span class="cm"> * Function : void NCR5380_dma_complete (struct Scsi_Host *instance)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : Called by interrupt handler when DMA finishes or a phase</span>
<span class="cm"> *	mismatch occurs (which would finish the DMA transfer).  </span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : instance - this instance of the NCR5380.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">NCR5380_dma_complete</span><span class="p">(</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">SETUP_HOSTDATA</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
    <span class="kt">int</span>           <span class="n">transfered</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">data</span><span class="p">;</span>
    <span class="k">volatile</span> <span class="kt">int</span>  <span class="o">*</span><span class="n">count</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;scsi%d: received end of DMA interrupt with &quot;</span>
	       <span class="s">&quot;no connected cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">DMA_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: real DMA transfer complete, basr 0x%X, sr 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">),</span>
	       <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">));</span>

    <span class="k">if</span><span class="p">((</span><span class="n">sun3scsi_dma_finish</span><span class="p">(</span><span class="n">rq_data_dir</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">))))</span> <span class="p">{</span>
	    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d: overrun in UDC counter -- not prepared to deal with this!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
	    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;please e-mail sammy@sammy.net with a description of how this</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;error was produced.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	    <span class="n">BUG</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="cm">/* make sure we&#39;re not stuck in a data phase */</span>
    <span class="k">if</span><span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BASR_PHASE_MATCH</span> <span class="o">|</span>
					    <span class="n">BASR_ACK</span><span class="p">))</span> <span class="o">==</span>
       <span class="p">(</span><span class="n">BASR_PHASE_MATCH</span> <span class="o">|</span> <span class="n">BASR_ACK</span><span class="p">))</span> <span class="p">{</span>
	    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d: BASR %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">));</span>
	    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d: bus stuck in data phase -- probably a single byte &quot;</span>
		   <span class="s">&quot;overrun!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
	    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;not prepared for this error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;please e-mail sammy@sammy.net with a description of how this</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;error was produced.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	    <span class="n">BUG</span><span class="p">();</span>
    <span class="p">}</span>



    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">RESET_PARITY_INTERRUPT_REG</span><span class="p">);</span>
    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>

    <span class="n">transfered</span> <span class="o">=</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">dma_len</span> <span class="o">-</span> <span class="n">NCR5380_dma_residual</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">dma_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span><span class="p">);</span>
    <span class="o">*</span><span class="n">data</span> <span class="o">+=</span> <span class="n">transfered</span><span class="p">;</span>
    <span class="o">*</span><span class="n">count</span> <span class="o">-=</span> <span class="n">transfered</span><span class="p">;</span>

<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* REAL_DMA */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * Function : void NCR5380_intr (int irq)</span>
<span class="cm"> * </span>
<span class="cm"> * Purpose : handle interrupts, reestablishing I_T_L or I_T_L_Q nexuses</span>
<span class="cm"> *	from the disconnected queue, and restarting NCR5380_main() </span>
<span class="cm"> *	as required.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : int irq, irq that caused this interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">NCR5380_intr</span> <span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">first_instance</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">basr</span><span class="p">;</span>

    <span class="n">INT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: NCR5380 irq triggered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>

    <span class="cm">/* Look for pending interrupts */</span>
    <span class="n">basr</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">);</span>
    <span class="n">INT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: BASR=%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">basr</span><span class="p">);</span>
    <span class="cm">/* dispatch to appropriate routine if found and done=0 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">basr</span> <span class="o">&amp;</span> <span class="n">BASR_IRQ</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR_PRINT</span><span class="p">(</span><span class="n">NDEBUG_INTR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SR_SEL</span><span class="o">|</span><span class="n">SR_IO</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">SR_SEL</span><span class="o">|</span><span class="n">SR_IO</span><span class="p">))</span> <span class="p">{</span>
	    <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><pre><code>ENABLE_IRQ();
</code></pre></td><td class="code"><div class="highlight"><pre>	    <span class="n">INT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: SEL interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
	    <span class="n">NCR5380_reselect</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">RESET_PARITY_INTERRUPT_REG</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">basr</span> <span class="o">&amp;</span> <span class="n">BASR_PARITY_ERROR</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">INT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: PARITY interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
	    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">RESET_PARITY_INTERRUPT_REG</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_RST</span><span class="p">)</span> <span class="o">==</span> <span class="n">SR_RST</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">INT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: RESET interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
	    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">RESET_PARITY_INTERRUPT_REG</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
	    <span class="cm">/*  </span>
<span class="cm">	     * The rest of the interrupt conditions can occur only during a</span>
<span class="cm">	     * DMA transfer</span>
<span class="cm">	     */</span>

<span class="cp">#if defined(REAL_DMA)</span>
	    <span class="cm">/*</span>
<span class="cm">	     * We should only get PHASE MISMATCH and EOP interrupts if we have</span>
<span class="cm">	     * DMA enabled, so do a sanity check based on the current setting</span>
<span class="cm">	     * of the MODE register.</span>
<span class="cm">	     */</span>

	    <span class="k">if</span> <span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MR_DMA_MODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">((</span><span class="n">basr</span> <span class="o">&amp;</span> <span class="n">BASR_END_DMA_TRANSFER</span><span class="p">)</span> <span class="o">||</span> 
		 <span class="o">!</span><span class="p">(</span><span class="n">basr</span> <span class="o">&amp;</span> <span class="n">BASR_PHASE_MATCH</span><span class="p">)))</span> <span class="p">{</span>
		    
		<span class="n">INT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: PHASE MISM or EOP interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
		<span class="n">NCR5380_dma_complete</span><span class="p">(</span> <span class="n">instance</span> <span class="p">);</span>
		<span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><pre><code>ENABLE_IRQ();
</code></pre></td><td class="code"><div class="highlight"><pre>	    <span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif </span><span class="cm">/* REAL_DMA */</span><span class="cp"></span>
	    <span class="p">{</span>
<span class="cm">/* MS: Ignore unknown phase mismatch interrupts (caused by EOP interrupt) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">basr</span> <span class="o">&amp;</span> <span class="n">BASR_PHASE_MATCH</span><span class="p">)</span>
		   <span class="n">INT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: unknown interrupt, &quot;</span>
			   <span class="s">&quot;BASR 0x%x, MR 0x%x, SR 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">basr</span><span class="p">,</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">),</span>
			   <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">));</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">RESET_PARITY_INTERRUPT_REG</span><span class="p">);</span>
<span class="cp">#ifdef SUN3_SCSI_VME</span>
		<span class="n">dregs</span><span class="o">-&gt;</span><span class="n">csr</span> <span class="o">|=</span> <span class="n">CSR_DMA_ENABLE</span><span class="p">;</span>
<span class="cp">#endif</span>
	    <span class="p">}</span>
	<span class="p">}</span> <span class="cm">/* if !(SELECTION || PARITY) */</span>
	<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="cm">/* BASR &amp; IRQ */</span>
    <span class="k">else</span> <span class="p">{</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;scsi%d: interrupt without IRQ bit set in BASR, &quot;</span>
	       <span class="s">&quot;BASR 0x%X, MR 0x%X, SR 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">basr</span><span class="p">,</span>
	       <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">),</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">));</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">RESET_PARITY_INTERRUPT_REG</span><span class="p">);</span>
<span class="cp">#ifdef SUN3_SCSI_VME</span>
		<span class="n">dregs</span><span class="o">-&gt;</span><span class="n">csr</span> <span class="o">|=</span> <span class="n">CSR_DMA_ENABLE</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">INT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: in int routine, calling main</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
	<span class="cm">/* Put a call to NCR5380_main() on the queue... */</span>
	<span class="n">queue_main</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef NCR5380_STATS</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">collect_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">NCR5380_hostdata</span> <span class="o">*</span><span class="n">hostdata</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp"># ifdef NCR5380_STAT_LIMIT</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">NCR5380_STAT_LIMIT</span><span class="p">)</span>
<span class="cp"># endif</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">{</span>
	    <span class="k">case</span> <span class="n">WRITE</span>:
	    <span class="k">case</span> <span class="n">WRITE_6</span>:
	    <span class="k">case</span> <span class="n">WRITE_10</span>:
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_write</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">timebase</span><span class="p">);</span>
		<span class="cm">/*hostdata-&gt;bytes_write[cmd-&gt;device-&gt;id] += scsi_bufflen(cmd);*/</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">pendingw</span><span class="o">--</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	    <span class="k">case</span> <span class="n">READ</span>:
	    <span class="k">case</span> <span class="n">READ_6</span>:
	    <span class="k">case</span> <span class="n">READ_10</span>:
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">time_read</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">timebase</span><span class="p">);</span>
		<span class="cm">/*hostdata-&gt;bytes_read[cmd-&gt;device-&gt;id] += scsi_bufflen(cmd);*/</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">pendingr</span><span class="o">--</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* </span>
<span class="cm"> * Function : int NCR5380_select(struct Scsi_Host *instance,</span>
<span class="cm"> * 				 struct scsi_cmnd *cmd,	int tag);</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : establishes I_T_L or I_T_L_Q nexus for new or existing command,</span>
<span class="cm"> *	including ARBITRATION, SELECTION, and initial message out for </span>
<span class="cm"> *	IDENTIFY and queue messages. </span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : instance - instantiation of the 5380 driver on which this </span>
<span class="cm"> * 	target lives, cmd - SCSI command to execute, tag - set to TAG_NEXT for </span>
<span class="cm"> *	new tag, TAG_NONE for untagged queueing, otherwise set to the tag for </span>
<span class="cm"> *	the command that is presently connected.</span>
<span class="cm"> * </span>
<span class="cm"> * Returns : -1 if selection could not execute for some reason,</span>
<span class="cm"> *	0 if selection succeeded or failed because the target </span>
<span class="cm"> * 	did not respond.</span>
<span class="cm"> *</span>
<span class="cm"> * Side effects : </span>
<span class="cm"> * 	If bus busy, arbitration failed, etc, NCR5380_select() will exit </span>
<span class="cm"> *		with registers as they should have been on entry - ie</span>
<span class="cm"> *		SELECT_ENABLE will be set appropriately, the NCR5380</span>
<span class="cm"> *		will cease to drive any SCSI bus signals.</span>
<span class="cm"> *</span>
<span class="cm"> *	If successful : I_T_L or I_T_L_Q nexus will be established, </span>
<span class="cm"> *		instance-&gt;connected will be set to cmd.  </span>
<span class="cm"> * 		SELECT interrupt will be disabled.</span>
<span class="cm"> *</span>
<span class="cm"> *	If failed (no target) : cmd-&gt;scsi_done() will be called, and the </span>
<span class="cm"> *		cmd-&gt;result host byte set to DID_BAD_TARGET.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">NCR5380_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SETUP_HOSTDATA</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">phase</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">restart_select</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">NCR_PRINT</span><span class="p">(</span><span class="n">NDEBUG_ARBITRATION</span><span class="p">);</span>
    <span class="n">ARB_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: starting arbitration, id = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">,</span>
	       <span class="n">instance</span><span class="o">-&gt;</span><span class="n">this_id</span><span class="p">);</span>

    <span class="cm">/* </span>
<span class="cm">     * Set the phase bits to 0, otherwise the NCR5380 won&#39;t drive the </span>
<span class="cm">     * data bus during SELECTION.</span>
<span class="cm">     */</span>

    <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>


    <span class="cm">/* </span>
<span class="cm">     * Start arbitration.</span>
<span class="cm">     */</span>
    
    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">OUTPUT_DATA_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_ARBITRATE</span><span class="p">);</span>

    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

    <span class="cm">/* Wait for arbitration logic to complete */</span>
<span class="cp">#ifdef NCR_TIMEOUT</span>
    <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">NCR_TIMEOUT</span><span class="p">;</span>

      <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ICR_ARBITRATION_PROGRESS</span><span class="p">)</span>
	   <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span>
	<span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
      <span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi : arbitration timeout at %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* NCR_TIMEOUT */</span><span class="cp"></span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ICR_ARBITRATION_PROGRESS</span><span class="p">)</span>
	 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">);</span>
<span class="cp">#endif</span>

    <span class="n">ARB_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: arbitration complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span> 
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* </span>
<span class="cm">     * The arbitration delay is 2.2us, but this is a minimum and there is </span>
<span class="cm">     * no maximum so we can safely sleep for ceil(2.2) usecs to accommodate</span>
<span class="cm">     * the integral nature of udelay().</span>
<span class="cm">     *</span>
<span class="cm">     */</span>

    <span class="n">udelay</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="cm">/* Check for lost arbitration */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ICR_ARBITRATION_LOST</span><span class="p">)</span> <span class="o">||</span>
	<span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">CURRENT_SCSI_DATA_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_higher_mask</span><span class="p">)</span> <span class="o">||</span>
	<span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ICR_ARBITRATION_LOST</span><span class="p">)</span> <span class="o">||</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span> 
	<span class="n">ARB_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: lost arbitration, deasserting MR_ARBITRATE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">HOSTNO</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

     <span class="cm">/* after/during arbitration, BSY should be asserted.</span>
<span class="cm">	IBM DPES-31080 Version S31Q works now */</span>
     <span class="cm">/* Tnx to Thomas_Roesch@m2.maus.de for finding this! (Roman) */</span>
    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_SEL</span> <span class="o">|</span>
					 <span class="n">ICR_ASSERT_BSY</span> <span class="p">)</span> <span class="p">;</span>
    
    <span class="k">if</span> <span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ICR_ARBITRATION_LOST</span><span class="p">)</span> <span class="o">||</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
	<span class="n">ARB_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: lost arbitration, deasserting ICR_ASSERT_SEL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">HOSTNO</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* </span>
<span class="cm">     * Again, bus clear + bus settle time is 1.2us, however, this is </span>
<span class="cm">     * a minimum so we&#39;ll udelay ceil(1.2)</span>
<span class="cm">     */</span>

<span class="cp">#ifdef CONFIG_ATARI_SCSI_TOSHIBA_DELAY</span>
    <span class="cm">/* ++roman: But some targets (see above :-) seem to need a bit more... */</span>
    <span class="n">udelay</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
<span class="cp">#else</span>
    <span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="cp">#endif</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ARB_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: won arbitration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>

    <span class="cm">/* </span>
<span class="cm">     * Now that we have won arbitration, start Selection process, asserting </span>
<span class="cm">     * the host and target ID&#39;s on the SCSI bus.</span>
<span class="cm">     */</span>

    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">OUTPUT_DATA_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)));</span>

    <span class="cm">/* </span>
<span class="cm">     * Raise ATN while SEL is true before BSY goes false from arbitration,</span>
<span class="cm">     * since this is the only way to guarantee that we&#39;ll get a MESSAGE OUT</span>
<span class="cm">     * phase immediately after selection.</span>
<span class="cm">     */</span>

    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_BSY</span> <span class="o">|</span> 
	<span class="n">ICR_ASSERT_DATA</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span> <span class="o">|</span> <span class="n">ICR_ASSERT_SEL</span> <span class="p">));</span>
    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>

    <span class="cm">/* </span>
<span class="cm">     * Reselect interrupts must be turned off prior to the dropping of BSY,</span>
<span class="cm">     * otherwise we will trigger an interrupt.</span>
<span class="cm">     */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * The initiator shall then wait at least two deskew delays and release </span>
<span class="cm">     * the BSY signal.</span>
<span class="cm">     */</span>
    <span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>        <span class="cm">/* wingel -- wait two bus deskew delay &gt;2*45ns */</span>

    <span class="cm">/* Reset BSY */</span>
    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_DATA</span> <span class="o">|</span> 
	<span class="n">ICR_ASSERT_ATN</span> <span class="o">|</span> <span class="n">ICR_ASSERT_SEL</span><span class="p">));</span>

    <span class="cm">/* </span>
<span class="cm">     * Something weird happens when we cease to drive BSY - looks</span>
<span class="cm">     * like the board/chip is letting us do another read before the </span>
<span class="cm">     * appropriate propagation delay has expired, and we&#39;re confusing</span>
<span class="cm">     * a BSY signal from ourselves as the target&#39;s response to SELECTION.</span>
<span class="cm">     *</span>
<span class="cm">     * A small delay (the &#39;C++&#39; frontend breaks the pipeline with an</span>
<span class="cm">     * unnecessary jump, making it work on my 386-33/Trantor T128, the</span>
<span class="cm">     * tighter &#39;C&#39; code breaks and requires this) solves the problem - </span>
<span class="cm">     * the 1 us delay is arbitrary, and only used because this delay will </span>
<span class="cm">     * be the same on other platforms and since it works here, it should </span>
<span class="cm">     * work there.</span>
<span class="cm">     *</span>
<span class="cm">     * wingel suggests that this could be due to failing to wait</span>
<span class="cm">     * one deskew delay.</span>
<span class="cm">     */</span>

    <span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">SEL_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: selecting target %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

    <span class="cm">/* </span>
<span class="cm">     * The SCSI specification calls for a 250 ms timeout for the actual </span>
<span class="cm">     * selection.</span>
<span class="cm">     */</span>

    <span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">25</span><span class="p">;</span> 

    <span class="cm">/* </span>
<span class="cm">     * XXX very interesting - we&#39;re seeing a bounce where the BSY we </span>
<span class="cm">     * asserted is being reflected / still asserted (propagation delay?)</span>
<span class="cm">     * and it&#39;s detecting as true.  Sigh.</span>
<span class="cm">     */</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">    /* ++roman: If a target conformed to the SCSI standard, it wouldn&#39;t assert</span>
<span class="c">     * IO while SEL is true. But again, there are some disks out the in the</span>
<span class="c">     * world that do that nevertheless. (Somebody claimed that this announces</span>
<span class="c">     * reselection capability of the target.) So we better skip that test and</span>
<span class="c">     * only wait for BSY... (Famous german words: Der Klügere gibt nach :-)</span>
<span class="c">     */</span>

<span class="c">    while (time_before(jiffies, timeout) &amp;&amp; !(NCR5380_read(STATUS_REG) &amp; </span>
<span class="c">	(SR_BSY | SR_IO)));</span>

<span class="c">    if ((NCR5380_read(STATUS_REG) &amp; (SR_SEL | SR_IO)) == </span>
<span class="c">	    (SR_SEL | SR_IO)) {</span>
<span class="c">	    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);</span>
<span class="c">	    NCR5380_reselect(instance);</span>
<span class="c">	    printk (KERN_ERR &quot;scsi%d: reselection after won arbitration?\n&quot;,</span>
<span class="c">		    HOSTNO);</span>
<span class="c">	    NCR5380_write(SELECT_ENABLE_REG, hostdata-&gt;id_mask);</span>
<span class="c">	    return -1;</span>
<span class="c">    }</span>
<span class="cp">#else</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_BSY</span><span class="p">));</span>
<span class="cp">#endif</span>

    <span class="cm">/* </span>
<span class="cm">     * No less than two deskew delays after the initiator detects the </span>
<span class="cm">     * BSY signal is true, it shall release the SEL signal and may </span>
<span class="cm">     * change the DATA BUS.                                     -wingel</span>
<span class="cm">     */</span>

    <span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_BSY</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">targets_present</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
	    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;scsi%d: weirdness</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">restart_select</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">restart select</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	    <span class="n">NCR_PRINT</span><span class="p">(</span><span class="n">NDEBUG_ANY</span><span class="p">);</span>
	    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
	    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="cp">#ifdef NCR5380_STATS</span>
	<span class="n">collect_stats</span><span class="p">(</span><span class="n">hostdata</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
	<span class="n">cmd_free_tag</span><span class="p">(</span> <span class="n">cmd</span> <span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
	<span class="n">SEL_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: target did not respond within 250ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> 

    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">targets_present</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Since we followed the SCSI spec, and raised ATN while SEL </span>
<span class="cm">     * was true but before BSY was false during selection, the information</span>
<span class="cm">     * transfer phase should be a MESSAGE OUT phase so that we can send the</span>
<span class="cm">     * IDENTIFY message.</span>
<span class="cm">     * </span>
<span class="cm">     * If SCSI-II tagged queuing is enabled, we also send a SIMPLE_QUEUE_TAG</span>
<span class="cm">     * message (2 bytes) with a tag ID that we increment with every command</span>
<span class="cm">     * until it wraps back to 0.</span>
<span class="cm">     *</span>
<span class="cm">     * XXX - it turns out that there are some broken SCSI-II devices,</span>
<span class="cm">     *	     which claim to support tagged queuing but fail when more than</span>
<span class="cm">     *	     some number of commands are issued at once.</span>
<span class="cm">     */</span>

    <span class="cm">/* Wait for start of REQ/ACK handshake */</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">));</span>

    <span class="n">SEL_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: target %d selected, going into MESSAGE OUT phase.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
    <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">IDENTIFY</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

<span class="cp">#ifdef SUPPORT_TAGS</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">TAG_NONE</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">last_message</span> <span class="o">=</span> <span class="n">SIMPLE_QUEUE_TAG</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> 
	<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
    <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* SUPPORT_TAGS */</span><span class="cp"></span>

    <span class="cm">/* Send message(s) */</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">PHASE_MSGOUT</span><span class="p">;</span>
    <span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
    <span class="n">SEL_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: nexus established.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
    <span class="cm">/* XXX need to handle errors here */</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
<span class="cp">#ifndef SUPPORT_TAGS</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
<span class="cp">#endif    </span>
<span class="cp">#ifdef SUN3_SCSI_VME</span>
    <span class="n">dregs</span><span class="o">-&gt;</span><span class="n">csr</span> <span class="o">|=</span> <span class="n">CSR_INTR</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="n">initialize_SCp</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>


    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> * Function : int NCR5380_transfer_pio (struct Scsi_Host *instance, </span>
<span class="cm"> *      unsigned char *phase, int *count, unsigned char **data)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : transfers data in given phase using polled I/O</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : instance - instance of driver, *phase - pointer to </span>
<span class="cm"> *	what phase is expected, *count - pointer to number of </span>
<span class="cm"> *	bytes to transfer, **data - pointer to data pointer.</span>
<span class="cm"> * </span>
<span class="cm"> * Returns : -1 when different phase is entered without transferring</span>
<span class="cm"> *	maximum number of bytes, 0 if all bytes are transferred or exit</span>
<span class="cm"> *	is in same phase.</span>
<span class="cm"> *</span>
<span class="cm"> * 	Also, *phase, *count, *data are modified in place.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX Note : handling for bus free may be useful.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Note : this code is not as quick as it could be, however it </span>
<span class="cm"> * IS 100% reliable, and for the actual data transfer where speed</span>
<span class="cm"> * counts, we will always do a pseudo DMA or DMA transfer.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">NCR5380_transfer_pio</span><span class="p">(</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> 
				 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">phase</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">phase</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="k">register</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>
    <span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

    <span class="cm">/* </span>
<span class="cm">     * The NCR5380 chip will only drive the SCSI bus when the </span>
<span class="cm">     * phase specified in the appropriate bits of the TARGET COMMAND</span>
<span class="cm">     * REGISTER match the STATUS REGISTER</span>
<span class="cm">     */</span>

    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="n">PHASE_SR_TO_TCR</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>

    <span class="k">do</span> <span class="p">{</span>
	<span class="cm">/* </span>
<span class="cm">	 * Wait for assertion of REQ, after which the phase bits will be </span>
<span class="cm">	 * valid </span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">));</span>

	<span class="n">HSH_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: REQ detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>

	<span class="cm">/* Check for phase mismatch */</span>	
	<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">PIO_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: phase mismatch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
	    <span class="n">NCR_PRINT_PHASE</span><span class="p">(</span><span class="n">NDEBUG_PIO</span><span class="p">);</span>
	    <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do actual transfer from SCSI bus to / from memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">))</span> 
	    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">OUTPUT_DATA_REG</span><span class="p">,</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
	<span class="k">else</span> 
	    <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">CURRENT_SCSI_DATA_REG</span><span class="p">);</span>

	<span class="o">++</span><span class="n">d</span><span class="p">;</span>

	<span class="cm">/* </span>
<span class="cm">	 * The SCSI standard suggests that in MSGOUT phase, the initiator</span>
<span class="cm">	 * should drop ATN on the last byte of the message phase</span>
<span class="cm">	 * after REQ has been asserted for the handshake but before</span>
<span class="cm">	 * the initiator raises ACK.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">))</span> <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_MSG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> 
		    <span class="n">ICR_ASSERT_DATA</span><span class="p">);</span>
		<span class="n">NCR_PRINT</span><span class="p">(</span><span class="n">NDEBUG_PIO</span><span class="p">);</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> 
			<span class="n">ICR_ASSERT_DATA</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ACK</span><span class="p">);</span>
	    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span>
		    <span class="n">ICR_ASSERT_DATA</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>
		<span class="n">NCR_PRINT</span><span class="p">(</span><span class="n">NDEBUG_PIO</span><span class="p">);</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> 
		    <span class="n">ICR_ASSERT_DATA</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ACK</span><span class="p">);</span>
	    <span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	    <span class="n">NCR_PRINT</span><span class="p">(</span><span class="n">NDEBUG_PIO</span><span class="p">);</span>
	    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ACK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">);</span>

	<span class="n">HSH_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: req false, handshake complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We have several special cases to consider during REQ/ACK handshaking : </span>
<span class="cm"> * 1.  We were in MSGOUT phase, and we are on the last byte of the </span>
<span class="cm"> *	message.  ATN must be dropped as ACK is dropped.</span>
<span class="cm"> *</span>
<span class="cm"> * 2.  We are in a MSGIN phase, and we are on the last byte of the  </span>
<span class="cm"> *	message.  We must exit with ACK asserted, so that the calling</span>
<span class="cm"> *	code may raise ATN before dropping ACK to reject the message.</span>
<span class="cm"> *</span>
<span class="cm"> * 3.  ACK and ATN are clear and the target may proceed as normal.</span>
<span class="cm"> */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">PHASE_MSGIN</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>  
	    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">PHASE_MSGOUT</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>
	    <span class="k">else</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
	<span class="p">}</span> 
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">c</span><span class="p">);</span>

    <span class="n">PIO_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: residual %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

    <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">);</span>
    <span class="cm">/* The phase read from the bus is valid if either REQ is (already)</span>
<span class="cm">     * asserted or if ACK hasn&#39;t been released yet. The latter is the case if</span>
<span class="cm">     * we&#39;re in MSGIN and all wanted bytes have been received. */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">PHASE_MSGIN</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
	<span class="o">*</span><span class="n">phase</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">;</span>
    <span class="k">else</span> 
	<span class="o">*</span><span class="n">phase</span> <span class="o">=</span> <span class="n">PHASE_UNKNOWN</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">phase</span> <span class="o">==</span> <span class="n">p</span><span class="p">))</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> 
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function : do_abort (Scsi_Host *host)</span>
<span class="cm"> * </span>
<span class="cm"> * Purpose : abort the currently established nexus.  Should only be </span>
<span class="cm"> * 	called from a routine which can drop into a </span>
<span class="cm"> * </span>
<span class="cm"> * Returns : 0 on success, -1 on failure.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_abort</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">msgptr</span><span class="p">,</span> <span class="n">phase</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

    <span class="cm">/* Request message out phase */</span>
    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>

    <span class="cm">/* </span>
<span class="cm">     * Wait for the target to indicate a valid phase by asserting </span>
<span class="cm">     * REQ.  Once this happens, we&#39;ll have either a MSGOUT phase </span>
<span class="cm">     * and can immediately send the ABORT message, or we&#39;ll have some </span>
<span class="cm">     * other phase and will have to source/sink data.</span>
<span class="cm">     * </span>
<span class="cm">     * We really don&#39;t care what value was on the bus or what value</span>
<span class="cm">     * the target sees, so we just handshake.</span>
<span class="cm">     */</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">));</span>

    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="n">PHASE_SR_TO_TCR</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PHASE_MSGOUT</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span> <span class="o">|</span> 
		      <span class="n">ICR_ASSERT_ACK</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">);</span>
	<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>
    <span class="p">}</span>
   
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">ABORT</span><span class="p">;</span>
    <span class="n">msgptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">;</span>
    <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">PHASE_MSGOUT</span><span class="p">;</span>
    <span class="n">NCR5380_transfer_pio</span> <span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msgptr</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * If we got here, and the command completed successfully,</span>
<span class="cm">     * we&#39;re about to go into bus free state.</span>
<span class="cm">     */</span>

    <span class="k">return</span> <span class="n">len</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(REAL_DMA)</span>
<span class="cm">/* </span>
<span class="cm"> * Function : int NCR5380_transfer_dma (struct Scsi_Host *instance, </span>
<span class="cm"> *      unsigned char *phase, int *count, unsigned char **data)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : transfers data in given phase using either real</span>
<span class="cm"> *	or pseudo DMA.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : instance - instance of driver, *phase - pointer to </span>
<span class="cm"> *	what phase is expected, *count - pointer to number of </span>
<span class="cm"> *	bytes to transfer, **data - pointer to data pointer.</span>
<span class="cm"> * </span>
<span class="cm"> * Returns : -1 when different phase is entered without transferring</span>
<span class="cm"> *	maximum number of bytes, 0 if all bytes or transferred or exit</span>
<span class="cm"> *	is in same phase.</span>
<span class="cm"> *</span>
<span class="cm"> * 	Also, *phase, *count, *data are modified in place.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">NCR5380_transfer_dma</span><span class="p">(</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> 
				 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">phase</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SETUP_HOSTDATA</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
    <span class="k">register</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>
    <span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">phase</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

    <span class="cm">/* sanity check */</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">sun3_dma_setup_done</span><span class="p">)</span> <span class="p">{</span>
	 <span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d: transfer_dma without setup!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
	 <span class="n">BUG</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">dma_len</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

    <span class="n">DMA_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: initializing DMA for %s, %d bytes %s %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">HOSTNO</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;reading&quot;</span> <span class="o">:</span> <span class="s">&quot;writing&quot;</span><span class="p">,</span>
	       <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;to&quot;</span> <span class="o">:</span> <span class="s">&quot;from&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

    <span class="cm">/* netbsd turns off ints here, why not be safe and do it too */</span>
    <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    
    <span class="cm">/* send start chain */</span>
    <span class="n">sun3scsi_dma_start</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">SR_IO</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	    <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">RESET_PARITY_INTERRUPT_REG</span><span class="p">);</span>
	    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">)</span> <span class="o">|</span> <span class="n">MR_DMA_MODE</span> <span class="o">|</span> <span class="n">MR_ENABLE_EOP_INTR</span><span class="p">));</span>
	    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">START_DMA_INITIATOR_RECEIVE_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	    <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">RESET_PARITY_INTERRUPT_REG</span><span class="p">);</span>
	    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_ASSERT_DATA</span><span class="p">);</span>
	    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">)</span> <span class="o">|</span> <span class="n">MR_DMA_MODE</span> <span class="o">|</span> <span class="n">MR_ENABLE_EOP_INTR</span><span class="p">));</span>
	    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">START_DMA_SEND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

<span class="cp">#ifdef SUN3_SCSI_VME</span>
    <span class="n">dregs</span><span class="o">-&gt;</span><span class="n">csr</span> <span class="o">|=</span> <span class="n">CSR_DMA_ENABLE</span><span class="p">;</span>
<span class="cp">#endif</span>

    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

    <span class="n">sun3_dma_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* defined(REAL_DMA) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Function : NCR5380_information_transfer (struct Scsi_Host *instance)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : run through the various SCSI phases and do as the target </span>
<span class="cm"> * 	directs us to.  Operates on the currently connected command, </span>
<span class="cm"> *	instance-&gt;connected.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : instance, instance for which we are doing commands</span>
<span class="cm"> *</span>
<span class="cm"> * Side effects : SCSI things happen, the disconnected queue will be </span>
<span class="cm"> *	modified if a command disconnects, *instance-&gt;connected will</span>
<span class="cm"> *	change.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX Note : we need to watch for bus free or a reset condition here </span>
<span class="cm"> * 	to recover from an unexpected bus free condition.</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kt">void</span> <span class="nf">NCR5380_information_transfer</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SETUP_HOSTDATA</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msgout</span> <span class="o">=</span> <span class="n">NOP</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="cp">#if defined(REAL_DMA)</span>
    <span class="kt">int</span> <span class="n">transfersize</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">phase</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">old_phase</span><span class="o">=</span><span class="mh">0xff</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">;</span>

<span class="cp">#ifdef SUN3_SCSI_VME</span>
    <span class="n">dregs</span><span class="o">-&gt;</span><span class="n">csr</span> <span class="o">|=</span> <span class="n">CSR_INTR</span><span class="p">;</span>
<span class="cp">#endif</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">);</span>
	<span class="cm">/* We only have a valid SCSI phase when REQ is asserted */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">);</span> 
 	    <span class="k">if</span> <span class="p">(</span><span class="n">phase</span> <span class="o">!=</span> <span class="n">old_phase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">old_phase</span> <span class="o">=</span> <span class="n">phase</span><span class="p">;</span>
		<span class="n">NCR_PRINT_PHASE</span><span class="p">(</span><span class="n">NDEBUG_INFORMATION</span><span class="p">);</span>
	    <span class="p">}</span>

	    <span class="k">if</span><span class="p">(</span><span class="n">phase</span> <span class="o">==</span> <span class="n">PHASE_CMDOUT</span><span class="p">)</span> <span class="p">{</span>
		    <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
			<span class="n">d</span> <span class="o">=</span> <span class="n">SGADDR</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span><span class="p">;</span>
			<span class="n">d</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#ifdef REAL_DMA</span>
		<span class="cm">/* this command setup for dma yet? */</span>
		<span class="k">if</span><span class="p">((</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">SUN3_DMA_MINSIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sun3_dma_setup_done</span>
						  <span class="o">!=</span> <span class="n">cmd</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_FS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sun3scsi_dma_setup</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
						   <span class="n">rq_data_dir</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">));</span>
				<span class="n">sun3_dma_setup_done</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef SUN3_SCSI_VME</span>
		<span class="n">dregs</span><span class="o">-&gt;</span><span class="n">csr</span> <span class="o">|=</span> <span class="n">CSR_INTR</span><span class="p">;</span>
<span class="cp">#endif</span>
	    <span class="p">}</span>

	    
	    <span class="k">if</span> <span class="p">(</span><span class="n">sink</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">phase</span> <span class="o">!=</span> <span class="n">PHASE_MSGOUT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="n">PHASE_SR_TO_TCR</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>

		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ATN</span> <span class="o">|</span> 
		    <span class="n">ICR_ASSERT_ACK</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">);</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> 
		    <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>
		<span class="n">sink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">continue</span><span class="p">;</span>
	    <span class="p">}</span>

	    <span class="k">switch</span> <span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">case</span> <span class="n">PHASE_DATAOUT</span>:
<span class="cp">#if (NDEBUG &amp; NDEBUG_NO_DATAOUT)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d: NDEBUG_NO_DATAOUT set, attempted DATAOUT &quot;</span>
		       <span class="s">&quot;aborted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
		<span class="n">sink</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">do_abort</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span>  <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
	    <span class="k">case</span> <span class="n">PHASE_DATAIN</span>:
		<span class="cm">/* </span>
<span class="cm">		 * If there is no room left in the current buffer in the</span>
<span class="cm">		 * scatter-gather list, move onto the next one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span><span class="p">)</span> <span class="p">{</span>
		    <span class="o">++</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span>
		    <span class="o">--</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span><span class="p">;</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">SGADDR</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
		    <span class="n">INF_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: %d bytes and %d buffers left</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span><span class="p">,</span>
			       <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The preferred transfer method is going to be </span>
<span class="cm">		 * PSEUDO-DMA for systems that are strictly PIO,</span>
<span class="cm">		 * since we can let the hardware do the handshaking.</span>
<span class="cm">		 *</span>
<span class="cm">		 * For this to work, we need to know the transfersize</span>
<span class="cm">		 * ahead of time, since the pseudo-DMA code will sit</span>
<span class="cm">		 * in an unconditional loop.</span>
<span class="cm">		 */</span>

<span class="cm">/* ++roman: I suggest, this should be</span>
<span class="cm"> *   #if def(REAL_DMA)</span>
<span class="cm"> * instead of leaving REAL_DMA out.</span>
<span class="cm"> */</span>

<span class="cp">#if defined(REAL_DMA)</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><pre><code>if (!cmd-&gt;device-&gt;borken &amp;&amp;
</code></pre></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">((</span><span class="n">transfersize</span> <span class="o">=</span>
		    <span class="n">NCR5380_dma_xfer_len</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="n">cmd</span><span class="p">,</span><span class="n">phase</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">SUN3_DMA_MINSIZE</span><span class="p">)</span> <span class="p">{</span>
		    <span class="n">len</span> <span class="o">=</span> <span class="n">transfersize</span><span class="p">;</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span><span class="p">;</span>

		    <span class="k">if</span> <span class="p">(</span><span class="n">NCR5380_transfer_dma</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the watchdog timer fires, all future</span>
<span class="cm">			 * accesses to this device will use the</span>
<span class="cm">			 * polled-IO. */</span> 
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;scsi%d: switching target %d &quot;</span>
			       <span class="s">&quot;lun %d to slow handshake</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">,</span>
			       <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">borken</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> 
			    <span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>
			<span class="n">sink</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">do_abort</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span>  <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="cm">/* XXX - need to source or sink data here, as appropriate */</span>
		    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef REAL_DMA</span>
			<span class="cm">/* ++roman: When using real DMA,</span>
<span class="cm">			 * information_transfer() should return after</span>
<span class="cm">			 * starting DMA since it has nothing more to</span>
<span class="cm">			 * do.</span>
<span class="cm">			 */</span>
				    <span class="k">return</span><span class="p">;</span>
<span class="cp">#else			</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">-=</span> <span class="n">transfersize</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>
<span class="cp">#endif</span>
		    <span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> 
<span class="cp">#endif </span><span class="cm">/* defined(REAL_DMA) */</span><span class="cp"></span>
		  <span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> 
		    <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="p">)</span>
		    <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
<span class="cp">#ifdef REAL_DMA</span>
		<span class="cm">/* if we had intended to dma that command clear it */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">sun3_dma_setup_done</span> <span class="o">==</span> <span class="n">cmd</span><span class="p">)</span>
			<span class="n">sun3_dma_setup_done</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="k">break</span><span class="p">;</span>
	    <span class="k">case</span> <span class="n">PHASE_MSGIN</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">;</span>
		<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 	<span class="cm">/* disable reselects */</span>
		<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Message</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		
		<span class="k">switch</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Linking lets us reduce the time required to get the </span>
<span class="cm">		 * next command out to the device, hopefully this will</span>
<span class="cm">		 * mean we don&#39;t waste another revolution due to the delays</span>
<span class="cm">		 * required by ARBITRATION and another SELECTION.</span>
<span class="cm">		 *</span>
<span class="cm">		 * In the current implementation proposal, low level drivers</span>
<span class="cm">		 * merely have to start the next command, pointed to by </span>
<span class="cm">		 * next_link, done() is called as with unlinked commands.</span>
<span class="cm">		 */</span>
<span class="cp">#ifdef LINKED</span>
		<span class="k">case</span> <span class="n">LINKED_CMD_COMPLETE</span>:
		<span class="k">case</span> <span class="n">LINKED_FLG_CMD_COMPLETE</span>:
		    <span class="cm">/* Accept message by clearing ACK */</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
		    
		    <span class="n">LNK_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: target %d lun %d linked command &quot;</span>
			       <span class="s">&quot;complete.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

		    <span class="cm">/* Enable reselect interrupts */</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
		    <span class="cm">/*</span>
<span class="cm">		     * Sanity check : A linked command should only terminate</span>
<span class="cm">		     * with one of these messages if there are more linked</span>
<span class="cm">		     * commands available.</span>
<span class="cm">		     */</span>

		    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">next_link</span><span class="p">)</span> <span class="p">{</span>
			 <span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;scsi%d: target %d lun %d &quot;</span>
				<span class="s">&quot;linked command complete, no next_link</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">HOSTNO</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			    <span class="n">sink</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			    <span class="n">do_abort</span> <span class="p">(</span><span class="n">instance</span><span class="p">);</span>
			    <span class="k">return</span><span class="p">;</span>
		    <span class="p">}</span>

		    <span class="n">initialize_SCp</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">next_link</span><span class="p">);</span>
		    <span class="cm">/* The next command is still part of this process; copy it</span>
<span class="cm">		     * and don&#39;t free it! */</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">next_link</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span> <span class="o">|</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Message</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span> 
		    <span class="n">LNK_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: target %d lun %d linked request &quot;</span>
			       <span class="s">&quot;done, calling scsi_done().</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
<span class="cp">#ifdef NCR5380_STATS</span>
		    <span class="n">collect_stats</span><span class="p">(</span><span class="n">hostdata</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="cp">#endif</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		    <span class="n">cmd</span> <span class="o">=</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">;</span>
		    <span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* def LINKED */</span><span class="cp"></span>
		<span class="k">case</span> <span class="n">ABORT</span>:
		<span class="k">case</span> <span class="n">COMMAND_COMPLETE</span>: 
		    <span class="cm">/* Accept message by clearing ACK */</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
		    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		    <span class="n">QU_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: command for target %d, lun %d &quot;</span>
			      <span class="s">&quot;completed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
		    <span class="n">cmd_free_tag</span><span class="p">(</span> <span class="n">cmd</span> <span class="p">);</span>
		    <span class="k">if</span> <span class="p">(</span><span class="n">status_byte</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span><span class="p">)</span> <span class="o">==</span> <span class="n">QUEUE_FULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Turn a QUEUE FULL status into BUSY, I think the</span>
<span class="cm">			 * mid level cannot handle QUEUE FULL :-( (The</span>
<span class="cm">			 * command is retried after BUSY). Also update our</span>
<span class="cm">			 * queue size to the number of currently issued</span>
<span class="cm">			 * commands now.</span>
<span class="cm">			 */</span>
			<span class="cm">/* ++Andreas: the mid level code knows about</span>
<span class="cm">			   QUEUE_FULL now. */</span>
			<span class="n">TAG_ALLOC</span> <span class="o">*</span><span class="n">ta</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">TagAlloc</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">][</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">];</span>
			<span class="n">TAG_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: target %d lun %d returned &quot;</span>
				   <span class="s">&quot;QUEUE_FULL after %d commands</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span>
				   <span class="n">ta</span><span class="o">-&gt;</span><span class="n">nr_allocated</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">queue_size</span> <span class="o">&gt;</span> <span class="n">ta</span><span class="o">-&gt;</span><span class="n">nr_allocated</span><span class="p">)</span>
			    <span class="n">ta</span><span class="o">-&gt;</span><span class="n">nr_allocated</span> <span class="o">=</span> <span class="n">ta</span><span class="o">-&gt;</span><span class="n">queue_size</span><span class="p">;</span>
		    <span class="p">}</span>
<span class="cp">#else</span>
		    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
<span class="cp">#endif</span>
		    <span class="cm">/* Enable reselect interrupts */</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>

		    <span class="cm">/* </span>
<span class="cm">		     * I&#39;m not sure what the correct thing to do here is : </span>
<span class="cm">		     * </span>
<span class="cm">		     * If the command that just executed is NOT a request </span>
<span class="cm">		     * sense, the obvious thing to do is to set the result</span>
<span class="cm">		     * code to the values of the stored parameters.</span>
<span class="cm">		     * </span>
<span class="cm">		     * If it was a REQUEST SENSE command, we need some way to</span>
<span class="cm">		     * differentiate between the failure code of the original</span>
<span class="cm">		     * and the failure code of the REQUEST sense - the obvious</span>
<span class="cm">		     * case is success, where we fall through and leave the</span>
<span class="cm">		     * result code unchanged.</span>
<span class="cm">		     * </span>
<span class="cm">		     * The non-obvious place is where the REQUEST SENSE failed</span>
<span class="cm">		     */</span>

		    <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> 
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span> <span class="o">|</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Message</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span> 
		    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status_byte</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GOOD</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">&amp;</span> <span class="mh">0x00ffff</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		    
<span class="cp">#ifdef AUTOSENSE</span>
		    <span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			                        <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">ses</span><span class="p">.</span><span class="n">cmd_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsi_eh_restore_cmnd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">ses</span><span class="p">);</span>
			<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">ses</span><span class="p">.</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
		    <span class="p">}</span>

		    <span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
			<span class="p">(</span><span class="n">status_byte</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span><span class="p">)</span> <span class="o">==</span> <span class="n">CHECK_CONDITION</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">scsi_eh_prep_cmnd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">ses</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">ASEN_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: performing request sense</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">HOSTNO</span><span class="p">);</span>
			<span class="cm">/* this is initialized from initialize_SCp </span>
<span class="cm">			cmd-&gt;SCp.buffer = NULL;</span>
<span class="cm">			cmd-&gt;SCp.buffers_residual = 0;</span>
<span class="cm">			*/</span>

			<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">LIST</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">);</span>
			<span class="n">SET_NEXT</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">);</span>
		        <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmd</span><span class="p">;</span>
		        <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">QU_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: REQUEST SENSE added to head of &quot;</span>
				  <span class="s">&quot;issue queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">H_NO</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
		   <span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif </span><span class="cm">/* def AUTOSENSE */</span><span class="cp"></span>
		   <span class="p">{</span>
<span class="cp">#ifdef NCR5380_STATS</span>
		       <span class="n">collect_stats</span><span class="p">(</span><span class="n">hostdata</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="cp">#endif</span>
		       <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		    <span class="p">}</span>

		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
		    <span class="cm">/* </span>
<span class="cm">		     * Restore phase bits to 0 so an interrupted selection, </span>
<span class="cm">		     * arbitration can resume.</span>
<span class="cm">		     */</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		    
		    <span class="k">while</span> <span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_BSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span>
			<span class="n">barrier</span><span class="p">();</span>

		    <span class="k">return</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MESSAGE_REJECT</span>:
		    <span class="cm">/* Accept message by clearing ACK */</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
		    <span class="cm">/* Enable reselect interrupts */</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
		    <span class="k">switch</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">last_message</span><span class="p">)</span> <span class="p">{</span>
		    <span class="k">case</span> <span class="n">HEAD_OF_QUEUE_TAG</span>:
		    <span class="k">case</span> <span class="n">ORDERED_QUEUE_TAG</span>:
		    <span class="k">case</span> <span class="n">SIMPLE_QUEUE_TAG</span>:
			<span class="cm">/* The target obviously doesn&#39;t support tagged</span>
<span class="cm">			 * queuing, even though it announced this ability in</span>
<span class="cm">			 * its INQUIRY data ?!? (maybe only this LUN?) Ok,</span>
<span class="cm">			 * clear &#39;tagged_supported&#39; and lock the LUN, since</span>
<span class="cm">			 * the command is treated as untagged further on.</span>
<span class="cm">			 */</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">tagged_supported</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">TAG_NONE</span><span class="p">;</span>
			<span class="n">TAG_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: target %d lun %d rejected &quot;</span>
				   <span class="s">&quot;QUEUE_TAG message; tagged queuing &quot;</span>
				   <span class="s">&quot;disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		    <span class="p">}</span>
		    <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DISCONNECT</span>:
		    <span class="cm">/* Accept message by clearing ACK */</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
		    <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">disconnect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		    <span class="n">LIST</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">);</span>
		    <span class="n">SET_NEXT</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">);</span>
		    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
		    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		    <span class="n">QU_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: command for target %d lun %d was &quot;</span>
			      <span class="s">&quot;moved from connected to the &quot;</span>
			      <span class="s">&quot;disconnected_queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">,</span> 
			      <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
		    <span class="cm">/* </span>
<span class="cm">		     * Restore phase bits to 0 so an interrupted selection, </span>
<span class="cm">		     * arbitration can resume.</span>
<span class="cm">		     */</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		    <span class="cm">/* Enable reselect interrupts */</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
		    <span class="cm">/* Wait for bus free to avoid nasty timeouts */</span>
		    <span class="k">while</span> <span class="p">((</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_BSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span>
		    	<span class="n">barrier</span><span class="p">();</span>
<span class="cp">#ifdef SUN3_SCSI_VME</span>
		    <span class="n">dregs</span><span class="o">-&gt;</span><span class="n">csr</span> <span class="o">|=</span> <span class="n">CSR_DMA_ENABLE</span><span class="p">;</span>
<span class="cp">#endif</span>
		    <span class="k">return</span><span class="p">;</span>
		<span class="cm">/* </span>
<span class="cm">		 * The SCSI data pointer is *IMPLICITLY* saved on a disconnect</span>
<span class="cm">		 * operation, in violation of the SCSI spec so we can safely </span>
<span class="cm">		 * ignore SAVE/RESTORE pointers calls.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Unfortunately, some disks violate the SCSI spec and </span>
<span class="cm">		 * don&#39;t issue the required SAVE_POINTERS message before</span>
<span class="cm">		 * disconnecting, and we have to break spec to remain </span>
<span class="cm">		 * compatible.</span>
<span class="cm">		 */</span>
		<span class="k">case</span> <span class="n">SAVE_POINTERS</span>:
		<span class="k">case</span> <span class="n">RESTORE_POINTERS</span>:
		    <span class="cm">/* Accept message by clearing ACK */</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
		    <span class="cm">/* Enable reselect interrupts */</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
		    <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">EXTENDED_MESSAGE</span>:
<span class="cm">/* </span>
<span class="cm"> * Extended messages are sent in the following format :</span>
<span class="cm"> * Byte 	</span>
<span class="cm"> * 0		EXTENDED_MESSAGE == 1</span>
<span class="cm"> * 1		length (includes one byte for code, doesn&#39;t </span>
<span class="cm"> *		include first two bytes)</span>
<span class="cm"> * 2 		code</span>
<span class="cm"> * 3..length+1	arguments</span>
<span class="cm"> *</span>
<span class="cm"> * Start the extended message buffer with the EXTENDED_MESSAGE</span>
<span class="cm"> * byte, since spi_print_msg() wants the whole thing.  </span>
<span class="cm"> */</span>
		    <span class="n">extended_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXTENDED_MESSAGE</span><span class="p">;</span>
		    <span class="cm">/* Accept first byte by clearing ACK */</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>

		    <span class="n">EXT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: receiving extended message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>

		    <span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		    <span class="n">data</span> <span class="o">=</span> <span class="n">extended_msg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		    <span class="n">phase</span> <span class="o">=</span> <span class="n">PHASE_MSGIN</span><span class="p">;</span>
		    <span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		    <span class="n">EXT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: length=%d, code=0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">extended_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">extended_msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

		    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> 
			<span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">extended_msg</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Accept third byte by clearing ACK */</span>
			<span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">extended_msg</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">phase</span> <span class="o">=</span> <span class="n">PHASE_MSGIN</span><span class="p">;</span>

			<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
			<span class="n">EXT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: message received, residual %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">extended_msg</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">EXTENDED_SDTR</span>:
			<span class="k">case</span> <span class="n">EXTENDED_WDTR</span>:
			<span class="k">case</span> <span class="n">EXTENDED_MODIFY_DATA_POINTER</span>:
			<span class="k">case</span> <span class="n">EXTENDED_EXTENDED_IDENTIFY</span>:
			    <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;scsi%d: error receiving &quot;</span>
			       <span class="s">&quot;extended message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;scsi%d: extended message &quot;</span>
			       <span class="s">&quot;code %02x length %d is too long</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		    <span class="p">}</span>
		<span class="cm">/* Fall through to reject message */</span>

		<span class="cm">/* </span>
<span class="cm">  		 * If we get something weird that we aren&#39;t expecting, </span>
<span class="cm"> 		 * reject it.</span>
<span class="cm">		 */</span>
		<span class="nl">default:</span>
		    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;scsi%d: rejecting message &quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
			<span class="n">spi_print_msg</span><span class="p">(</span><span class="n">extended_msg</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">EXTENDED_MESSAGE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;scsi%d: rejecting unknown &quot;</span>
			       <span class="s">&quot;message %02x from target %d, lun %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
		    <span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;scsi%d: rejecting unknown &quot;</span>
			       <span class="s">&quot;extended message &quot;</span>
			       <span class="s">&quot;code %02x, length %d from target %d, lun %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">extended_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			       <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
   

		    <span class="n">msgout</span> <span class="o">=</span> <span class="n">MESSAGE_REJECT</span><span class="p">;</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> 
			<span class="n">ICR_ASSERT_ATN</span><span class="p">);</span>
		    <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="cm">/* switch (tmp) */</span>
		<span class="k">break</span><span class="p">;</span>
	    <span class="k">case</span> <span class="n">PHASE_MSGOUT</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msgout</span><span class="p">;</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">last_message</span> <span class="o">=</span> <span class="n">msgout</span><span class="p">;</span>
		<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msgout</span> <span class="o">==</span> <span class="n">ABORT</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
		    <span class="n">cmd_free_tag</span><span class="p">(</span> <span class="n">cmd</span> <span class="p">);</span>
<span class="cp">#else</span>
		    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
<span class="cp">#endif</span>
		    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="cp">#ifdef NCR5380_STATS</span>
		    <span class="n">collect_stats</span><span class="p">(</span><span class="n">hostdata</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="cp">#endif</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>
		    <span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msgout</span> <span class="o">=</span> <span class="n">NOP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	    <span class="k">case</span> <span class="n">PHASE_CMDOUT</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">;</span>
		<span class="cm">/* </span>
<span class="cm">		 * XXX for performance reasons, on machines with a </span>
<span class="cm">		 * PSEUDO-DMA architecture we should probably </span>
<span class="cm">		 * use the dma transfer function.  </span>
<span class="cm">		 */</span>
		<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> 
		    <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	    <span class="k">case</span> <span class="n">PHASE_STATIN</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">;</span>
		<span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	    <span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d: unknown phase</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
		<span class="n">NCR_PRINT</span><span class="p">(</span><span class="n">NDEBUG_ANY</span><span class="p">);</span>
	    <span class="p">}</span> <span class="cm">/* switch(phase) */</span>
	<span class="p">}</span> <span class="cm">/* if (tmp * SR_REQ) */</span> 
    <span class="p">}</span> <span class="cm">/* while (1) */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function : void NCR5380_reselect (struct Scsi_Host *instance)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : does reselection, initializing the instance-&gt;connected </span>
<span class="cm"> *	field to point to the struct scsi_cmnd for which the I_T_L or I_T_L_Q</span>
<span class="cm"> *	nexus has been reestablished,</span>
<span class="cm"> *	</span>
<span class="cm"> * Inputs : instance - this instance of the NCR5380.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/* it might eventually prove necessary to do a dma setup on</span>
<span class="cm">   reselection, but it doesn&#39;t seem to be needed now -- sam */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">NCR5380_reselect</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SETUP_HOSTDATA</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">target_mask</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lun</span><span class="p">;</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tag</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="cm">/*    unsigned long flags; */</span>

    <span class="cm">/*</span>
<span class="cm">     * Disable arbitration, etc. since the host adapter obviously</span>
<span class="cm">     * lost, and tell an interrupted NCR5380_select() to restart.</span>
<span class="cm">     */</span>

    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span><span class="p">);</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">restart_select</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">target_mask</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">CURRENT_SCSI_DATA_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">id_mask</span><span class="p">);</span>

    <span class="n">RSL_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: reselect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>

    <span class="cm">/* </span>
<span class="cm">     * At this point, we have detected that our SCSI ID is on the bus,</span>
<span class="cm">     * SEL is true and BSY was false for at least one bus settle delay</span>
<span class="cm">     * (400 ns).</span>
<span class="cm">     *</span>
<span class="cm">     * We must assert BSY ourselves, until the target drops the SEL</span>
<span class="cm">     * signal.</span>
<span class="cm">     */</span>

    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_BSY</span><span class="p">);</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_SEL</span><span class="p">);</span>
    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Wait for target to go into MSGIN.</span>
<span class="cm">     */</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SR_REQ</span><span class="p">));</span>

<span class="cp">#if 1</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>acknowledge toggle to MSGIN</p></td><td class="code"><div class="highlight"><pre>    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="n">PHASE_SR_TO_TCR</span><span class="p">(</span><span class="n">PHASE_MSGIN</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>peek at the byte without really hitting the bus</p></td><td class="code"><div class="highlight"><pre>    <span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">CURRENT_SCSI_DATA_REG</span><span class="p">);</span>
<span class="cp">#endif</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;scsi%d: expecting IDENTIFY message, got &quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
	<span class="n">spi_print_msg</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">do_abort</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">lun</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">);</span>

    <span class="cm">/* </span>
<span class="cm">     * Find the command corresponding to the I_T_L or I_T_L_Q  nexus we </span>
<span class="cm">     * just reestablished, and remove it from the disconnected queue.</span>
<span class="cm">     */</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	 <span class="n">tmp</span><span class="p">;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">target_mask</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lun</span> <span class="o">==</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">)</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">)</span> 
<span class="cp">#endif</span>
	    <span class="p">)</span> <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">REMOVE</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">prev</span><span class="p">),</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
		<span class="n">SET_NEXT</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
	    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">REMOVE</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
		<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span> <span class="o">=</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	    <span class="p">}</span>
	    <span class="n">SET_NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	    <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;scsi%d: warning: target bitmask %02x lun %d &quot;</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
		<span class="s">&quot;tag %d &quot;</span>
<span class="cp">#endif</span>
		<span class="s">&quot;not in disconnected_queue.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">HOSTNO</span><span class="p">,</span> <span class="n">target_mask</span><span class="p">,</span> <span class="n">lun</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
		<span class="p">,</span> <span class="n">tag</span>
<span class="cp">#endif</span>
		<span class="p">);</span>
	<span class="cm">/* </span>
<span class="cm">	 * Since we have an established nexus that we can&#39;t do anything</span>
<span class="cm">	 * with, we must abort it.  </span>
<span class="cm">	 */</span>
	<span class="n">do_abort</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#if 1</span>
    <span class="cm">/* engage dma setup for the command we just saw */</span>
    <span class="p">{</span>
	    <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
	    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>

	    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span><span class="p">)</span> <span class="p">{</span>
		    <span class="n">count</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		    <span class="n">d</span> <span class="o">=</span> <span class="n">SGADDR</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
	    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		    <span class="n">count</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span><span class="p">;</span>
		    <span class="n">d</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
	    <span class="p">}</span>
<span class="cp">#ifdef REAL_DMA</span>
	    <span class="cm">/* setup this command for dma if not already */</span>
	    <span class="k">if</span><span class="p">((</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">SUN3_DMA_MINSIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sun3_dma_setup_done</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">))</span>
	    <span class="p">{</span>
		    <span class="n">sun3scsi_dma_setup</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">rq_data_dir</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">));</span>
		    <span class="n">sun3_dma_setup_done</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	    <span class="p">}</span>
<span class="cp">#endif</span>
    <span class="p">}</span>
<span class="cp">#endif</span>

    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_ACK</span><span class="p">);</span>
    <span class="cm">/* Accept message by clearing ACK */</span>
    <span class="n">NCR5380_write</span><span class="p">(</span><span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span><span class="p">);</span>

<span class="cp">#ifdef SUPPORT_TAGS</span>
    <span class="cm">/* If the phase is still MSGIN, the target wants to send some more</span>
<span class="cm">     * messages. In case it supports tagged queuing, this is probably a</span>
<span class="cm">     * SIMPLE_QUEUE_TAG for the I_T_L_Q nexus.</span>
<span class="cm">     */</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="n">TAG_NONE</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">phase</span> <span class="o">==</span> <span class="n">PHASE_MSGIN</span> <span class="o">&amp;&amp;</span> <span class="n">setup_use_tagged_queuing</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* Accept previous IDENTIFY message by clearing ACK */</span>
	<span class="n">NCR5380_write</span><span class="p">(</span> <span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">msg</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NCR5380_transfer_pio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">SIMPLE_QUEUE_TAG</span><span class="p">)</span>
	    <span class="n">tag</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">TAG_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: target mask %02x, lun %d sent tag %d at &quot;</span>
		   <span class="s">&quot;reselection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">target_mask</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#endif</span>
    
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="n">RSL_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: nexus established, target = %d, lun = %d, tag = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">HOSTNO</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Function : int NCR5380_abort(struct scsi_cmnd *cmd)</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose : abort a command</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs : cmd - the struct scsi_cmnd to abort, code - code to set the</span>
<span class="cm"> * 	host byte of the result field to, if zero DID_ABORTED is </span>
<span class="cm"> *	used.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns : 0 - success, -1 on failure.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX - there is no way to abort the command that is currently </span>
<span class="cm"> * 	 connected, you have to wait for it to complete.  If this is </span>
<span class="cm"> *	 a problem, we could implement longjmp() / setjmp(), setjmp()</span>
<span class="cm"> * 	 called where the loop started in NCR5380_main().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">NCR5380_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
    <span class="n">SETUP_HOSTDATA</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">**</span><span class="n">prev</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;scsi%d: aborting command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
    <span class="n">scsi_print_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

    <span class="n">NCR5380_print_status</span> <span class="p">(</span><span class="n">instance</span><span class="p">);</span>

    <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    
    <span class="n">ABRT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: abort called basr 0x%02x, sr 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">,</span>
		<span class="n">NCR5380_read</span><span class="p">(</span><span class="n">BUS_AND_STATUS_REG</span><span class="p">),</span>
		<span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">));</span>

<span class="cp">#if 1</span>
<span class="cm">/* </span>
<span class="cm"> * Case 1 : If the command is the currently executing command, </span>
<span class="cm"> * we&#39;ll set the aborted flag and return control so that </span>
<span class="cm"> * information transfer routine can exit cleanly.</span>
<span class="cm"> */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">==</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">ABRT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: aborting connected command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * We should perform BSY checking, and make sure we haven&#39;t slipped</span>
<span class="cm"> * into BUS FREE.</span>
<span class="cm"> */</span>

<span class="cm">/*	NCR5380_write(INITIATOR_COMMAND_REG, ICR_ASSERT_ATN); */</span>
<span class="cm">/* </span>
<span class="cm"> * Since we can&#39;t change phases until we&#39;ve completed the current </span>
<span class="cm"> * handshake, we have to source or sink a byte of data if the current</span>
<span class="cm"> * phase is not MSGOUT.</span>
<span class="cm"> */</span>

<span class="cm">/* </span>
<span class="cm"> * Return control to the executing NCR drive so we can clear the</span>
<span class="cm"> * aborted flag and get back into our main loop.</span>
<span class="cm"> */</span> 

	<span class="k">if</span> <span class="p">(</span><span class="n">do_abort</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	  <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">aborted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	  <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	  <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
	  <span class="n">cmd_free_tag</span><span class="p">(</span> <span class="n">cmd</span> <span class="p">);</span>
<span class="cp">#else</span>
	  <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
<span class="cp">#endif</span>
	  <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	  <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	  <span class="k">return</span> <span class="n">SCSI_ABORT_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cm">/*	  local_irq_restore(flags); */</span>
	  <span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d: abort of connected command failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
	  <span class="k">return</span> <span class="n">SCSI_ABORT_ERROR</span><span class="p">;</span>
	<span class="p">}</span> 
   <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* </span>
<span class="cm"> * Case 2 : If the command hasn&#39;t been issued yet, we simply remove it </span>
<span class="cm"> * 	    from the issue queue.</span>
<span class="cm"> */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">),</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">NEXTADDR</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">REMOVE</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
	    <span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span> <span class="o">=</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	    <span class="n">SET_NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	    <span class="n">ABRT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: abort removed command from issue queue.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">HOSTNO</span><span class="p">);</span>
	    <span class="cm">/* Tagged queuing note: no tag to free here, hasn&#39;t been assigned</span>
<span class="cm">	     * yet... */</span>
	    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	    <span class="k">return</span> <span class="n">SCSI_ABORT_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> * Case 3 : If any commands are connected, we&#39;re going to fail the abort</span>
<span class="cm"> *	    and let the high level SCSI driver retry at a later time or </span>
<span class="cm"> *	    issue a reset.</span>
<span class="cm"> *</span>
<span class="cm"> *	    Timeouts, and therefore aborted commands, will be highly unlikely</span>
<span class="cm"> *          and handling them cleanly in this situation would make the common</span>
<span class="cm"> *	    case of noresets less efficient, and would pollute our code.  So,</span>
<span class="cm"> *	    we fail.</span>
<span class="cm"> */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ABRT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: abort failed, command connected.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">SCSI_ABORT_SNOOZE</span><span class="p">;</span>
    <span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Case 4: If the command is currently disconnected from the bus, and </span>
<span class="cm"> * 	there are no connected commands, we reconnect the I_T_L or </span>
<span class="cm"> *	I_T_L_Q nexus associated with it, go into message out, and send </span>
<span class="cm"> *      an abort message.</span>
<span class="cm"> *</span>
<span class="cm"> * This case is especially ugly. In order to reestablish the nexus, we</span>
<span class="cm"> * need to call NCR5380_select().  The easiest way to implement this </span>
<span class="cm"> * function was to abort if the bus was busy, and let the interrupt</span>
<span class="cm"> * handler triggered on the SEL for reselect take care of lost arbitrations</span>
<span class="cm"> * where necessary, meaning interrupts need to be enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * When interrupts are enabled, the queues may change - so we </span>
<span class="cm"> * can&#39;t remove it from the disconnected queue before selecting it</span>
<span class="cm"> * because that could cause a failure in hashing the nexus if that </span>
<span class="cm"> * device reselected.</span>
<span class="cm"> * </span>
<span class="cm"> * Since the queues may change, we can&#39;t use the pointers from when we</span>
<span class="cm"> * first locate it.</span>
<span class="cm"> *</span>
<span class="cm"> * So, we must first locate the command, and if NCR5380_select()</span>
<span class="cm"> * succeeds, then issue the abort, relocate the command and remove</span>
<span class="cm"> * it from the disconnected queue.</span>
<span class="cm"> */</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">;</span> <span class="n">tmp</span><span class="p">;</span>
	 <span class="n">tmp</span> <span class="o">=</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	    <span class="n">ABRT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: aborting disconnected command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>
  
            <span class="k">if</span> <span class="p">(</span><span class="n">NCR5380_select</span> <span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">))</span> 
		<span class="k">return</span> <span class="n">SCSI_ABORT_BUSY</span><span class="p">;</span>

	    <span class="n">ABRT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: nexus reestablished.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span>

	    <span class="n">do_abort</span> <span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	    <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	    <span class="k">for</span> <span class="p">(</span><span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">),</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">;</span>
		<span class="n">tmp</span><span class="p">;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">NEXTADDR</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">)</span>
		    <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		    <span class="n">REMOVE</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
		    <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		    <span class="n">SET_NEXT</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		    <span class="cm">/* We must unlock the tag/LUN immediately here, since the</span>
<span class="cm">		     * target goes to BUS FREE and doesn&#39;t send us another</span>
<span class="cm">		     * message (COMMAND_COMPLETE or the like)</span>
<span class="cm">		     */</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
		    <span class="n">cmd_free_tag</span><span class="p">(</span> <span class="n">tmp</span> <span class="p">);</span>
<span class="cp">#else</span>
		    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
<span class="cp">#endif</span>
		    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		    <span class="k">return</span> <span class="n">SCSI_ABORT_SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Case 5 : If we reached this point, the command was not found in any of </span>
<span class="cm"> *	    the queues.</span>
<span class="cm"> *</span>
<span class="cm"> * We probably reached this point because of an unlikely race condition</span>
<span class="cm"> * between the command completing successfully and the abortion code,</span>
<span class="cm"> * so we won&#39;t panic, but we will notify the user in case something really</span>
<span class="cm"> * broke.</span>
<span class="cm"> */</span>

    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scsi%d: warning : SCSI command probably completed successfully before abortion</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HOSTNO</span><span class="p">);</span> 

    <span class="k">return</span> <span class="n">SCSI_ABORT_NOT_RUNNING</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* </span>
<span class="cm"> * Function : int NCR5380_bus_reset(struct scsi_cmnd *cmd)</span>
<span class="cm"> * </span>
<span class="cm"> * Purpose : reset the SCSI bus.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns : SCSI_RESET_WAKEUP</span>
<span class="cm"> *</span>
<span class="cm"> */</span> 

<span class="k">static</span> <span class="kt">int</span> <span class="nf">NCR5380_bus_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SETUP_HOSTDATA</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
    <span class="kt">int</span>           <span class="n">i</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#if 1</span>
    <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">connected</span><span class="p">,</span> <span class="o">*</span><span class="n">disconnected_queue</span><span class="p">;</span>
<span class="cp">#endif</span>


    <span class="n">NCR5380_print_status</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

    <span class="cm">/* get in phase */</span>
    <span class="n">NCR5380_write</span><span class="p">(</span> <span class="n">TARGET_COMMAND_REG</span><span class="p">,</span>
		   <span class="n">PHASE_SR_TO_TCR</span><span class="p">(</span> <span class="n">NCR5380_read</span><span class="p">(</span><span class="n">STATUS_REG</span><span class="p">)</span> <span class="p">));</span>
    <span class="cm">/* assert RST */</span>
    <span class="n">NCR5380_write</span><span class="p">(</span> <span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="o">|</span> <span class="n">ICR_ASSERT_RST</span> <span class="p">);</span>
    <span class="n">udelay</span> <span class="p">(</span><span class="mi">40</span><span class="p">);</span>
    <span class="cm">/* reset NCR registers */</span>
    <span class="n">NCR5380_write</span><span class="p">(</span> <span class="n">INITIATOR_COMMAND_REG</span><span class="p">,</span> <span class="n">ICR_BASE</span> <span class="p">);</span>
    <span class="n">NCR5380_write</span><span class="p">(</span> <span class="n">MODE_REG</span><span class="p">,</span> <span class="n">MR_BASE</span> <span class="p">);</span>
    <span class="n">NCR5380_write</span><span class="p">(</span> <span class="n">TARGET_COMMAND_REG</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="n">NCR5380_write</span><span class="p">(</span> <span class="n">SELECT_ENABLE_REG</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="cm">/* ++roman: reset interrupt condition! otherwise no interrupts don&#39;t get</span>
<span class="cm">     * through anymore ... */</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">NCR5380_read</span><span class="p">(</span> <span class="n">RESET_PARITY_INTERRUPT_REG</span> <span class="p">);</span>

<span class="cp">#if 1 </span><span class="cm">/* XXX Should now be done by midlevel code, but it&#39;s broken XXX */</span><span class="cp"></span>
      <span class="cm">/* XXX see below                                            XXX */</span>

    <span class="cm">/* MSch: old-style reset: actually abort all command processing here */</span>

    <span class="cm">/* After the reset, there are no more connected or disconnected commands</span>
<span class="cm">     * and no busy units; to avoid problems with re-inserting the commands</span>
<span class="cm">     * into the issue_queue (via scsi_done()), the aborted commands are</span>
<span class="cm">     * remembered in local variables first.</span>
<span class="cm">     */</span>
    <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    <span class="n">connected</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">;</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">disconnected_queue</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">;</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
    <span class="n">free_all_tags</span><span class="p">();</span>
<span class="cp">#endif</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef REAL_DMA</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">dma_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

    <span class="cm">/* In order to tell the mid-level code which commands were aborted, </span>
<span class="cm">     * set the command status to DID_RESET and call scsi_done() !!!</span>
<span class="cm">     * This ultimately aborts processing of these commands in the mid-level.</span>
<span class="cm">     */</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">connected</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">ABRT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: reset aborted a connected command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">H_NO</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">DID_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span> <span class="n">cmd</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">disconnected_queue</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">disconnected_queue</span> <span class="o">=</span> <span class="n">NEXT</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">SET_NEXT</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">DID_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span> <span class="n">cmd</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">ABRT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi: reset aborted %d disconnected command(s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>


    <span class="cm">/* since all commands have been explicitly terminated, we need to tell</span>
<span class="cm">     * the midlevel code that the reset was SUCCESSFUL, and there is no </span>
<span class="cm">     * need to &#39;wake up&#39; the commands by a request_sense</span>
<span class="cm">     */</span>
    <span class="k">return</span> <span class="n">SCSI_RESET_SUCCESS</span> <span class="o">|</span> <span class="n">SCSI_RESET_BUS_RESET</span><span class="p">;</span>
<span class="cp">#else </span><span class="cm">/* 1 */</span><span class="cp"></span>

    <span class="cm">/* MSch: new-style reset handling: let the mid-level do what it can */</span>

    <span class="cm">/* ++guenther: MID-LEVEL IS STILL BROKEN.</span>
<span class="cm">     * Mid-level is supposed to requeue all commands that were active on the</span>
<span class="cm">     * various low-level queues. In fact it does this, but that&#39;s not enough</span>
<span class="cm">     * because all these commands are subject to timeout. And if a timeout</span>
<span class="cm">     * happens for any removed command, *_abort() is called but all queues</span>
<span class="cm">     * are now empty. Abort then gives up the falcon lock, which is fatal,</span>
<span class="cm">     * since the mid-level will queue more commands and must have the lock</span>
<span class="cm">     * (it&#39;s all happening inside timer interrupt handler!!).</span>
<span class="cm">     * Even worse, abort will return NOT_RUNNING for all those commands not</span>
<span class="cm">     * on any queue, so they won&#39;t be retried ...</span>
<span class="cm">     *</span>
<span class="cm">     * Conclusion: either scsi.c disables timeout for all resetted commands</span>
<span class="cm">     * immediately, or we lose!  As of linux-2.0.20 it doesn&#39;t.</span>
<span class="cm">     */</span>

    <span class="cm">/* After the reset, there are no more connected or disconnected commands</span>
<span class="cm">     * and no busy units; so clear the low-level status here to avoid </span>
<span class="cm">     * conflicts when the mid-level code tries to wake up the affected </span>
<span class="cm">     * commands!</span>
<span class="cm">     */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span><span class="p">)</span>
	<span class="n">ABRT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: reset aborted issued command(s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">H_NO</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> 
	<span class="n">ABRT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: reset aborted a connected command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">H_NO</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span><span class="p">)</span>
	<span class="n">ABRT_PRINTK</span><span class="p">(</span><span class="s">&quot;scsi%d: reset aborted disconnected command(s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">H_NO</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

    <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">issue_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">disconnected_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#ifdef SUPPORT_TAGS</span>
    <span class="n">free_all_tags</span><span class="p">();</span>
<span class="cp">#endif</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
	<span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef REAL_DMA</span>
    <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">dma_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

    <span class="cm">/* we did no complete reset of all commands, so a wakeup is required */</span>
    <span class="k">return</span> <span class="n">SCSI_RESET_WAKEUP</span> <span class="o">|</span> <span class="n">SCSI_RESET_BUS_RESET</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* 1 */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cm">/* Local Variables: */</span>
<span class="cm">/* tab-width: 8     */</span>
<span class="cm">/* End:             */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
