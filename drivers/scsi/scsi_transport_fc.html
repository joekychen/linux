<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › scsi_transport_fc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>scsi_transport_fc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  FiberChannel transport specific attributes exported to sysfs.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2003 Silicon Graphics, Inc.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> *</span>
<span class="cm"> *  ========</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2004-2007   James Smart, Emulex Corporation</span>
<span class="cm"> *    Rewrite for host, target, device, and remote port attributes,</span>
<span class="cm"> *    statistics, and service functions...</span>
<span class="cm"> *    Add vports, etc</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_fc.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;linux/netlink.h&gt;</span>
<span class="cp">#include &lt;net/netlink.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_netlink_fc.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_bsg_fc.h&gt;</span>
<span class="cp">#include &quot;scsi_priv.h&quot;</span>
<span class="cp">#include &quot;scsi_transport_fc_internal.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">fc_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_vport_sched_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fc_vport_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_vport_identifiers</span>  <span class="o">*</span><span class="n">ids</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">**</span><span class="n">vport</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fc_bsg_hostadd</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_host_attrs</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fc_bsg_rportadd</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_bsg_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_bsg_goose_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Module Parameters</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * dev_loss_tmo: the default number of seconds that the FC transport</span>
<span class="cm"> *   should insulate the loss of a remote port.</span>
<span class="cm"> *   The maximum will be capped by the value of SCSI_DEVICE_BLOCK_MAX_TIMEOUT.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fc_dev_loss_tmo</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>		<span class="cm">/* seconds */</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">dev_loss_tmo</span><span class="p">,</span> <span class="n">fc_dev_loss_tmo</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">dev_loss_tmo</span><span class="p">,</span>
		 <span class="s">&quot;Maximum number of seconds that the FC transport should&quot;</span>
		 <span class="s">&quot; insulate the loss of a remote port. Once this value is&quot;</span>
		 <span class="s">&quot; exceeded, the scsi target is removed. Value should be&quot;</span>
		 <span class="s">&quot; between 1 and SCSI_DEVICE_BLOCK_MAX_TIMEOUT if&quot;</span>
		 <span class="s">&quot; fast_io_fail_tmo is not set.&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Redefine so that we can have same named attributes in the</span>
<span class="cm"> * sdev/starget/host objects.</span>
<span class="cm"> */</span>
<span class="cp">#define FC_DEVICE_ATTR(_prefix,_name,_mode,_show,_store)		\</span>
<span class="cp">struct device_attribute device_attr_##_prefix##_##_name = 	\</span>
<span class="cp">	__ATTR(_name,_mode,_show,_store)</span>

<span class="cp">#define fc_enum_name_search(title, table_type, table)			\</span>
<span class="cp">static const char *get_fc_##title##_name(enum table_type table_key)	\</span>
<span class="cp">{									\</span>
<span class="cp">	int i;								\</span>
<span class="cp">	char *name = NULL;						\</span>
<span class="cp">									\</span>
<span class="cp">	for (i = 0; i &lt; ARRAY_SIZE(table); i++) {			\</span>
<span class="cp">		if (table[i].value == table_key) {			\</span>
<span class="cp">			name = table[i].name;				\</span>
<span class="cp">			break;						\</span>
<span class="cp">		}							\</span>
<span class="cp">	}								\</span>
<span class="cp">	return name;							\</span>
<span class="cp">}</span>

<span class="cp">#define fc_enum_name_match(title, table_type, table)			\</span>
<span class="cp">static int get_fc_##title##_match(const char *table_key,		\</span>
<span class="cp">		enum table_type *value)					\</span>
<span class="cp">{									\</span>
<span class="cp">	int i;								\</span>
<span class="cp">									\</span>
<span class="cp">	for (i = 0; i &lt; ARRAY_SIZE(table); i++) {			\</span>
<span class="cp">		if (strncmp(table_key, table[i].name,			\</span>
<span class="cp">				table[i].matchlen) == 0) {		\</span>
<span class="cp">			*value = table[i].value;			\</span>
<span class="cp">			return 0; </span><span class="cm">/* success */</span><span class="cp">				\</span>
<span class="cp">		}							\</span>
<span class="cp">	}								\</span>
<span class="cp">	return 1; </span><span class="cm">/* failure */</span><span class="cp">						\</span>
<span class="cp">}</span>


<span class="cm">/* Convert fc_port_type values to ascii string name */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">fc_port_type</span>	<span class="n">value</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fc_port_type_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">FC_PORTTYPE_UNKNOWN</span><span class="p">,</span>		<span class="s">&quot;Unknown&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTTYPE_OTHER</span><span class="p">,</span>		<span class="s">&quot;Other&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTTYPE_NOTPRESENT</span><span class="p">,</span>	<span class="s">&quot;Not Present&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTTYPE_NPORT</span><span class="p">,</span>	<span class="s">&quot;NPort (fabric via point-to-point)&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTTYPE_NLPORT</span><span class="p">,</span>	<span class="s">&quot;NLPort (fabric via loop)&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTTYPE_LPORT</span><span class="p">,</span>	<span class="s">&quot;LPort (private loop)&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTTYPE_PTP</span><span class="p">,</span>	<span class="s">&quot;Point-To-Point (direct nport connection)&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTTYPE_NPIV</span><span class="p">,</span>		<span class="s">&quot;NPIV VPORT&quot;</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">fc_enum_name_search</span><span class="p">(</span><span class="n">port_type</span><span class="p">,</span> <span class="n">fc_port_type</span><span class="p">,</span> <span class="n">fc_port_type_names</span><span class="p">)</span>
<span class="cp">#define FC_PORTTYPE_MAX_NAMELEN		50</span>

<span class="cm">/* Reuse fc_port_type enum function for vport_type */</span>
<span class="cp">#define get_fc_vport_type_name get_fc_port_type_name</span>


<span class="cm">/* Convert fc_host_event_code values to ascii string name */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">fc_host_event_code</span>		<span class="n">value</span><span class="p">;</span>
	<span class="kt">char</span>				<span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fc_host_event_code_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">FCH_EVT_LIP</span><span class="p">,</span>			<span class="s">&quot;lip&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FCH_EVT_LINKUP</span><span class="p">,</span>		<span class="s">&quot;link_up&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FCH_EVT_LINKDOWN</span><span class="p">,</span>		<span class="s">&quot;link_down&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FCH_EVT_LIPRESET</span><span class="p">,</span>		<span class="s">&quot;lip_reset&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FCH_EVT_RSCN</span><span class="p">,</span>			<span class="s">&quot;rscn&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FCH_EVT_ADAPTER_CHANGE</span><span class="p">,</span>	<span class="s">&quot;adapter_chg&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FCH_EVT_PORT_UNKNOWN</span><span class="p">,</span>		<span class="s">&quot;port_unknown&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FCH_EVT_PORT_ONLINE</span><span class="p">,</span>		<span class="s">&quot;port_online&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FCH_EVT_PORT_OFFLINE</span><span class="p">,</span>		<span class="s">&quot;port_offline&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FCH_EVT_PORT_FABRIC</span><span class="p">,</span>		<span class="s">&quot;port_fabric&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FCH_EVT_LINK_UNKNOWN</span><span class="p">,</span>		<span class="s">&quot;link_unknown&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FCH_EVT_VENDOR_UNIQUE</span><span class="p">,</span>	<span class="s">&quot;vendor_unique&quot;</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">fc_enum_name_search</span><span class="p">(</span><span class="n">host_event_code</span><span class="p">,</span> <span class="n">fc_host_event_code</span><span class="p">,</span>
		<span class="n">fc_host_event_code_names</span><span class="p">)</span>
<span class="cp">#define FC_HOST_EVENT_CODE_MAX_NAMELEN	30</span>


<span class="cm">/* Convert fc_port_state values to ascii string name */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">fc_port_state</span>	<span class="n">value</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fc_port_state_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">FC_PORTSTATE_UNKNOWN</span><span class="p">,</span>		<span class="s">&quot;Unknown&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSTATE_NOTPRESENT</span><span class="p">,</span>	<span class="s">&quot;Not Present&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSTATE_ONLINE</span><span class="p">,</span>		<span class="s">&quot;Online&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSTATE_OFFLINE</span><span class="p">,</span>		<span class="s">&quot;Offline&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSTATE_BLOCKED</span><span class="p">,</span>		<span class="s">&quot;Blocked&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSTATE_BYPASSED</span><span class="p">,</span>	<span class="s">&quot;Bypassed&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSTATE_DIAGNOSTICS</span><span class="p">,</span>	<span class="s">&quot;Diagnostics&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSTATE_LINKDOWN</span><span class="p">,</span>	<span class="s">&quot;Linkdown&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSTATE_ERROR</span><span class="p">,</span>		<span class="s">&quot;Error&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSTATE_LOOPBACK</span><span class="p">,</span>	<span class="s">&quot;Loopback&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSTATE_DELETED</span><span class="p">,</span>		<span class="s">&quot;Deleted&quot;</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">fc_enum_name_search</span><span class="p">(</span><span class="n">port_state</span><span class="p">,</span> <span class="n">fc_port_state</span><span class="p">,</span> <span class="n">fc_port_state_names</span><span class="p">)</span>
<span class="cp">#define FC_PORTSTATE_MAX_NAMELEN	20</span>


<span class="cm">/* Convert fc_vport_state values to ascii string name */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">fc_vport_state</span>	<span class="n">value</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fc_vport_state_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">FC_VPORT_UNKNOWN</span><span class="p">,</span>		<span class="s">&quot;Unknown&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_VPORT_ACTIVE</span><span class="p">,</span>		<span class="s">&quot;Active&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_VPORT_DISABLED</span><span class="p">,</span>		<span class="s">&quot;Disabled&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_VPORT_LINKDOWN</span><span class="p">,</span>		<span class="s">&quot;Linkdown&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_VPORT_INITIALIZING</span><span class="p">,</span>	<span class="s">&quot;Initializing&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_VPORT_NO_FABRIC_SUPP</span><span class="p">,</span>	<span class="s">&quot;No Fabric Support&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_VPORT_NO_FABRIC_RSCS</span><span class="p">,</span>	<span class="s">&quot;No Fabric Resources&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_VPORT_FABRIC_LOGOUT</span><span class="p">,</span>	<span class="s">&quot;Fabric Logout&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_VPORT_FABRIC_REJ_WWN</span><span class="p">,</span>	<span class="s">&quot;Fabric Rejected WWN&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_VPORT_FAILED</span><span class="p">,</span>		<span class="s">&quot;VPort Failed&quot;</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">fc_enum_name_search</span><span class="p">(</span><span class="n">vport_state</span><span class="p">,</span> <span class="n">fc_vport_state</span><span class="p">,</span> <span class="n">fc_vport_state_names</span><span class="p">)</span>
<span class="cp">#define FC_VPORTSTATE_MAX_NAMELEN	24</span>

<span class="cm">/* Reuse fc_vport_state enum function for vport_last_state */</span>
<span class="cp">#define get_fc_vport_last_state_name get_fc_vport_state_name</span>


<span class="cm">/* Convert fc_tgtid_binding_type values to ascii string name */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">fc_tgtid_binding_type</span>	<span class="n">value</span><span class="p">;</span>
	<span class="kt">char</span>				<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">matchlen</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fc_tgtid_binding_type_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">FC_TGTID_BIND_NONE</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">,</span> <span class="mi">4</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_TGTID_BIND_BY_WWPN</span><span class="p">,</span> <span class="s">&quot;wwpn (World Wide Port Name)&quot;</span><span class="p">,</span> <span class="mi">4</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_TGTID_BIND_BY_WWNN</span><span class="p">,</span> <span class="s">&quot;wwnn (World Wide Node Name)&quot;</span><span class="p">,</span> <span class="mi">4</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_TGTID_BIND_BY_ID</span><span class="p">,</span> <span class="s">&quot;port_id (FC Address)&quot;</span><span class="p">,</span> <span class="mi">7</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">fc_enum_name_search</span><span class="p">(</span><span class="n">tgtid_bind_type</span><span class="p">,</span> <span class="n">fc_tgtid_binding_type</span><span class="p">,</span>
		<span class="n">fc_tgtid_binding_type_names</span><span class="p">)</span>
<span class="n">fc_enum_name_match</span><span class="p">(</span><span class="n">tgtid_bind_type</span><span class="p">,</span> <span class="n">fc_tgtid_binding_type</span><span class="p">,</span>
		<span class="n">fc_tgtid_binding_type_names</span><span class="p">)</span>
<span class="cp">#define FC_BINDTYPE_MAX_NAMELEN	30</span>


<span class="cp">#define fc_bitfield_name_search(title, table)			\</span>
<span class="cp">static ssize_t							\</span>
<span class="cp">get_fc_##title##_names(u32 table_key, char *buf)		\</span>
<span class="cp">{								\</span>
<span class="cp">	char *prefix = &quot;&quot;;					\</span>
<span class="cp">	ssize_t len = 0;					\</span>
<span class="cp">	int i;							\</span>
<span class="cp">								\</span>
<span class="cp">	for (i = 0; i &lt; ARRAY_SIZE(table); i++) {		\</span>
<span class="cp">		if (table[i].value &amp; table_key) {		\</span>
<span class="cp">			len += sprintf(buf + len, &quot;%s%s&quot;,	\</span>
<span class="cp">				prefix, table[i].name);		\</span>
<span class="cp">			prefix = &quot;, &quot;;				\</span>
<span class="cp">		}						\</span>
<span class="cp">	}							\</span>
<span class="cp">	len += sprintf(buf + len, &quot;\n&quot;);			\</span>
<span class="cp">	return len;						\</span>
<span class="cp">}</span>


<span class="cm">/* Convert FC_COS bit values to ascii string name */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u32</span> 			<span class="n">value</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fc_cos_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">FC_COS_CLASS1</span><span class="p">,</span>	<span class="s">&quot;Class 1&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_COS_CLASS2</span><span class="p">,</span>	<span class="s">&quot;Class 2&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_COS_CLASS3</span><span class="p">,</span>	<span class="s">&quot;Class 3&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_COS_CLASS4</span><span class="p">,</span>	<span class="s">&quot;Class 4&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_COS_CLASS6</span><span class="p">,</span>	<span class="s">&quot;Class 6&quot;</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">fc_bitfield_name_search</span><span class="p">(</span><span class="n">cos</span><span class="p">,</span> <span class="n">fc_cos_names</span><span class="p">)</span>


<span class="cm">/* Convert FC_PORTSPEED bit values to ascii string name */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u32</span> 			<span class="n">value</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fc_port_speed_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">FC_PORTSPEED_1GBIT</span><span class="p">,</span>		<span class="s">&quot;1 Gbit&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSPEED_2GBIT</span><span class="p">,</span>		<span class="s">&quot;2 Gbit&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSPEED_4GBIT</span><span class="p">,</span>		<span class="s">&quot;4 Gbit&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSPEED_10GBIT</span><span class="p">,</span>		<span class="s">&quot;10 Gbit&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSPEED_8GBIT</span><span class="p">,</span>		<span class="s">&quot;8 Gbit&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSPEED_16GBIT</span><span class="p">,</span>		<span class="s">&quot;16 Gbit&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORTSPEED_NOT_NEGOTIATED</span><span class="p">,</span>	<span class="s">&quot;Not Negotiated&quot;</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">fc_bitfield_name_search</span><span class="p">(</span><span class="n">port_speed</span><span class="p">,</span> <span class="n">fc_port_speed_names</span><span class="p">)</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="n">show_fc_fc4s</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">fc4_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FC_FC4_LIST_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">fc4_list</span><span class="o">++</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span> <span class="p">,</span> <span class="s">&quot;0x%02x &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">fc4_list</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Convert FC_PORT_ROLE bit values to ascii string name */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u32</span> 			<span class="n">value</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fc_port_role_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">FC_PORT_ROLE_FCP_TARGET</span><span class="p">,</span>	<span class="s">&quot;FCP Target&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORT_ROLE_FCP_INITIATOR</span><span class="p">,</span>	<span class="s">&quot;FCP Initiator&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FC_PORT_ROLE_IP_PORT</span><span class="p">,</span>		<span class="s">&quot;IP Port&quot;</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">fc_bitfield_name_search</span><span class="p">(</span><span class="n">port_roles</span><span class="p">,</span> <span class="n">fc_port_role_names</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm"> * Define roles that are specific to port_id. Values are relative to ROLE_MASK.</span>
<span class="cm"> */</span>
<span class="cp">#define FC_WELLKNOWN_PORTID_MASK	0xfffff0</span>
<span class="cp">#define FC_WELLKNOWN_ROLE_MASK  	0x00000f</span>
<span class="cp">#define FC_FPORT_PORTID			0x00000e</span>
<span class="cp">#define FC_FABCTLR_PORTID		0x00000d</span>
<span class="cp">#define FC_DIRSRVR_PORTID		0x00000c</span>
<span class="cp">#define FC_TIMESRVR_PORTID		0x00000b</span>
<span class="cp">#define FC_MGMTSRVR_PORTID		0x00000a</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_timeout_deleted_rport</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_timeout_fail_rport_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fc_scsi_scan_rport</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute counts pre object type...</span>
<span class="cm"> * Increase these values if you add attributes</span>
<span class="cm"> */</span>
<span class="cp">#define FC_STARGET_NUM_ATTRS 	3</span>
<span class="cp">#define FC_RPORT_NUM_ATTRS	10</span>
<span class="cp">#define FC_VPORT_NUM_ATTRS	9</span>
<span class="cp">#define FC_HOST_NUM_ATTRS	29</span>

<span class="k">struct</span> <span class="n">fc_internal</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_function_template</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For attributes : each object has :</span>
<span class="cm">	 *   An array of the actual attributes structures</span>
<span class="cm">	 *   An array of null-terminated pointers to the attribute</span>
<span class="cm">	 *     structures - used for mid-layer interaction.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The attribute containers for the starget and host are are</span>
<span class="cm">	 * part of the midlayer. As the remote port is specific to the</span>
<span class="cm">	 * fc transport, we must provide the attribute container.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">private_starget_attrs</span><span class="p">[</span>
							<span class="n">FC_STARGET_NUM_ATTRS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">starget_attrs</span><span class="p">[</span><span class="n">FC_STARGET_NUM_ATTRS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">private_host_attrs</span><span class="p">[</span><span class="n">FC_HOST_NUM_ATTRS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">host_attrs</span><span class="p">[</span><span class="n">FC_HOST_NUM_ATTRS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">transport_container</span> <span class="n">rport_attr_cont</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">private_rport_attrs</span><span class="p">[</span><span class="n">FC_RPORT_NUM_ATTRS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">rport_attrs</span><span class="p">[</span><span class="n">FC_RPORT_NUM_ATTRS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">transport_container</span> <span class="n">vport_attr_cont</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">private_vport_attrs</span><span class="p">[</span><span class="n">FC_VPORT_NUM_ATTRS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">vport_attrs</span><span class="p">[</span><span class="n">FC_VPORT_NUM_ATTRS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define to_fc_internal(tmpl)	container_of(tmpl, struct fc_internal, t)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_target_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">to_scsi_target</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">starget_to_rport</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if parent is remote port, use values from remote port.</span>
<span class="cm">	 * Otherwise, this host uses the fc_transport, but not the</span>
<span class="cm">	 * remote port interface. As such, initialize to known non-values.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc_starget_node_name</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">;</span>
		<span class="n">fc_starget_port_name</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">;</span>
		<span class="n">fc_starget_port_id</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fc_starget_node_name</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">fc_starget_port_name</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">fc_starget_port_id</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DECLARE_TRANSPORT_CLASS</span><span class="p">(</span><span class="n">fc_transport_class</span><span class="p">,</span>
			       <span class="s">&quot;fc_transport&quot;</span><span class="p">,</span>
			       <span class="n">fc_target_setup</span><span class="p">,</span>
			       <span class="nb">NULL</span><span class="p">,</span>
			       <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_host_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_host_attrs</span> <span class="o">*</span><span class="n">fc_host</span> <span class="o">=</span> <span class="n">shost_to_fc_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set default values easily detected by the midlayer as</span>
<span class="cm">	 * failure cases.  The scsi lldd is responsible for initializing</span>
<span class="cm">	 * all transport attributes to valid values per host.</span>
<span class="cm">	 */</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">node_name</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">port_name</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">permanent_port_name</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">supported_classes</span> <span class="o">=</span> <span class="n">FC_COS_UNSPECIFIED</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">supported_fc4s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">supported_fc4s</span><span class="p">));</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">supported_speeds</span> <span class="o">=</span> <span class="n">FC_PORTSPEED_UNKNOWN</span><span class="p">;</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">maxframe_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">max_npiv_vports</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">serial_number</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">serial_number</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">manufacturer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">manufacturer</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">model_description</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">model_description</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">hardware_version</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">hardware_version</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">driver_version</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">driver_version</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">firmware_version</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">firmware_version</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">optionrom_version</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">optionrom_version</span><span class="p">));</span>

	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">=</span> <span class="n">FC_PORTTYPE_UNKNOWN</span><span class="p">;</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">FC_PORTSTATE_UNKNOWN</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">active_fc4s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">active_fc4s</span><span class="p">));</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">FC_PORTSPEED_UNKNOWN</span><span class="p">;</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">fabric_name</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">symbolic_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">symbolic_name</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">system_hostname</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">system_hostname</span><span class="p">));</span>

	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">tgtid_bind_type</span> <span class="o">=</span> <span class="n">FC_TGTID_BIND_BY_WWPN</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">rports</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">rport_bindings</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">vports</span><span class="p">);</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">next_rport_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">next_target_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">next_vport_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">npiv_vports_inuse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">work_q_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">work_q_name</span><span class="p">),</span>
		 <span class="s">&quot;fc_wq_%d&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">work_q</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">work_q_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">work_q</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo</span> <span class="o">=</span> <span class="n">fc_dev_loss_tmo</span><span class="p">;</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">devloss_work_q_name</span><span class="p">,</span>
		 <span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">devloss_work_q_name</span><span class="p">),</span>
		 <span class="s">&quot;fc_dl_%d&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">devloss_work_q</span> <span class="o">=</span>
			<span class="n">alloc_workqueue</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">devloss_work_q_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">devloss_work_q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">work_q</span><span class="p">);</span>
		<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">work_q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fc_bsg_hostadd</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_host</span><span class="p">);</span>
	<span class="cm">/* ignore any bsg add error - we just can&#39;t do sgio */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_host_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_host_attrs</span> <span class="o">*</span><span class="n">fc_host</span> <span class="o">=</span> <span class="n">shost_to_fc_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="n">fc_bsg_remove</span><span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">rqst_q</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DECLARE_TRANSPORT_CLASS</span><span class="p">(</span><span class="n">fc_host_class</span><span class="p">,</span>
			       <span class="s">&quot;fc_host&quot;</span><span class="p">,</span>
			       <span class="n">fc_host_setup</span><span class="p">,</span>
			       <span class="n">fc_host_remove</span><span class="p">,</span>
			       <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Setup and Remove actions for remote ports are handled</span>
<span class="cm"> * in the service functions below.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DECLARE_TRANSPORT_CLASS</span><span class="p">(</span><span class="n">fc_rport_class</span><span class="p">,</span>
			       <span class="s">&quot;fc_remote_ports&quot;</span><span class="p">,</span>
			       <span class="nb">NULL</span><span class="p">,</span>
			       <span class="nb">NULL</span><span class="p">,</span>
			       <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Setup and Remove actions for virtual ports are handled</span>
<span class="cm"> * in the service functions below.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DECLARE_TRANSPORT_CLASS</span><span class="p">(</span><span class="n">fc_vport_class</span><span class="p">,</span>
			       <span class="s">&quot;fc_vports&quot;</span><span class="p">,</span>
			       <span class="nb">NULL</span><span class="p">,</span>
			       <span class="nb">NULL</span><span class="p">,</span>
			       <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Netlink Infrastructure</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">fc_event_seq</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * fc_get_event_number - Obtain the next sequential FC event number</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *   We could have inlined this, but it would have required fc_event_seq to</span>
<span class="cm"> *   be exposed. For now, live with the subroutine call.</span>
<span class="cm"> *   Atomic used to avoid lock/unlock...</span>
<span class="cm"> */</span>
<span class="n">u32</span>
<span class="nf">fc_get_event_number</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_event_seq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_get_event_number</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * fc_host_post_event - called to post an even on an fc_host.</span>
<span class="cm"> * @shost:		host the event occurred on</span>
<span class="cm"> * @event_number:	fc event number obtained from get_fc_event_number()</span>
<span class="cm"> * @event_code:		fc_host event being posted</span>
<span class="cm"> * @event_data:		32bits of data for the event being posted</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	This routine assumes no locks are held on entry.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">fc_host_post_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event_number</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">fc_host_event_code</span> <span class="n">event_code</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlmsghdr</span>	<span class="o">*</span><span class="n">nlh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_nl_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="n">skblen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_nl_sock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">send_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">FC_NL_MSGALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">));</span>
	<span class="n">skblen</span> <span class="o">=</span> <span class="n">NLMSG_SPACE</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">skblen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">send_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nlh</span> <span class="o">=</span> <span class="n">nlmsg_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCSI_TRANSPORT_MSG</span><span class="p">,</span>
				<span class="n">skblen</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nlh</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nlh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">send_fail_skb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">NLMSG_DATA</span><span class="p">(</span><span class="n">nlh</span><span class="p">);</span>

	<span class="n">INIT_SCSI_NL_HDR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">snlh</span><span class="p">,</span> <span class="n">SCSI_NL_TRANSPORT_FC</span><span class="p">,</span>
				<span class="n">FC_NL_ASYNC_EVENT</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">seconds</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">vendor_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">host_no</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">event_datalen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>	<span class="cm">/* bytes */</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">event_num</span> <span class="o">=</span> <span class="n">event_number</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">event_code</span> <span class="o">=</span> <span class="n">event_code</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">event_data</span> <span class="o">=</span> <span class="n">event_data</span><span class="p">;</span>

	<span class="n">nlmsg_multicast</span><span class="p">(</span><span class="n">scsi_nl_sock</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCSI_NL_GRP_FC_EVENTS</span><span class="p">,</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">send_fail_skb:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">send_fail:</span>
	<span class="n">name</span> <span class="o">=</span> <span class="n">get_fc_host_event_code_name</span><span class="p">(</span><span class="n">event_code</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		<span class="s">&quot;%s: Dropped Event : host %d %s data 0x%08x - err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span>
		<span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">?</span> <span class="n">name</span> <span class="o">:</span> <span class="s">&quot;&lt;unknown&gt;&quot;</span><span class="p">,</span> <span class="n">event_data</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_host_post_event</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * fc_host_post_vendor_event - called to post a vendor unique event on an fc_host</span>
<span class="cm"> * @shost:		host the event occurred on</span>
<span class="cm"> * @event_number:	fc event number obtained from get_fc_event_number()</span>
<span class="cm"> * @data_len:		amount, in bytes, of vendor unique data</span>
<span class="cm"> * @data_buf:		pointer to vendor unique data</span>
<span class="cm"> * @vendor_id:          Vendor id</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	This routine assumes no locks are held on entry.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">fc_host_post_vendor_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event_number</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">data_len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">data_buf</span><span class="p">,</span> <span class="n">u64</span> <span class="n">vendor_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlmsghdr</span>	<span class="o">*</span><span class="n">nlh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_nl_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="n">skblen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_nl_sock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">send_vendor_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">FC_NL_MSGALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_len</span><span class="p">);</span>
	<span class="n">skblen</span> <span class="o">=</span> <span class="n">NLMSG_SPACE</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">skblen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">send_vendor_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nlh</span> <span class="o">=</span> <span class="n">nlmsg_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCSI_TRANSPORT_MSG</span><span class="p">,</span>
				<span class="n">skblen</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nlh</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nlh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">send_vendor_fail_skb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">NLMSG_DATA</span><span class="p">(</span><span class="n">nlh</span><span class="p">);</span>

	<span class="n">INIT_SCSI_NL_HDR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">snlh</span><span class="p">,</span> <span class="n">SCSI_NL_TRANSPORT_FC</span><span class="p">,</span>
				<span class="n">FC_NL_ASYNC_EVENT</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">seconds</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">vendor_id</span> <span class="o">=</span> <span class="n">vendor_id</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">host_no</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">event_datalen</span> <span class="o">=</span> <span class="n">data_len</span><span class="p">;</span>	<span class="cm">/* bytes */</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">event_num</span> <span class="o">=</span> <span class="n">event_number</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">event_code</span> <span class="o">=</span> <span class="n">FCH_EVT_VENDOR_UNIQUE</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event_data</span><span class="p">,</span> <span class="n">data_buf</span><span class="p">,</span> <span class="n">data_len</span><span class="p">);</span>

	<span class="n">nlmsg_multicast</span><span class="p">(</span><span class="n">scsi_nl_sock</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCSI_NL_GRP_FC_EVENTS</span><span class="p">,</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">send_vendor_fail_skb:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">send_vendor_fail:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		<span class="s">&quot;%s: Dropped Event : host %d vendor_unique - err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_host_post_vendor_event</span><span class="p">);</span>



<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">fc_transport_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_event_seq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">transport_class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_host_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">transport_class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_vport_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unreg_host_class</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">transport_class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_rport_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unreg_vport_class</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">transport_class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_transport_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unreg_rport_class</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">unreg_rport_class:</span>
	<span class="n">transport_class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_rport_class</span><span class="p">);</span>
<span class="nl">unreg_vport_class:</span>
	<span class="n">transport_class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_vport_class</span><span class="p">);</span>
<span class="nl">unreg_host_class:</span>
	<span class="n">transport_class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_host_class</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">fc_transport_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transport_class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_transport_class</span><span class="p">);</span>
	<span class="n">transport_class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_rport_class</span><span class="p">);</span>
	<span class="n">transport_class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_host_class</span><span class="p">);</span>
	<span class="n">transport_class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_vport_class</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * FC Remote Port Attribute Management</span>
<span class="cm"> */</span>

<span class="cp">#define fc_rport_show_function(field, format_string, sz, cast)		\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">show_fc_rport_##field (struct device *dev, 				\</span>
<span class="cp">		       struct device_attribute *attr, char *buf)	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct fc_rport *rport = transport_class_to_rport(dev);		\</span>
<span class="cp">	struct Scsi_Host *shost = rport_to_shost(rport);		\</span>
<span class="cp">	struct fc_internal *i = to_fc_internal(shost-&gt;transportt);	\</span>
<span class="cp">	if ((i-&gt;f-&gt;get_rport_##field) &amp;&amp;				\</span>
<span class="cp">	    !((rport-&gt;port_state == FC_PORTSTATE_BLOCKED) ||		\</span>
<span class="cp">	      (rport-&gt;port_state == FC_PORTSTATE_DELETED) ||		\</span>
<span class="cp">	      (rport-&gt;port_state == FC_PORTSTATE_NOTPRESENT)))		\</span>
<span class="cp">		i-&gt;f-&gt;get_rport_##field(rport);				\</span>
<span class="cp">	return snprintf(buf, sz, format_string, cast rport-&gt;field); 	\</span>
<span class="cp">}</span>

<span class="cp">#define fc_rport_store_function(field)					\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">store_fc_rport_##field(struct device *dev,				\</span>
<span class="cp">		       struct device_attribute *attr,			\</span>
<span class="cp">		       const char *buf,	size_t count)			\</span>
<span class="cp">{									\</span>
<span class="cp">	int val;							\</span>
<span class="cp">	struct fc_rport *rport = transport_class_to_rport(dev);		\</span>
<span class="cp">	struct Scsi_Host *shost = rport_to_shost(rport);		\</span>
<span class="cp">	struct fc_internal *i = to_fc_internal(shost-&gt;transportt);	\</span>
<span class="cp">	char *cp;							\</span>
<span class="cp">	if ((rport-&gt;port_state == FC_PORTSTATE_BLOCKED) ||		\</span>
<span class="cp">	    (rport-&gt;port_state == FC_PORTSTATE_DELETED) ||		\</span>
<span class="cp">	    (rport-&gt;port_state == FC_PORTSTATE_NOTPRESENT))		\</span>
<span class="cp">		return -EBUSY;						\</span>
<span class="cp">	val = simple_strtoul(buf, &amp;cp, 0);				\</span>
<span class="cp">	if (*cp &amp;&amp; (*cp != &#39;\n&#39;))					\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	i-&gt;f-&gt;set_rport_##field(rport, val);				\</span>
<span class="cp">	return count;							\</span>
<span class="cp">}</span>

<span class="cp">#define fc_rport_rd_attr(field, format_string, sz)			\</span>
<span class="cp">	fc_rport_show_function(field, format_string, sz, )		\</span>
<span class="cp">static FC_DEVICE_ATTR(rport, field, S_IRUGO,			\</span>
<span class="cp">			 show_fc_rport_##field, NULL)</span>

<span class="cp">#define fc_rport_rd_attr_cast(field, format_string, sz, cast)		\</span>
<span class="cp">	fc_rport_show_function(field, format_string, sz, (cast))	\</span>
<span class="cp">static FC_DEVICE_ATTR(rport, field, S_IRUGO,			\</span>
<span class="cp">			  show_fc_rport_##field, NULL)</span>

<span class="cp">#define fc_rport_rw_attr(field, format_string, sz)			\</span>
<span class="cp">	fc_rport_show_function(field, format_string, sz, )		\</span>
<span class="cp">	fc_rport_store_function(field)					\</span>
<span class="cp">static FC_DEVICE_ATTR(rport, field, S_IRUGO | S_IWUSR,		\</span>
<span class="cp">			show_fc_rport_##field,				\</span>
<span class="cp">			store_fc_rport_##field)</span>


<span class="cp">#define fc_private_rport_show_function(field, format_string, sz, cast)	\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">show_fc_rport_##field (struct device *dev, 				\</span>
<span class="cp">		       struct device_attribute *attr, char *buf)	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct fc_rport *rport = transport_class_to_rport(dev);		\</span>
<span class="cp">	return snprintf(buf, sz, format_string, cast rport-&gt;field); 	\</span>
<span class="cp">}</span>

<span class="cp">#define fc_private_rport_rd_attr(field, format_string, sz)		\</span>
<span class="cp">	fc_private_rport_show_function(field, format_string, sz, )	\</span>
<span class="cp">static FC_DEVICE_ATTR(rport, field, S_IRUGO,			\</span>
<span class="cp">			 show_fc_rport_##field, NULL)</span>

<span class="cp">#define fc_private_rport_rd_attr_cast(field, format_string, sz, cast)	\</span>
<span class="cp">	fc_private_rport_show_function(field, format_string, sz, (cast)) \</span>
<span class="cp">static FC_DEVICE_ATTR(rport, field, S_IRUGO,			\</span>
<span class="cp">			  show_fc_rport_##field, NULL)</span>


<span class="cp">#define fc_private_rport_rd_enum_attr(title, maxlen)			\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">show_fc_rport_##title (struct device *dev,				\</span>
<span class="cp">		       struct device_attribute *attr, char *buf)	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct fc_rport *rport = transport_class_to_rport(dev);		\</span>
<span class="cp">	const char *name;						\</span>
<span class="cp">	name = get_fc_##title##_name(rport-&gt;title);			\</span>
<span class="cp">	if (!name)							\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	return snprintf(buf, maxlen, &quot;%s\n&quot;, name);			\</span>
<span class="cp">}									\</span>
<span class="cp">static FC_DEVICE_ATTR(rport, title, S_IRUGO,			\</span>
<span class="cp">			show_fc_rport_##title, NULL)</span>


<span class="cp">#define SETUP_RPORT_ATTRIBUTE_RD(field)					\</span>
<span class="cp">	i-&gt;private_rport_attrs[count] = device_attr_rport_##field; \</span>
<span class="cp">	i-&gt;private_rport_attrs[count].attr.mode = S_IRUGO;		\</span>
<span class="cp">	i-&gt;private_rport_attrs[count].store = NULL;			\</span>
<span class="cp">	i-&gt;rport_attrs[count] = &amp;i-&gt;private_rport_attrs[count];		\</span>
<span class="cp">	if (i-&gt;f-&gt;show_rport_##field)					\</span>
<span class="cp">		count++</span>

<span class="cp">#define SETUP_PRIVATE_RPORT_ATTRIBUTE_RD(field)				\</span>
<span class="cp">	i-&gt;private_rport_attrs[count] = device_attr_rport_##field; \</span>
<span class="cp">	i-&gt;private_rport_attrs[count].attr.mode = S_IRUGO;		\</span>
<span class="cp">	i-&gt;private_rport_attrs[count].store = NULL;			\</span>
<span class="cp">	i-&gt;rport_attrs[count] = &amp;i-&gt;private_rport_attrs[count];		\</span>
<span class="cp">	count++</span>

<span class="cp">#define SETUP_RPORT_ATTRIBUTE_RW(field)					\</span>
<span class="cp">	i-&gt;private_rport_attrs[count] = device_attr_rport_##field; \</span>
<span class="cp">	if (!i-&gt;f-&gt;set_rport_##field) {					\</span>
<span class="cp">		i-&gt;private_rport_attrs[count].attr.mode = S_IRUGO;	\</span>
<span class="cp">		i-&gt;private_rport_attrs[count].store = NULL;		\</span>
<span class="cp">	}								\</span>
<span class="cp">	i-&gt;rport_attrs[count] = &amp;i-&gt;private_rport_attrs[count];		\</span>
<span class="cp">	if (i-&gt;f-&gt;show_rport_##field)					\</span>
<span class="cp">		count++</span>

<span class="cp">#define SETUP_PRIVATE_RPORT_ATTRIBUTE_RW(field)				\</span>
<span class="cp">{									\</span>
<span class="cp">	i-&gt;private_rport_attrs[count] = device_attr_rport_##field; \</span>
<span class="cp">	i-&gt;rport_attrs[count] = &amp;i-&gt;private_rport_attrs[count];		\</span>
<span class="cp">	count++;							\</span>
<span class="cp">}</span>


<span class="cm">/* The FC Transport Remote Port Attributes: */</span>

<span class="cm">/* Fixed Remote Port Attributes */</span>

<span class="n">fc_private_rport_rd_attr</span><span class="p">(</span><span class="n">maxframe_size</span><span class="p">,</span> <span class="s">&quot;%u bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_fc_rport_supported_classes</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">transport_class_to_rport</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">supported_classes</span> <span class="o">==</span> <span class="n">FC_COS_UNSPECIFIED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;unspecified</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">get_fc_cos_names</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">supported_classes</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="n">supported_classes</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		<span class="n">show_fc_rport_supported_classes</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/* Dynamic Remote Port Attributes */</span>

<span class="cm">/*</span>
<span class="cm"> * dev_loss_tmo attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_str_to_dev_loss</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">cp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">cp</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check for overflow; dev_loss_tmo is u32</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_rport_set_dev_loss_tmo</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">rport_to_shost</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">FC_PORTSTATE_BLOCKED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">FC_PORTSTATE_DELETED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">FC_PORTSTATE_NOTPRESENT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check for overflow; dev_loss_tmo is u32</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If fast_io_fail is off we have to cap</span>
<span class="cm">	 * dev_loss_tmo at SCSI_DEVICE_BLOCK_MAX_TIMEOUT</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">fast_io_fail_tmo</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">val</span> <span class="o">&gt;</span> <span class="n">SCSI_DEVICE_BLOCK_MAX_TIMEOUT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">set_rport_dev_loss_tmo</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">fc_rport_show_function</span><span class="p">(</span><span class="n">dev_loss_tmo</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="p">)</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="n">store_fc_rport_dev_loss_tmo</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">transport_class_to_rport</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fc_str_to_dev_loss</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fc_rport_set_dev_loss_tmo</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="n">dev_loss_tmo</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		<span class="n">show_fc_rport_dev_loss_tmo</span><span class="p">,</span> <span class="n">store_fc_rport_dev_loss_tmo</span><span class="p">);</span>


<span class="cm">/* Private Remote Port Attributes */</span>

<span class="n">fc_private_rport_rd_attr_cast</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
<span class="n">fc_private_rport_rd_attr_cast</span><span class="p">(</span><span class="n">port_name</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
<span class="n">fc_private_rport_rd_attr</span><span class="p">(</span><span class="n">port_id</span><span class="p">,</span> <span class="s">&quot;0x%06x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_fc_rport_roles</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">transport_class_to_rport</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* identify any roles that are port_id specific */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">&amp;</span> <span class="n">FC_WELLKNOWN_PORTID_MASK</span><span class="p">)</span> <span class="o">==</span>
					<span class="n">FC_WELLKNOWN_PORTID_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">&amp;</span> <span class="n">FC_WELLKNOWN_ROLE_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FC_FPORT_PORTID</span>:
			<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="s">&quot;Fabric Port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">FC_FABCTLR_PORTID</span>:
			<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="s">&quot;Fabric Controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">FC_DIRSRVR_PORTID</span>:
			<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="s">&quot;Directory Server</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">FC_TIMESRVR_PORTID</span>:
			<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="s">&quot;Time Server</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">FC_MGMTSRVR_PORTID</span>:
			<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="s">&quot;Management Server</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="s">&quot;Unknown Fabric Entity</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">==</span> <span class="n">FC_PORT_ROLE_UNKNOWN</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">get_fc_port_roles_names</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="n">roles</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		<span class="n">show_fc_rport_roles</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="n">fc_private_rport_rd_enum_attr</span><span class="p">(</span><span class="n">port_state</span><span class="p">,</span> <span class="n">FC_PORTSTATE_MAX_NAMELEN</span><span class="p">);</span>
<span class="n">fc_private_rport_rd_attr</span><span class="p">(</span><span class="n">scsi_target_id</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * fast_io_fail_tmo attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_fc_rport_fast_io_fail_tmo</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">transport_class_to_rport</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">fast_io_fail_tmo</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s">&quot;off</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">fast_io_fail_tmo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_fc_rport_fast_io_fail_tmo</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">transport_class_to_rport</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">FC_PORTSTATE_BLOCKED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">FC_PORTSTATE_DELETED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">FC_PORTSTATE_NOTPRESENT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">fast_io_fail_tmo</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">cp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">cp</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Cap fast_io_fail by dev_loss_tmo or</span>
<span class="cm">		 * SCSI_DEVICE_BLOCK_MAX_TIMEOUT.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">SCSI_DEVICE_BLOCK_MAX_TIMEOUT</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">fast_io_fail_tmo</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="n">fast_io_fail_tmo</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="n">show_fc_rport_fast_io_fail_tmo</span><span class="p">,</span> <span class="n">store_fc_rport_fast_io_fail_tmo</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * FC SCSI Target Attribute Management</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Note: in the target show function we recognize when the remote</span>
<span class="cm"> *  port is in the hierarchy and do not allow the driver to get</span>
<span class="cm"> *  involved in sysfs functions. The driver only gets involved if</span>
<span class="cm"> *  it&#39;s the &quot;old&quot; style that doesn&#39;t use rports.</span>
<span class="cm"> */</span>
<span class="cp">#define fc_starget_show_function(field, format_string, sz, cast)	\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">show_fc_starget_##field (struct device *dev, 				\</span>
<span class="cp">			 struct device_attribute *attr, char *buf)	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct scsi_target *starget = transport_class_to_starget(dev);	\</span>
<span class="cp">	struct Scsi_Host *shost = dev_to_shost(starget-&gt;dev.parent);	\</span>
<span class="cp">	struct fc_internal *i = to_fc_internal(shost-&gt;transportt);	\</span>
<span class="cp">	struct fc_rport *rport = starget_to_rport(starget);		\</span>
<span class="cp">	if (rport)							\</span>
<span class="cp">		fc_starget_##field(starget) = rport-&gt;field;		\</span>
<span class="cp">	else if (i-&gt;f-&gt;get_starget_##field)				\</span>
<span class="cp">		i-&gt;f-&gt;get_starget_##field(starget);			\</span>
<span class="cp">	return snprintf(buf, sz, format_string, 			\</span>
<span class="cp">		cast fc_starget_##field(starget)); 			\</span>
<span class="cp">}</span>

<span class="cp">#define fc_starget_rd_attr(field, format_string, sz)			\</span>
<span class="cp">	fc_starget_show_function(field, format_string, sz, )		\</span>
<span class="cp">static FC_DEVICE_ATTR(starget, field, S_IRUGO,			\</span>
<span class="cp">			 show_fc_starget_##field, NULL)</span>

<span class="cp">#define fc_starget_rd_attr_cast(field, format_string, sz, cast)		\</span>
<span class="cp">	fc_starget_show_function(field, format_string, sz, (cast))	\</span>
<span class="cp">static FC_DEVICE_ATTR(starget, field, S_IRUGO,			\</span>
<span class="cp">			  show_fc_starget_##field, NULL)</span>

<span class="cp">#define SETUP_STARGET_ATTRIBUTE_RD(field)				\</span>
<span class="cp">	i-&gt;private_starget_attrs[count] = device_attr_starget_##field; \</span>
<span class="cp">	i-&gt;private_starget_attrs[count].attr.mode = S_IRUGO;		\</span>
<span class="cp">	i-&gt;private_starget_attrs[count].store = NULL;			\</span>
<span class="cp">	i-&gt;starget_attrs[count] = &amp;i-&gt;private_starget_attrs[count];	\</span>
<span class="cp">	if (i-&gt;f-&gt;show_starget_##field)					\</span>
<span class="cp">		count++</span>

<span class="cp">#define SETUP_STARGET_ATTRIBUTE_RW(field)				\</span>
<span class="cp">	i-&gt;private_starget_attrs[count] = device_attr_starget_##field; \</span>
<span class="cp">	if (!i-&gt;f-&gt;set_starget_##field) {				\</span>
<span class="cp">		i-&gt;private_starget_attrs[count].attr.mode = S_IRUGO;	\</span>
<span class="cp">		i-&gt;private_starget_attrs[count].store = NULL;		\</span>
<span class="cp">	}								\</span>
<span class="cp">	i-&gt;starget_attrs[count] = &amp;i-&gt;private_starget_attrs[count];	\</span>
<span class="cp">	if (i-&gt;f-&gt;show_starget_##field)					\</span>
<span class="cp">		count++</span>

<span class="cm">/* The FC Transport SCSI Target Attributes: */</span>
<span class="n">fc_starget_rd_attr_cast</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
<span class="n">fc_starget_rd_attr_cast</span><span class="p">(</span><span class="n">port_name</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
<span class="n">fc_starget_rd_attr</span><span class="p">(</span><span class="n">port_id</span><span class="p">,</span> <span class="s">&quot;0x%06x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * FC Virtual Port Attribute Management</span>
<span class="cm"> */</span>

<span class="cp">#define fc_vport_show_function(field, format_string, sz, cast)		\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">show_fc_vport_##field (struct device *dev, 				\</span>
<span class="cp">		       struct device_attribute *attr, char *buf)	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct fc_vport *vport = transport_class_to_vport(dev);		\</span>
<span class="cp">	struct Scsi_Host *shost = vport_to_shost(vport);		\</span>
<span class="cp">	struct fc_internal *i = to_fc_internal(shost-&gt;transportt);	\</span>
<span class="cp">	if ((i-&gt;f-&gt;get_vport_##field) &amp;&amp;				\</span>
<span class="cp">	    !(vport-&gt;flags &amp; (FC_VPORT_DEL | FC_VPORT_CREATING)))	\</span>
<span class="cp">		i-&gt;f-&gt;get_vport_##field(vport);				\</span>
<span class="cp">	return snprintf(buf, sz, format_string, cast vport-&gt;field); 	\</span>
<span class="cp">}</span>

<span class="cp">#define fc_vport_store_function(field)					\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">store_fc_vport_##field(struct device *dev,				\</span>
<span class="cp">		       struct device_attribute *attr,			\</span>
<span class="cp">		       const char *buf,	size_t count)			\</span>
<span class="cp">{									\</span>
<span class="cp">	int val;							\</span>
<span class="cp">	struct fc_vport *vport = transport_class_to_vport(dev);		\</span>
<span class="cp">	struct Scsi_Host *shost = vport_to_shost(vport);		\</span>
<span class="cp">	struct fc_internal *i = to_fc_internal(shost-&gt;transportt);	\</span>
<span class="cp">	char *cp;							\</span>
<span class="cp">	if (vport-&gt;flags &amp; (FC_VPORT_DEL | FC_VPORT_CREATING))	\</span>
<span class="cp">		return -EBUSY;						\</span>
<span class="cp">	val = simple_strtoul(buf, &amp;cp, 0);				\</span>
<span class="cp">	if (*cp &amp;&amp; (*cp != &#39;\n&#39;))					\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	i-&gt;f-&gt;set_vport_##field(vport, val);				\</span>
<span class="cp">	return count;							\</span>
<span class="cp">}</span>

<span class="cp">#define fc_vport_store_str_function(field, slen)			\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">store_fc_vport_##field(struct device *dev,				\</span>
<span class="cp">		       struct device_attribute *attr, 			\</span>
<span class="cp">		       const char *buf,	size_t count)			\</span>
<span class="cp">{									\</span>
<span class="cp">	struct fc_vport *vport = transport_class_to_vport(dev);		\</span>
<span class="cp">	struct Scsi_Host *shost = vport_to_shost(vport);		\</span>
<span class="cp">	struct fc_internal *i = to_fc_internal(shost-&gt;transportt);	\</span>
<span class="cp">	unsigned int cnt=count;						\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* count may include a LF at end of string */</span><span class="cp">			\</span>
<span class="cp">	if (buf[cnt-1] == &#39;\n&#39;)						\</span>
<span class="cp">		cnt--;							\</span>
<span class="cp">	if (cnt &gt; ((slen) - 1))						\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	memcpy(vport-&gt;field, buf, cnt);					\</span>
<span class="cp">	i-&gt;f-&gt;set_vport_##field(vport);					\</span>
<span class="cp">	return count;							\</span>
<span class="cp">}</span>

<span class="cp">#define fc_vport_rd_attr(field, format_string, sz)			\</span>
<span class="cp">	fc_vport_show_function(field, format_string, sz, )		\</span>
<span class="cp">static FC_DEVICE_ATTR(vport, field, S_IRUGO,			\</span>
<span class="cp">			 show_fc_vport_##field, NULL)</span>

<span class="cp">#define fc_vport_rd_attr_cast(field, format_string, sz, cast)		\</span>
<span class="cp">	fc_vport_show_function(field, format_string, sz, (cast))	\</span>
<span class="cp">static FC_DEVICE_ATTR(vport, field, S_IRUGO,			\</span>
<span class="cp">			  show_fc_vport_##field, NULL)</span>

<span class="cp">#define fc_vport_rw_attr(field, format_string, sz)			\</span>
<span class="cp">	fc_vport_show_function(field, format_string, sz, )		\</span>
<span class="cp">	fc_vport_store_function(field)					\</span>
<span class="cp">static FC_DEVICE_ATTR(vport, field, S_IRUGO | S_IWUSR,		\</span>
<span class="cp">			show_fc_vport_##field,				\</span>
<span class="cp">			store_fc_vport_##field)</span>

<span class="cp">#define fc_private_vport_show_function(field, format_string, sz, cast)	\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">show_fc_vport_##field (struct device *dev,				\</span>
<span class="cp">		       struct device_attribute *attr, char *buf)	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct fc_vport *vport = transport_class_to_vport(dev);		\</span>
<span class="cp">	return snprintf(buf, sz, format_string, cast vport-&gt;field); 	\</span>
<span class="cp">}</span>

<span class="cp">#define fc_private_vport_store_u32_function(field)			\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">store_fc_vport_##field(struct device *dev,				\</span>
<span class="cp">		       struct device_attribute *attr,			\</span>
<span class="cp">		       const char *buf,	size_t count)			\</span>
<span class="cp">{									\</span>
<span class="cp">	u32 val;							\</span>
<span class="cp">	struct fc_vport *vport = transport_class_to_vport(dev);		\</span>
<span class="cp">	char *cp;							\</span>
<span class="cp">	if (vport-&gt;flags &amp; (FC_VPORT_DEL | FC_VPORT_CREATING))		\</span>
<span class="cp">		return -EBUSY;						\</span>
<span class="cp">	val = simple_strtoul(buf, &amp;cp, 0);				\</span>
<span class="cp">	if (*cp &amp;&amp; (*cp != &#39;\n&#39;))					\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	vport-&gt;field = val;						\</span>
<span class="cp">	return count;							\</span>
<span class="cp">}</span>


<span class="cp">#define fc_private_vport_rd_attr(field, format_string, sz)		\</span>
<span class="cp">	fc_private_vport_show_function(field, format_string, sz, )	\</span>
<span class="cp">static FC_DEVICE_ATTR(vport, field, S_IRUGO,			\</span>
<span class="cp">			 show_fc_vport_##field, NULL)</span>

<span class="cp">#define fc_private_vport_rd_attr_cast(field, format_string, sz, cast)	\</span>
<span class="cp">	fc_private_vport_show_function(field, format_string, sz, (cast)) \</span>
<span class="cp">static FC_DEVICE_ATTR(vport, field, S_IRUGO,			\</span>
<span class="cp">			  show_fc_vport_##field, NULL)</span>

<span class="cp">#define fc_private_vport_rw_u32_attr(field, format_string, sz)		\</span>
<span class="cp">	fc_private_vport_show_function(field, format_string, sz, )	\</span>
<span class="cp">	fc_private_vport_store_u32_function(field)			\</span>
<span class="cp">static FC_DEVICE_ATTR(vport, field, S_IRUGO | S_IWUSR,		\</span>
<span class="cp">			show_fc_vport_##field,				\</span>
<span class="cp">			store_fc_vport_##field)</span>


<span class="cp">#define fc_private_vport_rd_enum_attr(title, maxlen)			\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">show_fc_vport_##title (struct device *dev,				\</span>
<span class="cp">		       struct device_attribute *attr,			\</span>
<span class="cp">		       char *buf)					\</span>
<span class="cp">{									\</span>
<span class="cp">	struct fc_vport *vport = transport_class_to_vport(dev);		\</span>
<span class="cp">	const char *name;						\</span>
<span class="cp">	name = get_fc_##title##_name(vport-&gt;title);			\</span>
<span class="cp">	if (!name)							\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	return snprintf(buf, maxlen, &quot;%s\n&quot;, name);			\</span>
<span class="cp">}									\</span>
<span class="cp">static FC_DEVICE_ATTR(vport, title, S_IRUGO,			\</span>
<span class="cp">			show_fc_vport_##title, NULL)</span>


<span class="cp">#define SETUP_VPORT_ATTRIBUTE_RD(field)					\</span>
<span class="cp">	i-&gt;private_vport_attrs[count] = device_attr_vport_##field; \</span>
<span class="cp">	i-&gt;private_vport_attrs[count].attr.mode = S_IRUGO;		\</span>
<span class="cp">	i-&gt;private_vport_attrs[count].store = NULL;			\</span>
<span class="cp">	i-&gt;vport_attrs[count] = &amp;i-&gt;private_vport_attrs[count];		\</span>
<span class="cp">	if (i-&gt;f-&gt;get_##field)						\</span>
<span class="cp">		count++</span>
	<span class="cm">/* NOTE: Above MACRO differs: checks function not show bit */</span>

<span class="cp">#define SETUP_PRIVATE_VPORT_ATTRIBUTE_RD(field)				\</span>
<span class="cp">	i-&gt;private_vport_attrs[count] = device_attr_vport_##field; \</span>
<span class="cp">	i-&gt;private_vport_attrs[count].attr.mode = S_IRUGO;		\</span>
<span class="cp">	i-&gt;private_vport_attrs[count].store = NULL;			\</span>
<span class="cp">	i-&gt;vport_attrs[count] = &amp;i-&gt;private_vport_attrs[count];		\</span>
<span class="cp">	count++</span>

<span class="cp">#define SETUP_VPORT_ATTRIBUTE_WR(field)					\</span>
<span class="cp">	i-&gt;private_vport_attrs[count] = device_attr_vport_##field; \</span>
<span class="cp">	i-&gt;vport_attrs[count] = &amp;i-&gt;private_vport_attrs[count];		\</span>
<span class="cp">	if (i-&gt;f-&gt;field)						\</span>
<span class="cp">		count++</span>
	<span class="cm">/* NOTE: Above MACRO differs: checks function */</span>

<span class="cp">#define SETUP_VPORT_ATTRIBUTE_RW(field)					\</span>
<span class="cp">	i-&gt;private_vport_attrs[count] = device_attr_vport_##field; \</span>
<span class="cp">	if (!i-&gt;f-&gt;set_vport_##field) {					\</span>
<span class="cp">		i-&gt;private_vport_attrs[count].attr.mode = S_IRUGO;	\</span>
<span class="cp">		i-&gt;private_vport_attrs[count].store = NULL;		\</span>
<span class="cp">	}								\</span>
<span class="cp">	i-&gt;vport_attrs[count] = &amp;i-&gt;private_vport_attrs[count];		\</span>
<span class="cp">	count++</span>
	<span class="cm">/* NOTE: Above MACRO differs: does not check show bit */</span>

<span class="cp">#define SETUP_PRIVATE_VPORT_ATTRIBUTE_RW(field)				\</span>
<span class="cp">{									\</span>
<span class="cp">	i-&gt;private_vport_attrs[count] = device_attr_vport_##field; \</span>
<span class="cp">	i-&gt;vport_attrs[count] = &amp;i-&gt;private_vport_attrs[count];		\</span>
<span class="cp">	count++;							\</span>
<span class="cp">}</span>


<span class="cm">/* The FC Transport Virtual Port Attributes: */</span>

<span class="cm">/* Fixed Virtual Port Attributes */</span>

<span class="cm">/* Dynamic Virtual Port Attributes */</span>

<span class="cm">/* Private Virtual Port Attributes */</span>

<span class="n">fc_private_vport_rd_enum_attr</span><span class="p">(</span><span class="n">vport_state</span><span class="p">,</span> <span class="n">FC_VPORTSTATE_MAX_NAMELEN</span><span class="p">);</span>
<span class="n">fc_private_vport_rd_enum_attr</span><span class="p">(</span><span class="n">vport_last_state</span><span class="p">,</span> <span class="n">FC_VPORTSTATE_MAX_NAMELEN</span><span class="p">);</span>
<span class="n">fc_private_vport_rd_attr_cast</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
<span class="n">fc_private_vport_rd_attr_cast</span><span class="p">(</span><span class="n">port_name</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_fc_vport_roles</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">transport_class_to_vport</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">==</span> <span class="n">FC_PORT_ROLE_UNKNOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">get_fc_port_roles_names</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">roles</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">roles</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">show_fc_vport_roles</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="n">fc_private_vport_rd_enum_attr</span><span class="p">(</span><span class="n">vport_type</span><span class="p">,</span> <span class="n">FC_PORTTYPE_MAX_NAMELEN</span><span class="p">);</span>

<span class="n">fc_private_vport_show_function</span><span class="p">(</span><span class="n">symbolic_name</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">FC_VPORT_SYMBOLIC_NAMELEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">)</span>
<span class="n">fc_vport_store_str_function</span><span class="p">(</span><span class="n">symbolic_name</span><span class="p">,</span> <span class="n">FC_VPORT_SYMBOLIC_NAMELEN</span><span class="p">)</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">symbolic_name</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		<span class="n">show_fc_vport_symbolic_name</span><span class="p">,</span> <span class="n">store_fc_vport_symbolic_name</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_fc_vport_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">transport_class_to_vport</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">vport_to_shost</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FC_VPORT_DEL</span> <span class="o">|</span> <span class="n">FC_VPORT_CREATING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FC_VPORT_DELETING</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">fc_queue_work</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vport_delete_work</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">vport_delete</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="n">store_fc_vport_delete</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Enable/Disable vport</span>
<span class="cm"> *  Write &quot;1&quot; to disable, write &quot;0&quot; to enable</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_fc_vport_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">transport_class_to_vport</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">vport_to_shost</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">stat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FC_VPORT_DEL</span> <span class="o">|</span> <span class="n">FC_VPORT_CREATING</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vport_state</span> <span class="o">!=</span> <span class="n">FC_VPORT_DISABLED</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vport_state</span> <span class="o">==</span> <span class="n">FC_VPORT_DISABLED</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">stat</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">vport_disable</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="p">((</span><span class="o">*</span><span class="n">buf</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">?</span> <span class="nb">false</span> <span class="o">:</span> <span class="nb">true</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">stat</span> <span class="o">?</span> <span class="n">stat</span> <span class="o">:</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">vport_disable</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="n">store_fc_vport_disable</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Host Attribute Management</span>
<span class="cm"> */</span>

<span class="cp">#define fc_host_show_function(field, format_string, sz, cast)		\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">show_fc_host_##field (struct device *dev,				\</span>
<span class="cp">		      struct device_attribute *attr, char *buf)		\</span>
<span class="cp">{									\</span>
<span class="cp">	struct Scsi_Host *shost = transport_class_to_shost(dev);	\</span>
<span class="cp">	struct fc_internal *i = to_fc_internal(shost-&gt;transportt);	\</span>
<span class="cp">	if (i-&gt;f-&gt;get_host_##field)					\</span>
<span class="cp">		i-&gt;f-&gt;get_host_##field(shost);				\</span>
<span class="cp">	return snprintf(buf, sz, format_string, cast fc_host_##field(shost)); \</span>
<span class="cp">}</span>

<span class="cp">#define fc_host_store_function(field)					\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">store_fc_host_##field(struct device *dev, 				\</span>
<span class="cp">		      struct device_attribute *attr,			\</span>
<span class="cp">		      const char *buf,	size_t count)			\</span>
<span class="cp">{									\</span>
<span class="cp">	int val;							\</span>
<span class="cp">	struct Scsi_Host *shost = transport_class_to_shost(dev);	\</span>
<span class="cp">	struct fc_internal *i = to_fc_internal(shost-&gt;transportt);	\</span>
<span class="cp">	char *cp;							\</span>
<span class="cp">									\</span>
<span class="cp">	val = simple_strtoul(buf, &amp;cp, 0);				\</span>
<span class="cp">	if (*cp &amp;&amp; (*cp != &#39;\n&#39;))					\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	i-&gt;f-&gt;set_host_##field(shost, val);				\</span>
<span class="cp">	return count;							\</span>
<span class="cp">}</span>

<span class="cp">#define fc_host_store_str_function(field, slen)				\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">store_fc_host_##field(struct device *dev,				\</span>
<span class="cp">		      struct device_attribute *attr,			\</span>
<span class="cp">		      const char *buf, size_t count)			\</span>
<span class="cp">{									\</span>
<span class="cp">	struct Scsi_Host *shost = transport_class_to_shost(dev);	\</span>
<span class="cp">	struct fc_internal *i = to_fc_internal(shost-&gt;transportt);	\</span>
<span class="cp">	unsigned int cnt=count;						\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* count may include a LF at end of string */</span><span class="cp">			\</span>
<span class="cp">	if (buf[cnt-1] == &#39;\n&#39;)						\</span>
<span class="cp">		cnt--;							\</span>
<span class="cp">	if (cnt &gt; ((slen) - 1))						\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	memcpy(fc_host_##field(shost), buf, cnt);			\</span>
<span class="cp">	i-&gt;f-&gt;set_host_##field(shost);					\</span>
<span class="cp">	return count;							\</span>
<span class="cp">}</span>

<span class="cp">#define fc_host_rd_attr(field, format_string, sz)			\</span>
<span class="cp">	fc_host_show_function(field, format_string, sz, )		\</span>
<span class="cp">static FC_DEVICE_ATTR(host, field, S_IRUGO,			\</span>
<span class="cp">			 show_fc_host_##field, NULL)</span>

<span class="cp">#define fc_host_rd_attr_cast(field, format_string, sz, cast)		\</span>
<span class="cp">	fc_host_show_function(field, format_string, sz, (cast))		\</span>
<span class="cp">static FC_DEVICE_ATTR(host, field, S_IRUGO,			\</span>
<span class="cp">			  show_fc_host_##field, NULL)</span>

<span class="cp">#define fc_host_rw_attr(field, format_string, sz)			\</span>
<span class="cp">	fc_host_show_function(field, format_string, sz, )		\</span>
<span class="cp">	fc_host_store_function(field)					\</span>
<span class="cp">static FC_DEVICE_ATTR(host, field, S_IRUGO | S_IWUSR,		\</span>
<span class="cp">			show_fc_host_##field,				\</span>
<span class="cp">			store_fc_host_##field)</span>

<span class="cp">#define fc_host_rd_enum_attr(title, maxlen)				\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">show_fc_host_##title (struct device *dev,				\</span>
<span class="cp">		      struct device_attribute *attr, char *buf)		\</span>
<span class="cp">{									\</span>
<span class="cp">	struct Scsi_Host *shost = transport_class_to_shost(dev);	\</span>
<span class="cp">	struct fc_internal *i = to_fc_internal(shost-&gt;transportt);	\</span>
<span class="cp">	const char *name;						\</span>
<span class="cp">	if (i-&gt;f-&gt;get_host_##title)					\</span>
<span class="cp">		i-&gt;f-&gt;get_host_##title(shost);				\</span>
<span class="cp">	name = get_fc_##title##_name(fc_host_##title(shost));		\</span>
<span class="cp">	if (!name)							\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	return snprintf(buf, maxlen, &quot;%s\n&quot;, name);			\</span>
<span class="cp">}									\</span>
<span class="cp">static FC_DEVICE_ATTR(host, title, S_IRUGO, show_fc_host_##title, NULL)</span>

<span class="cp">#define SETUP_HOST_ATTRIBUTE_RD(field)					\</span>
<span class="cp">	i-&gt;private_host_attrs[count] = device_attr_host_##field;	\</span>
<span class="cp">	i-&gt;private_host_attrs[count].attr.mode = S_IRUGO;		\</span>
<span class="cp">	i-&gt;private_host_attrs[count].store = NULL;			\</span>
<span class="cp">	i-&gt;host_attrs[count] = &amp;i-&gt;private_host_attrs[count];		\</span>
<span class="cp">	if (i-&gt;f-&gt;show_host_##field)					\</span>
<span class="cp">		count++</span>

<span class="cp">#define SETUP_HOST_ATTRIBUTE_RD_NS(field)				\</span>
<span class="cp">	i-&gt;private_host_attrs[count] = device_attr_host_##field;	\</span>
<span class="cp">	i-&gt;private_host_attrs[count].attr.mode = S_IRUGO;		\</span>
<span class="cp">	i-&gt;private_host_attrs[count].store = NULL;			\</span>
<span class="cp">	i-&gt;host_attrs[count] = &amp;i-&gt;private_host_attrs[count];		\</span>
<span class="cp">	count++</span>

<span class="cp">#define SETUP_HOST_ATTRIBUTE_RW(field)					\</span>
<span class="cp">	i-&gt;private_host_attrs[count] = device_attr_host_##field;	\</span>
<span class="cp">	if (!i-&gt;f-&gt;set_host_##field) {					\</span>
<span class="cp">		i-&gt;private_host_attrs[count].attr.mode = S_IRUGO;	\</span>
<span class="cp">		i-&gt;private_host_attrs[count].store = NULL;		\</span>
<span class="cp">	}								\</span>
<span class="cp">	i-&gt;host_attrs[count] = &amp;i-&gt;private_host_attrs[count];		\</span>
<span class="cp">	if (i-&gt;f-&gt;show_host_##field)					\</span>
<span class="cp">		count++</span>


<span class="cp">#define fc_private_host_show_function(field, format_string, sz, cast)	\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">show_fc_host_##field (struct device *dev,				\</span>
<span class="cp">		      struct device_attribute *attr, char *buf)		\</span>
<span class="cp">{									\</span>
<span class="cp">	struct Scsi_Host *shost = transport_class_to_shost(dev);	\</span>
<span class="cp">	return snprintf(buf, sz, format_string, cast fc_host_##field(shost)); \</span>
<span class="cp">}</span>

<span class="cp">#define fc_private_host_rd_attr(field, format_string, sz)		\</span>
<span class="cp">	fc_private_host_show_function(field, format_string, sz, )	\</span>
<span class="cp">static FC_DEVICE_ATTR(host, field, S_IRUGO,			\</span>
<span class="cp">			 show_fc_host_##field, NULL)</span>

<span class="cp">#define fc_private_host_rd_attr_cast(field, format_string, sz, cast)	\</span>
<span class="cp">	fc_private_host_show_function(field, format_string, sz, (cast)) \</span>
<span class="cp">static FC_DEVICE_ATTR(host, field, S_IRUGO,			\</span>
<span class="cp">			  show_fc_host_##field, NULL)</span>

<span class="cp">#define SETUP_PRIVATE_HOST_ATTRIBUTE_RD(field)			\</span>
<span class="cp">	i-&gt;private_host_attrs[count] = device_attr_host_##field;	\</span>
<span class="cp">	i-&gt;private_host_attrs[count].attr.mode = S_IRUGO;		\</span>
<span class="cp">	i-&gt;private_host_attrs[count].store = NULL;			\</span>
<span class="cp">	i-&gt;host_attrs[count] = &amp;i-&gt;private_host_attrs[count];		\</span>
<span class="cp">	count++</span>

<span class="cp">#define SETUP_PRIVATE_HOST_ATTRIBUTE_RW(field)			\</span>
<span class="cp">{									\</span>
<span class="cp">	i-&gt;private_host_attrs[count] = device_attr_host_##field;	\</span>
<span class="cp">	i-&gt;host_attrs[count] = &amp;i-&gt;private_host_attrs[count];		\</span>
<span class="cp">	count++;							\</span>
<span class="cp">}</span>


<span class="cm">/* Fixed Host Attributes */</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_fc_host_supported_classes</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			        <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_host_supported_classes</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">==</span> <span class="n">FC_COS_UNSPECIFIED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;unspecified</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">get_fc_cos_names</span><span class="p">(</span><span class="n">fc_host_supported_classes</span><span class="p">(</span><span class="n">shost</span><span class="p">),</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">supported_classes</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		<span class="n">show_fc_host_supported_classes</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_fc_host_supported_fc4s</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">show_fc_fc4s</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">fc_host_supported_fc4s</span><span class="p">(</span><span class="n">shost</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">supported_fc4s</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		<span class="n">show_fc_host_supported_fc4s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_fc_host_supported_speeds</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_host_supported_speeds</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">==</span> <span class="n">FC_PORTSPEED_UNKNOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">get_fc_port_speed_names</span><span class="p">(</span><span class="n">fc_host_supported_speeds</span><span class="p">(</span><span class="n">shost</span><span class="p">),</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">supported_speeds</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		<span class="n">show_fc_host_supported_speeds</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>


<span class="n">fc_private_host_rd_attr_cast</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
<span class="n">fc_private_host_rd_attr_cast</span><span class="p">(</span><span class="n">port_name</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
<span class="n">fc_private_host_rd_attr_cast</span><span class="p">(</span><span class="n">permanent_port_name</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
<span class="n">fc_private_host_rd_attr</span><span class="p">(</span><span class="n">maxframe_size</span><span class="p">,</span> <span class="s">&quot;%u bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">fc_private_host_rd_attr</span><span class="p">(</span><span class="n">max_npiv_vports</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">fc_private_host_rd_attr</span><span class="p">(</span><span class="n">serial_number</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">FC_SERIAL_NUMBER_SIZE</span> <span class="o">+</span><span class="mi">1</span><span class="p">));</span>
<span class="n">fc_private_host_rd_attr</span><span class="p">(</span><span class="n">manufacturer</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">FC_SERIAL_NUMBER_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">fc_private_host_rd_attr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">FC_SYMBOLIC_NAME_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">fc_private_host_rd_attr</span><span class="p">(</span><span class="n">model_description</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">FC_SYMBOLIC_NAME_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">fc_private_host_rd_attr</span><span class="p">(</span><span class="n">hardware_version</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">FC_VERSION_STRING_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">fc_private_host_rd_attr</span><span class="p">(</span><span class="n">driver_version</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">FC_VERSION_STRING_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">fc_private_host_rd_attr</span><span class="p">(</span><span class="n">firmware_version</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">FC_VERSION_STRING_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">fc_private_host_rd_attr</span><span class="p">(</span><span class="n">optionrom_version</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">FC_VERSION_STRING_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>


<span class="cm">/* Dynamic Host Attributes */</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_fc_host_active_fc4s</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_host_active_fc4s</span><span class="p">)</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_host_active_fc4s</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">show_fc_fc4s</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">fc_host_active_fc4s</span><span class="p">(</span><span class="n">shost</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">active_fc4s</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		<span class="n">show_fc_host_active_fc4s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_fc_host_speed</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_host_speed</span><span class="p">)</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_host_speed</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_host_speed</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">==</span> <span class="n">FC_PORTSPEED_UNKNOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">get_fc_port_speed_names</span><span class="p">(</span><span class="n">fc_host_speed</span><span class="p">(</span><span class="n">shost</span><span class="p">),</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		<span class="n">show_fc_host_speed</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>


<span class="n">fc_host_rd_attr</span><span class="p">(</span><span class="n">port_id</span><span class="p">,</span> <span class="s">&quot;0x%06x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">fc_host_rd_enum_attr</span><span class="p">(</span><span class="n">port_type</span><span class="p">,</span> <span class="n">FC_PORTTYPE_MAX_NAMELEN</span><span class="p">);</span>
<span class="n">fc_host_rd_enum_attr</span><span class="p">(</span><span class="n">port_state</span><span class="p">,</span> <span class="n">FC_PORTSTATE_MAX_NAMELEN</span><span class="p">);</span>
<span class="n">fc_host_rd_attr_cast</span><span class="p">(</span><span class="n">fabric_name</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
<span class="n">fc_host_rd_attr</span><span class="p">(</span><span class="n">symbolic_name</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">FC_SYMBOLIC_NAME_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

<span class="n">fc_private_host_show_function</span><span class="p">(</span><span class="n">system_hostname</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">FC_SYMBOLIC_NAME_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">)</span>
<span class="n">fc_host_store_str_function</span><span class="p">(</span><span class="n">system_hostname</span><span class="p">,</span> <span class="n">FC_SYMBOLIC_NAME_SIZE</span><span class="p">)</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">system_hostname</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		<span class="n">show_fc_host_system_hostname</span><span class="p">,</span> <span class="n">store_fc_host_system_hostname</span><span class="p">);</span>


<span class="cm">/* Private Host Attributes */</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_fc_private_host_tgtid_bind_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">get_fc_tgtid_bind_type_name</span><span class="p">(</span><span class="n">fc_host_tgtid_bind_type</span><span class="p">(</span><span class="n">shost</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">FC_BINDTYPE_MAX_NAMELEN</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define get_list_head_entry(pos, head, member) 		\</span>
<span class="cp">	pos = list_entry((head)-&gt;next, typeof(*pos), member)</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_fc_private_host_tgtid_bind_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
 	<span class="k">enum</span> <span class="n">fc_tgtid_binding_type</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_fc_tgtid_bind_type_match</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* if changing bind type, purge all unused consistent bindings */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">fc_host_tgtid_bind_type</span><span class="p">(</span><span class="n">shost</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_host_rport_bindings</span><span class="p">(</span><span class="n">shost</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">get_list_head_entry</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">fc_host_rport_bindings</span><span class="p">(</span><span class="n">shost</span><span class="p">),</span> <span class="n">peers</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">);</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">FC_PORTSTATE_DELETED</span><span class="p">;</span>
			<span class="n">fc_queue_work</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">rport_delete_work</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fc_host_tgtid_bind_type</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">tgtid_bind_type</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
			<span class="n">show_fc_private_host_tgtid_bind_type</span><span class="p">,</span>
			<span class="n">store_fc_private_host_tgtid_bind_type</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_fc_private_host_issue_lip</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* ignore any data value written to the attribute */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">issue_fc_host_lip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">issue_fc_host_lip</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span><span class="o">:</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">issue_lip</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="n">store_fc_private_host_issue_lip</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_fc_private_host_dev_loss_tmo</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_host_attrs</span> <span class="o">*</span><span class="n">fc_host</span> <span class="o">=</span> <span class="n">shost_to_fc_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fc_str_to_dev_loss</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">fc_host_dev_loss_tmo</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">rports</span><span class="p">,</span> <span class="n">peers</span><span class="p">)</span>
		<span class="n">fc_rport_set_dev_loss_tmo</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">fc_private_host_show_function</span><span class="p">(</span><span class="n">dev_loss_tmo</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="p">);</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">dev_loss_tmo</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		      <span class="n">show_fc_host_dev_loss_tmo</span><span class="p">,</span>
		      <span class="n">store_fc_private_host_dev_loss_tmo</span><span class="p">);</span>

<span class="n">fc_private_host_rd_attr</span><span class="p">(</span><span class="n">npiv_vports_inuse</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Host Statistics Management</span>
<span class="cm"> */</span>

<span class="cm">/* Show a given an attribute in the statistics group */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">fc_stat_show</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_host_statistics</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_host_statistics</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">offset</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_fc_host_stats</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stats</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_fc_host_stats</span><span class="p">)(</span><span class="n">shost</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stats</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">stats</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* generate a read-only statistics attribute */</span>
<span class="cp">#define fc_host_statistic(name)						\</span>
<span class="cp">static ssize_t show_fcstat_##name(struct device *cd,			\</span>
<span class="cp">				  struct device_attribute *attr,	\</span>
<span class="cp">				  char *buf)				\</span>
<span class="cp">{									\</span>
<span class="cp">	return fc_stat_show(cd, buf, 					\</span>
<span class="cp">			    offsetof(struct fc_host_statistics, name));	\</span>
<span class="cp">}									\</span>
<span class="cp">static FC_DEVICE_ATTR(host, name, S_IRUGO, show_fcstat_##name, NULL)</span>

<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">seconds_since_last_reset</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">tx_frames</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">tx_words</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">rx_frames</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">rx_words</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">lip_count</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">nos_count</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">error_frames</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">dumped_frames</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">link_failure_count</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">loss_of_sync_count</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">loss_of_signal_count</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">prim_seq_protocol_err_count</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">invalid_tx_word_count</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">invalid_crc_count</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">fcp_input_requests</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">fcp_output_requests</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">fcp_control_requests</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">fcp_input_megabytes</span><span class="p">);</span>
<span class="n">fc_host_statistic</span><span class="p">(</span><span class="n">fcp_output_megabytes</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">fc_reset_statistics</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>

	<span class="cm">/* ignore any data value written to the attribute */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">reset_fc_host_stats</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">reset_fc_host_stats</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">reset_statistics</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="n">fc_reset_statistics</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">fc_statistics_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_seconds_since_last_reset</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_tx_frames</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_tx_words</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_rx_frames</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_rx_words</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_lip_count</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_nos_count</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_error_frames</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_dumped_frames</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_link_failure_count</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_loss_of_sync_count</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_loss_of_signal_count</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_prim_seq_protocol_err_count</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_invalid_tx_word_count</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_invalid_crc_count</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_fcp_input_requests</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_fcp_output_requests</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_fcp_control_requests</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_fcp_input_megabytes</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_fcp_output_megabytes</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_host_reset_statistics</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">fc_statistics_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;statistics&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">fc_statistics_attrs</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* Host Vport Attributes */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">fc_parse_wwn</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">nm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">wwn</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">wwn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wwn</span><span class="p">));</span>

	<span class="cm">/* Validate and store the new name */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

		<span class="n">value</span> <span class="o">=</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="o">*</span><span class="n">ns</span><span class="o">++</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">value</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wwn</span><span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">nm</span> <span class="o">=</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">wwn</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * &quot;Short-cut&quot; sysfs variable to create a new vport on a FC Host.</span>
<span class="cm"> * Input is a string of the form &quot;&lt;WWPN&gt;:&lt;WWNN&gt;&quot;. Other attributes</span>
<span class="cm"> * will default to a NPIV-based FCP_Initiator; The WWNs are specified</span>
<span class="cm"> * as hex characters, and may *not* contain any prefixes (e.g. 0x, x, etc)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_fc_host_vport_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_vport_identifiers</span> <span class="n">vid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">=</span><span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stat</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vid</span><span class="p">));</span>

	<span class="cm">/* count may include a LF at end of string */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="n">cnt</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* validate we have enough characters for WWPN */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cnt</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">16</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">16</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;:&#39;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">stat</span> <span class="o">=</span> <span class="n">fc_parse_wwn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">vid</span><span class="p">.</span><span class="n">port_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">stat</span><span class="p">;</span>

	<span class="n">stat</span> <span class="o">=</span> <span class="n">fc_parse_wwn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">17</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">vid</span><span class="p">.</span><span class="n">node_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">stat</span><span class="p">;</span>

	<span class="n">vid</span><span class="p">.</span><span class="n">roles</span> <span class="o">=</span> <span class="n">FC_PORT_ROLE_FCP_INITIATOR</span><span class="p">;</span>
	<span class="n">vid</span><span class="p">.</span><span class="n">vport_type</span> <span class="o">=</span> <span class="n">FC_PORTTYPE_NPIV</span><span class="p">;</span>
	<span class="cm">/* vid.symbolic_name is already zero/NULL&#39;s */</span>
	<span class="n">vid</span><span class="p">.</span><span class="n">disable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>		<span class="cm">/* always enabled */</span>

	<span class="cm">/* we only allow support on Channel 0 !!! */</span>
	<span class="n">stat</span> <span class="o">=</span> <span class="n">fc_vport_setup</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">stat</span> <span class="o">?</span> <span class="n">stat</span> <span class="o">:</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">vport_create</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="n">store_fc_host_vport_create</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * &quot;Short-cut&quot; sysfs variable to delete a vport on a FC Host.</span>
<span class="cm"> * Vport is identified by a string containing &quot;&lt;WWPN&gt;:&lt;WWNN&gt;&quot;.</span>
<span class="cm"> * The WWNs are specified as hex characters, and may *not* contain</span>
<span class="cm"> * any prefixes (e.g. 0x, x, etc)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_fc_host_vport_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_host_attrs</span> <span class="o">*</span><span class="n">fc_host</span> <span class="o">=</span> <span class="n">shost_to_fc_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">wwpn</span><span class="p">,</span> <span class="n">wwnn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">=</span><span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stat</span><span class="p">,</span> <span class="n">match</span><span class="p">;</span>

	<span class="cm">/* count may include a LF at end of string */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="n">cnt</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* validate we have enough characters for WWPN */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cnt</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">16</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">16</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;:&#39;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">stat</span> <span class="o">=</span> <span class="n">fc_parse_wwn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">wwpn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">stat</span><span class="p">;</span>

	<span class="n">stat</span> <span class="o">=</span> <span class="n">fc_parse_wwn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">17</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">wwnn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">stat</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">match</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* we only allow support on Channel 0 !!! */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">vports</span><span class="p">,</span> <span class="n">peers</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_name</span> <span class="o">==</span> <span class="n">wwpn</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">node_name</span> <span class="o">==</span> <span class="n">wwnn</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FC_VPORT_DEL</span> <span class="o">|</span> <span class="n">FC_VPORT_CREATING</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FC_VPORT_DELETING</span><span class="p">;</span>
			<span class="n">match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">stat</span> <span class="o">=</span> <span class="n">fc_vport_terminate</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">stat</span> <span class="o">?</span> <span class="n">stat</span> <span class="o">:</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FC_DEVICE_ATTR</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">vport_delete</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="n">store_fc_host_vport_delete</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_host_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">attribute_container</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_is_host_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span>  <span class="o">||</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="o">-&gt;</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">class</span>
	    <span class="o">!=</span> <span class="o">&amp;</span><span class="n">fc_host_class</span><span class="p">.</span><span class="n">class</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span> <span class="o">==</span> <span class="n">cont</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_target_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">attribute_container</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_is_target_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span>  <span class="o">||</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="o">-&gt;</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">class</span>
	    <span class="o">!=</span> <span class="o">&amp;</span><span class="n">fc_host_class</span><span class="p">.</span><span class="n">class</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">target_attrs</span><span class="p">.</span><span class="n">ac</span> <span class="o">==</span> <span class="n">cont</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_rport_dev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">dev_to_rport</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">scsi_is_fc_rport</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">==</span> <span class="n">fc_rport_dev_release</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_is_fc_rport</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_rport_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">attribute_container</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_is_fc_rport</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span>  <span class="o">||</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="o">-&gt;</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">class</span>
	    <span class="o">!=</span> <span class="o">&amp;</span><span class="n">fc_host_class</span><span class="p">.</span><span class="n">class</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">rport_attr_cont</span><span class="p">.</span><span class="n">ac</span> <span class="o">==</span> <span class="n">cont</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_vport_dev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">dev_to_vport</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>		<span class="cm">/* release kobj parent */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">scsi_is_fc_vport</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">==</span> <span class="n">fc_vport_dev_release</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_is_fc_vport</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_vport_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">attribute_container</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_is_fc_vport</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vport</span> <span class="o">=</span> <span class="n">dev_to_vport</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">vport_to_shost</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span>  <span class="o">||</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="o">-&gt;</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">class</span>
	    <span class="o">!=</span> <span class="o">&amp;</span><span class="n">fc_host_class</span><span class="p">.</span><span class="n">class</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">vport_attr_cont</span><span class="p">.</span><span class="n">ac</span> <span class="o">==</span> <span class="n">cont</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fc_timed_out - FC Transport I/O timeout intercept handler</span>
<span class="cm"> * @scmd:	The SCSI command which timed out</span>
<span class="cm"> *</span>
<span class="cm"> * This routine protects against error handlers getting invoked while a</span>
<span class="cm"> * rport is in a blocked state, typically due to a temporarily loss of</span>
<span class="cm"> * connectivity. If the error handlers are allowed to proceed, requests</span>
<span class="cm"> * to abort i/o, reset the target, etc will likely fail as there is no way</span>
<span class="cm"> * to communicate with the device to perform the requested function. These</span>
<span class="cm"> * failures may result in the midlayer taking the device offline, requiring</span>
<span class="cm"> * manual intervention to restore operation.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine, called whenever an i/o times out, validates the state of</span>
<span class="cm"> * the underlying rport. If the rport is blocked, it returns</span>
<span class="cm"> * EH_RESET_TIMER, which will continue to reschedule the timeout.</span>
<span class="cm"> * Eventually, either the device will return, or devloss_tmo will fire,</span>
<span class="cm"> * and when the timeout then fires, it will be handled normally.</span>
<span class="cm"> * If the rport is not blocked, normal error handling continues.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	This routine assumes no locks are held on entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">blk_eh_timer_return</span>
<span class="nf">fc_timed_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">starget_to_rport</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">FC_PORTSTATE_BLOCKED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">BLK_EH_RESET_TIMER</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">BLK_EH_NOT_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called by fc_user_scan to locate an rport on the shost that</span>
<span class="cm"> * matches the channel and target id, and invoke scsi_scan_target()</span>
<span class="cm"> * on the rport.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_user_scan_tgt</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="n">uint</span> <span class="n">channel</span><span class="p">,</span> <span class="n">uint</span> <span class="n">id</span><span class="p">,</span> <span class="n">uint</span> <span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_host_rports</span><span class="p">(</span><span class="n">shost</span><span class="p">),</span> <span class="n">peers</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">!=</span> <span class="n">FC_PORTSTATE_ONLINE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">channel</span> <span class="o">==</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">scsi_scan_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called via sysfs scan routines. Necessary, as the FC transport</span>
<span class="cm"> * wants to place all target objects below the rport object. So this</span>
<span class="cm"> * routine must invoke the scsi_scan_target() routine with the rport</span>
<span class="cm"> * object as the parent.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">fc_user_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="n">uint</span> <span class="n">channel</span><span class="p">,</span> <span class="n">uint</span> <span class="n">id</span><span class="p">,</span> <span class="n">uint</span> <span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uint</span> <span class="n">chlo</span><span class="p">,</span> <span class="n">chhi</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">tgtlo</span><span class="p">,</span> <span class="n">tgthi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">channel</span> <span class="o">!=</span> <span class="n">SCAN_WILD_CARD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&gt;</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_channel</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">id</span> <span class="o">!=</span> <span class="n">SCAN_WILD_CARD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_id</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">lun</span> <span class="o">!=</span> <span class="n">SCAN_WILD_CARD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lun</span> <span class="o">&gt;</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_lun</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="n">SCAN_WILD_CARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chlo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">chhi</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">chlo</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
		<span class="n">chhi</span> <span class="o">=</span> <span class="n">channel</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">SCAN_WILD_CARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tgtlo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tgthi</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tgtlo</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
		<span class="n">tgthi</span> <span class="o">=</span> <span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">chlo</span> <span class="o">&lt;</span> <span class="n">chhi</span><span class="p">;</span> <span class="n">chlo</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">tgtlo</span> <span class="o">&lt;</span> <span class="n">tgthi</span><span class="p">;</span> <span class="n">tgtlo</span><span class="o">++</span><span class="p">)</span>
			<span class="n">fc_user_scan_tgt</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">chlo</span><span class="p">,</span> <span class="n">tgtlo</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_tsk_mgmt_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nexus</span><span class="p">,</span> <span class="n">u64</span> <span class="n">tm_id</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">tsk_mgmt_response</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">nexus</span><span class="p">,</span> <span class="n">tm_id</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fc_it_nexus_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nexus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">it_nexus_response</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">nexus</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span>
<span class="nf">fc_attach_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_function_template</span> <span class="o">*</span><span class="n">ft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_internal</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">target_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">starget_attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">target_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fc_transport_class</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">target_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">fc_target_match</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">target_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_starget_attrs</span><span class="p">);</span>
	<span class="n">transport_container_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">target_attrs</span><span class="p">);</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">host_attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fc_host_class</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">fc_host_match</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">host_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_host_attrs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ft</span><span class="o">-&gt;</span><span class="n">get_fc_host_stats</span><span class="p">)</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">statistics</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fc_statistics_group</span><span class="p">;</span>
	<span class="n">transport_container_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">host_attrs</span><span class="p">);</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">rport_attr_cont</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">rport_attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">rport_attr_cont</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fc_rport_class</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">rport_attr_cont</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">fc_rport_match</span><span class="p">;</span>
	<span class="n">transport_container_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">rport_attr_cont</span><span class="p">);</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">vport_attr_cont</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">vport_attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">vport_attr_cont</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fc_vport_class</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">vport_attr_cont</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">fc_vport_match</span><span class="p">;</span>
	<span class="n">transport_container_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">vport_attr_cont</span><span class="p">);</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span> <span class="o">=</span> <span class="n">ft</span><span class="p">;</span>

	<span class="cm">/* Transport uses the shost workq for scsi scanning */</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">create_work_queue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">eh_timed_out</span> <span class="o">=</span> <span class="n">fc_timed_out</span><span class="p">;</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">user_scan</span> <span class="o">=</span> <span class="n">fc_user_scan</span><span class="p">;</span>

	<span class="cm">/* target-mode drivers&#39; functions */</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">tsk_mgmt_response</span> <span class="o">=</span> <span class="n">fc_tsk_mgmt_response</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">it_nexus_response</span> <span class="o">=</span> <span class="n">fc_it_nexus_response</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup SCSI Target Attributes.</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">SETUP_STARGET_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">node_name</span><span class="p">);</span>
	<span class="n">SETUP_STARGET_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">port_name</span><span class="p">);</span>
	<span class="n">SETUP_STARGET_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">port_id</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">FC_STARGET_NUM_ATTRS</span><span class="p">);</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">starget_attrs</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * Setup SCSI Host Attributes.</span>
<span class="cm">	 */</span>
	<span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">node_name</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">port_name</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">permanent_port_name</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">supported_classes</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">supported_fc4s</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">supported_speeds</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">maxframe_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ft</span><span class="o">-&gt;</span><span class="n">vport_create</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SETUP_HOST_ATTRIBUTE_RD_NS</span><span class="p">(</span><span class="n">max_npiv_vports</span><span class="p">);</span>
		<span class="n">SETUP_HOST_ATTRIBUTE_RD_NS</span><span class="p">(</span><span class="n">npiv_vports_inuse</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">serial_number</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">manufacturer</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">model</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">model_description</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">hardware_version</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">driver_version</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">firmware_version</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">optionrom_version</span><span class="p">);</span>

	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">port_id</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">port_type</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">port_state</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">active_fc4s</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">speed</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">fabric_name</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">symbolic_name</span><span class="p">);</span>
	<span class="n">SETUP_HOST_ATTRIBUTE_RW</span><span class="p">(</span><span class="n">system_hostname</span><span class="p">);</span>

	<span class="cm">/* Transport-managed attributes */</span>
	<span class="n">SETUP_PRIVATE_HOST_ATTRIBUTE_RW</span><span class="p">(</span><span class="n">dev_loss_tmo</span><span class="p">);</span>
	<span class="n">SETUP_PRIVATE_HOST_ATTRIBUTE_RW</span><span class="p">(</span><span class="n">tgtid_bind_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ft</span><span class="o">-&gt;</span><span class="n">issue_fc_host_lip</span><span class="p">)</span>
		<span class="n">SETUP_PRIVATE_HOST_ATTRIBUTE_RW</span><span class="p">(</span><span class="n">issue_lip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ft</span><span class="o">-&gt;</span><span class="n">vport_create</span><span class="p">)</span>
		<span class="n">SETUP_PRIVATE_HOST_ATTRIBUTE_RW</span><span class="p">(</span><span class="n">vport_create</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ft</span><span class="o">-&gt;</span><span class="n">vport_delete</span><span class="p">)</span>
		<span class="n">SETUP_PRIVATE_HOST_ATTRIBUTE_RW</span><span class="p">(</span><span class="n">vport_delete</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">FC_HOST_NUM_ATTRS</span><span class="p">);</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">host_attrs</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup Remote Port Attributes.</span>
<span class="cm">	 */</span>
	<span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">SETUP_RPORT_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">maxframe_size</span><span class="p">);</span>
	<span class="n">SETUP_RPORT_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">supported_classes</span><span class="p">);</span>
	<span class="n">SETUP_RPORT_ATTRIBUTE_RW</span><span class="p">(</span><span class="n">dev_loss_tmo</span><span class="p">);</span>
	<span class="n">SETUP_PRIVATE_RPORT_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">node_name</span><span class="p">);</span>
	<span class="n">SETUP_PRIVATE_RPORT_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">port_name</span><span class="p">);</span>
	<span class="n">SETUP_PRIVATE_RPORT_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">port_id</span><span class="p">);</span>
	<span class="n">SETUP_PRIVATE_RPORT_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">roles</span><span class="p">);</span>
	<span class="n">SETUP_PRIVATE_RPORT_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">port_state</span><span class="p">);</span>
	<span class="n">SETUP_PRIVATE_RPORT_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">scsi_target_id</span><span class="p">);</span>
	<span class="n">SETUP_PRIVATE_RPORT_ATTRIBUTE_RW</span><span class="p">(</span><span class="n">fast_io_fail_tmo</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">FC_RPORT_NUM_ATTRS</span><span class="p">);</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">rport_attrs</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup Virtual Port Attributes.</span>
<span class="cm">	 */</span>
	<span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">SETUP_PRIVATE_VPORT_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">vport_state</span><span class="p">);</span>
	<span class="n">SETUP_PRIVATE_VPORT_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">vport_last_state</span><span class="p">);</span>
	<span class="n">SETUP_PRIVATE_VPORT_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">node_name</span><span class="p">);</span>
	<span class="n">SETUP_PRIVATE_VPORT_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">port_name</span><span class="p">);</span>
	<span class="n">SETUP_PRIVATE_VPORT_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">roles</span><span class="p">);</span>
	<span class="n">SETUP_PRIVATE_VPORT_ATTRIBUTE_RD</span><span class="p">(</span><span class="n">vport_type</span><span class="p">);</span>
	<span class="n">SETUP_VPORT_ATTRIBUTE_RW</span><span class="p">(</span><span class="n">symbolic_name</span><span class="p">);</span>
	<span class="n">SETUP_VPORT_ATTRIBUTE_WR</span><span class="p">(</span><span class="n">vport_delete</span><span class="p">);</span>
	<span class="n">SETUP_VPORT_ATTRIBUTE_WR</span><span class="p">(</span><span class="n">vport_disable</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">FC_VPORT_NUM_ATTRS</span><span class="p">);</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">vport_attrs</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_attach_transport</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">fc_release_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

	<span class="n">transport_container_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">target_attrs</span><span class="p">);</span>
	<span class="n">transport_container_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">host_attrs</span><span class="p">);</span>
	<span class="n">transport_container_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">rport_attr_cont</span><span class="p">);</span>
	<span class="n">transport_container_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">vport_attr_cont</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_release_transport</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_queue_work - Queue work to the fc_host workqueue.</span>
<span class="cm"> * @shost:	Pointer to Scsi_Host bound to fc_host.</span>
<span class="cm"> * @work:	Work to queue for execution.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> * 	1 - work queued for execution</span>
<span class="cm"> *	0 - work is already queued</span>
<span class="cm"> *	-EINVAL - work queue doesn&#39;t exist</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">fc_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fc_host_work_q</span><span class="p">(</span><span class="n">shost</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;ERROR: FC host &#39;%s&#39; attempted to queue work, &quot;</span>
			<span class="s">&quot;when no workqueue created.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">queue_work</span><span class="p">(</span><span class="n">fc_host_work_q</span><span class="p">(</span><span class="n">shost</span><span class="p">),</span> <span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_flush_work - Flush a fc_host&#39;s workqueue.</span>
<span class="cm"> * @shost:	Pointer to Scsi_Host bound to fc_host.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_flush_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fc_host_work_q</span><span class="p">(</span><span class="n">shost</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;ERROR: FC host &#39;%s&#39; attempted to flush work, &quot;</span>
			<span class="s">&quot;when no workqueue created.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">fc_host_work_q</span><span class="p">(</span><span class="n">shost</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_queue_devloss_work - Schedule work for the fc_host devloss workqueue.</span>
<span class="cm"> * @shost:	Pointer to Scsi_Host bound to fc_host.</span>
<span class="cm"> * @work:	Work to queue for execution.</span>
<span class="cm"> * @delay:	jiffies to delay the work queuing</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> * 	1 on success / 0 already queued / &lt; 0 for error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">fc_queue_devloss_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fc_host_devloss_work_q</span><span class="p">(</span><span class="n">shost</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;ERROR: FC host &#39;%s&#39; attempted to queue work, &quot;</span>
			<span class="s">&quot;when no workqueue created.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">fc_host_devloss_work_q</span><span class="p">(</span><span class="n">shost</span><span class="p">),</span> <span class="n">work</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_flush_devloss - Flush a fc_host&#39;s devloss workqueue.</span>
<span class="cm"> * @shost:	Pointer to Scsi_Host bound to fc_host.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_flush_devloss</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fc_host_devloss_work_q</span><span class="p">(</span><span class="n">shost</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;ERROR: FC host &#39;%s&#39; attempted to flush work, &quot;</span>
			<span class="s">&quot;when no workqueue created.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">fc_host_devloss_work_q</span><span class="p">(</span><span class="n">shost</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fc_remove_host - called to terminate any fc_transport-related elements for a scsi host.</span>
<span class="cm"> * @shost:	Which &amp;Scsi_Host</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is expected to be called immediately preceding the</span>
<span class="cm"> * a driver&#39;s call to scsi_remove_host().</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING: A driver utilizing the fc_transport, which fails to call</span>
<span class="cm"> *   this routine prior to scsi_remove_host(), will leave dangling</span>
<span class="cm"> *   objects in /sys/class/fc_remote_ports. Access to any of these</span>
<span class="cm"> *   objects can result in a system crash !!!</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	This routine assumes no locks are held on entry.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">fc_remove_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">next_vport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">next_rport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">work_q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_host_attrs</span> <span class="o">*</span><span class="n">fc_host</span> <span class="o">=</span> <span class="n">shost_to_fc_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Remove any vports */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">next_vport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">vports</span><span class="p">,</span> <span class="n">peers</span><span class="p">)</span>
		<span class="n">fc_queue_work</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vport_delete_work</span><span class="p">);</span>

	<span class="cm">/* Remove any remote ports */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="n">next_rport</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">rports</span><span class="p">,</span> <span class="n">peers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">);</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">FC_PORTSTATE_DELETED</span><span class="p">;</span>
		<span class="n">fc_queue_work</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">rport_delete_work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="n">next_rport</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">rport_bindings</span><span class="p">,</span> <span class="n">peers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">);</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">FC_PORTSTATE_DELETED</span><span class="p">;</span>
		<span class="n">fc_queue_work</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">rport_delete_work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* flush all scan work items */</span>
	<span class="n">scsi_flush_work</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="cm">/* flush all stgt delete, and rport delete work items, then kill it  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">work_q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">work_q</span> <span class="o">=</span> <span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">work_q</span><span class="p">;</span>
		<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">work_q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">work_q</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* flush all devloss work items, then kill it  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">devloss_work_q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">work_q</span> <span class="o">=</span> <span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">devloss_work_q</span><span class="p">;</span>
		<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">devloss_work_q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">work_q</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_remove_host</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_terminate_rport_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">rport_to_shost</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>

	<span class="cm">/* Involve the LLDD if possible to terminate all io on the rport. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">terminate_rport_io</span><span class="p">)</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">terminate_rport_io</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * must unblock to flush queued IO. The caller will have set</span>
<span class="cm">	 * the port_state or flags, so that fc_remote_port_chkready will</span>
<span class="cm">	 * fail IO.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_target_unblock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_starget_delete - called to delete the scsi descendants of an rport</span>
<span class="cm"> * @work:	remote port to be operated on.</span>
<span class="cm"> *</span>
<span class="cm"> * Deletes target and all sdevs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_starget_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_rport</span><span class="p">,</span> <span class="n">stgt_delete_work</span><span class="p">);</span>

	<span class="n">fc_terminate_rport_io</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
	<span class="n">scsi_remove_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fc_rport_final_delete - finish rport termination and delete it.</span>
<span class="cm"> * @work:	remote port to be deleted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_rport_final_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_rport</span><span class="p">,</span> <span class="n">rport_delete_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">rport_to_shost</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_callback</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fc_terminate_rport_io</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if a scan is pending, flush the SCSI Host work_q so that</span>
<span class="cm">	 * that we can reclaim the rport scan work element.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FC_RPORT_SCAN_PENDING</span><span class="p">)</span>
		<span class="n">scsi_flush_work</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cancel any outstanding timers. These should really exist</span>
<span class="cm">	 * only when rmmod&#39;ing the LLDD and we&#39;re asking for</span>
<span class="cm">	 * immediate termination of the rports</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FC_RPORT_DEVLOSS_PENDING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">fail_io_work</span><span class="p">))</span>
			<span class="n">fc_flush_devloss</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev_loss_work</span><span class="p">))</span>
			<span class="n">fc_flush_devloss</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_RPORT_DEVLOSS_PENDING</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Delete SCSI target and sdevs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">fc_starget_delete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">stgt_delete_work</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Notify the driver that the rport is now dead. The LLDD will</span>
<span class="cm">	 * also guarantee that any communication to the rport is terminated</span>
<span class="cm">	 *</span>
<span class="cm">	 * Avoid this call if we already called it when we preserved the</span>
<span class="cm">	 * rport for the binding.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FC_RPORT_DEVLOSS_CALLBK_DONE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo_callbk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FC_RPORT_DEVLOSS_CALLBK_DONE</span><span class="p">;</span>
		<span class="n">do_callback</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">do_callback</span><span class="p">)</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo_callbk</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>

	<span class="n">fc_bsg_remove</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">rqst_q</span><span class="p">);</span>

	<span class="n">transport_remove_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">device_del</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">transport_destroy_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">);</span>	<span class="cm">/* for fc_host-&gt;rport list */</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>			<span class="cm">/* for self-reference */</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fc_rport_create - allocates and creates a remote FC port.</span>
<span class="cm"> * @shost:	scsi host the remote port is connected to.</span>
<span class="cm"> * @channel:	Channel on shost port connected to.</span>
<span class="cm"> * @ids:	The world wide names, fc address, and FC4 port</span>
<span class="cm"> *		roles for the remote port.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates and creates the remoter port structure, including the</span>
<span class="cm"> * class and sysfs creation.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	This routine assumes no locks are held on entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span>
<span class="nf">fc_rport_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">fc_rport_identifiers</span>  <span class="o">*</span><span class="n">ids</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_host_attrs</span> <span class="o">*</span><span class="n">fc_host</span> <span class="o">=</span> <span class="n">shost_to_fc_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">fci</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span><span class="p">)</span> <span class="o">+</span> <span class="n">fci</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dd_fcrport_size</span><span class="p">);</span>
	<span class="n">rport</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rport</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: allocation failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">maxframe_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">supported_classes</span> <span class="o">=</span> <span class="n">FC_COS_UNSPECIFIED</span><span class="p">;</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo</span> <span class="o">=</span> <span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">));</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">=</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">;</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">=</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">roles</span><span class="p">;</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">FC_PORTSTATE_ONLINE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fci</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dd_fcrport_size</span><span class="p">)</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rport</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">fast_io_fail_tmo</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev_loss_work</span><span class="p">,</span> <span class="n">fc_timeout_deleted_rport</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">fail_io_work</span><span class="p">,</span> <span class="n">fc_timeout_fail_rport_io</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scan_work</span><span class="p">,</span> <span class="n">fc_scsi_scan_rport</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">stgt_delete_work</span><span class="p">,</span> <span class="n">fc_starget_delete</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">rport_delete_work</span><span class="p">,</span> <span class="n">fc_rport_final_delete</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">next_rport_number</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">&amp;</span> <span class="n">FC_PORT_ROLE_FCP_TARGET</span><span class="p">)</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">=</span> <span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">next_target_id</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">rports</span><span class="p">);</span>
	<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">);</span>	<span class="cm">/* for fc_host-&gt;rport list */</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">device_initialize</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>			<span class="cm">/* takes self reference */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">);</span> <span class="cm">/* parent reference */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="n">fc_rport_dev_release</span><span class="p">;</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rport-%d:%d-%d&quot;</span><span class="p">,</span>
		     <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="n">transport_setup_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">device_add</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;FC Remote Port device_add failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">delete_rport</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">transport_add_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">transport_configure_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">fc_bsg_rportadd</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">rport</span><span class="p">);</span>
	<span class="cm">/* ignore any bsg add error - we just can&#39;t do sgio */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">&amp;</span> <span class="n">FC_PORT_ROLE_FCP_TARGET</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* initiate a scan of the target */</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FC_RPORT_SCAN_PENDING</span><span class="p">;</span>
		<span class="n">scsi_queue_work</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scan_work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rport</span><span class="p">;</span>

<span class="nl">delete_rport:</span>
	<span class="n">transport_destroy_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">);</span>	<span class="cm">/* for fc_host-&gt;rport list */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_remote_port_add - notify fc transport of the existence of a remote FC port.</span>
<span class="cm"> * @shost:	scsi host the remote port is connected to.</span>
<span class="cm"> * @channel:	Channel on shost port connected to.</span>
<span class="cm"> * @ids:	The world wide names, fc address, and FC4 port</span>
<span class="cm"> *		roles for the remote port.</span>
<span class="cm"> *</span>
<span class="cm"> * The LLDD calls this routine to notify the transport of the existence</span>
<span class="cm"> * of a remote port. The LLDD provides the unique identifiers (wwpn,wwn)</span>
<span class="cm"> * of the port, it&#39;s FC address (port_id), and the FC4 roles that are</span>
<span class="cm"> * active for the port.</span>
<span class="cm"> *</span>
<span class="cm"> * For ports that are FCP targets (aka scsi targets), the FC transport</span>
<span class="cm"> * maintains consistent target id bindings on behalf of the LLDD.</span>
<span class="cm"> * A consistent target id binding is an assignment of a target id to</span>
<span class="cm"> * a remote port identifier, which persists while the scsi host is</span>
<span class="cm"> * attached. The remote port can disappear, then later reappear, and</span>
<span class="cm"> * it&#39;s target id assignment remains the same. This allows for shifts</span>
<span class="cm"> * in FC addressing (if binding by wwpn or wwnn) with no apparent</span>
<span class="cm"> * changes to the scsi subsystem which is based on scsi host number and</span>
<span class="cm"> * target id values.  Bindings are only valid during the attachment of</span>
<span class="cm"> * the scsi host. If the host detaches, then later re-attaches, target</span>
<span class="cm"> * id bindings may change.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is responsible for returning a remote port structure.</span>
<span class="cm"> * The routine will search the list of remote ports it maintains</span>
<span class="cm"> * internally on behalf of consistent target id mappings. If found, the</span>
<span class="cm"> * remote port structure will be reused. Otherwise, a new remote port</span>
<span class="cm"> * structure will be allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * Whenever a remote port is allocated, a new fc_remote_port class</span>
<span class="cm"> * device is created.</span>
<span class="cm"> *</span>
<span class="cm"> * Should not be called from interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	This routine assumes no locks are held on entry.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span>
<span class="nf">fc_remote_port_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">fc_rport_identifiers</span>  <span class="o">*</span><span class="n">ids</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">fci</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_host_attrs</span> <span class="o">*</span><span class="n">fc_host</span> <span class="o">=</span> <span class="n">shost_to_fc_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">match</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* ensure any stgt delete functions are done */</span>
	<span class="n">fc_flush_work</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search the list of &quot;active&quot; rports, for an rport that has been</span>
<span class="cm">	 * deleted, but we&#39;ve held off the real delete while the target</span>
<span class="cm">	 * is in a &quot;blocked&quot; state.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">rports</span><span class="p">,</span> <span class="n">peers</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">FC_PORTSTATE_BLOCKED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">==</span> <span class="n">channel</span><span class="p">))</span> <span class="p">{</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">tgtid_bind_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">FC_TGTID_BIND_BY_WWPN</span>:
			<span class="k">case</span> <span class="n">FC_TGTID_BIND_NONE</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_name</span> <span class="o">==</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">)</span>
					<span class="n">match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">FC_TGTID_BIND_BY_WWNN</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">node_name</span> <span class="o">==</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">)</span>
					<span class="n">match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">FC_TGTID_BIND_BY_ID</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">==</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">)</span>
					<span class="n">match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="p">{</span>

				<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">));</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">));</span>
				<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">=</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">;</span>

				<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">FC_PORTSTATE_ONLINE</span><span class="p">;</span>
				<span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">=</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">roles</span><span class="p">;</span>

				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">fci</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dd_fcrport_size</span><span class="p">)</span>
					<span class="n">memset</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">fci</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dd_fcrport_size</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * If we were not a target, cancel the</span>
<span class="cm">				 * io terminate and rport timers, and</span>
<span class="cm">				 * we&#39;re done.</span>
<span class="cm">				 *</span>
<span class="cm">				 * If we were a target, but our new role</span>
<span class="cm">				 * doesn&#39;t indicate a target, leave the</span>
<span class="cm">				 * timers running expecting the role to</span>
<span class="cm">				 * change as the target fully logs in. If</span>
<span class="cm">				 * it doesn&#39;t, the target will be torn down.</span>
<span class="cm">				 *</span>
<span class="cm">				 * If we were a target, and our role shows</span>
<span class="cm">				 * we&#39;re still a target, cancel the timers</span>
<span class="cm">				 * and kick off a scan.</span>
<span class="cm">				 */</span>

				<span class="cm">/* was a target, not in roles */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">&amp;</span> <span class="n">FC_PORT_ROLE_FCP_TARGET</span><span class="p">)))</span>
					<span class="k">return</span> <span class="n">rport</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * Stop the fail io and dev_loss timers.</span>
<span class="cm">				 * If they flush, the port_state will</span>
<span class="cm">				 * be checked and will NOOP the function.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">fail_io_work</span><span class="p">))</span>
					<span class="n">fc_flush_devloss</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev_loss_work</span><span class="p">))</span>
					<span class="n">fc_flush_devloss</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

				<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FC_RPORT_FAST_FAIL_TIMEDOUT</span> <span class="o">|</span>
						  <span class="n">FC_RPORT_DEVLOSS_PENDING</span> <span class="o">|</span>
						  <span class="n">FC_RPORT_DEVLOSS_CALLBK_DONE</span><span class="p">);</span>

				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

				<span class="cm">/* if target, initiate a scan */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">scsi_target_unblock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

					<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
							  <span class="n">flags</span><span class="p">);</span>
					<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FC_RPORT_SCAN_PENDING</span><span class="p">;</span>
					<span class="n">scsi_queue_work</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scan_work</span><span class="p">);</span>
					<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
							<span class="n">flags</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">fc_bsg_goose_queue</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>

				<span class="k">return</span> <span class="n">rport</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search the bindings array</span>
<span class="cm">	 * Note: if never a FCP target, you won&#39;t be on this list</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">tgtid_bind_type</span> <span class="o">!=</span> <span class="n">FC_TGTID_BIND_NONE</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* search for a matching consistent binding */</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">rport_bindings</span><span class="p">,</span>
					<span class="n">peers</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">!=</span> <span class="n">channel</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">tgtid_bind_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">FC_TGTID_BIND_BY_WWPN</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_name</span> <span class="o">==</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">)</span>
					<span class="n">match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">FC_TGTID_BIND_BY_WWNN</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">node_name</span> <span class="o">==</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">)</span>
					<span class="n">match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">FC_TGTID_BIND_BY_ID</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">==</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">)</span>
					<span class="n">match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">FC_TGTID_BIND_NONE</span>: <span class="cm">/* to keep compiler happy */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">rports</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">));</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">));</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">=</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">;</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">=</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">roles</span><span class="p">;</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">FC_PORTSTATE_ONLINE</span><span class="p">;</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_RPORT_FAST_FAIL_TIMEDOUT</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">fci</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dd_fcrport_size</span><span class="p">)</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">fci</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dd_fcrport_size</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">&amp;</span> <span class="n">FC_PORT_ROLE_FCP_TARGET</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">scsi_target_unblock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

				<span class="cm">/* initiate a scan of the target */</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FC_RPORT_SCAN_PENDING</span><span class="p">;</span>
				<span class="n">scsi_queue_work</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scan_work</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">rport</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* No consistent binding found - create new remote port entry */</span>
	<span class="n">rport</span> <span class="o">=</span> <span class="n">fc_rport_create</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">ids</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rport</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_remote_port_add</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * fc_remote_port_delete - notifies the fc transport that a remote port is no longer in existence.</span>
<span class="cm"> * @rport:	The remote port that no longer exists</span>
<span class="cm"> *</span>
<span class="cm"> * The LLDD calls this routine to notify the transport that a remote</span>
<span class="cm"> * port is no longer part of the topology. Note: Although a port</span>
<span class="cm"> * may no longer be part of the topology, it may persist in the remote</span>
<span class="cm"> * ports displayed by the fc_host. We do this under 2 conditions:</span>
<span class="cm"> * 1) If the port was a scsi target, we delay its deletion by &quot;blocking&quot; it.</span>
<span class="cm"> *   This allows the port to temporarily disappear, then reappear without</span>
<span class="cm"> *   disrupting the SCSI device tree attached to it. During the &quot;blocked&quot;</span>
<span class="cm"> *   period the port will still exist.</span>
<span class="cm"> * 2) If the port was a scsi target and disappears for longer than we</span>
<span class="cm"> *   expect, we&#39;ll delete the port and the tear down the SCSI device tree</span>
<span class="cm"> *   attached to it. However, we want to semi-persist the target id assigned</span>
<span class="cm"> *   to that port if it eventually does exist. The port structure will</span>
<span class="cm"> *   remain (although with minimal information) so that the target id</span>
<span class="cm"> *   bindings remails.</span>
<span class="cm"> *</span>
<span class="cm"> * If the remote port is not an FCP Target, it will be fully torn down</span>
<span class="cm"> * and deallocated, including the fc_remote_port class device.</span>
<span class="cm"> *</span>
<span class="cm"> * If the remote port is an FCP Target, the port will be placed in a</span>
<span class="cm"> * temporary blocked state. From the LLDD&#39;s perspective, the rport no</span>
<span class="cm"> * longer exists. From the SCSI midlayer&#39;s perspective, the SCSI target</span>
<span class="cm"> * exists, but all sdevs on it are blocked from further I/O. The following</span>
<span class="cm"> * is then expected.</span>
<span class="cm"> *</span>
<span class="cm"> *   If the remote port does not return (signaled by a LLDD call to</span>
<span class="cm"> *   fc_remote_port_add()) within the dev_loss_tmo timeout, then the</span>
<span class="cm"> *   scsi target is removed - killing all outstanding i/o and removing the</span>
<span class="cm"> *   scsi devices attached ot it. The port structure will be marked Not</span>
<span class="cm"> *   Present and be partially cleared, leaving only enough information to</span>
<span class="cm"> *   recognize the remote port relative to the scsi target id binding if</span>
<span class="cm"> *   it later appears.  The port will remain as long as there is a valid</span>
<span class="cm"> *   binding (e.g. until the user changes the binding type or unloads the</span>
<span class="cm"> *   scsi host with the binding).</span>
<span class="cm"> *</span>
<span class="cm"> *   If the remote port returns within the dev_loss_tmo value (and matches</span>
<span class="cm"> *   according to the target id binding type), the port structure will be</span>
<span class="cm"> *   reused. If it is no longer a SCSI target, the target will be torn</span>
<span class="cm"> *   down. If it continues to be a SCSI target, then the target will be</span>
<span class="cm"> *   unblocked (allowing i/o to be resumed), and a scan will be activated</span>
<span class="cm"> *   to ensure that all luns are detected.</span>
<span class="cm"> *</span>
<span class="cm"> * Called from normal process context only - cannot be called from interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	This routine assumes no locks are held on entry.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">fc_remote_port_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span>  <span class="o">*</span><span class="n">rport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">rport_to_shost</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No need to flush the fc_host work_q&#39;s, as all adds are synchronous.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We do need to reclaim the rport scan work element, so eventually</span>
<span class="cm">	 * (in fc_rport_final_delete()) we&#39;ll flush the scsi host work_q if</span>
<span class="cm">	 * there&#39;s still a scan pending.</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">!=</span> <span class="n">FC_PORTSTATE_ONLINE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * In the past, we if this was not an FCP-Target, we would</span>
<span class="cm">	 * unconditionally just jump to deleting the rport.</span>
<span class="cm">	 * However, rports can be used as node containers by the LLDD,</span>
<span class="cm">	 * and its not appropriate to just terminate the rport at the</span>
<span class="cm">	 * first sign of a loss in connectivity. The LLDD may want to</span>
<span class="cm">	 * send ELS traffic to re-validate the login. If the rport is</span>
<span class="cm">	 * immediately deleted, it makes it inappropriate for a node</span>
<span class="cm">	 * container.</span>
<span class="cm">	 * So... we now unconditionally wait dev_loss_tmo before</span>
<span class="cm">	 * destroying an rport.</span>
<span class="cm">	 */</span>

	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">FC_PORTSTATE_BLOCKED</span><span class="p">;</span>

	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FC_RPORT_DEVLOSS_PENDING</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">&amp;</span> <span class="n">FC_PORT_ROLE_FCP_INITIATOR</span> <span class="o">&amp;&amp;</span>
	    <span class="n">shost</span><span class="o">-&gt;</span><span class="n">active_mode</span> <span class="o">&amp;</span> <span class="n">MODE_TARGET</span><span class="p">)</span>
		<span class="n">fc_tgt_it_nexus_destroy</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">rport</span><span class="p">);</span>

	<span class="n">scsi_target_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* see if we need to kill io faster than waiting for device loss */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">fast_io_fail_tmo</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">fast_io_fail_tmo</span> <span class="o">&lt;</span> <span class="n">timeout</span><span class="p">))</span>
		<span class="n">fc_queue_devloss_work</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">fail_io_work</span><span class="p">,</span>
					<span class="n">rport</span><span class="o">-&gt;</span><span class="n">fast_io_fail_tmo</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="cm">/* cap the length the devices can be blocked until they are deleted */</span>
	<span class="n">fc_queue_devloss_work</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev_loss_work</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_remote_port_delete</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_remote_port_rolechg - notifies the fc transport that the roles on a remote may have changed.</span>
<span class="cm"> * @rport:	The remote port that changed.</span>
<span class="cm"> * @roles:      New roles for this port.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: The LLDD calls this routine to notify the transport that the</span>
<span class="cm"> * roles on a remote port may have changed. The largest effect of this is</span>
<span class="cm"> * if a port now becomes a FCP Target, it must be allocated a</span>
<span class="cm"> * scsi target id.  If the port is no longer a FCP target, any</span>
<span class="cm"> * scsi target id value assigned to it will persist in case the</span>
<span class="cm"> * role changes back to include FCP Target. No changes in the scsi</span>
<span class="cm"> * midlayer will be invoked if the role changes (in the expectation</span>
<span class="cm"> * that the role will be resumed. If it doesn&#39;t normal error processing</span>
<span class="cm"> * will take place).</span>
<span class="cm"> *</span>
<span class="cm"> * Should not be called from interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	This routine assumes no locks are held on entry.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">fc_remote_port_rolechg</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span>  <span class="o">*</span><span class="n">rport</span><span class="p">,</span> <span class="n">u32</span> <span class="n">roles</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">rport_to_shost</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_host_attrs</span> <span class="o">*</span><span class="n">fc_host</span> <span class="o">=</span> <span class="n">shost_to_fc_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">create</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">roles</span> <span class="o">&amp;</span> <span class="n">FC_PORT_ROLE_FCP_TARGET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">=</span> <span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">next_target_id</span><span class="o">++</span><span class="p">;</span>
			<span class="n">create</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">&amp;</span> <span class="n">FC_PORT_ROLE_FCP_TARGET</span><span class="p">))</span>
			<span class="n">create</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">active_mode</span> <span class="o">&amp;</span> <span class="n">MODE_TARGET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">fc_tgt_it_nexus_create</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">rport</span><span class="p">,</span>
					     <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;FC Remore Port tgt nexus failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">=</span> <span class="n">roles</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">create</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * There may have been a delete timer running on the</span>
<span class="cm">		 * port. Ensure that it is cancelled as we now know</span>
<span class="cm">		 * the port is an FCP Target.</span>
<span class="cm">		 * Note: we know the rport is exists and in an online</span>
<span class="cm">		 *  state as the LLDD would not have had an rport</span>
<span class="cm">		 *  reference to pass us.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Take no action on the del_timer failure as the state</span>
<span class="cm">		 * machine state change will validate the</span>
<span class="cm">		 * transaction.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">fail_io_work</span><span class="p">))</span>
			<span class="n">fc_flush_devloss</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev_loss_work</span><span class="p">))</span>
			<span class="n">fc_flush_devloss</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FC_RPORT_FAST_FAIL_TIMEDOUT</span> <span class="o">|</span>
				  <span class="n">FC_RPORT_DEVLOSS_PENDING</span> <span class="o">|</span>
				  <span class="n">FC_RPORT_DEVLOSS_CALLBK_DONE</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* ensure any stgt delete functions are done */</span>
		<span class="n">fc_flush_work</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

		<span class="n">scsi_target_unblock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="cm">/* initiate a scan of the target */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FC_RPORT_SCAN_PENDING</span><span class="p">;</span>
		<span class="n">scsi_queue_work</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scan_work</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_remote_port_rolechg</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_timeout_deleted_rport - Timeout handler for a deleted remote port.</span>
<span class="cm"> * @work:	rport target that failed to reappear in the allotted time.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: An attempt to delete a remote port blocks, and if it fails</span>
<span class="cm"> *              to return in the allotted time this gets called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_timeout_deleted_rport</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_rport</span><span class="p">,</span> <span class="n">dev_loss_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">rport_to_shost</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_host_attrs</span> <span class="o">*</span><span class="n">fc_host</span> <span class="o">=</span> <span class="n">shost_to_fc_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_callback</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_RPORT_DEVLOSS_PENDING</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the port is ONLINE, then it came back. If it was a SCSI</span>
<span class="cm">	 * target, validate it still is. If not, tear down the</span>
<span class="cm">	 * scsi_target on it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">FC_PORTSTATE_ONLINE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">&amp;</span> <span class="n">FC_PORT_ROLE_FCP_TARGET</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;blocked FC remote port time out: no longer&quot;</span>
			<span class="s">&quot; a FCP target, removing starget</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">scsi_target_unblock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">fc_queue_work</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">stgt_delete_work</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* NOOP state - we&#39;re flushing workq&#39;s */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">!=</span> <span class="n">FC_PORTSTATE_BLOCKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;blocked FC remote port time out: leaving&quot;</span>
			<span class="s">&quot; rport%s alone</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span>  <span class="s">&quot; and starget&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">tgtid_bind_type</span> <span class="o">==</span> <span class="n">FC_TGTID_BIND_NONE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">);</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">FC_PORTSTATE_DELETED</span><span class="p">;</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;blocked FC remote port time out: removing&quot;</span>
			<span class="s">&quot; rport%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span>  <span class="s">&quot; and starget&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="n">fc_queue_work</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">rport_delete_work</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;blocked FC remote port time out: removing target and &quot;</span>
		<span class="s">&quot;saving binding</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">rport_bindings</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: We do not remove or clear the hostdata area. This allows</span>
<span class="cm">	 *   host-specific target data to persist along with the</span>
<span class="cm">	 *   scsi_target_id. It&#39;s up to the host to manage it&#39;s hostdata area.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reinitialize port attributes that may change if the port comes back.</span>
<span class="cm">	 */</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">maxframe_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">supported_classes</span> <span class="o">=</span> <span class="n">FC_COS_UNSPECIFIED</span><span class="p">;</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">=</span> <span class="n">FC_PORT_ROLE_UNKNOWN</span><span class="p">;</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">FC_PORTSTATE_NOTPRESENT</span><span class="p">;</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_RPORT_FAST_FAIL_TIMEDOUT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pre-emptively kill I/O rather than waiting for the work queue</span>
<span class="cm">	 * item to teardown the starget. (FCOE libFC folks prefer this</span>
<span class="cm">	 * and to have the rport_port_id still set when it&#39;s done).</span>
<span class="cm">	 */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">fc_terminate_rport_io</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">FC_PORTSTATE_NOTPRESENT</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* still missing */</span>

		<span class="cm">/* remove the identifiers that aren&#39;t used in the consisting binding */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">tgtid_bind_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FC_TGTID_BIND_BY_WWPN</span>:
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">node_name</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FC_TGTID_BIND_BY_WWNN</span>:
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_name</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FC_TGTID_BIND_BY_ID</span>:
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">node_name</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_name</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FC_TGTID_BIND_NONE</span>:	<span class="cm">/* to keep compiler happy */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * As this only occurs if the remote port (scsi target)</span>
<span class="cm">		 * went away and didn&#39;t come back - we&#39;ll remove</span>
<span class="cm">		 * all attached scsi devices.</span>
<span class="cm">		 */</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FC_RPORT_DEVLOSS_CALLBK_DONE</span><span class="p">;</span>
		<span class="n">fc_queue_work</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">stgt_delete_work</span><span class="p">);</span>

		<span class="n">do_callback</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Notify the driver that the rport is now dead. The LLDD will</span>
<span class="cm">	 * also guarantee that any communication to the rport is terminated</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: we set the CALLBK_DONE flag above to correspond</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_callback</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo_callbk</span><span class="p">)</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo_callbk</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fc_timeout_fail_rport_io - Timeout handler for a fast io failing on a disconnected SCSI target.</span>
<span class="cm"> * @work:	rport to terminate io on.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes: Only requests the failure of the io, not that all are flushed</span>
<span class="cm"> *    prior to returning.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_timeout_fail_rport_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_rport</span><span class="p">,</span> <span class="n">fail_io_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">!=</span> <span class="n">FC_PORTSTATE_BLOCKED</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FC_RPORT_FAST_FAIL_TIMEDOUT</span><span class="p">;</span>
	<span class="n">fc_terminate_rport_io</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_scsi_scan_rport - called to perform a scsi scan on a remote port.</span>
<span class="cm"> * @work:	remote port to be scanned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_scsi_scan_rport</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_rport</span><span class="p">,</span> <span class="n">scan_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">rport_to_shost</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">FC_PORTSTATE_ONLINE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">&amp;</span> <span class="n">FC_PORT_ROLE_FCP_TARGET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">disable_target_scan</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">scsi_scan_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span><span class="p">,</span> <span class="n">SCAN_WILD_CARD</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_RPORT_SCAN_PENDING</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_block_scsi_eh - Block SCSI eh thread for blocked fc_rport</span>
<span class="cm"> * @cmnd: SCSI command that scsi_eh is trying to recover</span>
<span class="cm"> *</span>
<span class="cm"> * This routine can be called from a FC LLD scsi_eh callback. It</span>
<span class="cm"> * blocks the scsi_eh thread until the fc_rport leaves the</span>
<span class="cm"> * FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is</span>
<span class="cm"> * necessary to avoid the scsi_eh failing recovery actions for blocked</span>
<span class="cm"> * rports which would lead to offlined SCSI devices.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if the fc_rport left the state FC_PORTSTATE_BLOCKED.</span>
<span class="cm"> *	    FAST_IO_FAIL if the fast_io_fail_tmo fired, this should be</span>
<span class="cm"> *	    passed back to scsi_eh.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fc_block_scsi_eh</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">starget_to_rport</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">FC_PORTSTATE_BLOCKED</span> <span class="o">&amp;&amp;</span>
	       <span class="o">!</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FC_RPORT_FAST_FAIL_TIMEDOUT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FC_RPORT_FAST_FAIL_TIMEDOUT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FAST_IO_FAIL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_block_scsi_eh</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_vport_setup - allocates and creates a FC virtual port.</span>
<span class="cm"> * @shost:	scsi host the virtual port is connected to.</span>
<span class="cm"> * @channel:	Channel on shost port connected to.</span>
<span class="cm"> * @pdev:	parent device for vport</span>
<span class="cm"> * @ids:	The world wide names, FC4 port roles, etc for</span>
<span class="cm"> *              the virtual port.</span>
<span class="cm"> * @ret_vport:	The pointer to the created vport.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates and creates the vport structure, calls the parent host</span>
<span class="cm"> * to instantiate the vport, the completes w/ class and sysfs creation.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	This routine assumes no locks are held on entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">fc_vport_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">fc_vport_identifiers</span>  <span class="o">*</span><span class="n">ids</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">**</span><span class="n">ret_vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_host_attrs</span> <span class="o">*</span><span class="n">fc_host</span> <span class="o">=</span> <span class="n">shost_to_fc_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">fci</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ret_vport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">fci</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">vport_create</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span><span class="p">)</span> <span class="o">+</span> <span class="n">fci</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dd_fcvport_size</span><span class="p">);</span>
	<span class="n">vport</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">vport</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: allocation failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">vport_state</span> <span class="o">=</span> <span class="n">FC_VPORT_UNKNOWN</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">vport_last_state</span> <span class="o">=</span> <span class="n">FC_VPORT_UNKNOWN</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">node_name</span> <span class="o">=</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_name</span> <span class="o">=</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">=</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">roles</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">vport_type</span> <span class="o">=</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">vport_type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fci</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dd_fcvport_size</span><span class="p">)</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">dd_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vport</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">shost</span> <span class="o">=</span> <span class="n">shost</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">FC_VPORT_CREATING</span><span class="p">;</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vport_delete_work</span><span class="p">,</span> <span class="n">fc_vport_sched_delete</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">npiv_vports_inuse</span> <span class="o">&gt;=</span> <span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">max_npiv_vports</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">npiv_vports_inuse</span><span class="o">++</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">next_vport_number</span><span class="o">++</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">vports</span><span class="p">);</span>
	<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">);</span>	<span class="cm">/* for fc_host-&gt;vport list */</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">device_initialize</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>			<span class="cm">/* takes self reference */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">get_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>		<span class="cm">/* takes parent reference */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="n">fc_vport_dev_release</span><span class="p">;</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vport-%d:%d-%d&quot;</span><span class="p">,</span>
		     <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="n">transport_setup_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">device_add</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;FC Virtual Port device_add failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">delete_vport</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">transport_add_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">transport_configure_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">fci</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">vport_create</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">disable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;FC Virtual Port LLDD Create failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">delete_vport_all</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * if the parent isn&#39;t the physical adapter&#39;s Scsi_Host, ensure</span>
<span class="cm">	 * the Scsi_Host at least contains ia symlink to the vport.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;%s: Cannot create vport symlinks for &quot;</span>
				<span class="s">&quot;%s, err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VPORT_CREATING</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span>
			<span class="s">&quot;%s created via shost%d channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span>
			<span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ret_vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">delete_vport_all:</span>
	<span class="n">transport_remove_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">device_del</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">delete_vport:</span>
	<span class="n">transport_destroy_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">);</span>	<span class="cm">/* for fc_host-&gt;vport list */</span>
	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">npiv_vports_inuse</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_vport_create - Admin App or LLDD requests creation of a vport</span>
<span class="cm"> * @shost:	scsi host the virtual port is connected to.</span>
<span class="cm"> * @channel:	channel on shost port connected to.</span>
<span class="cm"> * @ids:	The world wide names, FC4 port roles, etc for</span>
<span class="cm"> *              the virtual port.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	This routine assumes no locks are held on entry.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span>
<span class="nf">fc_vport_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">fc_vport_identifiers</span> <span class="o">*</span><span class="n">ids</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">stat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>

	<span class="n">stat</span> <span class="o">=</span> <span class="n">fc_vport_setup</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">,</span>
		 <span class="n">ids</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">stat</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">vport</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_vport_create</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_vport_terminate - Admin App or LLDD requests termination of a vport</span>
<span class="cm"> * @vport:	fc_vport to be terminated</span>
<span class="cm"> *</span>
<span class="cm"> * Calls the LLDD vport_delete() function, then deallocates and removes</span>
<span class="cm"> * the vport from the shost and object tree.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	This routine assumes no locks are held on entry.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">fc_vport_terminate</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">vport_to_shost</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_host_attrs</span> <span class="o">*</span><span class="n">fc_host</span> <span class="o">=</span> <span class="n">shost_to_fc_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">vport_delete</span><span class="p">)</span>
		<span class="n">stat</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">vport_delete</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">stat</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VPORT_DELETING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stat</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FC_VPORT_DELETED</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">);</span>
		<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">npiv_vports_inuse</span><span class="o">--</span><span class="p">;</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">);</span>  <span class="cm">/* for fc_host-&gt;vport list */</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">stat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">)</span>
		<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">transport_remove_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">device_del</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">transport_destroy_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Removing our self-reference should mean our</span>
<span class="cm">	 * release function gets called, which will drop the remaining</span>
<span class="cm">	 * parent reference and free the data structure.</span>
<span class="cm">	 */</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>			<span class="cm">/* for self-reference */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* SUCCESS */</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fc_vport_terminate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fc_vport_sched_delete - workq-based delete request for a vport</span>
<span class="cm"> * @work:	vport to be deleted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_vport_sched_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_vport</span><span class="p">,</span> <span class="n">vport_delete_work</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">stat</span><span class="p">;</span>

	<span class="n">stat</span> <span class="o">=</span> <span class="n">fc_vport_terminate</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">)</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
			<span class="s">&quot;%s: %s could not be deleted created via &quot;</span>
			<span class="s">&quot;shost%d channel %d - error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * BSG support</span>
<span class="cm"> */</span>


<span class="cm">/**</span>
<span class="cm"> * fc_destroy_bsgjob - routine to teardown/delete a fc bsg job</span>
<span class="cm"> * @job:	fc_bsg_job that is to be torn down</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_destroy_bsgjob</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_bsg_job</span> <span class="o">*</span><span class="n">job</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">job_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">job_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">job_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">put_device</span><span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* release reference for the request */</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">request_payload</span><span class="p">.</span><span class="n">sg_list</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">reply_payload</span><span class="p">.</span><span class="n">sg_list</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">job</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_bsg_jobdone - completion routine for bsg requests that the LLD has</span>
<span class="cm"> *                  completed</span>
<span class="cm"> * @job:	fc_bsg_job that is complete</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_bsg_jobdone</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_bsg_job</span> <span class="o">*</span><span class="n">job</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">job</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rsp</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">job</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="n">job</span><span class="o">-&gt;</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* we&#39;re only returning the result field in the reply */</span>
		<span class="n">job</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">sense_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">job</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">sense_len</span> <span class="o">=</span> <span class="n">job</span><span class="o">-&gt;</span><span class="n">reply_len</span><span class="p">;</span>

	<span class="cm">/* we assume all request payload was transferred, residual == 0 */</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">resid_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">reply_payload_rcv_len</span> <span class="o">&gt;</span> <span class="n">rsp</span><span class="o">-&gt;</span><span class="n">resid_len</span><span class="p">);</span>

		<span class="cm">/* set reply (bidi) residual */</span>
		<span class="n">rsp</span><span class="o">-&gt;</span><span class="n">resid_len</span> <span class="o">-=</span> <span class="n">min</span><span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">reply_payload_rcv_len</span><span class="p">,</span>
				      <span class="n">rsp</span><span class="o">-&gt;</span><span class="n">resid_len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">blk_complete_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_bsg_softirq_done - softirq done routine for destroying the bsg requests</span>
<span class="cm"> * @rq:        BSG request that holds the job to be destroyed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fc_bsg_softirq_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_bsg_job</span> <span class="o">*</span><span class="n">job</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">job_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">state_flags</span> <span class="o">|=</span> <span class="n">FC_RQST_STATE_DONE</span><span class="p">;</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">job_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">blk_end_request_all</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">errors</span><span class="p">);</span>
	<span class="n">fc_destroy_bsgjob</span><span class="p">(</span><span class="n">job</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_bsg_job_timeout - handler for when a bsg request timesout</span>
<span class="cm"> * @req:	request that timed out</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">blk_eh_timer_return</span>
<span class="nf">fc_bsg_job_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_bsg_job</span> <span class="o">*</span><span class="n">job</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">job</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">&amp;&amp;</span> <span class="n">job</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">FC_PORTSTATE_BLOCKED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">BLK_EH_RESET_TIMER</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">job_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">state_flags</span> <span class="o">&amp;</span> <span class="n">FC_RQST_STATE_DONE</span><span class="p">)</span>
		<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">job</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">job_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">bsg_timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* call LLDD to abort the i/o as it has timed out */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">bsg_timeout</span><span class="p">(</span><span class="n">job</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">job</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="o">--</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">BLK_EH_RESET_TIMER</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ERROR: FC BSG request timeout - LLD &quot;</span>
				<span class="s">&quot;abort failed with status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* the blk_end_sync_io() doesn&#39;t check the error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">BLK_EH_NOT_HANDLED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">BLK_EH_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">fc_bsg_map_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_bsg_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span><span class="p">)</span> <span class="o">*</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nr_phys_segments</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">nr_phys_segments</span><span class="p">);</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">sg_list</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">sg_init_table</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nr_phys_segments</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">sg_cnt</span> <span class="o">=</span> <span class="n">blk_rq_map_sg</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">payload_len</span> <span class="o">=</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fc_req_to_bsgjob - Allocate/create the fc_bsg_job structure for the</span>
<span class="cm"> *                   bsg request</span>
<span class="cm"> * @shost:	SCSI Host corresponding to the bsg object</span>
<span class="cm"> * @rport:	(optional) FC Remote Port corresponding to the bsg object</span>
<span class="cm"> * @req:	BSG request that needs a job structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">fc_req_to_bsgjob</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rsp</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_bsg_job</span> <span class="o">*</span><span class="n">job</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">);</span>

	<span class="n">job</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_bsg_job</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dd_bsg_size</span><span class="p">,</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">job</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: this is a bit silly.</span>
<span class="cm">	 * The request gets formatted as a SGIO v4 ioctl request, which</span>
<span class="cm">	 * then gets reformatted as a blk request, which then gets</span>
<span class="cm">	 * reformatted as a fc bsg request. And on completion, we have</span>
<span class="cm">	 * to wrap return results such that SGIO v4 thinks it was a scsi</span>
<span class="cm">	 * status.  I hope this was all worth it.</span>
<span class="cm">	 */</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">special</span> <span class="o">=</span> <span class="n">job</span><span class="p">;</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">shost</span> <span class="o">=</span> <span class="n">shost</span><span class="p">;</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">=</span> <span class="n">rport</span><span class="p">;</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dd_bsg_size</span><span class="p">)</span>
		<span class="n">job</span><span class="o">-&gt;</span><span class="n">dd_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">job</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">job_lock</span><span class="p">);</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">request</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_bsg_request</span> <span class="o">*</span><span class="p">)</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">request_len</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">reply</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">sense</span><span class="p">;</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">reply_len</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>	<span class="cm">/* Size of sense buffer</span>
<span class="cm">						 * allocated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">fc_bsg_map_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">request_payload</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failjob_rls_job</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsp</span> <span class="o">&amp;&amp;</span> <span class="n">rsp</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">fc_bsg_map_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">reply_payload</span><span class="p">,</span> <span class="n">rsp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failjob_rls_rqst_payload</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">job_done</span> <span class="o">=</span> <span class="n">fc_bsg_jobdone</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span>
		<span class="n">job</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">job</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">;</span>
	<span class="n">get_device</span><span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>		<span class="cm">/* take a reference for the request */</span>

	<span class="n">job</span><span class="o">-&gt;</span><span class="n">ref_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>


<span class="nl">failjob_rls_rqst_payload:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">request_payload</span><span class="p">.</span><span class="n">sg_list</span><span class="p">);</span>
<span class="nl">failjob_rls_job:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">job</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">enum</span> <span class="n">fc_dispatch_result</span> <span class="p">{</span>
	<span class="n">FC_DISPATCH_BREAK</span><span class="p">,</span>	<span class="cm">/* on return, q is locked, break from q loop */</span>
	<span class="n">FC_DISPATCH_LOCKED</span><span class="p">,</span>	<span class="cm">/* on return, q is locked, continue on */</span>
	<span class="n">FC_DISPATCH_UNLOCKED</span><span class="p">,</span>	<span class="cm">/* on return, q is unlocked, continue on */</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * fc_bsg_host_dispatch - process fc host bsg requests and dispatch to LLDD</span>
<span class="cm"> * @q:		fc host request queue</span>
<span class="cm"> * @shost:	scsi host rport attached to</span>
<span class="cm"> * @job:	bsg job to be processed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">fc_dispatch_result</span>
<span class="nf">fc_bsg_host_dispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">fc_bsg_job</span> <span class="o">*</span><span class="n">job</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cmdlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>	<span class="cm">/* start with length of msgcode */</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Validate the host command */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">msgcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FC_BSG_HST_ADD_RPORT</span>:
		<span class="n">cmdlen</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_bsg_host_add_rport</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FC_BSG_HST_DEL_RPORT</span>:
		<span class="n">cmdlen</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_bsg_host_del_rport</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FC_BSG_HST_ELS_NOLOGIN</span>:
		<span class="n">cmdlen</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_bsg_host_els</span><span class="p">);</span>
		<span class="cm">/* there better be a xmt and rcv payloads */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">request_payload</span><span class="p">.</span><span class="n">payload_len</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">reply_payload</span><span class="p">.</span><span class="n">payload_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail_host_msg</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FC_BSG_HST_CT</span>:
		<span class="n">cmdlen</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_bsg_host_ct</span><span class="p">);</span>
		<span class="cm">/* there better be xmt and rcv payloads */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">request_payload</span><span class="p">.</span><span class="n">payload_len</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">reply_payload</span><span class="p">.</span><span class="n">payload_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail_host_msg</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FC_BSG_HST_VENDOR</span>:
		<span class="n">cmdlen</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_bsg_host_vendor</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">vendor_id</span> <span class="o">==</span> <span class="mi">0L</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">rqst_data</span><span class="p">.</span><span class="n">h_vendor</span><span class="p">.</span><span class="n">vendor_id</span> <span class="o">!=</span>
			<span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">vendor_id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail_host_msg</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_host_msg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check if we really have all the request data needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">request_len</span> <span class="o">&lt;</span> <span class="n">cmdlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_host_msg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">bsg_request</span><span class="p">(</span><span class="n">job</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FC_DISPATCH_UNLOCKED</span><span class="p">;</span>

<span class="nl">fail_host_msg:</span>
	<span class="cm">/* return the errno failure code as the only status */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">reply_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">reply_payload_rcv_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">reply_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">fc_bsg_jobdone</span><span class="p">(</span><span class="n">job</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">FC_DISPATCH_UNLOCKED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * fc_bsg_goose_queue - restart rport queue in case it was stopped</span>
<span class="cm"> * @rport:	rport to be restarted</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_bsg_goose_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">rqst_q</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This get/put dance makes no sense</span>
<span class="cm">	 */</span>
	<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">blk_run_queue_async</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">rqst_q</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_bsg_rport_dispatch - process rport bsg requests and dispatch to LLDD</span>
<span class="cm"> * @q:		rport request queue</span>
<span class="cm"> * @shost:	scsi host rport attached to</span>
<span class="cm"> * @rport:	rport request destined to</span>
<span class="cm"> * @job:	bsg job to be processed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">fc_dispatch_result</span>
<span class="nf">fc_bsg_rport_dispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_bsg_job</span> <span class="o">*</span><span class="n">job</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cmdlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>	<span class="cm">/* start with length of msgcode */</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Validate the rport command */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">msgcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FC_BSG_RPT_ELS</span>:
		<span class="n">cmdlen</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_bsg_rport_els</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">check_bidi</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FC_BSG_RPT_CT</span>:
		<span class="n">cmdlen</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_bsg_rport_ct</span><span class="p">);</span>
<span class="nl">check_bidi:</span>
		<span class="cm">/* there better be xmt and rcv payloads */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">request_payload</span><span class="p">.</span><span class="n">payload_len</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">reply_payload</span><span class="p">.</span><span class="n">payload_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail_rport_msg</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_rport_msg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check if we really have all the request data needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">request_len</span> <span class="o">&lt;</span> <span class="n">cmdlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_rport_msg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">bsg_request</span><span class="p">(</span><span class="n">job</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FC_DISPATCH_UNLOCKED</span><span class="p">;</span>

<span class="nl">fail_rport_msg:</span>
	<span class="cm">/* return the errno failure code as the only status */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">reply_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">reply_payload_rcv_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">job</span><span class="o">-&gt;</span><span class="n">reply_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">fc_bsg_jobdone</span><span class="p">(</span><span class="n">job</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">FC_DISPATCH_UNLOCKED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fc_bsg_request_handler - generic handler for bsg requests</span>
<span class="cm"> * @q:		request queue to manage</span>
<span class="cm"> * @shost:	Scsi_Host related to the bsg object</span>
<span class="cm"> * @rport:	FC remote port related to the bsg object (optional)</span>
<span class="cm"> * @dev:	device structure for bsg object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_bsg_request_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_bsg_job</span> <span class="o">*</span><span class="n">job</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_dispatch_result</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">FC_PORTSTATE_BLOCKED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FC_RPORT_FAST_FAIL_TIMEDOUT</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">req</span> <span class="o">=</span> <span class="n">blk_fetch_request</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">!=</span> <span class="n">FC_PORTSTATE_ONLINE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
			<span class="n">blk_end_request_all</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">fc_req_to_bsgjob</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">blk_end_request_all</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">job</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">;</span>

		<span class="cm">/* check if we have the msgcode value at least */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">request_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">job</span><span class="o">-&gt;</span><span class="n">reply_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
			<span class="n">job</span><span class="o">-&gt;</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">reply_payload_rcv_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">job</span><span class="o">-&gt;</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
			<span class="n">job</span><span class="o">-&gt;</span><span class="n">reply_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
			<span class="n">fc_bsg_jobdone</span><span class="p">(</span><span class="n">job</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* the dispatch routines will unlock the queue_lock */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">fc_bsg_rport_dispatch</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">job</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">fc_bsg_host_dispatch</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="n">job</span><span class="p">);</span>

		<span class="cm">/* did dispatcher hit state that can&#39;t process any more */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">FC_DISPATCH_BREAK</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* did dispatcher had released the lock */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">FC_DISPATCH_UNLOCKED</span><span class="p">)</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fc_bsg_host_handler - handler for bsg requests for a fc host</span>
<span class="cm"> * @q:		fc host request queue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_bsg_host_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>

	<span class="n">fc_bsg_request_handler</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fc_bsg_rport_handler - handler for bsg requests for a fc rport</span>
<span class="cm"> * @q:		rport request queue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_bsg_rport_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">rport_to_shost</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>

	<span class="n">fc_bsg_request_handler</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fc_bsg_hostadd - Create and add the bsg hooks so we can receive requests</span>
<span class="cm"> * @shost:	shost for fc_host</span>
<span class="cm"> * @fc_host:	fc_host adding the structures to</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">fc_bsg_hostadd</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_host_attrs</span> <span class="o">*</span><span class="n">fc_host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">bsg_name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>

	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">rqst_q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">bsg_request</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">bsg_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bsg_name</span><span class="p">),</span>
		 <span class="s">&quot;fc_host%d&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>

	<span class="n">q</span> <span class="o">=</span> <span class="n">__scsi_alloc_queue</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_bsg_host_handler</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fc_host%d: bsg interface failed to &quot;</span>
				<span class="s">&quot;initialize - no request queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span> <span class="o">=</span> <span class="n">shost</span><span class="p">;</span>
	<span class="n">queue_flag_set_unlocked</span><span class="p">(</span><span class="n">QUEUE_FLAG_BIDI</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="n">blk_queue_softirq_done</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">fc_bsg_softirq_done</span><span class="p">);</span>
	<span class="n">blk_queue_rq_timed_out</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">fc_bsg_job_timeout</span><span class="p">);</span>
	<span class="n">blk_queue_rq_timeout</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">FC_DEFAULT_BSG_TIMEOUT</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">bsg_register_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">bsg_name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fc_host%d: bsg interface failed to &quot;</span>
				<span class="s">&quot;initialize - register queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
		<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fc_host</span><span class="o">-&gt;</span><span class="n">rqst_q</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fc_bsg_rportadd - Create and add the bsg hooks so we can receive requests</span>
<span class="cm"> * @shost:	shost that rport is attached to</span>
<span class="cm"> * @rport:	rport that the bsg hooks are being attached to</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">fc_bsg_rportadd</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_fc_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">rqst_q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">bsg_request</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="n">q</span> <span class="o">=</span> <span class="n">__scsi_alloc_queue</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_bsg_rport_handler</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: bsg interface failed to &quot;</span>
				<span class="s">&quot;initialize - no request queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span> <span class="o">=</span> <span class="n">rport</span><span class="p">;</span>
	<span class="n">queue_flag_set_unlocked</span><span class="p">(</span><span class="n">QUEUE_FLAG_BIDI</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="n">blk_queue_softirq_done</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">fc_bsg_softirq_done</span><span class="p">);</span>
	<span class="n">blk_queue_rq_timed_out</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">fc_bsg_job_timeout</span><span class="p">);</span>
	<span class="n">blk_queue_rq_timeout</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">BLK_DEFAULT_SG_TIMEOUT</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">bsg_register_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: bsg interface failed to &quot;</span>
				<span class="s">&quot;initialize - register queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">rqst_q</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fc_bsg_remove - Deletes the bsg hooks on fchosts/rports</span>
<span class="cm"> * @q:	the request_queue that is to be torn down.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *   Before unregistering the queue empty any requests that are blocked</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fc_bsg_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span> <span class="cm">/* block request */</span>
	<span class="kt">int</span> <span class="n">counts</span><span class="p">;</span> <span class="cm">/* totals for request_list count and starved */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Stop taking in new requests */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">blk_stop_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

		<span class="cm">/* drain all requests in the queue */</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* need the lock to fetch a request</span>
<span class="cm">			 * this may fetch the same reqeust as the previous pass</span>
<span class="cm">			 */</span>
			<span class="n">req</span> <span class="o">=</span> <span class="n">blk_fetch_request</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
			<span class="cm">/* save requests in use and starved */</span>
			<span class="n">counts</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">.</span><span class="n">starved</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">.</span><span class="n">starved</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
			<span class="cm">/* any requests still outstanding? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">counts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* This may be the same req as the previous iteration,</span>
<span class="cm">			 * always send the blk_end_request_all after a prefetch.</span>
<span class="cm">			 * It is not okay to not end the request because the</span>
<span class="cm">			 * prefetch started the request.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* return -ENXIO to indicate that this queue is</span>
<span class="cm">				 * going away</span>
<span class="cm">				 */</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
				<span class="n">blk_end_request_all</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">msleep</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span> <span class="cm">/* allow bsg to possibly finish */</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">bsg_unregister_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* Original Author:  Martin Hicks */</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;James Smart&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;FC Transport Attributes&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">fc_transport_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">fc_transport_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
