<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › scsi_scan.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>scsi_scan.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * scsi_scan.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2000 Eric Youngdale,</span>
<span class="cm"> * Copyright (C) 2002 Patrick Mansfield</span>
<span class="cm"> *</span>
<span class="cm"> * The general scanning/probing algorithm is as follows, exceptions are</span>
<span class="cm"> * made to it depending on device specific flags, compilation options, and</span>
<span class="cm"> * global variable (boot or module load time) settings.</span>
<span class="cm"> *</span>
<span class="cm"> * A specific LUN is scanned via an INQUIRY command; if the LUN has a</span>
<span class="cm"> * device attached, a scsi_device is allocated and setup for it.</span>
<span class="cm"> *</span>
<span class="cm"> * For every id of every channel on the given host:</span>
<span class="cm"> *</span>
<span class="cm"> * 	Scan LUN 0; if the target responds to LUN 0 (even if there is no</span>
<span class="cm"> * 	device or storage attached to LUN 0):</span>
<span class="cm"> *</span>
<span class="cm"> * 		If LUN 0 has a device attached, allocate and setup a</span>
<span class="cm"> * 		scsi_device for it.</span>
<span class="cm"> *</span>
<span class="cm"> * 		If target is SCSI-3 or up, issue a REPORT LUN, and scan</span>
<span class="cm"> * 		all of the LUNs returned by the REPORT LUN; else,</span>
<span class="cm"> * 		sequentially scan LUNs up until some maximum is reached,</span>
<span class="cm"> * 		or a LUN is seen that cannot have a device attached to it.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/async.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_driver.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_devinfo.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>

<span class="cp">#include &quot;scsi_priv.h&quot;</span>
<span class="cp">#include &quot;scsi_logging.h&quot;</span>

<span class="cp">#define ALLOC_FAILURE_MSG	KERN_ERR &quot;%s: Allocation failure during&quot; \</span>
<span class="cp">	&quot; SCSI scanning, some SCSI devices might not be configured\n&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Default timeout</span>
<span class="cm"> */</span>
<span class="cp">#define SCSI_TIMEOUT (2*HZ)</span>

<span class="cm">/*</span>
<span class="cm"> * Prefix values for the SCSI id&#39;s (stored in sysfs name field)</span>
<span class="cm"> */</span>
<span class="cp">#define SCSI_UID_SER_NUM &#39;S&#39;</span>
<span class="cp">#define SCSI_UID_UNKNOWN &#39;Z&#39;</span>

<span class="cm">/*</span>
<span class="cm"> * Return values of some of the scanning functions.</span>
<span class="cm"> *</span>
<span class="cm"> * SCSI_SCAN_NO_RESPONSE: no valid response received from the target, this</span>
<span class="cm"> * includes allocation or general failures preventing IO from being sent.</span>
<span class="cm"> *</span>
<span class="cm"> * SCSI_SCAN_TARGET_PRESENT: target responded, but no device is available</span>
<span class="cm"> * on the given LUN.</span>
<span class="cm"> *</span>
<span class="cm"> * SCSI_SCAN_LUN_PRESENT: target responded, and a device is available on a</span>
<span class="cm"> * given LUN.</span>
<span class="cm"> */</span>
<span class="cp">#define SCSI_SCAN_NO_RESPONSE		0</span>
<span class="cp">#define SCSI_SCAN_TARGET_PRESENT	1</span>
<span class="cp">#define SCSI_SCAN_LUN_PRESENT		2</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scsi_null_device_strs</span> <span class="o">=</span> <span class="s">&quot;nullnullnullnull&quot;</span><span class="p">;</span>

<span class="cp">#define MAX_SCSI_LUNS	512</span>

<span class="cp">#ifdef CONFIG_SCSI_MULTI_LUN</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_scsi_luns</span> <span class="o">=</span> <span class="n">MAX_SCSI_LUNS</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_scsi_luns</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">max_luns</span><span class="p">,</span> <span class="n">max_scsi_luns</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_luns</span><span class="p">,</span>
		 <span class="s">&quot;last scsi LUN (should be between 1 and 2^32-1)&quot;</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SCSI_SCAN_ASYNC</span>
<span class="cp">#define SCSI_SCAN_TYPE_DEFAULT &quot;async&quot;</span>
<span class="cp">#else</span>
<span class="cp">#define SCSI_SCAN_TYPE_DEFAULT &quot;sync&quot;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">scsi_scan_type</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCSI_SCAN_TYPE_DEFAULT</span><span class="p">;</span>

<span class="n">module_param_string</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span> <span class="n">scsi_scan_type</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scsi_scan_type</span><span class="p">),</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span> <span class="s">&quot;sync, async or none&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * max_scsi_report_luns: the maximum number of LUNS that will be</span>
<span class="cm"> * returned from the REPORT LUNS command. 8 times this value must</span>
<span class="cm"> * be allocated. In theory this could be up to an 8 byte value, but</span>
<span class="cm"> * in practice, the maximum number of LUNs suppored by any device</span>
<span class="cm"> * is about 16k.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_scsi_report_luns</span> <span class="o">=</span> <span class="mi">511</span><span class="p">;</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">max_report_luns</span><span class="p">,</span> <span class="n">max_scsi_report_luns</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_report_luns</span><span class="p">,</span>
		 <span class="s">&quot;REPORT LUNS maximum number of LUNS received (should be&quot;</span>
		 <span class="s">&quot; between 1 and 16384)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scsi_inq_timeout</span> <span class="o">=</span> <span class="n">SCSI_TIMEOUT</span><span class="o">/</span><span class="n">HZ</span> <span class="o">+</span> <span class="mi">18</span><span class="p">;</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">inq_timeout</span><span class="p">,</span> <span class="n">scsi_inq_timeout</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">inq_timeout</span><span class="p">,</span> 
		 <span class="s">&quot;Timeout (in seconds) waiting for devices to answer INQUIRY.&quot;</span>
		 <span class="s">&quot; Default is 20. Some devices may need more; most need less.&quot;</span><span class="p">);</span>

<span class="cm">/* This lock protects only this list */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">async_scan_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">scanning_hosts</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">async_scan_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">prev_finished</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_complete_async_scans - Wait for asynchronous scans to complete</span>
<span class="cm"> *</span>
<span class="cm"> * When this function returns, any host which started scanning before</span>
<span class="cm"> * this function was called will have finished its scan.  Hosts which</span>
<span class="cm"> * started scanning after this function was called may or may not have</span>
<span class="cm"> * finished.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">scsi_complete_async_scans</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">async_scan_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scanning_hosts</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="cm">/* If we can&#39;t get memory immediately, that&#39;s OK.  Just</span>
<span class="cm">		 * sleep a little.  Even if we never get memory, the async</span>
<span class="cm">		 * scans will finish eventually.</span>
<span class="cm">		 */</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">);</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">shost</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">prev_finished</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_scan_lock</span><span class="p">);</span>
	<span class="cm">/* Check that there&#39;s still somebody else on the list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scanning_hosts</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scanning_hosts</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_scan_lock</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scsi: waiting for bus probes to complete ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">prev_finished</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_scan_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scanning_hosts</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">async_scan_data</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">scanning_hosts</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">async_scan_data</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev_finished</span><span class="p">);</span>
	<span class="p">}</span>
 <span class="nl">done:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_scan_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">async_synchronize_full_domain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scsi_sd_probe_domain</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Only exported for the benefit of scsi_wait_scan */</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">scsi_complete_async_scans</span><span class="p">);</span>

<span class="cp">#ifndef MODULE</span>
<span class="cm">/*</span>
<span class="cm"> * For async scanning we need to wait for all the scans to complete before</span>
<span class="cm"> * trying to mount the root fs.  Otherwise non-modular drivers may not be ready</span>
<span class="cm"> * yet.</span>
<span class="cm"> */</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">scsi_complete_async_scans</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_unlock_floptical - unlock device via a special MODE SENSE command</span>
<span class="cm"> * @sdev:	scsi device to send command to</span>
<span class="cm"> * @result:	area to store the result of the MODE SENSE</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Send a vendor specific MODE SENSE (not a MODE SELECT) command.</span>
<span class="cm"> *     Called for BLIST_KEY devices.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_unlock_floptical</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">scsi_cmd</span><span class="p">[</span><span class="n">MAX_COMMAND_SIZE</span><span class="p">];</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;scsi: unlocking floptical drive</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MODE_SENSE</span><span class="p">;</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x2e</span><span class="p">;</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x2a</span><span class="p">;</span>     <span class="cm">/* size */</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">scsi_execute_req</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">scsi_cmd</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="mh">0x2a</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			 <span class="n">SCSI_TIMEOUT</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_alloc_sdev - allocate and setup a scsi_Device</span>
<span class="cm"> * @starget: which target to allocate a &amp;scsi_device for</span>
<span class="cm"> * @lun: which lun</span>
<span class="cm"> * @hostdata: usually NULL and set by -&gt;slave_alloc instead</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Allocate, initialize for io, and return a pointer to a scsi_Device.</span>
<span class="cm"> *     Stores the @shost, @channel, @id, and @lun in the scsi_Device, and</span>
<span class="cm"> *     adds scsi_Device to the appropriate list.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *     scsi_Device pointer, or NULL on failure.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="nf">scsi_alloc_sdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hostdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">display_failure_msg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_evt_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_requeue_run_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sdev</span><span class="p">)</span> <span class="o">+</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="o">-&gt;</span><span class="n">device_size</span><span class="p">,</span>
		       <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">=</span> <span class="n">scsi_null_device_strs</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">model</span> <span class="o">=</span> <span class="n">scsi_null_device_strs</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">rev</span> <span class="o">=</span> <span class="n">scsi_null_device_strs</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">shost</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_ramp_up_period</span> <span class="o">=</span> <span class="n">SCSI_DEFAULT_RAMP_UP_PERIOD</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">starget</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">lun</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">starget</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">=</span> <span class="n">SDEV_CREATED</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">siblings</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">same_target_siblings</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">starved_entry</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">event_work</span><span class="p">,</span> <span class="n">scsi_evt_thread</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">requeue_work</span><span class="p">,</span> <span class="n">scsi_requeue_run_queue</span><span class="p">);</span>

	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span> <span class="o">=</span> <span class="n">starget</span><span class="p">;</span>

	<span class="cm">/* usually NULL and set by -&gt;slave_alloc instead */</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">hostdata</span> <span class="o">=</span> <span class="n">hostdata</span><span class="p">;</span>

	<span class="cm">/* if the device needs this changing, it may do so in the</span>
<span class="cm">	 * slave_configure function */</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">max_device_blocked</span> <span class="o">=</span> <span class="n">SCSI_DEFAULT_DEVICE_BLOCKED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some low level driver could use device-&gt;type</span>
<span class="cm">	 */</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Assume that the device will have handshaking problems,</span>
<span class="cm">	 * and then fix this field later if it turns out it</span>
<span class="cm">	 * doesn&#39;t</span>
<span class="cm">	 */</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">borken</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span> <span class="o">=</span> <span class="n">scsi_alloc_queue</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* release fn is set up in scsi_sysfs_device_initialise, so</span>
<span class="cm">		 * have to free and put manually here */</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">blk_get_queue</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">));</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="o">-&gt;</span><span class="n">queuedata</span> <span class="o">=</span> <span class="n">sdev</span><span class="p">;</span>
	<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span><span class="p">);</span>

	<span class="n">scsi_sysfs_device_initialize</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">slave_alloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">slave_alloc</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * if LLDD reports slave not present, don&#39;t clutter</span>
<span class="cm">			 * console with alloc failure messages</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">)</span>
				<span class="n">display_failure_msg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_device_destroy</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sdev</span><span class="p">;</span>

<span class="nl">out_device_destroy:</span>
	<span class="n">__scsi_remove_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">display_failure_msg</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">ALLOC_FAILURE_MSG</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_target_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">transport_destroy_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">target_destroy</span><span class="p">)</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">target_destroy</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">siblings</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_target_dev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">to_scsi_target</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="n">scsi_target_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;scsi_target&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">scsi_target_dev_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">scsi_is_target_device</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">scsi_target_type</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_is_target_device</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="nf">__scsi_find_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="n">uint</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span> <span class="o">*</span><span class="n">found_starget</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Search for an existing target for this sdev.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">__targets</span><span class="p">,</span> <span class="n">siblings</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span> <span class="o">&amp;&amp;</span>
		    <span class="n">starget</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">==</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found_starget</span> <span class="o">=</span> <span class="n">starget</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found_starget</span><span class="p">)</span>
		<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found_starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">found_starget</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_alloc_target - allocate a new or find an existing target</span>
<span class="cm"> * @parent:	parent of the target (need not be a scsi host)</span>
<span class="cm"> * @channel:	target channel number (zero if no channels)</span>
<span class="cm"> * @id:		target id number</span>
<span class="cm"> *</span>
<span class="cm"> * Return an existing target if one exists, provided it hasn&#39;t already</span>
<span class="cm"> * gone into STARGET_DEL state, otherwise allocate a new target.</span>
<span class="cm"> *</span>
<span class="cm"> * The target is returned with an incremented reference, so the caller</span>
<span class="cm"> * is responsible for both reaping and doing a last put</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="nf">scsi_alloc_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="n">uint</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span><span class="p">)</span>
		<span class="o">+</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="o">-&gt;</span><span class="n">target_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">found_target</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">starget</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">starget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: allocation failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">device_initialize</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">starget</span><span class="o">-&gt;</span><span class="n">reap_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">get_device</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;target%d:%d:%d&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scsi_bus_type</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scsi_target_type</span><span class="p">;</span>
	<span class="n">starget</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">starget</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">starget</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">siblings</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">);</span>
	<span class="n">starget</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STARGET_CREATED</span><span class="p">;</span>
	<span class="n">starget</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">=</span> <span class="n">SCSI_2</span><span class="p">;</span>
	<span class="n">starget</span><span class="o">-&gt;</span><span class="n">max_target_blocked</span> <span class="o">=</span> <span class="n">SCSI_DEFAULT_TARGET_BLOCKED</span><span class="p">;</span>
 <span class="nl">retry:</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">found_target</span> <span class="o">=</span> <span class="n">__scsi_find_target</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found_target</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">siblings</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">__targets</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* allocate and add */</span>
	<span class="n">transport_setup_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">target_alloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">target_alloc</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;target allocation failed, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="cm">/* don&#39;t want scsi_target_reap to do the final</span>
<span class="cm">			 * put because it will be under the host lock */</span>
			<span class="n">scsi_target_destroy</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">get_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">starget</span><span class="p">;</span>

 <span class="nl">found:</span>
	<span class="n">found_target</span><span class="o">-&gt;</span><span class="n">reap_ref</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found_target</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">STARGET_DEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">found_target</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Unfortunately, we found a dying target; need to</span>
<span class="cm">	 * wait until it&#39;s dead before we can get a new one */</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found_target</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">flush_scheduled_work</span><span class="p">();</span>
	<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_target_reap_usercontext</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_target</span><span class="p">,</span> <span class="n">ew</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="n">transport_remove_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">scsi_target_destroy</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_target_reap - check to see if target is in use and destroy if not</span>
<span class="cm"> * @starget: target to be checked</span>
<span class="cm"> *</span>
<span class="cm"> * This is used after removing a LUN or doing a last put of the target</span>
<span class="cm"> * it checks atomically that nothing is using the target and removes</span>
<span class="cm"> * it if so.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_target_reap</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">scsi_target_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">starget</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">reap_ref</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">starget</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STARGET_DEL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">STARGET_DEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">STARGET_CREATED</span><span class="p">)</span>
		<span class="n">scsi_target_destroy</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">execute_in_process_context</span><span class="p">(</span><span class="n">scsi_target_reap_usercontext</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">ew</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sanitize_inquiry_string - remove non-graphical chars from an INQUIRY result string</span>
<span class="cm"> * @s: INQUIRY result string to sanitize</span>
<span class="cm"> * @len: length of the string</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *	The SCSI spec says that INQUIRY vendor, product, and revision</span>
<span class="cm"> *	strings must consist entirely of graphic ASCII characters,</span>
<span class="cm"> *	padded on the right with spaces.  Since not all devices obey</span>
<span class="cm"> *	this rule, we will replace non-graphic or non-ASCII characters</span>
<span class="cm"> *	with spaces.  Exception: a NUL character is interpreted as a</span>
<span class="cm"> *	string terminator, so all the following characters are set to</span>
<span class="cm"> *	spaces.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sanitize_inquiry_string</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">terminated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="o">--</span><span class="n">len</span><span class="p">,</span> <span class="o">++</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">terminated</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">terminated</span> <span class="o">||</span> <span class="o">*</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mh">0x20</span> <span class="o">||</span> <span class="o">*</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mh">0x7e</span><span class="p">)</span>
			<span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_probe_lun - probe a single LUN using a SCSI INQUIRY</span>
<span class="cm"> * @sdev:	scsi_device to probe</span>
<span class="cm"> * @inq_result:	area to store the INQUIRY result</span>
<span class="cm"> * @result_len: len of inq_result</span>
<span class="cm"> * @bflags:	store any bflags found here</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Probe the lun associated with @req using a standard SCSI INQUIRY;</span>
<span class="cm"> *</span>
<span class="cm"> *     If the INQUIRY is successful, zero is returned and the</span>
<span class="cm"> *     INQUIRY data is in @inq_result; the scsi_level and INQUIRY length</span>
<span class="cm"> *     are copied to the scsi_device any flags value is stored in *@bflags.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scsi_probe_lun</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">inq_result</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">result_len</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">scsi_cmd</span><span class="p">[</span><span class="n">MAX_COMMAND_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">first_inquiry_len</span><span class="p">,</span> <span class="n">try_inquiry_len</span><span class="p">,</span> <span class="n">next_inquiry_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">response_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pass</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>

	<span class="o">*</span><span class="n">bflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Perform up to 3 passes.  The first pass uses a conservative</span>
<span class="cm">	 * transfer length of 36 unless sdev-&gt;inquiry_len specifies a</span>
<span class="cm">	 * different value. */</span>
	<span class="n">first_inquiry_len</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span> <span class="o">?</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span> <span class="o">:</span> <span class="mi">36</span><span class="p">;</span>
	<span class="n">try_inquiry_len</span> <span class="o">=</span> <span class="n">first_inquiry_len</span><span class="p">;</span>
	<span class="n">pass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

 <span class="nl">next_pass:</span>
	<span class="n">SCSI_LOG_SCAN_BUS</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span>
				<span class="s">&quot;scsi scan: INQUIRY pass %d length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pass</span><span class="p">,</span> <span class="n">try_inquiry_len</span><span class="p">));</span>

	<span class="cm">/* Each pass gets up to three chances to ignore Unit Attention */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">resid</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
		<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">INQUIRY</span><span class="p">;</span>
		<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">try_inquiry_len</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">inq_result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">try_inquiry_len</span><span class="p">);</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">scsi_execute_req</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span>  <span class="n">scsi_cmd</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">,</span>
					  <span class="n">inq_result</span><span class="p">,</span> <span class="n">try_inquiry_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">,</span>
					  <span class="n">HZ</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">scsi_inq_timeout</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">resid</span><span class="p">);</span>

		<span class="n">SCSI_LOG_SCAN_BUS</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scsi scan: INQUIRY %s &quot;</span>
				<span class="s">&quot;with code 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">result</span> <span class="o">?</span> <span class="s">&quot;failed&quot;</span> <span class="o">:</span> <span class="s">&quot;successful&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * not-ready to ready transition [asc/ascq=0x28/0x0]</span>
<span class="cm">			 * or power-on, reset [asc/ascq=0x29/0x0], continue.</span>
<span class="cm">			 * INQUIRY should not yield UNIT_ATTENTION</span>
<span class="cm">			 * but many buggy devices do so anyway. </span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">driver_byte</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DRIVER_SENSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">scsi_sense_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sshdr</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">UNIT_ATTENTION</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">((</span><span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x28</span><span class="p">)</span> <span class="o">||</span>
				     <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x29</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * if nothing was transferred, we try</span>
<span class="cm">			 * again. It&#39;s a workaround for some USB</span>
<span class="cm">			 * devices.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">resid</span> <span class="o">==</span> <span class="n">try_inquiry_len</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sanitize_inquiry_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">sanitize_inquiry_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">sanitize_inquiry_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="mi">4</span><span class="p">);</span>

		<span class="n">response_len</span> <span class="o">=</span> <span class="n">inq_result</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">response_len</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span>
			<span class="n">response_len</span> <span class="o">=</span> <span class="n">first_inquiry_len</span><span class="p">;</span>	<span class="cm">/* sanity */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get any flags for this device.</span>
<span class="cm">		 *</span>
<span class="cm">		 * XXX add a bflags to scsi_device, and replace the</span>
<span class="cm">		 * corresponding bit fields in scsi_device, so bflags</span>
<span class="cm">		 * need not be passed as an argument.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">bflags</span> <span class="o">=</span> <span class="n">scsi_get_device_flags</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>
				<span class="o">&amp;</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>

		<span class="cm">/* When the first pass succeeds we gain information about</span>
<span class="cm">		 * what larger transfer lengths might work. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pass</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">BLIST_INQUIRY_36</span> <span class="o">&amp;</span> <span class="o">*</span><span class="n">bflags</span><span class="p">)</span>
				<span class="n">next_inquiry_len</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">BLIST_INQUIRY_58</span> <span class="o">&amp;</span> <span class="o">*</span><span class="n">bflags</span><span class="p">)</span>
				<span class="n">next_inquiry_len</span> <span class="o">=</span> <span class="mi">58</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span><span class="p">)</span>
				<span class="n">next_inquiry_len</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">next_inquiry_len</span> <span class="o">=</span> <span class="n">response_len</span><span class="p">;</span>

			<span class="cm">/* If more data is available perform the second pass */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next_inquiry_len</span> <span class="o">&gt;</span> <span class="n">try_inquiry_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">try_inquiry_len</span> <span class="o">=</span> <span class="n">next_inquiry_len</span><span class="p">;</span>
				<span class="n">pass</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">next_pass</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pass</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scsi scan: %d byte inquiry failed.  &quot;</span>
				<span class="s">&quot;Consider BLIST_INQUIRY_36 for this device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">try_inquiry_len</span><span class="p">);</span>

		<span class="cm">/* If this pass failed, the third pass goes back and transfers</span>
<span class="cm">		 * the same amount as we successfully got in the first pass. */</span>
		<span class="n">try_inquiry_len</span> <span class="o">=</span> <span class="n">first_inquiry_len</span><span class="p">;</span>
		<span class="n">pass</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">next_pass</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the last transfer attempt got an error, assume the</span>
<span class="cm">	 * peripheral doesn&#39;t exist or is dead. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t report any more data than the device says is valid */</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">try_inquiry_len</span><span class="p">,</span> <span class="n">response_len</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX Abort if the response length is less than 36? If less than</span>
<span class="cm">	 * 32, the lookup of the device flags (above) could be invalid,</span>
<span class="cm">	 * and it would be possible to take an incorrect action - we do</span>
<span class="cm">	 * not want to hang because of a short INQUIRY. On the flip side,</span>
<span class="cm">	 * if the device is spun down or becoming ready (and so it gives a</span>
<span class="cm">	 * short INQUIRY), an abort here prevents any further use of the</span>
<span class="cm">	 * device, including spin up.</span>
<span class="cm">	 *</span>
<span class="cm">	 * On the whole, the best approach seems to be to assume the first</span>
<span class="cm">	 * 36 bytes are valid no matter what the device says.  That&#39;s</span>
<span class="cm">	 * better than copying &lt; 36 bytes to the inquiry-result buffer</span>
<span class="cm">	 * and displaying garbage for the Vendor, Product, or Revision</span>
<span class="cm">	 * strings.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span> <span class="o">&lt;</span> <span class="mi">36</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scsi scan: INQUIRY result too short (%d),&quot;</span>
				<span class="s">&quot; using 36</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Related to the above issue:</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX Devices (disk or all?) should be sent a TEST UNIT READY,</span>
<span class="cm">	 * and if not ready, sent a START_STOP to start (maybe spin up) and</span>
<span class="cm">	 * then send the INQUIRY again, since the INQUIRY can change after</span>
<span class="cm">	 * a device is initialized.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Ideally, start a device if explicitly asked to do so.  This</span>
<span class="cm">	 * assumes that a device is spun up on power on, spun down on</span>
<span class="cm">	 * request, and then spun up on request.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * The scanning code needs to know the scsi_level, even if no</span>
<span class="cm">	 * device is attached at LUN 0 (SCSI_SCAN_TARGET_PRESENT) so</span>
<span class="cm">	 * non-zero LUNs can be scanned.</span>
<span class="cm">	 */</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">=</span> <span class="n">inq_result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span><span class="o">++</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_add_lun - allocate and fully initialze a scsi_device</span>
<span class="cm"> * @sdev:	holds information to be stored in the new scsi_device</span>
<span class="cm"> * @inq_result:	holds the result of a previous INQUIRY to the LUN</span>
<span class="cm"> * @bflags:	black/white list flag</span>
<span class="cm"> * @async:	1 if this device is being scanned asynchronously</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Initialize the scsi_device @sdev.  Optionally set fields based</span>
<span class="cm"> *     on values in *@bflags.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     SCSI_SCAN_NO_RESPONSE: could not allocate or setup a scsi_device</span>
<span class="cm"> *     SCSI_SCAN_LUN_PRESENT: a new scsi_device was allocated and initialized</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scsi_add_lun</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">inq_result</span><span class="p">,</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">bflags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">async</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX do not save the inquiry, since it can change underneath us,</span>
<span class="cm">	 * save just vendor/model/rev.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Rather than save it and have an ioctl that retrieves the saved</span>
<span class="cm">	 * value, have an ioctl that executes the same INQUIRY code used</span>
<span class="cm">	 * in scsi_probe_lun, let user level programs doing INQUIRY</span>
<span class="cm">	 * scanning run at their own risk, or supply a user level program</span>
<span class="cm">	 * that can correctly scan.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy at least 36 bytes of INQUIRY data, so that we don&#39;t</span>
<span class="cm">	 * dereference unallocated memory when accessing the Vendor,</span>
<span class="cm">	 * Product, and Revision strings.  Badly behaved devices may set</span>
<span class="cm">	 * the INQUIRY Additional Length byte to a small value, indicating</span>
<span class="cm">	 * these strings are invalid, but often they contain plausible data</span>
<span class="cm">	 * nonetheless.  It doesn&#39;t matter if the device sent &lt; 36 bytes</span>
<span class="cm">	 * total, since scsi_probe_lun() initializes inq_result with 0s.</span>
<span class="cm">	 */</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">inq_result</span><span class="p">,</span>
				<span class="n">max_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span><span class="p">,</span> <span class="mi">36</span><span class="p">),</span>
				<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCSI_SCAN_NO_RESPONSE</span><span class="p">;</span>

	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">model</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">rev</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span> <span class="o">+</span> <span class="mi">32</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_ISROM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">TYPE_ROM</span><span class="p">;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">=</span> <span class="p">(</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TYPE_RBC</span>:
	<span class="k">case</span> <span class="n">TYPE_TAPE</span>:
	<span class="k">case</span> <span class="n">TYPE_DISK</span>:
	<span class="k">case</span> <span class="n">TYPE_PRINTER</span>:
	<span class="k">case</span> <span class="n">TYPE_MOD</span>:
	<span class="k">case</span> <span class="n">TYPE_PROCESSOR</span>:
	<span class="k">case</span> <span class="n">TYPE_SCANNER</span>:
	<span class="k">case</span> <span class="n">TYPE_MEDIUM_CHANGER</span>:
	<span class="k">case</span> <span class="n">TYPE_ENCLOSURE</span>:
	<span class="k">case</span> <span class="n">TYPE_COMM</span>:
	<span class="k">case</span> <span class="n">TYPE_RAID</span>:
	<span class="k">case</span> <span class="n">TYPE_OSD</span>:
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">writeable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TYPE_ROM</span>:
	<span class="k">case</span> <span class="n">TYPE_WORM</span>:
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">writeable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scsi: unknown device type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_RBC</span> <span class="o">||</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_ROM</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* RBC and MMC devices can return SCSI-3 compliance and yet</span>
<span class="cm">		 * still not support REPORT LUNS, so make them act as</span>
<span class="cm">		 * BLIST_NOREPORTLUN unless BLIST_REPORTLUN2 is</span>
<span class="cm">		 * specifically set */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_REPORTLUN2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">*</span><span class="n">bflags</span> <span class="o">|=</span> <span class="n">BLIST_NOREPORTLUN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For a peripheral qualifier (PQ) value of 1 (001b), the SCSI</span>
<span class="cm">	 * spec says: The device server is capable of supporting the</span>
<span class="cm">	 * specified peripheral device type on this logical unit. However,</span>
<span class="cm">	 * the physical device is not currently connected to this logical</span>
<span class="cm">	 * unit.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The above is vague, as it implies that we could treat 001 and</span>
<span class="cm">	 * 011 the same. Stay compatible with previous code, and create a</span>
<span class="cm">	 * scsi_device for a PQ of 1</span>
<span class="cm">	 *</span>
<span class="cm">	 * Don&#39;t set the device offline here; rather let the upper</span>
<span class="cm">	 * level drivers eval the PQ to decide whether they should</span>
<span class="cm">	 * attach. So remove ((inq_result[0] &gt;&gt; 5) &amp; 7) == 1 check.</span>
<span class="cm">	 */</span> 

	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inq_periph_qual</span> <span class="o">=</span> <span class="p">(</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lockable</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">removable</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">soft_reset</span> <span class="o">=</span> <span class="p">(</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">&gt;=</span> <span class="n">SCSI_3</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span> <span class="o">&gt;</span> <span class="mi">56</span> <span class="o">&amp;&amp;</span> <span class="n">inq_result</span><span class="p">[</span><span class="mi">56</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x04</span><span class="p">))</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ppr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x60</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">wdtr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdtr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span> <span class="s">&quot;%s %.8s %.16s %.4s PQ: %d &quot;</span>
			<span class="s">&quot;ANSI: %d%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">scsi_device_type</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">,</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inq_periph_qual</span><span class="p">,</span> <span class="n">inq_result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">,</span>
			<span class="p">(</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">&quot; CCS&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">&gt;=</span> <span class="n">SCSI_2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">inq_result</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_NOTQ</span><span class="p">))</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some devices (Texel CD ROM drives) have handshaking problems</span>
<span class="cm">	 * when used with the Seagate controllers. borken is initialized</span>
<span class="cm">	 * to 1, and then set it to 0 here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_BORKEN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">borken</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_NO_ULD_ATTACH</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">no_uld_attach</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Apparently some really broken devices (contrary to the SCSI</span>
<span class="cm">	 * standards) need to be selected without asserting ATN</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_SELECT_NO_ATN</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">select_no_atn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Maximum 512 sector transfer length</span>
<span class="cm">	 * broken RA4x00 Compaq Disk Array</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_MAX_512</span><span class="p">)</span>
		<span class="n">blk_queue_max_hw_sectors</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some devices may not want to have a start command automatically</span>
<span class="cm">	 * issued when a device is added.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_NOSTARTONADD</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">no_start_on_add</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_SINGLELUN</span><span class="p">)</span>
		<span class="n">scsi_target</span><span class="p">(</span><span class="n">sdev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">single_lun</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_10_for_rw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_MS_SKIP_PAGE_08</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">skip_ms_page_8</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_MS_SKIP_PAGE_3F</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">skip_ms_page_3f</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_USE_10_BYTE_MS</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_10_for_ms</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* set the device running here so that slave configure</span>
<span class="cm">	 * may do I/O */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">SDEV_RUNNING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">SDEV_BLOCK</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span>
				    <span class="s">&quot;in wrong state %s to complete scan</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">scsi_device_state_name</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span><span class="p">));</span>
			<span class="k">return</span> <span class="n">SCSI_SCAN_NO_RESPONSE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_MS_192_BYTES_FOR_3F</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_192_bytes_for_3f</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_NOT_LOCKABLE</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lockable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_RETRY_HWERROR</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">retry_hwerror</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">transport_configure_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">slave_configure</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">slave_configure</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * if LLDD reports slave not present, don&#39;t clutter</span>
<span class="cm">			 * console with alloc failure messages</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span>
					<span class="s">&quot;failed to configure device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">SCSI_SCAN_NO_RESPONSE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">max_queue_depth</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ok, the device is now all set up, we can</span>
<span class="cm">	 * register it and tell the rest of the kernel</span>
<span class="cm">	 * about it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">async</span> <span class="o">&amp;&amp;</span> <span class="n">scsi_sysfs_add_sdev</span><span class="p">(</span><span class="n">sdev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCSI_SCAN_NO_RESPONSE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">SCSI_SCAN_LUN_PRESENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SCSI_LOGGING</span>
<span class="cm">/** </span>
<span class="cm"> * scsi_inq_str - print INQUIRY data from min to max index, strip trailing whitespace</span>
<span class="cm"> * @buf:   Output buffer with at least end-first+1 bytes of space</span>
<span class="cm"> * @inq:   Inquiry buffer (input)</span>
<span class="cm"> * @first: Offset of string into inq</span>
<span class="cm"> * @end:   Index after last character in inq</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">scsi_inq_str</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">inq</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="n">first</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">term</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">first</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">first</span> <span class="o">&lt;</span> <span class="n">inq</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inq</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="n">first</span><span class="p">]</span> <span class="o">&gt;</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inq</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="n">first</span><span class="p">];</span>
			<span class="n">term</span> <span class="o">=</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">term</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_probe_and_add_lun - probe a LUN, if a LUN is found add it</span>
<span class="cm"> * @starget:	pointer to target device structure</span>
<span class="cm"> * @lun:	LUN of target device</span>
<span class="cm"> * @bflagsp:	store bflags here if not NULL</span>
<span class="cm"> * @sdevp:	probe the LUN corresponding to this scsi_device</span>
<span class="cm"> * @rescan:     if nonzero skip some code only needed on first scan</span>
<span class="cm"> * @hostdata:	passed to scsi_alloc_sdev()</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Call scsi_probe_lun, if a LUN with an attached device is found,</span>
<span class="cm"> *     allocate and set it up by calling scsi_add_lun.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     SCSI_SCAN_NO_RESPONSE: could not allocate or setup a scsi_device</span>
<span class="cm"> *     SCSI_SCAN_TARGET_PRESENT: target responded, but no device is</span>
<span class="cm"> *         attached at the LUN</span>
<span class="cm"> *     SCSI_SCAN_LUN_PRESENT: a new scsi_device was allocated and initialized</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scsi_probe_and_add_lun</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span>
				  <span class="n">uint</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bflagsp</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">**</span><span class="n">sdevp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rescan</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">hostdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bflags</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">SCSI_SCAN_NO_RESPONSE</span><span class="p">,</span> <span class="n">result_len</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The rescan flag is used as an optimization, the first scan of a</span>
<span class="cm">	 * host adapter calls into here with rescan == 0.</span>
<span class="cm">	 */</span>
	<span class="n">sdev</span> <span class="o">=</span> <span class="n">scsi_device_lookup_by_target</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rescan</span> <span class="o">||</span> <span class="o">!</span><span class="n">scsi_device_created</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SCSI_LOG_SCAN_BUS</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				<span class="s">&quot;scsi scan: device exists on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">)));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sdevp</span><span class="p">)</span>
				<span class="o">*</span><span class="n">sdevp</span> <span class="o">=</span> <span class="n">sdev</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bflagsp</span><span class="p">)</span>
				<span class="o">*</span><span class="n">bflagsp</span> <span class="o">=</span> <span class="n">scsi_get_device_flags</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span>
								 <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span>
								 <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">SCSI_SCAN_LUN_PRESENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sdev</span> <span class="o">=</span> <span class="n">scsi_alloc_sdev</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">hostdata</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">result_len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span>
			<span class="p">((</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span><span class="p">)</span> <span class="o">?</span> <span class="n">__GFP_DMA</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_sdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_probe_lun</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">result_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bflags</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free_result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bflagsp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">bflagsp</span> <span class="o">=</span> <span class="n">bflags</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * result contains valid SCSI INQUIRY data.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_ATTACH_PQ3</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For a Peripheral qualifier 3 (011b), the SCSI</span>
<span class="cm">		 * spec says: The device server is not capable of</span>
<span class="cm">		 * supporting a physical device on this logical</span>
<span class="cm">		 * unit.</span>
<span class="cm">		 *</span>
<span class="cm">		 * For disks, this implies that there is no</span>
<span class="cm">		 * logical disk configured at sdev-&gt;lun, but there</span>
<span class="cm">		 * is a target id responding.</span>
<span class="cm">		 */</span>
		<span class="n">SCSI_LOG_SCAN_BUS</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span> <span class="s">&quot;scsi scan:&quot;</span>
				   <span class="s">&quot; peripheral qualifier of 3, device not&quot;</span>
				   <span class="s">&quot; added</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lun</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SCSI_LOG_SCAN_BUS</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">vend</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
				<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mod</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>

				<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span>
					<span class="s">&quot;scsi scan: consider passing scsi_mod.&quot;</span>
					<span class="s">&quot;dev_flags=%s:%s:0x240 or 0x1000240</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">scsi_inq_str</span><span class="p">(</span><span class="n">vend</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
					<span class="n">scsi_inq_str</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">));</span>
			<span class="p">});</span>

		<span class="p">}</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">SCSI_SCAN_TARGET_PRESENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some targets may set slight variations of PQ and PDT to signal</span>
<span class="cm">	 * that no LUN is present, so don&#39;t add sdev in these cases.</span>
<span class="cm">	 * Two specific examples are:</span>
<span class="cm">	 * 1) NetApp targets: return PQ=1, PDT=0x1f</span>
<span class="cm">	 * 2) USB UFI: returns PDT=0x1f, with the PQ bits being &quot;reserved&quot;</span>
<span class="cm">	 *    in the UFI 1.0 spec (we cannot rely on reserved bits).</span>
<span class="cm">	 *</span>
<span class="cm">	 * References:</span>
<span class="cm">	 * 1) SCSI SPC-3, pp. 145-146</span>
<span class="cm">	 * PQ=1: &quot;A peripheral device having the specified peripheral</span>
<span class="cm">	 * device type is not connected to this logical unit. However, the</span>
<span class="cm">	 * device server is capable of supporting the specified peripheral</span>
<span class="cm">	 * device type on this logical unit.&quot;</span>
<span class="cm">	 * PDT=0x1f: &quot;Unknown or no device type&quot;</span>
<span class="cm">	 * 2) USB UFI 1.0, p. 20</span>
<span class="cm">	 * PDT=00h Direct-access device (floppy)</span>
<span class="cm">	 * PDT=1Fh none (no FDD connected to the requested logical unit)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">starget</span><span class="o">-&gt;</span><span class="n">pdt_1f_for_no_lun</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x1f</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">scsi_is_wlun</span><span class="p">(</span><span class="n">lun</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">SCSI_LOG_SCAN_BUS</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
					<span class="s">&quot;scsi scan: peripheral device type&quot;</span>
					<span class="s">&quot; of 31, no device added</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">SCSI_SCAN_TARGET_PRESENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">scsi_add_lun</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bflags</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">async_scan</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">SCSI_SCAN_LUN_PRESENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_KEY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lockable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">scsi_unlock_floptical</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">out_free_result:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
 <span class="nl">out_free_sdev:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">SCSI_SCAN_LUN_PRESENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdevp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scsi_device_get</span><span class="p">(</span><span class="n">sdev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">sdevp</span> <span class="o">=</span> <span class="n">sdev</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">__scsi_remove_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
				<span class="n">res</span> <span class="o">=</span> <span class="n">SCSI_SCAN_NO_RESPONSE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">__scsi_remove_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_sequential_lun_scan - sequentially scan a SCSI target</span>
<span class="cm"> * @starget:	pointer to target structure to scan</span>
<span class="cm"> * @bflags:	black/white list flag for LUN 0</span>
<span class="cm"> * @scsi_level: Which version of the standard does this device adhere to</span>
<span class="cm"> * @rescan:     passed to scsi_probe_add_lun()</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Generally, scan from LUN 1 (LUN 0 is assumed to already have been</span>
<span class="cm"> *     scanned) to some maximum lun until a LUN is found with no device</span>
<span class="cm"> *     attached. Use the bflags to figure out any oddities.</span>
<span class="cm"> *</span>
<span class="cm"> *     Modifies sdevscan-&gt;lun.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_sequential_lun_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">bflags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scsi_level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rescan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sparse_lun</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">max_dev_lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">SCSI_LOG_SCAN_BUS</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scsi scan: Sequential scan of&quot;</span>
				    <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)));</span>

	<span class="n">max_dev_lun</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max_scsi_luns</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_lun</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this device is known to support sparse multiple units,</span>
<span class="cm">	 * override the other settings, and scan all of them. Normally,</span>
<span class="cm">	 * SCSI-3 devices should be scanned via the REPORT LUNS.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_SPARSELUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">max_dev_lun</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_lun</span><span class="p">;</span>
		<span class="n">sparse_lun</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sparse_lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If less than SCSI_1_CSS, and no special lun scaning, stop</span>
<span class="cm">	 * scanning; this matches 2.4 behaviour, but could just be a bug</span>
<span class="cm">	 * (to continue scanning a SCSI_1_CSS device).</span>
<span class="cm">	 *</span>
<span class="cm">	 * This test is broken.  We might not have any device on lun0 for</span>
<span class="cm">	 * a sparselun device, and if that&#39;s the case then how would we</span>
<span class="cm">	 * know the real scsi_level, eh?  It might make sense to just not</span>
<span class="cm">	 * scan any SCSI_1 device for non-0 luns, but that check would best</span>
<span class="cm">	 * go into scsi_alloc_sdev() and just have it return null when asked</span>
<span class="cm">	 * to alloc an sdev for lun &gt; 0 on an already found SCSI_1 device.</span>
<span class="cm">	 *</span>
<span class="cm">	if ((sdevscan-&gt;scsi_level &lt; SCSI_1_CCS) &amp;&amp;</span>
<span class="cm">	    ((bflags &amp; (BLIST_FORCELUN | BLIST_SPARSELUN | BLIST_MAX5LUN))</span>
<span class="cm">	     == 0))</span>
<span class="cm">		return;</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this device is known to support multiple units, override</span>
<span class="cm">	 * the other settings, and scan all of them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_FORCELUN</span><span class="p">)</span>
		<span class="n">max_dev_lun</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_lun</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * REGAL CDC-4X: avoid hang after LUN 4</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_MAX5LUN</span><span class="p">)</span>
		<span class="n">max_dev_lun</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">5U</span><span class="p">,</span> <span class="n">max_dev_lun</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do not scan SCSI-2 or lower device past LUN 7, unless</span>
<span class="cm">	 * BLIST_LARGELUN.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_level</span> <span class="o">&lt;</span> <span class="n">SCSI_3</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_LARGELUN</span><span class="p">))</span>
		<span class="n">max_dev_lun</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">8U</span><span class="p">,</span> <span class="n">max_dev_lun</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have already scanned LUN 0, so start at LUN 1. Keep scanning</span>
<span class="cm">	 * until we reach the max, or no LUN is found and we are not</span>
<span class="cm">	 * sparse_lun.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lun</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">lun</span> <span class="o">&lt;</span> <span class="n">max_dev_lun</span><span class="p">;</span> <span class="o">++</span><span class="n">lun</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">scsi_probe_and_add_lun</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">rescan</span><span class="p">,</span>
					    <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SCSI_SCAN_LUN_PRESENT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">sparse_lun</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsilun_to_int - convert a scsi_lun to an int</span>
<span class="cm"> * @scsilun:	struct scsi_lun to be converted.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Convert @scsilun from a struct scsi_lun to a four byte host byte-ordered</span>
<span class="cm"> *     integer, and return the result. The caller must check for</span>
<span class="cm"> *     truncation before using this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *     The struct scsi_lun is assumed to be four levels, with each level</span>
<span class="cm"> *     effectively containing a SCSI byte-ordered (big endian) short; the</span>
<span class="cm"> *     addressing bits of each level are ignored (the highest two bits).</span>
<span class="cm"> *     For a description of the LUN format, post SCSI-3 see the SCSI</span>
<span class="cm"> *     Architecture Model, for SCSI-3 see the SCSI Controller Commands.</span>
<span class="cm"> *</span>
<span class="cm"> *     Given a struct scsi_lun of: 0a 04 0b 03 00 00 00 00, this function returns</span>
<span class="cm"> *     the integer: 0x0b030a04</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">scsilun_to_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_lun</span> <span class="o">*</span><span class="n">scsilun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">;</span>

	<span class="n">lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lun</span><span class="p">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">lun</span> <span class="o">=</span> <span class="n">lun</span> <span class="o">|</span> <span class="p">(((</span><span class="n">scsilun</span><span class="o">-&gt;</span><span class="n">scsi_lun</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
			      <span class="n">scsilun</span><span class="o">-&gt;</span><span class="n">scsi_lun</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">lun</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsilun_to_int</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * int_to_scsilun - reverts an int into a scsi_lun</span>
<span class="cm"> * @lun:        integer to be reverted</span>
<span class="cm"> * @scsilun:	struct scsi_lun to be set.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Reverts the functionality of the scsilun_to_int, which packed</span>
<span class="cm"> *     an 8-byte lun value into an int. This routine unpacks the int</span>
<span class="cm"> *     back into the lun value.</span>
<span class="cm"> *     Note: the scsilun_to_int() routine does not truly handle all</span>
<span class="cm"> *     8bytes of the lun value. This functions restores only as much</span>
<span class="cm"> *     as was set by the routine.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *     Given an integer : 0x0b030a04,  this function returns a</span>
<span class="cm"> *     scsi_lun of : struct scsi_lun of: 0a 04 0b 03 00 00 00 00</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">int_to_scsilun</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_lun</span> <span class="o">*</span><span class="n">scsilun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">scsilun</span><span class="o">-&gt;</span><span class="n">scsi_lun</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scsilun</span><span class="o">-&gt;</span><span class="n">scsi_lun</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lun</span><span class="p">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsilun</span><span class="o">-&gt;</span><span class="n">scsi_lun</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lun</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
		<span class="n">scsilun</span><span class="o">-&gt;</span><span class="n">scsi_lun</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lun</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
		<span class="n">lun</span> <span class="o">=</span> <span class="n">lun</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">int_to_scsilun</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_report_lun_scan - Scan using SCSI REPORT LUN results</span>
<span class="cm"> * @starget: which target</span>
<span class="cm"> * @bflags: Zero or a mix of BLIST_NOLUN, BLIST_REPORTLUN2, or BLIST_NOREPORTLUN</span>
<span class="cm"> * @rescan: nonzero if we can skip code only needed on first scan</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Fast scanning for modern (SCSI-3) devices by sending a REPORT LUN command.</span>
<span class="cm"> *   Scan the resulting list of LUNs by calling scsi_probe_and_add_lun.</span>
<span class="cm"> *</span>
<span class="cm"> *   If BLINK_REPORTLUN2 is set, scan a target that supports more than 8</span>
<span class="cm"> *   LUNs even if it&#39;s older than SCSI-3.</span>
<span class="cm"> *   If BLIST_NOREPORTLUN is set, return 1 always.</span>
<span class="cm"> *   If BLIST_NOLUN is set, return 0 always.</span>
<span class="cm"> *   If starget-&gt;no_report_luns is set, return 1 always.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     0: scan completed (or no memory, so further scanning is futile)</span>
<span class="cm"> *     1: could not scan with REPORT LUN</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scsi_report_lun_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bflags</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">rescan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">devname</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">scsi_cmd</span><span class="p">[</span><span class="n">MAX_COMMAND_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_luns</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">retries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_lun</span> <span class="o">*</span><span class="n">lunp</span><span class="p">,</span> <span class="o">*</span><span class="n">lun_data</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only support SCSI-3 and up devices if BLIST_NOREPORTLUN is not set.</span>
<span class="cm">	 * Also allow SCSI-2 if BLIST_REPORTLUN2 is set and host adapter does</span>
<span class="cm">	 * support more than 8 LUNs.</span>
<span class="cm">	 * Don&#39;t attempt if the target doesn&#39;t support REPORT LUNS.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_NOREPORTLUN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">&lt;</span> <span class="n">SCSI_2</span> <span class="o">&amp;&amp;</span>
	    <span class="n">starget</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">!=</span> <span class="n">SCSI_UNKNOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">&lt;</span> <span class="n">SCSI_3</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_REPORTLUN2</span><span class="p">)</span> <span class="o">||</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">BLIST_NOLUN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">no_report_luns</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">scsi_device_lookup_by_target</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">sdev</span> <span class="o">=</span> <span class="n">scsi_alloc_sdev</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_device_get</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__scsi_remove_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">devname</span><span class="p">,</span> <span class="s">&quot;host %d channel %d id %d&quot;</span><span class="p">,</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate enough to hold the header (the same size as one scsi_lun)</span>
<span class="cm">	 * plus the max number of luns we are requesting.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Reallocating and trying again (with the exact amount we need)</span>
<span class="cm">	 * would be nice, but then we need to somehow limit the size</span>
<span class="cm">	 * allocated based on the available memory and the limits of</span>
<span class="cm">	 * kmalloc - we don&#39;t want a kmalloc() failure of a huge value to</span>
<span class="cm">	 * prevent us from finding any LUNs on this target.</span>
<span class="cm">	 */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_scsi_report_luns</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_lun</span><span class="p">);</span>
	<span class="n">lun_data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span>
			   <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span> <span class="o">?</span> <span class="n">__GFP_DMA</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lun_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">ALLOC_FAILURE_MSG</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">REPORT_LUNS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * bytes 1 - 5: reserved, set to zero.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * bytes 6 - 9: length of the command.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">length</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* reserved */</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* control */</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can get a UNIT ATTENTION, for example a power on/reset, so</span>
<span class="cm">	 * retry a few times (like sd.c does for TEST UNIT READY).</span>
<span class="cm">	 * Experience shows some combinations of adapter/devices get at</span>
<span class="cm">	 * least two power on/resets.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Illegal requests (for devices that do not support REPORT LUNS)</span>
<span class="cm">	 * should come through as a check condition, and will not generate</span>
<span class="cm">	 * a retry.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">retries</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCSI_LOG_SCAN_BUS</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scsi scan: Sending&quot;</span>
				<span class="s">&quot; REPORT LUNS to %s (try %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devname</span><span class="p">,</span>
				<span class="n">retries</span><span class="p">));</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">scsi_execute_req</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">scsi_cmd</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">,</span>
					  <span class="n">lun_data</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">,</span>
					  <span class="n">SCSI_TIMEOUT</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">SCSI_LOG_SCAN_BUS</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scsi scan: REPORT LUNS&quot;</span>
				<span class="s">&quot; %s (try %d) result 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span>
				<span class="o">?</span>  <span class="s">&quot;failed&quot;</span> <span class="o">:</span> <span class="s">&quot;successful&quot;</span><span class="p">,</span> <span class="n">retries</span><span class="p">,</span> <span class="n">result</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scsi_sense_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sshdr</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">!=</span> <span class="n">UNIT_ATTENTION</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The device probably does not support a REPORT LUN command</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the length from the first four bytes of lun_data.</span>
<span class="cm">	 */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">lun_data</span><span class="o">-&gt;</span><span class="n">scsi_lun</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		  <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">));</span>

	<span class="n">num_luns</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_lun</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_luns</span> <span class="o">&gt;</span> <span class="n">max_scsi_report_luns</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;scsi: On %s only %d (max_scsi_report_luns)&quot;</span>
		       <span class="s">&quot; of %d luns reported, try increasing&quot;</span>
		       <span class="s">&quot; max_scsi_report_luns.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devname</span><span class="p">,</span>
		       <span class="n">max_scsi_report_luns</span><span class="p">,</span> <span class="n">num_luns</span><span class="p">);</span>
		<span class="n">num_luns</span> <span class="o">=</span> <span class="n">max_scsi_report_luns</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SCSI_LOG_SCAN_BUS</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sdev_printk</span> <span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span>
		<span class="s">&quot;scsi scan: REPORT LUN scan</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Scan the luns in lun_data. The entry at offset 0 is really</span>
<span class="cm">	 * the header, so start at 1 and go up to and including num_luns.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lunp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lun_data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">lunp</span> <span class="o">&lt;=</span> <span class="o">&amp;</span><span class="n">lun_data</span><span class="p">[</span><span class="n">num_luns</span><span class="p">];</span> <span class="n">lunp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lun</span> <span class="o">=</span> <span class="n">scsilun_to_int</span><span class="p">(</span><span class="n">lunp</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if the unused part of lunp is non-zero, and so</span>
<span class="cm">		 * does not fit in lun.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lunp</span><span class="o">-&gt;</span><span class="n">scsi_lun</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">lun</span><span class="p">)],</span> <span class="s">&quot;</span><span class="se">\0\0\0\0</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Output an error displaying the LUN in byte order,</span>
<span class="cm">			 * this differs from what linux would print for the</span>
<span class="cm">			 * integer LUN value.</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;scsi: %s lun 0x&quot;</span><span class="p">,</span> <span class="n">devname</span><span class="p">);</span>
			<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">lunp</span><span class="o">-&gt;</span><span class="n">scsi_lun</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_lun</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; has a LUN larger than currently supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lun</span> <span class="o">&gt;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_lun</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;scsi: %s lun%d has a LUN larger&quot;</span>
			       <span class="s">&quot; than allowed by the host adapter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">devname</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

			<span class="n">res</span> <span class="o">=</span> <span class="n">scsi_probe_and_add_lun</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span>
				<span class="n">lun</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">rescan</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">SCSI_SCAN_NO_RESPONSE</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Got some results, but now none, abort.</span>
<span class="cm">				 */</span>
				<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span>
					<span class="s">&quot;Unexpected response&quot;</span>
				        <span class="s">&quot; from lun %d while scanning, scan&quot;</span>
				        <span class="s">&quot; aborted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">out_err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lun_data</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_device_created</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * the sdev we used didn&#39;t appear in the report luns scan</span>
<span class="cm">		 */</span>
		<span class="n">__scsi_remove_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="nf">__scsi_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="n">uint</span> <span class="n">channel</span><span class="p">,</span>
				      <span class="n">uint</span> <span class="n">id</span><span class="p">,</span> <span class="n">uint</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hostdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">scsi_scan_type</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="n">starget</span> <span class="o">=</span> <span class="n">scsi_alloc_target</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">starget</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">scsi_autopm_get_target</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">async_scan</span><span class="p">)</span>
		<span class="n">scsi_complete_async_scans</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_host_scan_allowed</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">scsi_autopm_get_host</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_probe_and_add_lun</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hostdata</span><span class="p">);</span>
		<span class="n">scsi_autopm_put_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>
	<span class="n">scsi_autopm_put_target</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
	<span class="n">scsi_target_reap</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sdev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__scsi_add_device</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">scsi_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="n">uint</span> <span class="n">channel</span><span class="p">,</span>
		    <span class="n">uint</span> <span class="n">target</span><span class="p">,</span> <span class="n">uint</span> <span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> 
		<span class="n">__scsi_add_device</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

	<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_add_device</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">scsi_rescan_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">drv</span> <span class="o">=</span> <span class="n">to_scsi_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">rescan</span><span class="p">)</span>
			<span class="n">drv</span><span class="o">-&gt;</span><span class="n">rescan</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_rescan_device</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__scsi_scan_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rescan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">bflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t scan the host adapter</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">starget</span> <span class="o">=</span> <span class="n">scsi_alloc_target</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">starget</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">scsi_autopm_get_target</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lun</span> <span class="o">!=</span> <span class="n">SCAN_WILD_CARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Scan for a specific host/chan/id/lun.</span>
<span class="cm">		 */</span>
		<span class="n">scsi_probe_and_add_lun</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">rescan</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_reap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Scan LUN 0, if there is some response, scan further. Ideally, we</span>
<span class="cm">	 * would not configure LUN 0 until all LUNs are scanned.</span>
<span class="cm">	 */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">scsi_probe_and_add_lun</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bflags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">rescan</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">SCSI_SCAN_LUN_PRESENT</span> <span class="o">||</span> <span class="n">res</span> <span class="o">==</span> <span class="n">SCSI_SCAN_TARGET_PRESENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_report_lun_scan</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="n">bflags</span><span class="p">,</span> <span class="n">rescan</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * The REPORT LUN did not scan the target,</span>
<span class="cm">			 * do a sequential scan.</span>
<span class="cm">			 */</span>
			<span class="n">scsi_sequential_lun_scan</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="n">bflags</span><span class="p">,</span>
						 <span class="n">starget</span><span class="o">-&gt;</span><span class="n">scsi_level</span><span class="p">,</span> <span class="n">rescan</span><span class="p">);</span>
	<span class="p">}</span>

 <span class="nl">out_reap:</span>
	<span class="n">scsi_autopm_put_target</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
	<span class="cm">/* now determine if the target has any children at all</span>
<span class="cm">	 * and if not, nuke it */</span>
	<span class="n">scsi_target_reap</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>

	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_scan_target - scan a target id, possibly including all LUNs on the target.</span>
<span class="cm"> * @parent:	host to scan</span>
<span class="cm"> * @channel:	channel to scan</span>
<span class="cm"> * @id:		target id to scan</span>
<span class="cm"> * @lun:	Specific LUN to scan or SCAN_WILD_CARD</span>
<span class="cm"> * @rescan:	passed to LUN scanning routines</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Scan the target id on @parent, @channel, and @id. Scan at least LUN 0,</span>
<span class="cm"> *     and possibly all LUNs on the target id.</span>
<span class="cm"> *</span>
<span class="cm"> *     First try a REPORT LUN scan, if that does not scan the target, do a</span>
<span class="cm"> *     sequential scan of LUNs on the target id.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">scsi_scan_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rescan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">scsi_scan_type</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">async_scan</span><span class="p">)</span>
		<span class="n">scsi_complete_async_scans</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_host_scan_allowed</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">scsi_autopm_get_host</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__scsi_scan_target</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">rescan</span><span class="p">);</span>
		<span class="n">scsi_autopm_put_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_scan_target</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_scan_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rescan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uint</span> <span class="n">order_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">SCAN_WILD_CARD</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_id</span><span class="p">;</span> <span class="o">++</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * XXX adapter drivers when possible (FCP, iSCSI)</span>
<span class="cm">			 * could modify max_id to match the current max,</span>
<span class="cm">			 * not the absolute max.</span>
<span class="cm">			 *</span>
<span class="cm">			 * XXX add a shost id iterator, so for example,</span>
<span class="cm">			 * the FC ID can be the same as a target id</span>
<span class="cm">			 * without a huge overhead of sparse id&#39;s.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">reverse_ordering</span><span class="p">)</span>
				<span class="cm">/*</span>
<span class="cm">				 * Scan from high to low id.</span>
<span class="cm">				 */</span>
				<span class="n">order_id</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">-</span> <span class="n">id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">order_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
			<span class="n">__scsi_scan_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
					<span class="n">order_id</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">rescan</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">__scsi_scan_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
				<span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">rescan</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">scsi_scan_host_selected</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rescan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SCSI_LOG_SCAN_BUS</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">shost_printk</span> <span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span>
		<span class="s">&quot;%s: &lt;%u:%u:%u&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">channel</span> <span class="o">!=</span> <span class="n">SCAN_WILD_CARD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&gt;</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_channel</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">id</span> <span class="o">!=</span> <span class="n">SCAN_WILD_CARD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_id</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">lun</span> <span class="o">!=</span> <span class="n">SCAN_WILD_CARD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lun</span> <span class="o">&gt;</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_lun</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">async_scan</span><span class="p">)</span>
		<span class="n">scsi_complete_async_scans</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_host_scan_allowed</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">scsi_autopm_get_host</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="n">SCAN_WILD_CARD</span><span class="p">)</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">channel</span> <span class="o">&lt;=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_channel</span><span class="p">;</span>
			     <span class="n">channel</span><span class="o">++</span><span class="p">)</span>
				<span class="n">scsi_scan_channel</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span>
						  <span class="n">rescan</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">scsi_scan_channel</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">rescan</span><span class="p">);</span>
		<span class="n">scsi_autopm_put_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_sysfs_add_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="n">shost_for_each_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">shost</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_host_scan_allowed</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">scsi_sysfs_add_sdev</span><span class="p">(</span><span class="n">sdev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">__scsi_remove_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_prep_async_scan - prepare for an async scan</span>
<span class="cm"> * @shost: the host which will be scanned</span>
<span class="cm"> * Returns: a cookie to be passed to scsi_finish_async_scan()</span>
<span class="cm"> *</span>
<span class="cm"> * Tells the midlayer this host is going to do an asynchronous scan.</span>
<span class="cm"> * It reserves the host&#39;s position in the scanning list and ensures</span>
<span class="cm"> * that other asynchronous scans started after this one won&#39;t affect the</span>
<span class="cm"> * ordering of the discovered devices.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">async_scan_data</span> <span class="o">*</span><span class="nf">scsi_prep_async_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">async_scan_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">scsi_scan_type</span><span class="p">,</span> <span class="s">&quot;sync&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">async_scan</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s called twice for host %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_get</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">prev_finished</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">async_scan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_scan_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scanning_hosts</span><span class="p">))</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">prev_finished</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scanning_hosts</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_scan_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>

 <span class="nl">err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_finish_async_scan - asynchronous scan has finished</span>
<span class="cm"> * @data: cookie returned from earlier call to scsi_prep_async_scan()</span>
<span class="cm"> *</span>
<span class="cm"> * All the devices currently attached to this host have been found.</span>
<span class="cm"> * This function announces all the devices it has found to the rest</span>
<span class="cm"> * of the system.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_finish_async_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">async_scan_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">async_scan</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s called twice for host %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">prev_finished</span><span class="p">);</span>

	<span class="n">scsi_sysfs_add_devices</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">async_scan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_scan_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scanning_hosts</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">async_scan_data</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">scanning_hosts</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">async_scan_data</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev_finished</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_scan_lock</span><span class="p">);</span>

	<span class="n">scsi_autopm_put_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_scsi_scan_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">scan_finished</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">scan_start</span><span class="p">)</span>
			<span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">scan_start</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">scan_finished</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">scsi_scan_host_selected</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">SCAN_WILD_CARD</span><span class="p">,</span> <span class="n">SCAN_WILD_CARD</span><span class="p">,</span>
				<span class="n">SCAN_WILD_CARD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_scan_async</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">async_scan_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">;</span>

	<span class="n">do_scsi_scan_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">scsi_finish_async_scan</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_scan_host - scan the given adapter</span>
<span class="cm"> * @shost:	adapter to scan</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">scsi_scan_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">async_scan_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">scsi_scan_type</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_autopm_get_host</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">scsi_prep_async_scan</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_scsi_scan_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
		<span class="n">scsi_autopm_put_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">do_scan_async</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="s">&quot;scsi_scan_%d&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">do_scan_async</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="cm">/* scsi_autopm_put_host(shost) is called in scsi_finish_async_scan() */</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_scan_host</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">scsi_forget_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

 <span class="nl">restart:</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">__devices</span><span class="p">,</span> <span class="n">siblings</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">==</span> <span class="n">SDEV_DEL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">__scsi_remove_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_get_host_dev - Create a scsi_device that points to the host adapter itself</span>
<span class="cm"> * @shost: Host that needs a scsi_device</span>
<span class="cm"> *</span>
<span class="cm"> * Lock status: None assumed.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:     The scsi_device or NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	Attach a single scsi_device to the Scsi_Host - this should</span>
<span class="cm"> *	be made to look like a &quot;pseudo-device&quot; that points to the</span>
<span class="cm"> *	HA itself.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note - this device is not accessible from any high-level</span>
<span class="cm"> *	drivers (including generics), which is probably not</span>
<span class="cm"> *	optimal.  We can add hooks later to attach.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="nf">scsi_get_host_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_host_scan_allowed</span><span class="p">(</span><span class="n">shost</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">starget</span> <span class="o">=</span> <span class="n">scsi_alloc_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">this_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">starget</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">scsi_alloc_sdev</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">borken</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">scsi_target_reap</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_get_host_dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_free_host_dev - Free a scsi_device that points to the host adapter itself</span>
<span class="cm"> * @sdev: Host device to be freed</span>
<span class="cm"> *</span>
<span class="cm"> * Lock status: None assumed.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:     Nothing</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_free_host_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">this_id</span><span class="p">);</span>

	<span class="n">__scsi_remove_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_free_host_dev</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
