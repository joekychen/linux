<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › be2iscsi › be.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>be.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Copyright (C) 2005 - 2011 Emulex</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version 2</span>
<span class="cm"> * as published by the Free Software Foundation.  The full GNU General</span>
<span class="cm"> * Public License is included in this distribution in the file called COPYING.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> * linux-drivers@emulex.com</span>
<span class="cm"> *</span>
<span class="cm"> * Emulex</span>
<span class="cm"> * 3333 Susan Street</span>
<span class="cm"> * Costa Mesa, CA 92626</span>
<span class="cm"> */</span>

<span class="cp">#ifndef BEISCSI_H</span>
<span class="cp">#define BEISCSI_H</span>

<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/blk-iopoll.h&gt;</span>
<span class="cp">#define FW_VER_LEN	32</span>
<span class="cp">#define MCC_Q_LEN	128</span>
<span class="cp">#define MCC_CQ_LEN	256</span>
<span class="cp">#define MAX_MCC_CMD	16</span>
<span class="cm">/* BladeEngine Generation numbers */</span>
<span class="cp">#define BE_GEN2 2</span>
<span class="cp">#define BE_GEN3 3</span>

<span class="k">struct</span> <span class="n">be_dma_mem</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">be_queue_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">be_dma_mem</span> <span class="n">dma_mem</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">entry_size</span><span class="p">;</span>		<span class="cm">/* Size of an element in the queue */</span>
	<span class="n">u16</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tail</span><span class="p">,</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">created</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">used</span><span class="p">;</span>		<span class="cm">/* Number of valid elements in the queue */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">MODULO</span><span class="p">(</span><span class="n">u16</span> <span class="n">val</span><span class="p">,</span> <span class="n">u16</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">limit</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">index_inc</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">index</span> <span class="o">=</span> <span class="n">MODULO</span><span class="p">((</span><span class="o">*</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">limit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">queue_head_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">be_queue_info</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_mem</span><span class="p">.</span><span class="n">va</span> <span class="o">+</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">*</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">queue_get_wrb</span><span class="p">(</span><span class="k">struct</span> <span class="n">be_queue_info</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wrb_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_mem</span><span class="p">.</span><span class="n">va</span> <span class="o">+</span> <span class="n">wrb_num</span> <span class="o">*</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">queue_tail_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">be_queue_info</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_mem</span><span class="p">.</span><span class="n">va</span> <span class="o">+</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">*</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">queue_head_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">be_queue_info</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">index_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">queue_tail_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">be_queue_info</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">index_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*ISCSI */</span>

<span class="k">struct</span> <span class="n">be_eq_obj</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">be_queue_info</span> <span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">beiscsi_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">be_queue_info</span> <span class="o">*</span><span class="n">cq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blk_iopoll</span>	<span class="n">iopoll</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">be_mcc_obj</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">be_queue_info</span> <span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">be_queue_info</span> <span class="n">cq</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">be_ctrl_info</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">csr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>		<span class="cm">/* Door Bell */</span>
	<span class="n">u8</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pcicfg</span><span class="p">;</span>	<span class="cm">/* PCI config space */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/* Mbox used for cmd request/response */</span>
	<span class="n">spinlock_t</span> <span class="n">mbox_lock</span><span class="p">;</span>	<span class="cm">/* For serializing mbox cmds to BE card */</span>
	<span class="k">struct</span> <span class="n">be_dma_mem</span> <span class="n">mbox_mem</span><span class="p">;</span>
	<span class="cm">/* Mbox mem is adjusted to align to 16 bytes. The allocated addr</span>
<span class="cm">	 * is stored for freeing purpose */</span>
	<span class="k">struct</span> <span class="n">be_dma_mem</span> <span class="n">mbox_mem_alloced</span><span class="p">;</span>

	<span class="cm">/* MCC Rings */</span>
	<span class="k">struct</span> <span class="n">be_mcc_obj</span> <span class="n">mcc_obj</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">mcc_lock</span><span class="p">;</span>	<span class="cm">/* For serializing mcc cmds to BE card */</span>
	<span class="n">spinlock_t</span> <span class="n">mcc_cq_lock</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span> <span class="n">mcc_wait</span><span class="p">[</span><span class="n">MAX_MCC_CMD</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mcc_tag</span><span class="p">[</span><span class="n">MAX_MCC_CMD</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mcc_numtag</span><span class="p">[</span><span class="n">MAX_MCC_CMD</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mcc_alloc_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mcc_free_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mcc_tag_available</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#include &quot;be_cmds.h&quot;</span>

<span class="cp">#define PAGE_SHIFT_4K 12</span>
<span class="cp">#define PAGE_SIZE_4K (1 &lt;&lt; PAGE_SHIFT_4K)</span>
<span class="cp">#define mcc_timeout		120000 </span><span class="cm">/* 5s timeout */</span><span class="cp"></span>

<span class="cm">/* Returns number of pages spanned by the data starting at the given addr */</span>
<span class="cp">#define PAGES_4K_SPANNED(_address, size)				\</span>
<span class="cp">		((u32)((((size_t)(_address) &amp; (PAGE_SIZE_4K - 1)) +	\</span>
<span class="cp">			(size) + (PAGE_SIZE_4K - 1)) &gt;&gt; PAGE_SHIFT_4K))</span>

<span class="cm">/* Returns bit offset within a DWORD of a bitfield */</span>
<span class="cp">#define AMAP_BIT_OFFSET(_struct, field)					\</span>
<span class="cp">		(((size_t)&amp;(((_struct *)0)-&gt;field))%32)</span>

<span class="cm">/* Returns the bit mask of the field that is NOT shifted into location. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">amap_mask</span><span class="p">(</span><span class="n">u32</span> <span class="n">bitsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bitsize</span> <span class="o">==</span> <span class="mi">32</span> <span class="o">?</span> <span class="mh">0xFFFFFFFF</span> <span class="o">:</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bitsize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">amap_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dw_offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">dw</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">dw_offset</span><span class="p">;</span>
	<span class="o">*</span><span class="n">dw</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">);</span>
	<span class="o">*</span><span class="n">dw</span> <span class="o">|=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define AMAP_SET_BITS(_struct, field, ptr, val)				\</span>
<span class="cp">		amap_set(ptr,						\</span>
<span class="cp">			offsetof(_struct, field)/32,			\</span>
<span class="cp">			amap_mask(sizeof(((_struct *)0)-&gt;field)),	\</span>
<span class="cp">			AMAP_BIT_OFFSET(_struct, field),		\</span>
<span class="cp">			val)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">amap_get</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dw_offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">dw</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">dw</span> <span class="o">+</span> <span class="n">dw_offset</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define AMAP_GET_BITS(_struct, field, ptr)				\</span>
<span class="cp">		amap_get(ptr,						\</span>
<span class="cp">			offsetof(_struct, field)/32,			\</span>
<span class="cp">			amap_mask(sizeof(((_struct *)0)-&gt;field)),	\</span>
<span class="cp">			AMAP_BIT_OFFSET(_struct, field))</span>

<span class="cp">#define be_dws_cpu_to_le(wrb, len) swap_dws(wrb, len)</span>
<span class="cp">#define be_dws_le_to_cpu(wrb, len) swap_dws(wrb, len)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">swap_dws</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">wrb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef __BIG_ENDIAN</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">dw</span> <span class="o">=</span> <span class="n">wrb</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">%</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">dw</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">*</span><span class="n">dw</span><span class="p">);</span>
		<span class="n">dw</span><span class="o">++</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* __BIG_ENDIAN */</span><span class="cp"></span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* BEISCSI_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
