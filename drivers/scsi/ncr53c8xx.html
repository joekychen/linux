<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › ncr53c8xx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ncr53c8xx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm">**  Device driver for the PCI-SCSI NCR538XX controller family.</span>
<span class="cm">**</span>
<span class="cm">**  Copyright (C) 1994  Wolfgang Stanglmeier</span>
<span class="cm">**</span>
<span class="cm">**  This program is free software; you can redistribute it and/or modify</span>
<span class="cm">**  it under the terms of the GNU General Public License as published by</span>
<span class="cm">**  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">**  (at your option) any later version.</span>
<span class="cm">**</span>
<span class="cm">**  This program is distributed in the hope that it will be useful,</span>
<span class="cm">**  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">**  GNU General Public License for more details.</span>
<span class="cm">**</span>
<span class="cm">**  You should have received a copy of the GNU General Public License</span>
<span class="cm">**  along with this program; if not, write to the Free Software</span>
<span class="cm">**  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm">**</span>
<span class="cm">**-----------------------------------------------------------------------------</span>
<span class="cm">**</span>
<span class="cm">**  This driver has been ported to Linux from the FreeBSD NCR53C8XX driver</span>
<span class="cm">**  and is currently maintained by</span>
<span class="cm">**</span>
<span class="cm">**          Gerard Roudier              &lt;groudier@free.fr&gt;</span>
<span class="cm">**</span>
<span class="cm">**  Being given that this driver originates from the FreeBSD version, and</span>
<span class="cm">**  in order to keep synergy on both, any suggested enhancements and corrections</span>
<span class="cm">**  received on Linux are automatically a potential candidate for the FreeBSD </span>
<span class="cm">**  version.</span>
<span class="cm">**</span>
<span class="cm">**  The original driver has been written for 386bsd and FreeBSD by</span>
<span class="cm">**          Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;</span>
<span class="cm">**          Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;</span>
<span class="cm">**</span>
<span class="cm">**  And has been ported to NetBSD by</span>
<span class="cm">**          Charles M. Hannum           &lt;mycroft@gnu.ai.mit.edu&gt;</span>
<span class="cm">**</span>
<span class="cm">**-----------------------------------------------------------------------------</span>
<span class="cm">**</span>
<span class="cm">**                     Brief history</span>
<span class="cm">**</span>
<span class="cm">**  December 10 1995 by Gerard Roudier:</span>
<span class="cm">**     Initial port to Linux.</span>
<span class="cm">**</span>
<span class="cm">**  June 23 1996 by Gerard Roudier:</span>
<span class="cm">**     Support for 64 bits architectures (Alpha).</span>
<span class="cm">**</span>
<span class="cm">**  November 30 1996 by Gerard Roudier:</span>
<span class="cm">**     Support for Fast-20 scsi.</span>
<span class="cm">**     Support for large DMA fifo and 128 dwords bursting.</span>
<span class="cm">**</span>
<span class="cm">**  February 27 1997 by Gerard Roudier:</span>
<span class="cm">**     Support for Fast-40 scsi.</span>
<span class="cm">**     Support for on-Board RAM.</span>
<span class="cm">**</span>
<span class="cm">**  May 3 1997 by Gerard Roudier:</span>
<span class="cm">**     Full support for scsi scripts instructions pre-fetching.</span>
<span class="cm">**</span>
<span class="cm">**  May 19 1997 by Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;:</span>
<span class="cm">**     Support for NvRAM detection and reading.</span>
<span class="cm">**</span>
<span class="cm">**  August 18 1997 by Cort &lt;cort@cs.nmt.edu&gt;:</span>
<span class="cm">**     Support for Power/PC (Big Endian).</span>
<span class="cm">**</span>
<span class="cm">**  June 20 1998 by Gerard Roudier</span>
<span class="cm">**     Support for up to 64 tags per lun.</span>
<span class="cm">**     O(1) everywhere (C and SCRIPTS) for normal cases.</span>
<span class="cm">**     Low PCI traffic for command handling when on-chip RAM is present.</span>
<span class="cm">**     Aggressive SCSI SCRIPTS optimizations.</span>
<span class="cm">**</span>
<span class="cm">**  2005 by Matthew Wilcox and James Bottomley</span>
<span class="cm">**     PCI-ectomy.  This driver now supports only the 720 chip (see the</span>
<span class="cm">**     NCR_Q720 and zalon drivers for the bus probe logic).</span>
<span class="cm">**</span>
<span class="cm">*******************************************************************************</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">**	Supported SCSI-II features:</span>
<span class="cm">**	    Synchronous negotiation</span>
<span class="cm">**	    Wide negotiation        (depends on the NCR Chip)</span>
<span class="cm">**	    Enable disconnection</span>
<span class="cm">**	    Tagged command queuing</span>
<span class="cm">**	    Parity checking</span>
<span class="cm">**	    Etc...</span>
<span class="cm">**</span>
<span class="cm">**	Supported NCR/SYMBIOS chips:</span>
<span class="cm">**		53C720		(Wide,   Fast SCSI-2, intfly problems)</span>
<span class="cm">*/</span>

<span class="cm">/* Name and version of the driver */</span>
<span class="cp">#define SCSI_NCR_DRIVER_NAME	&quot;ncr53c8xx-3.4.3g&quot;</span>

<span class="cp">#define SCSI_NCR_DEBUG_FLAGS	(0)</span>

<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_dbg.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_spi.h&gt;</span>

<span class="cp">#include &quot;ncr53c8xx.h&quot;</span>

<span class="cp">#define NAME53C8XX		&quot;ncr53c8xx&quot;</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Debugging tags</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="cp">#define DEBUG_ALLOC    (0x0001)</span>
<span class="cp">#define DEBUG_PHASE    (0x0002)</span>
<span class="cp">#define DEBUG_QUEUE    (0x0008)</span>
<span class="cp">#define DEBUG_RESULT   (0x0010)</span>
<span class="cp">#define DEBUG_POINTER  (0x0020)</span>
<span class="cp">#define DEBUG_SCRIPT   (0x0040)</span>
<span class="cp">#define DEBUG_TINY     (0x0080)</span>
<span class="cp">#define DEBUG_TIMING   (0x0100)</span>
<span class="cp">#define DEBUG_NEGO     (0x0200)</span>
<span class="cp">#define DEBUG_TAGS     (0x0400)</span>
<span class="cp">#define DEBUG_SCATTER  (0x0800)</span>
<span class="cp">#define DEBUG_IC        (0x1000)</span>

<span class="cm">/*</span>
<span class="cm">**    Enable/Disable debug messages.</span>
<span class="cm">**    Can be changed at runtime too.</span>
<span class="cm">*/</span>

<span class="cp">#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ncr_debug</span> <span class="o">=</span> <span class="n">SCSI_NCR_DEBUG_FLAGS</span><span class="p">;</span>
	<span class="cp">#define DEBUG_FLAGS ncr_debug</span>
<span class="cp">#else</span>
	<span class="cp">#define DEBUG_FLAGS	SCSI_NCR_DEBUG_FLAGS</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="nf">ncr_list_pop</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">elem</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="n">list_del</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">elem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Simple power of two buddy-like allocator.</span>
<span class="cm">**</span>
<span class="cm">**	This simple code is not intended to be fast, but to </span>
<span class="cm">**	provide power of 2 aligned memory allocations.</span>
<span class="cm">**	Since the SCRIPTS processor only supplies 8 bit </span>
<span class="cm">**	arithmetic, this allocator allows simple and fast </span>
<span class="cm">**	address calculations  from the SCRIPTS code.</span>
<span class="cm">**	In addition, cache line alignment is guaranteed for </span>
<span class="cm">**	power of 2 cache line size.</span>
<span class="cm">**	Enhanced in linux-2.3.44 to provide a memory pool </span>
<span class="cm">**	per pcidev to support dynamic dma mapping. (I would </span>
<span class="cm">**	have preferred a real bus abstraction, btw).</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="cp">#define MEMO_SHIFT	4	</span><span class="cm">/* 16 bytes minimum memory chunk */</span><span class="cp"></span>
<span class="cp">#if PAGE_SIZE &gt;= 8192</span>
<span class="cp">#define MEMO_PAGE_ORDER	0	</span><span class="cm">/* 1 PAGE  maximum */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define MEMO_PAGE_ORDER	1	</span><span class="cm">/* 2 PAGES maximum */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#define MEMO_FREE_UNUSED	</span><span class="cm">/* Free unused pages immediately */</span><span class="cp"></span>
<span class="cp">#define MEMO_WARN	1</span>
<span class="cp">#define MEMO_GFP_FLAGS	GFP_ATOMIC</span>
<span class="cp">#define MEMO_CLUSTER_SHIFT	(PAGE_SHIFT+MEMO_PAGE_ORDER)</span>
<span class="cp">#define MEMO_CLUSTER_SIZE	(1UL &lt;&lt; MEMO_CLUSTER_SHIFT)</span>
<span class="cp">#define MEMO_CLUSTER_MASK	(MEMO_CLUSTER_SIZE-1)</span>

<span class="k">typedef</span> <span class="n">u_long</span> <span class="n">m_addr_t</span><span class="p">;</span>	<span class="cm">/* Enough bits to bit-hack addresses */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">m_bush_t</span><span class="p">;</span>	<span class="cm">/* Something that addresses DMAable */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">m_link</span> <span class="p">{</span>		<span class="cm">/* Link between free memory chunks */</span>
	<span class="k">struct</span> <span class="n">m_link</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">m_link_s</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">m_vtob</span> <span class="p">{</span>		<span class="cm">/* Virtual to Bus address translation */</span>
	<span class="k">struct</span> <span class="n">m_vtob</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">m_addr_t</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="n">m_addr_t</span> <span class="n">baddr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">m_vtob_s</span><span class="p">;</span>
<span class="cp">#define VTOB_HASH_SHIFT		5</span>
<span class="cp">#define VTOB_HASH_SIZE		(1UL &lt;&lt; VTOB_HASH_SHIFT)</span>
<span class="cp">#define VTOB_HASH_MASK		(VTOB_HASH_SIZE-1)</span>
<span class="cp">#define VTOB_HASH_CODE(m)	\</span>
<span class="cp">	((((m_addr_t) (m)) &gt;&gt; MEMO_CLUSTER_SHIFT) &amp; VTOB_HASH_MASK)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">m_pool</span> <span class="p">{</span>		<span class="cm">/* Memory pool of a given kind */</span>
	<span class="n">m_bush_t</span> <span class="n">bush</span><span class="p">;</span>
	<span class="n">m_addr_t</span> <span class="p">(</span><span class="o">*</span><span class="n">getp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">m_pool</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">freep</span><span class="p">)(</span><span class="k">struct</span> <span class="n">m_pool</span> <span class="o">*</span><span class="p">,</span> <span class="n">m_addr_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">nump</span><span class="p">;</span>
	<span class="n">m_vtob_s</span> <span class="o">*</span><span class="p">(</span><span class="n">vtob</span><span class="p">[</span><span class="n">VTOB_HASH_SIZE</span><span class="p">]);</span>
	<span class="k">struct</span> <span class="n">m_pool</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">m_link</span> <span class="n">h</span><span class="p">[</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="n">MEMO_SHIFT</span><span class="o">+</span><span class="n">MEMO_PAGE_ORDER</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">m_pool_s</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">___m_alloc</span><span class="p">(</span><span class="n">m_pool_s</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MEMO_SHIFT</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">m_addr_t</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">m_link_s</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">MEMO_PAGE_ORDER</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">++</span><span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">MEMO_PAGE_ORDER</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_link_s</span> <span class="o">*</span><span class="p">)</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">getp</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span><span class="p">)</span>
				<span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">++</span><span class="n">j</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_addr_t</span><span class="p">)</span> <span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">s</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_link_s</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">s</span><span class="p">);</span>
			<span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;___m_alloc(%d) = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">___m_free</span><span class="p">(</span><span class="n">m_pool_s</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MEMO_SHIFT</span><span class="p">);</span>
	<span class="n">m_link_s</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="n">m_addr_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">m_link_s</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;___m_free(%p, %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">MEMO_PAGE_ORDER</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">++</span><span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_addr_t</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef MEMO_FREE_UNUSED</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">MEMO_PAGE_ORDER</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">freep</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">s</span><span class="p">;</span>
		<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="p">(</span><span class="n">m_link_s</span> <span class="o">*</span><span class="p">)</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">((</span><span class="n">m_link_s</span> <span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
			<span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_link_s</span> <span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">++</span><span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ncr53c8xx_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__m_calloc2</span><span class="p">(</span><span class="n">m_pool_s</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">___m_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_ALLOC</span><span class="p">)</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;new %-10s[%4d] @%p.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">uflags</span> <span class="o">&amp;</span> <span class="n">MEMO_WARN</span><span class="p">)</span>
		<span class="n">printk</span> <span class="p">(</span><span class="n">NAME53C8XX</span> <span class="s">&quot;: failed to allocate %s[%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define __m_calloc(mp, s, n)	__m_calloc2(mp, s, n, MEMO_WARN)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__m_free</span><span class="p">(</span><span class="n">m_pool_s</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_ALLOC</span><span class="p">)</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;freeing %-10s[%4d] @%p.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="n">___m_free</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * With pci bus iommu support, we use a default pool of unmapped memory </span>
<span class="cm"> * for memory we donnot need to DMA from/to and one pool per pcidev for </span>
<span class="cm"> * memory accessed by the PCI chip. `mp0&#39; is the default not DMAable pool.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">m_addr_t</span> <span class="nf">___mp0_getp</span><span class="p">(</span><span class="n">m_pool_s</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">m_addr_t</span> <span class="n">m</span> <span class="o">=</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">MEMO_GFP_FLAGS</span><span class="p">,</span> <span class="n">MEMO_PAGE_ORDER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span>
		<span class="o">++</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">nump</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">___mp0_freep</span><span class="p">(</span><span class="n">m_pool_s</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="n">m_addr_t</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_pages</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">MEMO_PAGE_ORDER</span><span class="p">);</span>
	<span class="o">--</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">nump</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">m_pool_s</span> <span class="n">mp0</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">___mp0_getp</span><span class="p">,</span> <span class="n">___mp0_freep</span><span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * DMAable pools.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * With pci bus iommu support, we maintain one pool per pcidev and a </span>
<span class="cm"> * hashed reverse table for virtual to bus physical address translations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">m_addr_t</span> <span class="nf">___dma_getp</span><span class="p">(</span><span class="n">m_pool_s</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">m_addr_t</span> <span class="n">vp</span><span class="p">;</span>
	<span class="n">m_vtob_s</span> <span class="o">*</span><span class="n">vbp</span><span class="p">;</span>

	<span class="n">vbp</span> <span class="o">=</span> <span class="n">__m_calloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vbp</span><span class="p">),</span> <span class="s">&quot;VTOB&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vbp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">daddr</span><span class="p">;</span>
		<span class="n">vp</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_addr_t</span><span class="p">)</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">bush</span><span class="p">,</span>
						<span class="n">PAGE_SIZE</span><span class="o">&lt;&lt;</span><span class="n">MEMO_PAGE_ORDER</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vp</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">hc</span> <span class="o">=</span> <span class="n">VTOB_HASH_CODE</span><span class="p">(</span><span class="n">vp</span><span class="p">);</span>
			<span class="n">vbp</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">vp</span><span class="p">;</span>
			<span class="n">vbp</span><span class="o">-&gt;</span><span class="n">baddr</span> <span class="o">=</span> <span class="n">daddr</span><span class="p">;</span>
			<span class="n">vbp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">vtob</span><span class="p">[</span><span class="n">hc</span><span class="p">];</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">vtob</span><span class="p">[</span><span class="n">hc</span><span class="p">]</span> <span class="o">=</span> <span class="n">vbp</span><span class="p">;</span>
			<span class="o">++</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">nump</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">vp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vbp</span><span class="p">)</span>
		<span class="n">__m_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp0</span><span class="p">,</span> <span class="n">vbp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vbp</span><span class="p">),</span> <span class="s">&quot;VTOB&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">___dma_freep</span><span class="p">(</span><span class="n">m_pool_s</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="n">m_addr_t</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">m_vtob_s</span> <span class="o">**</span><span class="n">vbpp</span><span class="p">,</span> <span class="o">*</span><span class="n">vbp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hc</span> <span class="o">=</span> <span class="n">VTOB_HASH_CODE</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

	<span class="n">vbpp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">vtob</span><span class="p">[</span><span class="n">hc</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">vbpp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">vbpp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">!=</span> <span class="n">m</span><span class="p">)</span>
		<span class="n">vbpp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">vbpp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">vbpp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vbp</span> <span class="o">=</span> <span class="o">*</span><span class="n">vbpp</span><span class="p">;</span>
		<span class="o">*</span><span class="n">vbpp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">vbpp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">bush</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="o">&lt;&lt;</span><span class="n">MEMO_PAGE_ORDER</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">vbp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span><span class="n">vbp</span><span class="o">-&gt;</span><span class="n">baddr</span><span class="p">);</span>
		<span class="n">__m_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp0</span><span class="p">,</span> <span class="n">vbp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vbp</span><span class="p">),</span> <span class="s">&quot;VTOB&quot;</span><span class="p">);</span>
		<span class="o">--</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">nump</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">m_pool_s</span> <span class="o">*</span><span class="nf">___get_dma_pool</span><span class="p">(</span><span class="n">m_bush_t</span> <span class="n">bush</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">m_pool_s</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">mp</span> <span class="o">=</span> <span class="n">mp0</span><span class="p">.</span><span class="n">next</span><span class="p">;</span> <span class="n">mp</span> <span class="o">&amp;&amp;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">bush</span> <span class="o">!=</span> <span class="n">bush</span><span class="p">;</span> <span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">m_pool_s</span> <span class="o">*</span><span class="nf">___cre_dma_pool</span><span class="p">(</span><span class="n">m_bush_t</span> <span class="n">bush</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">m_pool_s</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">__m_calloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mp</span><span class="p">),</span> <span class="s">&quot;MPOOL&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mp</span><span class="p">));</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">bush</span> <span class="o">=</span> <span class="n">bush</span><span class="p">;</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">getp</span> <span class="o">=</span> <span class="n">___dma_getp</span><span class="p">;</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">freep</span> <span class="o">=</span> <span class="n">___dma_freep</span><span class="p">;</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">mp0</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="n">mp0</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">___del_dma_pool</span><span class="p">(</span><span class="n">m_pool_s</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">m_pool</span> <span class="o">**</span><span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mp0</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">pp</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">pp</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span>
		<span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">__m_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">),</span> <span class="s">&quot;MPOOL&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__m_calloc_dma</span><span class="p">(</span><span class="n">m_bush_t</span> <span class="n">bush</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">m_pool</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncr53c8xx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">___get_dma_pool</span><span class="p">(</span><span class="n">bush</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="p">)</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="n">___cre_dma_pool</span><span class="p">(</span><span class="n">bush</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">__m_calloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">nump</span><span class="p">)</span>
		<span class="n">___del_dma_pool</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncr53c8xx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__m_free_dma</span><span class="p">(</span><span class="n">m_bush_t</span> <span class="n">bush</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">m_pool</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncr53c8xx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">___get_dma_pool</span><span class="p">(</span><span class="n">bush</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span>
		<span class="n">__m_free</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">nump</span><span class="p">)</span>
		<span class="n">___del_dma_pool</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncr53c8xx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">m_addr_t</span> <span class="nf">__vtobus</span><span class="p">(</span><span class="n">m_bush_t</span> <span class="n">bush</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">m_pool_s</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hc</span> <span class="o">=</span> <span class="n">VTOB_HASH_CODE</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="n">m_vtob_s</span> <span class="o">*</span><span class="n">vp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">m_addr_t</span> <span class="n">a</span> <span class="o">=</span> <span class="p">((</span><span class="n">m_addr_t</span><span class="p">)</span> <span class="n">m</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MEMO_CLUSTER_MASK</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncr53c8xx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">___get_dma_pool</span><span class="p">(</span><span class="n">bush</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vp</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">vtob</span><span class="p">[</span><span class="n">hc</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">vp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">m_addr_t</span><span class="p">)</span> <span class="n">vp</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">!=</span> <span class="n">a</span><span class="p">)</span>
			<span class="n">vp</span> <span class="o">=</span> <span class="n">vp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncr53c8xx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vp</span> <span class="o">?</span> <span class="n">vp</span><span class="o">-&gt;</span><span class="n">baddr</span> <span class="o">+</span> <span class="p">(((</span><span class="n">m_addr_t</span><span class="p">)</span> <span class="n">m</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define _m_calloc_dma(np, s, n)		__m_calloc_dma(np-&gt;dev, s, n)</span>
<span class="cp">#define _m_free_dma(np, p, s, n)	__m_free_dma(np-&gt;dev, p, s, n)</span>
<span class="cp">#define m_calloc_dma(s, n)		_m_calloc_dma(np, s, n)</span>
<span class="cp">#define m_free_dma(p, s, n)		_m_free_dma(np, p, s, n)</span>
<span class="cp">#define _vtobus(np, p)			__vtobus(np-&gt;dev, p)</span>
<span class="cp">#define vtobus(p)			_vtobus(np, p)</span>

<span class="cm">/*</span>
<span class="cm"> *  Deal with DMA mapping/unmapping.</span>
<span class="cm"> */</span>

<span class="cm">/* To keep track of the dma mapping (sg/single) that has been set */</span>
<span class="cp">#define __data_mapped	SCp.phase</span>
<span class="cp">#define __data_mapping	SCp.have_data_in</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__unmap_scsi_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">__data_mapped</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">__data_mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__map_scsi_sg_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">use_sg</span><span class="p">;</span>

	<span class="n">use_sg</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">use_sg</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">__data_mapped</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">__data_mapping</span> <span class="o">=</span> <span class="n">use_sg</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">use_sg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define unmap_scsi_data(np, cmd)	__unmap_scsi_data(np-&gt;dev, cmd)</span>
<span class="cp">#define map_scsi_sg_data(np, cmd)	__map_scsi_sg_data(np-&gt;dev, cmd)</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Driver setup.</span>
<span class="cm">**</span>
<span class="cm">**	This structure is initialized from linux config </span>
<span class="cm">**	options. It can be overridden at boot-up by the boot </span>
<span class="cm">**	command line.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ncr_driver_setup</span>
	<span class="n">driver_setup</span>			<span class="o">=</span> <span class="n">SCSI_NCR_DRIVER_SETUP</span><span class="p">;</span>

<span class="cp">#ifndef MODULE</span>
<span class="cp">#ifdef	SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ncr_driver_setup</span>
	<span class="n">driver_safe_setup</span> <span class="n">__initdata</span>	<span class="o">=</span> <span class="n">SCSI_NCR_DRIVER_SAFE_SETUP</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="cm">/* !MODULE */</span><span class="cp"></span>

<span class="cp">#define initverbose (driver_setup.verbose)</span>
<span class="cp">#define bootverbose (np-&gt;verbose)</span>


<span class="cm">/*===================================================================</span>
<span class="cm">**</span>
<span class="cm">**	Driver setup from the boot command line</span>
<span class="cm">**</span>
<span class="cm">**===================================================================</span>
<span class="cm">*/</span>

<span class="cp">#ifdef MODULE</span>
<span class="cp">#define	ARG_SEP	&#39; &#39;</span>
<span class="cp">#else</span>
<span class="cp">#define	ARG_SEP	&#39;,&#39;</span>
<span class="cp">#endif</span>

<span class="cp">#define OPT_TAGS		1</span>
<span class="cp">#define OPT_MASTER_PARITY	2</span>
<span class="cp">#define OPT_SCSI_PARITY		3</span>
<span class="cp">#define OPT_DISCONNECTION	4</span>
<span class="cp">#define OPT_SPECIAL_FEATURES	5</span>
<span class="cp">#define OPT_UNUSED_1		6</span>
<span class="cp">#define OPT_FORCE_SYNC_NEGO	7</span>
<span class="cp">#define OPT_REVERSE_PROBE	8</span>
<span class="cp">#define OPT_DEFAULT_SYNC	9</span>
<span class="cp">#define OPT_VERBOSE		10</span>
<span class="cp">#define OPT_DEBUG		11</span>
<span class="cp">#define OPT_BURST_MAX		12</span>
<span class="cp">#define OPT_LED_PIN		13</span>
<span class="cp">#define OPT_MAX_WIDE		14</span>
<span class="cp">#define OPT_SETTLE_DELAY	15</span>
<span class="cp">#define OPT_DIFF_SUPPORT	16</span>
<span class="cp">#define OPT_IRQM		17</span>
<span class="cp">#define OPT_PCI_FIX_UP		18</span>
<span class="cp">#define OPT_BUS_CHECK		19</span>
<span class="cp">#define OPT_OPTIMIZE		20</span>
<span class="cp">#define OPT_RECOVERY		21</span>
<span class="cp">#define OPT_SAFE_SETUP		22</span>
<span class="cp">#define OPT_USE_NVRAM		23</span>
<span class="cp">#define OPT_EXCLUDE		24</span>
<span class="cp">#define OPT_HOST_ID		25</span>

<span class="cp">#ifdef SCSI_NCR_IARB_SUPPORT</span>
<span class="cp">#define OPT_IARB		26</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef MODULE</span>
<span class="cp">#define	ARG_SEP	&#39; &#39;</span>
<span class="cp">#else</span>
<span class="cp">#define	ARG_SEP	&#39;,&#39;</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef MODULE</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">setup_token</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> 
	<span class="s">&quot;tags:&quot;</span>   <span class="s">&quot;mpar:&quot;</span>
	<span class="s">&quot;spar:&quot;</span>   <span class="s">&quot;disc:&quot;</span>
	<span class="s">&quot;specf:&quot;</span>  <span class="s">&quot;ultra:&quot;</span>
	<span class="s">&quot;fsn:&quot;</span>    <span class="s">&quot;revprob:&quot;</span>
	<span class="s">&quot;sync:&quot;</span>   <span class="s">&quot;verb:&quot;</span>
	<span class="s">&quot;debug:&quot;</span>  <span class="s">&quot;burst:&quot;</span>
	<span class="s">&quot;led:&quot;</span>    <span class="s">&quot;wide:&quot;</span>
	<span class="s">&quot;settle:&quot;</span> <span class="s">&quot;diff:&quot;</span>
	<span class="s">&quot;irqm:&quot;</span>   <span class="s">&quot;pcifix:&quot;</span>
	<span class="s">&quot;buschk:&quot;</span> <span class="s">&quot;optim:&quot;</span>
	<span class="s">&quot;recovery:&quot;</span>
	<span class="s">&quot;safe:&quot;</span>   <span class="s">&quot;nvram:&quot;</span>
	<span class="s">&quot;excl:&quot;</span>   <span class="s">&quot;hostid:&quot;</span>
<span class="cp">#ifdef SCSI_NCR_IARB_SUPPORT</span>
	<span class="s">&quot;iarb:&quot;</span>
<span class="cp">#endif</span>
	<span class="p">;</span>	<span class="cm">/* DONNOT REMOVE THIS &#39;;&#39; */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">get_setup_token</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">setup_token</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pc</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">pc</span><span class="p">;</span>
		<span class="o">++</span><span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">pc</span> <span class="o">-</span> <span class="n">cur</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">pc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">sym53c8xx__setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pc</span><span class="p">,</span> <span class="o">*</span><span class="n">pv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pc</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">pe</span><span class="p">;</span>

		<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pv</span> <span class="o">=</span> <span class="n">pc</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="o">*++</span><span class="n">pv</span><span class="p">;</span>

		<span class="k">if</span>	<span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;n&#39;</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;y&#39;</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">get_setup_token</span><span class="p">(</span><span class="n">cur</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">OPT_TAGS</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">default_tags</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pe</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">pe</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">pe</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">pe</span> <span class="o">!=</span> <span class="n">ARG_SEP</span> <span class="o">&amp;&amp;</span> 
					<span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">driver_setup</span><span class="p">.</span><span class="n">tag_ctrl</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">driver_setup</span><span class="p">.</span><span class="n">tag_ctrl</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">pe</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">driver_setup</span><span class="p">.</span><span class="n">tag_ctrl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_MASTER_PARITY</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">master_parity</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_SCSI_PARITY</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">scsi_parity</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_DISCONNECTION</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">disconnection</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_SPECIAL_FEATURES</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">special_features</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_FORCE_SYNC_NEGO</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">force_sync_nego</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_REVERSE_PROBE</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">reverse_probe</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_DEFAULT_SYNC</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">default_sync</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_VERBOSE</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_DEBUG</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_BURST_MAX</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">burst_max</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_LED_PIN</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">led_pin</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_MAX_WIDE</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">max_wide</span> <span class="o">=</span> <span class="n">val</span><span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_SETTLE_DELAY</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">settle_delay</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_DIFF_SUPPORT</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">diff_support</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_IRQM</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">irqm</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_PCI_FIX_UP</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">pci_fix_up</span>	<span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_BUS_CHECK</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">bus_check</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_OPTIMIZE</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">optimize</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_RECOVERY</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">recovery</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_USE_NVRAM</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">use_nvram</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_SAFE_SETUP</span>:
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver_setup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_safe_setup</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">driver_setup</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_EXCLUDE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">xi</span> <span class="o">&lt;</span> <span class="n">SCSI_NCR_MAX_EXCLUDES</span><span class="p">)</span>
				<span class="n">driver_setup</span><span class="p">.</span><span class="n">excludes</span><span class="p">[</span><span class="n">xi</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OPT_HOST_ID</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">host_id</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef SCSI_NCR_IARB_SUPPORT</span>
		<span class="k">case</span> <span class="n">OPT_IARB</span>:
			<span class="n">driver_setup</span><span class="p">.</span><span class="n">iarb</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;sym53c8xx_setup: unexpected boot option &#39;%.*s&#39; ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">pc</span><span class="o">-</span><span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">cur</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">cur</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">ARG_SEP</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="o">++</span><span class="n">cur</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT */</span><span class="cp"></span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !MODULE */</span><span class="cp"></span>

<span class="cm">/*===================================================================</span>
<span class="cm">**</span>
<span class="cm">**	Get device queue depth from boot command line.</span>
<span class="cm">**</span>
<span class="cm">**===================================================================</span>
<span class="cm">*/</span>
<span class="cp">#define DEF_DEPTH	(driver_setup.default_tags)</span>
<span class="cp">#define ALL_TARGETS	-2</span>
<span class="cp">#define NO_TARGET	-1</span>
<span class="cp">#define ALL_LUNS	-2</span>
<span class="cp">#define NO_LUN		-1</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">device_queue_depth</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">driver_setup</span><span class="p">.</span><span class="n">tag_ctrl</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">h</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">NO_TARGET</span><span class="p">;</span>
	<span class="n">u</span> <span class="o">=</span> <span class="n">NO_LUN</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;/&#39;</span>:
			<span class="o">++</span><span class="n">h</span><span class="p">;</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">ALL_TARGETS</span><span class="p">;</span>
			<span class="n">u</span> <span class="o">=</span> <span class="n">ALL_LUNS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;t&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">target</span><span class="p">)</span>
				<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="o">?</span> <span class="n">v</span> <span class="o">:</span> <span class="n">NO_TARGET</span><span class="p">;</span>
			<span class="n">u</span> <span class="o">=</span> <span class="n">ALL_LUNS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;u&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="n">lun</span><span class="p">)</span>
				<span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">lun</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="o">?</span> <span class="n">v</span> <span class="o">:</span> <span class="n">NO_LUN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;q&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">==</span> <span class="n">unit</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">ALL_TARGETS</span> <span class="o">||</span> <span class="n">t</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">ALL_LUNS</span>    <span class="o">||</span> <span class="n">u</span> <span class="o">==</span> <span class="n">lun</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;-&#39;</span>:
			<span class="n">t</span> <span class="o">=</span> <span class="n">ALL_TARGETS</span><span class="p">;</span>
			<span class="n">u</span> <span class="o">=</span> <span class="n">ALL_LUNS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">DEF_DEPTH</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	The CCB done queue uses an array of CCB virtual </span>
<span class="cm">**	addresses. Empty entries are flagged using the bogus </span>
<span class="cm">**	virtual address 0xffffffff.</span>
<span class="cm">**</span>
<span class="cm">**	Since PCI ensures that only aligned DWORDs are accessed </span>
<span class="cm">**	atomically, 64 bit little-endian architecture requires </span>
<span class="cm">**	to test the high order DWORD of the entry to determine </span>
<span class="cm">**	if it is empty or valid.</span>
<span class="cm">**</span>
<span class="cm">**	BTW, I will make things differently as soon as I will </span>
<span class="cm">**	have a better idea, but this is simple and should work.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>
 
<span class="cp">#define SCSI_NCR_CCB_DONE_SUPPORT</span>
<span class="cp">#ifdef  SCSI_NCR_CCB_DONE_SUPPORT</span>

<span class="cp">#define MAX_DONE 24</span>
<span class="cp">#define CCB_DONE_EMPTY 0xffffffffUL</span>

<span class="cm">/* All 32 bit architectures */</span>
<span class="cp">#if BITS_PER_LONG == 32</span>
<span class="cp">#define CCB_DONE_VALID(cp)  (((u_long) cp) != CCB_DONE_EMPTY)</span>

<span class="cm">/* All &gt; 32 bit (64 bit) architectures regardless endian-ness */</span>
<span class="cp">#else</span>
<span class="cp">#define CCB_DONE_VALID(cp)  \</span>
<span class="cp">	((((u_long) cp) &amp; 0xffffffff00000000ul) &amp;&amp; 	\</span>
<span class="cp">	 (((u_long) cp) &amp; 0xfffffffful) != CCB_DONE_EMPTY)</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* SCSI_NCR_CCB_DONE_SUPPORT */</span><span class="cp"></span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Configuration and Debugging</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">**    SCSI address of this device.</span>
<span class="cm">**    The boot routines should have set it.</span>
<span class="cm">**    If not, use this.</span>
<span class="cm">*/</span>

<span class="cp">#ifndef SCSI_NCR_MYADDR</span>
<span class="cp">#define SCSI_NCR_MYADDR      (7)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">**    The maximum number of tags per logic unit.</span>
<span class="cm">**    Used only for disk devices that support tags.</span>
<span class="cm">*/</span>

<span class="cp">#ifndef SCSI_NCR_MAX_TAGS</span>
<span class="cp">#define SCSI_NCR_MAX_TAGS    (8)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">**    TAGS are actually limited to 64 tags/lun.</span>
<span class="cm">**    We need to deal with power of 2, for alignment constraints.</span>
<span class="cm">*/</span>
<span class="cp">#if	SCSI_NCR_MAX_TAGS &gt; 64</span>
<span class="cp">#define	MAX_TAGS (64)</span>
<span class="cp">#else</span>
<span class="cp">#define	MAX_TAGS SCSI_NCR_MAX_TAGS</span>
<span class="cp">#endif</span>

<span class="cp">#define NO_TAG	(255)</span>

<span class="cm">/*</span>
<span class="cm">**	Choose appropriate type for tag bitmap.</span>
<span class="cm">*/</span>
<span class="cp">#if	MAX_TAGS &gt; 32</span>
<span class="k">typedef</span> <span class="n">u64</span> <span class="n">tagmap_t</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">typedef</span> <span class="n">u32</span> <span class="n">tagmap_t</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">**    Number of targets supported by the driver.</span>
<span class="cm">**    n permits target numbers 0..n-1.</span>
<span class="cm">**    Default is 16, meaning targets #0..#15.</span>
<span class="cm">**    #7 .. is myself.</span>
<span class="cm">*/</span>

<span class="cp">#ifdef SCSI_NCR_MAX_TARGET</span>
<span class="cp">#define MAX_TARGET  (SCSI_NCR_MAX_TARGET)</span>
<span class="cp">#else</span>
<span class="cp">#define MAX_TARGET  (16)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">**    Number of logic units supported by the driver.</span>
<span class="cm">**    n enables logic unit numbers 0..n-1.</span>
<span class="cm">**    The common SCSI devices require only</span>
<span class="cm">**    one lun, so take 1 as the default.</span>
<span class="cm">*/</span>

<span class="cp">#ifdef SCSI_NCR_MAX_LUN</span>
<span class="cp">#define MAX_LUN    SCSI_NCR_MAX_LUN</span>
<span class="cp">#else</span>
<span class="cp">#define MAX_LUN    (1)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">**    Asynchronous pre-scaler (ns). Shall be 40</span>
<span class="cm">*/</span>
 
<span class="cp">#ifndef SCSI_NCR_MIN_ASYNC</span>
<span class="cp">#define SCSI_NCR_MIN_ASYNC (40)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">**    The maximum number of jobs scheduled for starting.</span>
<span class="cm">**    There should be one slot per target, and one slot</span>
<span class="cm">**    for each tag of each target in use.</span>
<span class="cm">**    The calculation below is actually quite silly ...</span>
<span class="cm">*/</span>

<span class="cp">#ifdef SCSI_NCR_CAN_QUEUE</span>
<span class="cp">#define MAX_START   (SCSI_NCR_CAN_QUEUE + 4)</span>
<span class="cp">#else</span>
<span class="cp">#define MAX_START   (MAX_TARGET + 7 * MAX_TAGS)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">**   We limit the max number of pending IO to 250.</span>
<span class="cm">**   since we donnot want to allocate more than 1 </span>
<span class="cm">**   PAGE for &#39;scripth&#39;.</span>
<span class="cm">*/</span>
<span class="cp">#if	MAX_START &gt; 250</span>
<span class="cp">#undef	MAX_START</span>
<span class="cp">#define	MAX_START 250</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">**    The maximum number of segments a transfer is split into.</span>
<span class="cm">**    We support up to 127 segments for both read and write.</span>
<span class="cm">**    The data scripts are broken into 2 sub-scripts.</span>
<span class="cm">**    80 (MAX_SCATTERL) segments are moved from a sub-script</span>
<span class="cm">**    in on-chip RAM. This makes data transfers shorter than </span>
<span class="cm">**    80k (assuming 1k fs) as fast as possible.</span>
<span class="cm">*/</span>

<span class="cp">#define MAX_SCATTER (SCSI_NCR_MAX_SCATTER)</span>

<span class="cp">#if (MAX_SCATTER &gt; 80)</span>
<span class="cp">#define MAX_SCATTERL	80</span>
<span class="cp">#define	MAX_SCATTERH	(MAX_SCATTER - MAX_SCATTERL)</span>
<span class="cp">#else</span>
<span class="cp">#define MAX_SCATTERL	(MAX_SCATTER-1)</span>
<span class="cp">#define	MAX_SCATTERH	1</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">**	other</span>
<span class="cm">*/</span>

<span class="cp">#define NCR_SNOOP_TIMEOUT (1000000)</span>

<span class="cm">/*</span>
<span class="cm">**	Other definitions</span>
<span class="cm">*/</span>

<span class="cp">#define ScsiResult(host_code, scsi_code) (((host_code) &lt;&lt; 16) + ((scsi_code) &amp; 0x7f))</span>

<span class="cp">#define initverbose (driver_setup.verbose)</span>
<span class="cp">#define bootverbose (np-&gt;verbose)</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Command control block states.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="cp">#define HS_IDLE		(0)</span>
<span class="cp">#define HS_BUSY		(1)</span>
<span class="cp">#define HS_NEGOTIATE	(2)	</span><span class="cm">/* sync/wide data transfer*/</span><span class="cp"></span>
<span class="cp">#define HS_DISCONNECT	(3)	</span><span class="cm">/* Disconnected by target */</span><span class="cp"></span>

<span class="cp">#define HS_DONEMASK	(0x80)</span>
<span class="cp">#define HS_COMPLETE	(4|HS_DONEMASK)</span>
<span class="cp">#define HS_SEL_TIMEOUT	(5|HS_DONEMASK)	</span><span class="cm">/* Selection timeout      */</span><span class="cp"></span>
<span class="cp">#define HS_RESET	(6|HS_DONEMASK)	</span><span class="cm">/* SCSI reset	          */</span><span class="cp"></span>
<span class="cp">#define HS_ABORTED	(7|HS_DONEMASK)	</span><span class="cm">/* Transfer aborted       */</span><span class="cp"></span>
<span class="cp">#define HS_TIMEOUT	(8|HS_DONEMASK)	</span><span class="cm">/* Software timeout       */</span><span class="cp"></span>
<span class="cp">#define HS_FAIL		(9|HS_DONEMASK)	</span><span class="cm">/* SCSI or PCI bus errors */</span><span class="cp"></span>
<span class="cp">#define HS_UNEXPECTED	(10|HS_DONEMASK)</span><span class="cm">/* Unexpected disconnect  */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm">**	Invalid host status values used by the SCRIPTS processor </span>
<span class="cm">**	when the nexus is not fully identified.</span>
<span class="cm">**	Shall never appear in a CCB.</span>
<span class="cm">*/</span>

<span class="cp">#define HS_INVALMASK	(0x40)</span>
<span class="cp">#define	HS_SELECTING	(0|HS_INVALMASK)</span>
<span class="cp">#define	HS_IN_RESELECT	(1|HS_INVALMASK)</span>
<span class="cp">#define	HS_STARTING	(2|HS_INVALMASK)</span>

<span class="cm">/*</span>
<span class="cm">**	Flags set by the SCRIPT processor for commands </span>
<span class="cm">**	that have been skipped.</span>
<span class="cm">*/</span>
<span class="cp">#define HS_SKIPMASK	(0x20)</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Software Interrupt Codes</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="cp">#define	SIR_BAD_STATUS		(1)</span>
<span class="cp">#define	SIR_XXXXXXXXXX		(2)</span>
<span class="cp">#define	SIR_NEGO_SYNC		(3)</span>
<span class="cp">#define	SIR_NEGO_WIDE		(4)</span>
<span class="cp">#define	SIR_NEGO_FAILED		(5)</span>
<span class="cp">#define	SIR_NEGO_PROTO		(6)</span>
<span class="cp">#define	SIR_REJECT_RECEIVED	(7)</span>
<span class="cp">#define	SIR_REJECT_SENT		(8)</span>
<span class="cp">#define	SIR_IGN_RESIDUE		(9)</span>
<span class="cp">#define	SIR_MISSING_SAVE	(10)</span>
<span class="cp">#define	SIR_RESEL_NO_MSG_IN	(11)</span>
<span class="cp">#define	SIR_RESEL_NO_IDENTIFY	(12)</span>
<span class="cp">#define	SIR_RESEL_BAD_LUN	(13)</span>
<span class="cp">#define	SIR_RESEL_BAD_TARGET	(14)</span>
<span class="cp">#define	SIR_RESEL_BAD_I_T_L	(15)</span>
<span class="cp">#define	SIR_RESEL_BAD_I_T_L_Q	(16)</span>
<span class="cp">#define	SIR_DONE_OVERFLOW	(17)</span>
<span class="cp">#define	SIR_INTFLY		(18)</span>
<span class="cp">#define	SIR_MAX			(18)</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Extended error codes.</span>
<span class="cm">**	xerr_status field of struct ccb.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="cp">#define	XE_OK		(0)</span>
<span class="cp">#define	XE_EXTRA_DATA	(1)	</span><span class="cm">/* unexpected data phase */</span><span class="cp"></span>
<span class="cp">#define	XE_BAD_PHASE	(2)	</span><span class="cm">/* illegal phase (4/5)   */</span><span class="cp"></span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Negotiation status.</span>
<span class="cm">**	nego_status field	of struct ccb.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="cp">#define NS_NOCHANGE	(0)</span>
<span class="cp">#define NS_SYNC		(1)</span>
<span class="cp">#define NS_WIDE		(2)</span>
<span class="cp">#define NS_PPR		(4)</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Misc.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="cp">#define CCB_MAGIC	(0xf2691ad2)</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Declaration of structs.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span><span class="n">ncr53c8xx_transport_template</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">tcb</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">lcb</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ccb</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ncb</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">script</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">link</span> <span class="p">{</span>
	<span class="n">ncrcmd</span>	<span class="n">l_cmd</span><span class="p">;</span>
	<span class="n">ncrcmd</span>	<span class="n">l_paddr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span>	<span class="n">usrcmd</span> <span class="p">{</span>
	<span class="n">u_long</span>	<span class="n">target</span><span class="p">;</span>
	<span class="n">u_long</span>	<span class="n">lun</span><span class="p">;</span>
	<span class="n">u_long</span>	<span class="n">data</span><span class="p">;</span>
	<span class="n">u_long</span>	<span class="n">cmd</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define UC_SETSYNC      10</span>
<span class="cp">#define UC_SETTAGS	11</span>
<span class="cp">#define UC_SETDEBUG	12</span>
<span class="cp">#define UC_SETORDER	13</span>
<span class="cp">#define UC_SETWIDE	14</span>
<span class="cp">#define UC_SETFLAG	15</span>
<span class="cp">#define UC_SETVERBOSE	17</span>

<span class="cp">#define	UF_TRACE	(0x01)</span>
<span class="cp">#define	UF_NODISC	(0x02)</span>
<span class="cp">#define	UF_NOSCAN	(0x04)</span>

<span class="cm">/*========================================================================</span>
<span class="cm">**</span>
<span class="cm">**	Declaration of structs:		target control block</span>
<span class="cm">**</span>
<span class="cm">**========================================================================</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">tcb</span> <span class="p">{</span>
	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	During reselection the ncr jumps to this point with SFBR </span>
<span class="cm">	**	set to the encoded target number with bit 7 set.</span>
<span class="cm">	**	if it&#39;s not this target, jump to the next.</span>
<span class="cm">	**</span>
<span class="cm">	**	JUMP  IF (SFBR != #target#), @(next tcb)</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">link</span>   <span class="n">jump_tcb</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Load the actual values for the sxfer and the scntl3</span>
<span class="cm">	**	register (sync/wide mode).</span>
<span class="cm">	**</span>
<span class="cm">	**	SCR_COPY (1), @(sval field of this tcb), @(sxfer  register)</span>
<span class="cm">	**	SCR_COPY (1), @(wval field of this tcb), @(scntl3 register)</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">ncrcmd</span>	<span class="n">getscr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Get the IDENTIFY message and load the LUN to SFBR.</span>
<span class="cm">	**</span>
<span class="cm">	**	CALL, &lt;RESEL_LUN&gt;</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">link</span>   <span class="n">call_lun</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Now look for the right lun.</span>
<span class="cm">	**</span>
<span class="cm">	**	For i = 0 to 3</span>
<span class="cm">	**		SCR_JUMP ^ IFTRUE(MASK(i, 3)), @(first lcb mod. i)</span>
<span class="cm">	**</span>
<span class="cm">	**	Recent chips will prefetch the 4 JUMPS using only 1 burst.</span>
<span class="cm">	**	It is kind of hashcoding.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">link</span>     <span class="n">jump_lcb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* JUMPs for reselection	*/</span>
	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span>	<span class="n">lp</span><span class="p">[</span><span class="n">MAX_LUN</span><span class="p">];</span>	<span class="cm">/* The lcb&#39;s of this tcb	*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Pointer to the ccb used for negotiation.</span>
<span class="cm">	**	Prevent from starting a negotiation for all queued commands </span>
<span class="cm">	**	when tagged command queuing is enabled.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span>   <span class="n">nego_cp</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	statistical data</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">u_long</span>	<span class="n">transfers</span><span class="p">;</span>
	<span class="n">u_long</span>	<span class="n">bytes</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	negotiation of wide and synch transfer and device quirks.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
<span class="cp">#ifdef SCSI_NCR_BIG_ENDIAN</span>
<span class="cm">/*0*/</span>	<span class="n">u16</span>	<span class="n">period</span><span class="p">;</span>
<span class="cm">/*2*/</span>	<span class="n">u_char</span>	<span class="n">sval</span><span class="p">;</span>
<span class="cm">/*3*/</span>	<span class="n">u_char</span>	<span class="n">minsync</span><span class="p">;</span>
<span class="cm">/*0*/</span>	<span class="n">u_char</span>	<span class="n">wval</span><span class="p">;</span>
<span class="cm">/*1*/</span>	<span class="n">u_char</span>	<span class="n">widedone</span><span class="p">;</span>
<span class="cm">/*2*/</span>	<span class="n">u_char</span>	<span class="n">quirks</span><span class="p">;</span>
<span class="cm">/*3*/</span>	<span class="n">u_char</span>	<span class="n">maxoffs</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cm">/*0*/</span>	<span class="n">u_char</span>	<span class="n">minsync</span><span class="p">;</span>
<span class="cm">/*1*/</span>	<span class="n">u_char</span>	<span class="n">sval</span><span class="p">;</span>
<span class="cm">/*2*/</span>	<span class="n">u16</span>	<span class="n">period</span><span class="p">;</span>
<span class="cm">/*0*/</span>	<span class="n">u_char</span>	<span class="n">maxoffs</span><span class="p">;</span>
<span class="cm">/*1*/</span>	<span class="n">u_char</span>	<span class="n">quirks</span><span class="p">;</span>
<span class="cm">/*2*/</span>	<span class="n">u_char</span>	<span class="n">widedone</span><span class="p">;</span>
<span class="cm">/*3*/</span>	<span class="n">u_char</span>	<span class="n">wval</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* User settable limits and options.  */</span>
	<span class="n">u_char</span>	<span class="n">usrsync</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">usrwide</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">usrtags</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">usrflag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*========================================================================</span>
<span class="cm">**</span>
<span class="cm">**	Declaration of structs:		lun control block</span>
<span class="cm">**</span>
<span class="cm">**========================================================================</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">lcb</span> <span class="p">{</span>
	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	During reselection the ncr jumps to this point</span>
<span class="cm">	**	with SFBR set to the &quot;Identify&quot; message.</span>
<span class="cm">	**	if it&#39;s not this lun, jump to the next.</span>
<span class="cm">	**</span>
<span class="cm">	**	JUMP  IF (SFBR != #lun#), @(next lcb of this target)</span>
<span class="cm">	**</span>
<span class="cm">	**	It is this lun. Load TEMP with the nexus jumps table </span>
<span class="cm">	**	address and jump to RESEL_TAG (or RESEL_NOTAG).</span>
<span class="cm">	**</span>
<span class="cm">	**		SCR_COPY (4), p_jump_ccb, TEMP,</span>
<span class="cm">	**		SCR_JUMP, &lt;RESEL_TAG&gt;</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">link</span>	<span class="n">jump_lcb</span><span class="p">;</span>
	<span class="n">ncrcmd</span>		<span class="n">load_jump_ccb</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">link</span>	<span class="n">jump_tag</span><span class="p">;</span>
	<span class="n">ncrcmd</span>		<span class="n">p_jump_ccb</span><span class="p">;</span>	<span class="cm">/* Jump table bus address	*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Jump table used by the script processor to directly jump </span>
<span class="cm">	**	to the CCB corresponding to the reselected nexus.</span>
<span class="cm">	**	Address is allocated on 256 bytes boundary in order to </span>
<span class="cm">	**	allow 8 bit calculation of the tag jump entry for up to </span>
<span class="cm">	**	64 possible tags.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">u32</span>		<span class="n">jump_ccb_0</span><span class="p">;</span>	<span class="cm">/* Default table if no tags	*/</span>
	<span class="n">u32</span>		<span class="o">*</span><span class="n">jump_ccb</span><span class="p">;</span>	<span class="cm">/* Virtual address		*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	CCB queue management.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">free_ccbq</span><span class="p">;</span>	<span class="cm">/* Queue of available CCBs	*/</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">busy_ccbq</span><span class="p">;</span>	<span class="cm">/* Queue of busy CCBs		*/</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">wait_ccbq</span><span class="p">;</span>	<span class="cm">/* Queue of waiting for IO CCBs	*/</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">skip_ccbq</span><span class="p">;</span>	<span class="cm">/* Queue of skipped CCBs	*/</span>
	<span class="n">u_char</span>		<span class="n">actccbs</span><span class="p">;</span>	<span class="cm">/* Number of allocated CCBs	*/</span>
	<span class="n">u_char</span>		<span class="n">busyccbs</span><span class="p">;</span>	<span class="cm">/* CCBs busy for this lun	*/</span>
	<span class="n">u_char</span>		<span class="n">queuedccbs</span><span class="p">;</span>	<span class="cm">/* CCBs queued to the controller*/</span>
	<span class="n">u_char</span>		<span class="n">queuedepth</span><span class="p">;</span>	<span class="cm">/* Queue depth for this lun	*/</span>
	<span class="n">u_char</span>		<span class="n">scdev_depth</span><span class="p">;</span>	<span class="cm">/* SCSI device queue depth	*/</span>
	<span class="n">u_char</span>		<span class="n">maxnxs</span><span class="p">;</span>		<span class="cm">/* Max possible nexuses		*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Control of tagged command queuing.</span>
<span class="cm">	**	Tags allocation is performed using a circular buffer.</span>
<span class="cm">	**	This avoids using a loop for tag allocation.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">u_char</span>		<span class="n">ia_tag</span><span class="p">;</span>		<span class="cm">/* Allocation index		*/</span>
	<span class="n">u_char</span>		<span class="n">if_tag</span><span class="p">;</span>		<span class="cm">/* Freeing index		*/</span>
	<span class="n">u_char</span> <span class="n">cb_tags</span><span class="p">[</span><span class="n">MAX_TAGS</span><span class="p">];</span>	<span class="cm">/* Circular tags buffer	*/</span>
	<span class="n">u_char</span>		<span class="n">usetags</span><span class="p">;</span>	<span class="cm">/* Command queuing is active	*/</span>
	<span class="n">u_char</span>		<span class="n">maxtags</span><span class="p">;</span>	<span class="cm">/* Max nr of tags asked by user	*/</span>
	<span class="n">u_char</span>		<span class="n">numtags</span><span class="p">;</span>	<span class="cm">/* Current number of tags	*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	QUEUE FULL control and ORDERED tag control.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	QUEUE FULL and ORDERED tag control.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">u16</span>		<span class="n">num_good</span><span class="p">;</span>	<span class="cm">/* Nr of GOOD since QUEUE FULL	*/</span>
	<span class="n">tagmap_t</span>	<span class="n">tags_umap</span><span class="p">;</span>	<span class="cm">/* Used tags bitmap		*/</span>
	<span class="n">tagmap_t</span>	<span class="n">tags_smap</span><span class="p">;</span>	<span class="cm">/* Tags in use at &#39;tag_stime&#39;	*/</span>
	<span class="n">u_long</span>		<span class="n">tags_stime</span><span class="p">;</span>	<span class="cm">/* Last time we set smap=umap	*/</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span>	<span class="n">held_ccb</span><span class="p">;</span>	<span class="cm">/* CCB held for QUEUE FULL	*/</span>
<span class="p">};</span>

<span class="cm">/*========================================================================</span>
<span class="cm">**</span>
<span class="cm">**      Declaration of structs:     the launch script.</span>
<span class="cm">**</span>
<span class="cm">**========================================================================</span>
<span class="cm">**</span>
<span class="cm">**	It is part of the CCB and is called by the scripts processor to </span>
<span class="cm">**	start or restart the data structure (nexus).</span>
<span class="cm">**	This 6 DWORDs mini script makes use of prefetching.</span>
<span class="cm">**</span>
<span class="cm">**------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">launch</span> <span class="p">{</span>
	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	SCR_COPY(4),	@(p_phys), @(dsa register)</span>
<span class="cm">	**	SCR_JUMP,	@(scheduler_point)</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">ncrcmd</span>		<span class="n">setup_dsa</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* Copy &#39;phys&#39; address to dsa	*/</span>
	<span class="k">struct</span> <span class="n">link</span>	<span class="n">schedule</span><span class="p">;</span>	<span class="cm">/* Jump to scheduler point	*/</span>
	<span class="n">ncrcmd</span>		<span class="n">p_phys</span><span class="p">;</span>		<span class="cm">/* &#39;phys&#39; header bus address	*/</span>
<span class="p">};</span>

<span class="cm">/*========================================================================</span>
<span class="cm">**</span>
<span class="cm">**      Declaration of structs:     global HEADER.</span>
<span class="cm">**</span>
<span class="cm">**========================================================================</span>
<span class="cm">**</span>
<span class="cm">**	This substructure is copied from the ccb to a global address after </span>
<span class="cm">**	selection (or reselection) and copied back before disconnect.</span>
<span class="cm">**</span>
<span class="cm">**	These fields are accessible to the script processor.</span>
<span class="cm">**</span>
<span class="cm">**------------------------------------------------------------------------</span>
<span class="cm">*/</span>

<span class="k">struct</span> <span class="n">head</span> <span class="p">{</span>
	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Saved data pointer.</span>
<span class="cm">	**	Points to the position in the script responsible for the</span>
<span class="cm">	**	actual transfer transfer of data.</span>
<span class="cm">	**	It&#39;s written after reception of a SAVE_DATA_POINTER message.</span>
<span class="cm">	**	The goalpointer points after the last transfer command.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">u32</span>		<span class="n">savep</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">lastp</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">goalp</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Alternate data pointer.</span>
<span class="cm">	**	They are copied back to savep/lastp/goalp by the SCRIPTS </span>
<span class="cm">	**	when the direction is unknown and the device claims data out.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">u32</span>		<span class="n">wlastp</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">wgoalp</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	The virtual address of the ccb containing this header.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span>	<span class="n">cp</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Status fields.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">u_char</span>		<span class="n">scr_st</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* script status		*/</span>
	<span class="n">u_char</span>		<span class="n">status</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* host status. must be the 	*/</span>
					<span class="cm">/*  last DWORD of the header.	*/</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">**	The status bytes are used by the host and the script processor.</span>
<span class="cm">**</span>
<span class="cm">**	The byte corresponding to the host_status must be stored in the </span>
<span class="cm">**	last DWORD of the CCB header since it is used for command </span>
<span class="cm">**	completion (ncr_wakeup()). Doing so, we are sure that the header </span>
<span class="cm">**	has been entirely copied back to the CCB when the host_status is </span>
<span class="cm">**	seen complete by the CPU.</span>
<span class="cm">**</span>
<span class="cm">**	The last four bytes (status[4]) are copied to the scratchb register</span>
<span class="cm">**	(declared as scr0..scr3 in ncr_reg.h) just after the select/reselect,</span>
<span class="cm">**	and copied back just after disconnecting.</span>
<span class="cm">**	Inside the script the XX_REG are used.</span>
<span class="cm">**</span>
<span class="cm">**	The first four bytes (scr_st[4]) are used inside the script by </span>
<span class="cm">**	&quot;COPY&quot; commands.</span>
<span class="cm">**	Because source and destination must have the same alignment</span>
<span class="cm">**	in a DWORD, the fields HAVE to be at the chosen offsets.</span>
<span class="cm">**		xerr_st		0	(0x34)	scratcha</span>
<span class="cm">**		sync_st		1	(0x05)	sxfer</span>
<span class="cm">**		wide_st		3	(0x03)	scntl3</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">**	Last four bytes (script)</span>
<span class="cm">*/</span>
<span class="cp">#define  QU_REG	scr0</span>
<span class="cp">#define  HS_REG	scr1</span>
<span class="cp">#define  HS_PRT	nc_scr1</span>
<span class="cp">#define  SS_REG	scr2</span>
<span class="cp">#define  SS_PRT	nc_scr2</span>
<span class="cp">#define  PS_REG	scr3</span>

<span class="cm">/*</span>
<span class="cm">**	Last four bytes (host)</span>
<span class="cm">*/</span>
<span class="cp">#ifdef SCSI_NCR_BIG_ENDIAN</span>
<span class="cp">#define  actualquirks  phys.header.status[3]</span>
<span class="cp">#define  host_status   phys.header.status[2]</span>
<span class="cp">#define  scsi_status   phys.header.status[1]</span>
<span class="cp">#define  parity_status phys.header.status[0]</span>
<span class="cp">#else</span>
<span class="cp">#define  actualquirks  phys.header.status[0]</span>
<span class="cp">#define  host_status   phys.header.status[1]</span>
<span class="cp">#define  scsi_status   phys.header.status[2]</span>
<span class="cp">#define  parity_status phys.header.status[3]</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">**	First four bytes (script)</span>
<span class="cm">*/</span>
<span class="cp">#define  xerr_st       header.scr_st[0]</span>
<span class="cp">#define  sync_st       header.scr_st[1]</span>
<span class="cp">#define  nego_st       header.scr_st[2]</span>
<span class="cp">#define  wide_st       header.scr_st[3]</span>

<span class="cm">/*</span>
<span class="cm">**	First four bytes (host)</span>
<span class="cm">*/</span>
<span class="cp">#define  xerr_status   phys.xerr_st</span>
<span class="cp">#define  nego_status   phys.nego_st</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define  sync_status   phys.sync_st</span>
<span class="c">#define  wide_status   phys.wide_st</span>
<span class="cp">#endif</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**      Declaration of structs:     Data structure block</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	During execution of a ccb by the script processor,</span>
<span class="cm">**	the DSA (data structure address) register points</span>
<span class="cm">**	to this substructure of the ccb.</span>
<span class="cm">**	This substructure contains the header with</span>
<span class="cm">**	the script-processor-changeable data and</span>
<span class="cm">**	data blocks for the indirect move commands.</span>
<span class="cm">**</span>
<span class="cm">**----------------------------------------------------------</span>
<span class="cm">*/</span>

<span class="k">struct</span> <span class="n">dsb</span> <span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	**	Header.</span>
<span class="cm">	*/</span>

	<span class="k">struct</span> <span class="n">head</span>	<span class="n">header</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Table data for Script</span>
<span class="cm">	*/</span>

	<span class="k">struct</span> <span class="n">scr_tblsel</span>  <span class="n">select</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scr_tblmove</span> <span class="n">smsg</span>  <span class="p">;</span>
	<span class="k">struct</span> <span class="n">scr_tblmove</span> <span class="n">cmd</span>   <span class="p">;</span>
	<span class="k">struct</span> <span class="n">scr_tblmove</span> <span class="n">sense</span> <span class="p">;</span>
	<span class="k">struct</span> <span class="n">scr_tblmove</span> <span class="n">data</span><span class="p">[</span><span class="n">MAX_SCATTER</span><span class="p">];</span>
<span class="p">};</span>


<span class="cm">/*========================================================================</span>
<span class="cm">**</span>
<span class="cm">**      Declaration of structs:     Command control block.</span>
<span class="cm">**</span>
<span class="cm">**========================================================================</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">ccb</span> <span class="p">{</span>
	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	This is the data structure which is pointed by the DSA </span>
<span class="cm">	**	register when it is executed by the script processor.</span>
<span class="cm">	**	It must be the first entry because it contains the header </span>
<span class="cm">	**	as first entry that must be cache line aligned.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">dsb</span>	<span class="n">phys</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Mini-script used at CCB execution start-up.</span>
<span class="cm">	**	Load the DSA with the data structure address (phys) and </span>
<span class="cm">	**	jump to SELECT. Jump to CANCEL if CCB is to be canceled.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">launch</span>	<span class="n">start</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Mini-script used at CCB relection to restart the nexus.</span>
<span class="cm">	**	Load the DSA with the data structure address (phys) and </span>
<span class="cm">	**	jump to RESEL_DSA. Jump to ABORT if CCB is to be aborted.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">launch</span>	<span class="n">restart</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	If a data transfer phase is terminated too early</span>
<span class="cm">	**	(after reception of a message (i.e. DISCONNECT)),</span>
<span class="cm">	**	we have to prepare a mini script to transfer</span>
<span class="cm">	**	the rest of the data.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">ncrcmd</span>		<span class="n">patch</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	The general SCSI driver provides a</span>
<span class="cm">	**	pointer to a control block.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span>	<span class="o">*</span><span class="n">cmd</span><span class="p">;</span>		<span class="cm">/* SCSI command 		*/</span>
	<span class="n">u_char</span>		<span class="n">cdb_buf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* Copy of CDB			*/</span>
	<span class="n">u_char</span>		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">int</span>		<span class="n">data_len</span><span class="p">;</span>	<span class="cm">/* Total data length		*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Message areas.</span>
<span class="cm">	**	We prepare a message to be sent after selection.</span>
<span class="cm">	**	We may use a second one if the command is rescheduled </span>
<span class="cm">	**	due to GETCC or QFULL.</span>
<span class="cm">	**      Contents are IDENTIFY and SIMPLE_TAG.</span>
<span class="cm">	**	While negotiating sync or wide transfer,</span>
<span class="cm">	**	a SDTR or WDTR message is appended.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">u_char</span>		<span class="n">scsi_smsg</span> <span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u_char</span>		<span class="n">scsi_smsg2</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Other fields.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">u_long</span>		<span class="n">p_ccb</span><span class="p">;</span>		<span class="cm">/* BUS address of this CCB	*/</span>
	<span class="n">u_char</span>		<span class="n">sensecmd</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>	<span class="cm">/* Sense command		*/</span>
	<span class="n">u_char</span>		<span class="n">tag</span><span class="p">;</span>		<span class="cm">/* Tag for this transfer	*/</span>
					<span class="cm">/*  255 means no tag		*/</span>
	<span class="n">u_char</span>		<span class="n">target</span><span class="p">;</span>
	<span class="n">u_char</span>		<span class="n">lun</span><span class="p">;</span>
	<span class="n">u_char</span>		<span class="n">queued</span><span class="p">;</span>
	<span class="n">u_char</span>		<span class="n">auto_sense</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span>	<span class="n">link_ccb</span><span class="p">;</span>	<span class="cm">/* Host adapter CCB chain	*/</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link_ccbq</span><span class="p">;</span>	<span class="cm">/* Link to unit CCB queue	*/</span>
	<span class="n">u32</span>		<span class="n">startp</span><span class="p">;</span>		<span class="cm">/* Initial data pointer		*/</span>
	<span class="n">u_long</span>		<span class="n">magic</span><span class="p">;</span>		<span class="cm">/* Free / busy  CCB flag	*/</span>
<span class="p">};</span>

<span class="cp">#define CCB_PHYS(cp,lbl)	(cp-&gt;p_ccb + offsetof(struct ccb, lbl))</span>


<span class="cm">/*========================================================================</span>
<span class="cm">**</span>
<span class="cm">**      Declaration of structs:     NCR device descriptor</span>
<span class="cm">**</span>
<span class="cm">**========================================================================</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">ncb</span> <span class="p">{</span>
	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	The global header.</span>
<span class="cm">	**	It is accessible to both the host and the script processor.</span>
<span class="cm">	**	Must be cache line size aligned (32 for x86) in order to </span>
<span class="cm">	**	allow cache line bursting when it is copied to/from CCB.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">head</span>     <span class="n">header</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	CCBs management queues.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span>	<span class="o">*</span><span class="n">waiting_list</span><span class="p">;</span>	<span class="cm">/* Commands waiting for a CCB	*/</span>
					<span class="cm">/*  when lcb is not allocated.	*/</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span>	<span class="o">*</span><span class="n">done_list</span><span class="p">;</span>	<span class="cm">/* Commands waiting for done()  */</span>
					<span class="cm">/* callback to be invoked.      */</span> 
	<span class="n">spinlock_t</span>	<span class="n">smp_lock</span><span class="p">;</span>	<span class="cm">/* Lock for SMP threading       */</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Chip and controller indentification.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="kt">int</span>		<span class="n">unit</span><span class="p">;</span>		<span class="cm">/* Unit number			*/</span>
	<span class="kt">char</span>		<span class="n">inst_name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* ncb instance name		*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Initial value of some IO register bits.</span>
<span class="cm">	**	These values are assumed to have been set by BIOS, and may </span>
<span class="cm">	**	be used for probing adapter implementation differences.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">u_char</span>	<span class="n">sv_scntl0</span><span class="p">,</span> <span class="n">sv_scntl3</span><span class="p">,</span> <span class="n">sv_dmode</span><span class="p">,</span> <span class="n">sv_dcntl</span><span class="p">,</span> <span class="n">sv_ctest0</span><span class="p">,</span> <span class="n">sv_ctest3</span><span class="p">,</span>
		<span class="n">sv_ctest4</span><span class="p">,</span> <span class="n">sv_ctest5</span><span class="p">,</span> <span class="n">sv_gpcntl</span><span class="p">,</span> <span class="n">sv_stest2</span><span class="p">,</span> <span class="n">sv_stest4</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Actual initial value of IO register bits used by the </span>
<span class="cm">	**	driver. They are loaded at initialisation according to  </span>
<span class="cm">	**	features that are to be enabled.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">u_char</span>	<span class="n">rv_scntl0</span><span class="p">,</span> <span class="n">rv_scntl3</span><span class="p">,</span> <span class="n">rv_dmode</span><span class="p">,</span> <span class="n">rv_dcntl</span><span class="p">,</span> <span class="n">rv_ctest0</span><span class="p">,</span> <span class="n">rv_ctest3</span><span class="p">,</span>
		<span class="n">rv_ctest4</span><span class="p">,</span> <span class="n">rv_ctest5</span><span class="p">,</span> <span class="n">rv_stest2</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Targets management.</span>
<span class="cm">	**	During reselection the ncr jumps to jump_tcb.</span>
<span class="cm">	**	The SFBR register is loaded with the encoded target id.</span>
<span class="cm">	**	For i = 0 to 3</span>
<span class="cm">	**		SCR_JUMP ^ IFTRUE(MASK(i, 3)), @(next tcb mod. i)</span>
<span class="cm">	**</span>
<span class="cm">	**	Recent chips will prefetch the 4 JUMPS using only 1 burst.</span>
<span class="cm">	**	It is kind of hashcoding.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">link</span>     <span class="n">jump_tcb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* JUMPs for reselection	*/</span>
	<span class="k">struct</span> <span class="n">tcb</span>  <span class="n">target</span><span class="p">[</span><span class="n">MAX_TARGET</span><span class="p">];</span>	<span class="cm">/* Target data			*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Virtual and physical bus addresses of the chip.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>		<span class="cm">/* Virtual and bus address of	*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">paddr</span><span class="p">;</span>		<span class="cm">/*  chip&#39;s IO registers.	*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">paddr2</span><span class="p">;</span>		<span class="cm">/* On-chip RAM bus address.	*/</span>
	<span class="k">volatile</span>			<span class="cm">/* Pointer to volatile for 	*/</span>
	<span class="k">struct</span> <span class="n">ncr_reg</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>	<span class="cm">/*  memory mapped IO.		*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	SCRIPTS virtual and physical bus addresses.</span>
<span class="cm">	**	&#39;script&#39;  is loaded in the on-chip RAM if present.</span>
<span class="cm">	**	&#39;scripth&#39; stays in main memory.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">script</span>	<span class="o">*</span><span class="n">script0</span><span class="p">;</span>	<span class="cm">/* Copies of script and scripth	*/</span>
	<span class="k">struct</span> <span class="n">scripth</span>	<span class="o">*</span><span class="n">scripth0</span><span class="p">;</span>	<span class="cm">/*  relocated for this ncb.	*/</span>
	<span class="k">struct</span> <span class="n">scripth</span>	<span class="o">*</span><span class="n">scripth</span><span class="p">;</span>	<span class="cm">/* Actual scripth virt. address	*/</span>
	<span class="n">u_long</span>		<span class="n">p_script</span><span class="p">;</span>	<span class="cm">/* Actual script and scripth	*/</span>
	<span class="n">u_long</span>		<span class="n">p_scripth</span><span class="p">;</span>	<span class="cm">/*  bus addresses.		*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	General controller parameters and configuration.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u_char</span>		<span class="n">revision_id</span><span class="p">;</span>	<span class="cm">/* PCI device revision id	*/</span>
	<span class="n">u32</span>		<span class="n">irq</span><span class="p">;</span>		<span class="cm">/* IRQ level			*/</span>
	<span class="n">u32</span>		<span class="n">features</span><span class="p">;</span>	<span class="cm">/* Chip features map		*/</span>
	<span class="n">u_char</span>		<span class="n">myaddr</span><span class="p">;</span>		<span class="cm">/* SCSI id of the adapter	*/</span>
	<span class="n">u_char</span>		<span class="n">maxburst</span><span class="p">;</span>	<span class="cm">/* log base 2 of dwords burst	*/</span>
	<span class="n">u_char</span>		<span class="n">maxwide</span><span class="p">;</span>	<span class="cm">/* Maximum transfer width	*/</span>
	<span class="n">u_char</span>		<span class="n">minsync</span><span class="p">;</span>	<span class="cm">/* Minimum sync period factor	*/</span>
	<span class="n">u_char</span>		<span class="n">maxsync</span><span class="p">;</span>	<span class="cm">/* Maximum sync period factor	*/</span>
	<span class="n">u_char</span>		<span class="n">maxoffs</span><span class="p">;</span>	<span class="cm">/* Max scsi offset		*/</span>
	<span class="n">u_char</span>		<span class="n">multiplier</span><span class="p">;</span>	<span class="cm">/* Clock multiplier (1,2,4)	*/</span>
	<span class="n">u_char</span>		<span class="n">clock_divn</span><span class="p">;</span>	<span class="cm">/* Number of clock divisors	*/</span>
	<span class="n">u_long</span>		<span class="n">clock_khz</span><span class="p">;</span>	<span class="cm">/* SCSI clock frequency in KHz	*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Start queue management.</span>
<span class="cm">	**	It is filled up by the host processor and accessed by the </span>
<span class="cm">	**	SCRIPTS processor in order to start SCSI commands.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">u16</span>		<span class="n">squeueput</span><span class="p">;</span>	<span class="cm">/* Next free slot of the queue	*/</span>
	<span class="n">u16</span>		<span class="n">actccbs</span><span class="p">;</span>	<span class="cm">/* Number of allocated CCBs	*/</span>
	<span class="n">u16</span>		<span class="n">queuedccbs</span><span class="p">;</span>	<span class="cm">/* Number of CCBs in start queue*/</span>
	<span class="n">u16</span>		<span class="n">queuedepth</span><span class="p">;</span>	<span class="cm">/* Start queue depth		*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Timeout handler.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>	<span class="cm">/* Timer handler link header	*/</span>
	<span class="n">u_long</span>		<span class="n">lasttime</span><span class="p">;</span>
	<span class="n">u_long</span>		<span class="n">settle_time</span><span class="p">;</span>	<span class="cm">/* Resetting the SCSI BUS	*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Debugging and profiling.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">ncr_reg</span>	<span class="n">regdump</span><span class="p">;</span>	<span class="cm">/* Register dump		*/</span>
	<span class="n">u_long</span>		<span class="n">regtime</span><span class="p">;</span>	<span class="cm">/* Time it has been done	*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Miscellaneous buffers accessed by the scripts-processor.</span>
<span class="cm">	**	They shall be DWORD aligned, because they may be read or </span>
<span class="cm">	**	written with a SCR_COPY script command.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">u_char</span>		<span class="n">msgout</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/* Buffer for MESSAGE OUT 	*/</span>
	<span class="n">u_char</span>		<span class="n">msgin</span> <span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/* Buffer for MESSAGE IN	*/</span>
	<span class="n">u32</span>		<span class="n">lastmsg</span><span class="p">;</span>	<span class="cm">/* Last SCSI message sent	*/</span>
	<span class="n">u_char</span>		<span class="n">scratch</span><span class="p">;</span>	<span class="cm">/* Scratch for SCSI receive	*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Miscellaneous configuration and status parameters.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="n">u_char</span>		<span class="n">disc</span><span class="p">;</span>		<span class="cm">/* Diconnection allowed		*/</span>
	<span class="n">u_char</span>		<span class="n">scsi_mode</span><span class="p">;</span>	<span class="cm">/* Current SCSI BUS mode	*/</span>
	<span class="n">u_char</span>		<span class="n">order</span><span class="p">;</span>		<span class="cm">/* Tag order to use		*/</span>
	<span class="n">u_char</span>		<span class="n">verbose</span><span class="p">;</span>	<span class="cm">/* Verbosity for this controller*/</span>
	<span class="kt">int</span>		<span class="n">ncr_cache</span><span class="p">;</span>	<span class="cm">/* Used for cache test at init.	*/</span>
	<span class="n">u_long</span>		<span class="n">p_ncb</span><span class="p">;</span>		<span class="cm">/* BUS address of this NCB	*/</span>

	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Command completion handling.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
<span class="cp">#ifdef SCSI_NCR_CCB_DONE_SUPPORT</span>
	<span class="k">struct</span> <span class="n">ccb</span>	<span class="o">*</span><span class="p">(</span><span class="n">ccb_done</span><span class="p">[</span><span class="n">MAX_DONE</span><span class="p">]);</span>
	<span class="kt">int</span>		<span class="n">ccb_done_ic</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">	**	Fields that should be removed or changed.</span>
<span class="cm">	**----------------------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">ccb</span>	<span class="o">*</span><span class="n">ccb</span><span class="p">;</span>		<span class="cm">/* Global CCB			*/</span>
	<span class="k">struct</span> <span class="n">usrcmd</span>	<span class="n">user</span><span class="p">;</span>		<span class="cm">/* Command from user		*/</span>
	<span class="k">volatile</span> <span class="n">u_char</span>	<span class="n">release_stage</span><span class="p">;</span>	<span class="cm">/* Synchronisation stage on release  */</span>
<span class="p">};</span>

<span class="cp">#define NCB_SCRIPT_PHYS(np,lbl)	 (np-&gt;p_script  + offsetof (struct script, lbl))</span>
<span class="cp">#define NCB_SCRIPTH_PHYS(np,lbl) (np-&gt;p_scripth + offsetof (struct scripth,lbl))</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**      Script for NCR-Processor.</span>
<span class="cm">**</span>
<span class="cm">**	Use ncr_script_fill() to create the variable parts.</span>
<span class="cm">**	Use ncr_script_copy_and_bind() to make a copy and</span>
<span class="cm">**	bind to physical addresses.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	We have to know the offsets of all labels before</span>
<span class="cm">**	we reach them (for forward jumps).</span>
<span class="cm">**	Therefore we declare a struct here.</span>
<span class="cm">**	If you make changes inside the script,</span>
<span class="cm">**	DONT FORGET TO CHANGE THE LENGTHS HERE!</span>
<span class="cm">**</span>
<span class="cm">**----------------------------------------------------------</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">**	For HP Zalon/53c720 systems, the Zalon interface</span>
<span class="cm">**	between CPU and 53c720 does prefetches, which causes</span>
<span class="cm">**	problems with self modifying scripts.  The problem</span>
<span class="cm">**	is overcome by calling a dummy subroutine after each</span>
<span class="cm">**	modification, to force a refetch of the script on</span>
<span class="cm">**	return from the subroutine.</span>
<span class="cm">*/</span>

<span class="cp">#ifdef CONFIG_NCR53C8XX_PREFETCH</span>
<span class="cp">#define PREFETCH_FLUSH_CNT	2</span>
<span class="cp">#define PREFETCH_FLUSH		SCR_CALL, PADDRH (wait_dma),</span>
<span class="cp">#else</span>
<span class="cp">#define PREFETCH_FLUSH_CNT	0</span>
<span class="cp">#define PREFETCH_FLUSH</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">**	Script fragments which are loaded into the on-chip RAM </span>
<span class="cm">**	of 825A, 875 and 895 chips.</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">script</span> <span class="p">{</span>
	<span class="n">ncrcmd</span>	<span class="n">start</span>		<span class="p">[</span>  <span class="mi">5</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">startpos</span>	<span class="p">[</span>  <span class="mi">1</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">select</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">select2</span>		<span class="p">[</span>  <span class="mi">9</span> <span class="o">+</span> <span class="n">PREFETCH_FLUSH_CNT</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">loadpos</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">send_ident</span>	<span class="p">[</span>  <span class="mi">9</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">prepare</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">prepare2</span>	<span class="p">[</span>  <span class="mi">7</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">command</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">dispatch</span>	<span class="p">[</span> <span class="mi">32</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">clrack</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">no_data</span>		<span class="p">[</span> <span class="mi">17</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">status</span>		<span class="p">[</span>  <span class="mi">8</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">msg_in</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">msg_in2</span>		<span class="p">[</span> <span class="mi">16</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">msg_bad</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">setmsg</span>		<span class="p">[</span>  <span class="mi">7</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">cleanup</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">complete</span>	<span class="p">[</span>  <span class="mi">9</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">cleanup_ok</span>	<span class="p">[</span>  <span class="mi">8</span> <span class="o">+</span> <span class="n">PREFETCH_FLUSH_CNT</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">cleanup0</span>	<span class="p">[</span>  <span class="mi">1</span><span class="p">];</span>
<span class="cp">#ifndef SCSI_NCR_CCB_DONE_SUPPORT</span>
	<span class="n">ncrcmd</span>	<span class="n">signal</span>		<span class="p">[</span> <span class="mi">12</span><span class="p">];</span>
<span class="cp">#else</span>
	<span class="n">ncrcmd</span>	<span class="n">signal</span>		<span class="p">[</span>  <span class="mi">9</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">done_pos</span>	<span class="p">[</span>  <span class="mi">1</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">done_plug</span>	<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">done_end</span>	<span class="p">[</span>  <span class="mi">7</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="n">ncrcmd</span>  <span class="n">save_dp</span>		<span class="p">[</span>  <span class="mi">7</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">restore_dp</span>	<span class="p">[</span>  <span class="mi">5</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">disconnect</span>	<span class="p">[</span> <span class="mi">10</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">msg_out</span>		<span class="p">[</span>  <span class="mi">9</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">msg_out_done</span>	<span class="p">[</span>  <span class="mi">7</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">idle</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">reselect</span>	<span class="p">[</span>  <span class="mi">8</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">reselected</span>	<span class="p">[</span>  <span class="mi">8</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">resel_dsa</span>	<span class="p">[</span>  <span class="mi">6</span> <span class="o">+</span> <span class="n">PREFETCH_FLUSH_CNT</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">loadpos1</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">resel_lun</span>	<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">resel_tag</span>	<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">jump_to_nexus</span>	<span class="p">[</span>  <span class="mi">4</span> <span class="o">+</span> <span class="n">PREFETCH_FLUSH_CNT</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">nexus_indirect</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">resel_notag</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">data_in</span>		<span class="p">[</span><span class="n">MAX_SCATTERL</span> <span class="o">*</span> <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">data_in2</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">data_out</span>	<span class="p">[</span><span class="n">MAX_SCATTERL</span> <span class="o">*</span> <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">data_out2</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">**	Script fragments which stay in main memory for all chips.</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">scripth</span> <span class="p">{</span>
	<span class="n">ncrcmd</span>  <span class="n">tryloop</span>		<span class="p">[</span><span class="n">MAX_START</span><span class="o">*</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">tryloop2</span>	<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
<span class="cp">#ifdef SCSI_NCR_CCB_DONE_SUPPORT</span>
	<span class="n">ncrcmd</span>  <span class="n">done_queue</span>	<span class="p">[</span><span class="n">MAX_DONE</span><span class="o">*</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">done_queue2</span>	<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="n">ncrcmd</span>	<span class="n">select_no_atn</span>	<span class="p">[</span>  <span class="mi">8</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">cancel</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">skip</span>		<span class="p">[</span>  <span class="mi">9</span> <span class="o">+</span> <span class="n">PREFETCH_FLUSH_CNT</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">skip2</span>		<span class="p">[</span> <span class="mi">19</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">par_err_data_in</span>	<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">par_err_other</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">msg_reject</span>	<span class="p">[</span>  <span class="mi">8</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">msg_ign_residue</span>	<span class="p">[</span> <span class="mi">24</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">msg_extended</span>	<span class="p">[</span> <span class="mi">10</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">msg_ext_2</span>	<span class="p">[</span> <span class="mi">10</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">msg_wdtr</span>	<span class="p">[</span> <span class="mi">14</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">send_wdtr</span>	<span class="p">[</span>  <span class="mi">7</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">msg_ext_3</span>	<span class="p">[</span> <span class="mi">10</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">msg_sdtr</span>	<span class="p">[</span> <span class="mi">14</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">send_sdtr</span>	<span class="p">[</span>  <span class="mi">7</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">nego_bad_phase</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">msg_out_abort</span>	<span class="p">[</span> <span class="mi">10</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">hdata_in</span>	<span class="p">[</span><span class="n">MAX_SCATTERH</span> <span class="o">*</span> <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">hdata_in2</span>	<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">hdata_out</span>	<span class="p">[</span><span class="n">MAX_SCATTERH</span> <span class="o">*</span> <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">hdata_out2</span>	<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">reset</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">aborttag</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">abort</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">abort_resel</span>	<span class="p">[</span> <span class="mi">20</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">resend_ident</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">clratn_go_on</span>	<span class="p">[</span>  <span class="mi">3</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">nxtdsp_go_on</span>	<span class="p">[</span>  <span class="mi">1</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">sdata_in</span>	<span class="p">[</span>  <span class="mi">8</span><span class="p">];</span>
	<span class="n">ncrcmd</span>  <span class="n">data_io</span>		<span class="p">[</span> <span class="mi">18</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">bad_identify</span>	<span class="p">[</span> <span class="mi">12</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">bad_i_t_l</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">bad_i_t_l_q</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">bad_target</span>	<span class="p">[</span>  <span class="mi">8</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">bad_status</span>	<span class="p">[</span>  <span class="mi">8</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">start_ram</span>	<span class="p">[</span>  <span class="mi">4</span> <span class="o">+</span> <span class="n">PREFETCH_FLUSH_CNT</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">start_ram0</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">sto_restart</span>	<span class="p">[</span>  <span class="mi">5</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">wait_dma</span>	<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">snooptest</span>	<span class="p">[</span>  <span class="mi">9</span><span class="p">];</span>
	<span class="n">ncrcmd</span>	<span class="n">snoopend</span>	<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**      Function headers.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_alloc_ccb</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tn</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">ln</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_complete</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_exception</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_free_ccb</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_init_ccb</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_init_tcb</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tn</span><span class="p">);</span>
<span class="k">static</span>	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span>	<span class="n">ncr_alloc_lcb</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tn</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">ln</span><span class="p">);</span>
<span class="k">static</span>	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span>	<span class="n">ncr_setup_lcb</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_getclock</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mult</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_selectclock</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">scntl3</span><span class="p">);</span>
<span class="k">static</span>	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">ncr_get_ccb</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_chip_reset</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delay</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_init</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reset</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">msg</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">code</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">int</span>	<span class="n">ncr_int_sbmc</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">int</span>	<span class="n">ncr_int_par</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_int_ma</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_int_sir</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">);</span>
<span class="k">static</span>  <span class="kt">void</span>    <span class="n">ncr_int_sto</span>     <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_negotiate</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span><span class="o">*</span> <span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcb</span><span class="o">*</span> <span class="n">tp</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">int</span>	<span class="n">ncr_prepare_nego</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">msgptr</span><span class="p">);</span>

<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_script_copy_and_bind</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">ncrcmd</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">ncrcmd</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span>  <span class="kt">void</span>    <span class="n">ncr_script_fill</span> <span class="p">(</span><span class="k">struct</span> <span class="n">script</span> <span class="o">*</span> <span class="n">scr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scripth</span> <span class="o">*</span> <span class="n">scripth</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">int</span>	<span class="n">ncr_scatter</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_getsync</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">sfac</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">fakp</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">scntl3p</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_setsync</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">scntl3</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">sxfer</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_setup_tags</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_setwide</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">wide</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">ack</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">int</span>	<span class="n">ncr_snooptest</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_timeout</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">);</span>
<span class="k">static</span>  <span class="kt">void</span>    <span class="n">ncr_wakeup</span>      <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">code</span><span class="p">);</span>
<span class="k">static</span>  <span class="kt">void</span>    <span class="n">ncr_wakeup_done</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_start_next_ccb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span> <span class="n">lp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxn</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">ncr_put_start_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">insert_into_waiting_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">retrieve_from_waiting_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">to_remove</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">process_waiting_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sts</span><span class="p">);</span>

<span class="cp">#define remove_from_waiting_list(np, cmd) \</span>
<span class="cp">		retrieve_from_waiting_list(1, (np), (cmd))</span>
<span class="cp">#define requeue_waiting_list(np) process_waiting_list((np), DID_OK)</span>
<span class="cp">#define reset_waiting_list(np) process_waiting_list((np), DID_RESET)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ncr_name</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">inst_name</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**      Scripts for NCR-Processor.</span>
<span class="cm">**</span>
<span class="cm">**      Use ncr_script_bind for binding to physical addresses.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	NADDR generates a reference to a field of the controller data.</span>
<span class="cm">**	PADDR generates a reference to another part of the script.</span>
<span class="cm">**	RADDR generates a reference to a script processor register.</span>
<span class="cm">**	FADDR generates a reference to a script processor register</span>
<span class="cm">**		with offset.</span>
<span class="cm">**</span>
<span class="cm">**----------------------------------------------------------</span>
<span class="cm">*/</span>

<span class="cp">#define	RELOC_SOFTC	0x40000000</span>
<span class="cp">#define	RELOC_LABEL	0x50000000</span>
<span class="cp">#define	RELOC_REGISTER	0x60000000</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define	RELOC_KVAR	0x70000000</span>
<span class="cp">#endif</span>
<span class="cp">#define	RELOC_LABELH	0x80000000</span>
<span class="cp">#define	RELOC_MASK	0xf0000000</span>

<span class="cp">#define	NADDR(label)	(RELOC_SOFTC | offsetof(struct ncb, label))</span>
<span class="cp">#define PADDR(label)    (RELOC_LABEL | offsetof(struct script, label))</span>
<span class="cp">#define PADDRH(label)   (RELOC_LABELH | offsetof(struct scripth, label))</span>
<span class="cp">#define	RADDR(label)	(RELOC_REGISTER | REG(label))</span>
<span class="cp">#define	FADDR(label,ofs)(RELOC_REGISTER | ((REG(label))+(ofs)))</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define	KVAR(which)	(RELOC_KVAR | (which))</span>
<span class="cp">#endif</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define	SCRIPT_KVAR_JIFFIES	(0)</span>
<span class="c">#define	SCRIPT_KVAR_FIRST		SCRIPT_KVAR_JIFFIES</span>
<span class="c">#define	SCRIPT_KVAR_LAST		SCRIPT_KVAR_JIFFIES</span>
<span class="c">/*</span>
<span class="c"> * Kernel variables referenced in the scripts.</span>
<span class="c"> * THESE MUST ALL BE ALIGNED TO A 4-BYTE BOUNDARY.</span>
<span class="c"> */</span>
<span class="c">static void *script_kvars[] __initdata =</span>
<span class="c">	{ (void *)&amp;jiffies };</span>
<span class="cp">#endif</span>

<span class="k">static</span>	<span class="k">struct</span> <span class="n">script</span> <span class="n">script0</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/*--------------------------&lt; START &gt;-----------------------*/</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	**	This NOP will be patched with LED ON</span>
<span class="cm">	**	SCR_REG_REG (gpreg, SCR_AND, 0xfe)</span>
<span class="cm">	*/</span>
	<span class="n">SCR_NO_OP</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**      Clear SIGP.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">ctest2</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	Then jump to a certain point in tryloop.</span>
<span class="cm">	**	Due to the lack of indirect addressing the code</span>
<span class="cm">	**	is self modifying here.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; STARTPOS &gt;--------------------*/</span><span class="p">,{</span>
		<span class="n">PADDRH</span><span class="p">(</span><span class="n">tryloop</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; SELECT &gt;----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	DSA	contains the address of a scheduled</span>
<span class="cm">	**		data structure.</span>
<span class="cm">	**</span>
<span class="cm">	**	SCRATCHA contains the address of the script,</span>
<span class="cm">	**		which starts the next entry.</span>
<span class="cm">	**</span>
<span class="cm">	**	Set Initiator mode.</span>
<span class="cm">	**</span>
<span class="cm">	**	(Target mode is left as an exercise for the reader)</span>
<span class="cm">	*/</span>

	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_TRG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">HS_REG</span><span class="p">,</span> <span class="n">HS_SELECTING</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	**      And try to select this target.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_SEL_TBL_ATN</span> <span class="o">^</span> <span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dsb</span><span class="p">,</span> <span class="n">select</span><span class="p">),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">reselect</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; SELECT2 &gt;----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Now there are 4 possibilities:</span>
<span class="cm">	**</span>
<span class="cm">	**	(1) The ncr loses arbitration.</span>
<span class="cm">	**	This is ok, because it will try again,</span>
<span class="cm">	**	when the bus becomes idle.</span>
<span class="cm">	**	(But beware of the timeout function!)</span>
<span class="cm">	**</span>
<span class="cm">	**	(2) The ncr is reselected.</span>
<span class="cm">	**	Then the script processor takes the jump</span>
<span class="cm">	**	to the RESELECT label.</span>
<span class="cm">	**</span>
<span class="cm">	**	(3) The ncr wins arbitration.</span>
<span class="cm">	**	Then it will execute SCRIPTS instruction until </span>
<span class="cm">	**	the next instruction that checks SCSI phase.</span>
<span class="cm">	**	Then will stop and wait for selection to be </span>
<span class="cm">	**	complete or selection time-out to occur.</span>
<span class="cm">	**	As a result the SCRIPTS instructions until </span>
<span class="cm">	**	LOADPOS + 2 should be executed in parallel with </span>
<span class="cm">	**	the SCSI core performing selection.</span>
<span class="cm">	*/</span>

	<span class="cm">/*</span>
<span class="cm">	**	The MESSAGE_REJECT problem seems to be due to a selection </span>
<span class="cm">	**	timing problem.</span>
<span class="cm">	**	Wait immediately for the selection to complete. </span>
<span class="cm">	**	(2.5x behaves so)</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="mi">0</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	**	Next time use the next slot.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">startpos</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**      The ncr doesn&#39;t have an indirect load</span>
<span class="cm">	**	or store command. So we have to</span>
<span class="cm">	**	copy part of the control block to a</span>
<span class="cm">	**	fixed place, where we can access it.</span>
<span class="cm">	**</span>
<span class="cm">	**	We patch the address part of a</span>
<span class="cm">	**	COPY command with the DSA-register.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY_F</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">dsa</span><span class="p">),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">loadpos</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Flush script prefetch if required</span>
<span class="cm">	*/</span>
	<span class="n">PREFETCH_FLUSH</span>
	<span class="cm">/*</span>
<span class="cm">	**	then we do the actual copy.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">head</span><span class="p">)),</span>
	<span class="cm">/*</span>
<span class="cm">	**	continued after the next label ...</span>
<span class="cm">	*/</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; LOADPOS &gt;---------------------*/</span><span class="p">,{</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Wait for the next phase or the selection</span>
<span class="cm">	**	to complete or time-out.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">prepare</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; SEND_IDENT &gt;----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Selection complete.</span>
<span class="cm">	**	Send the IDENTIFY and SIMPLE_TAG messages</span>
<span class="cm">	**	(and the EXTENDED_SDTR message)</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_TBL</span> <span class="o">^</span> <span class="n">SCR_MSG_OUT</span><span class="p">,</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dsb</span><span class="p">,</span> <span class="n">smsg</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">resend_ident</span><span class="p">),</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">lastmsg</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PREPARE &gt;----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**      load the savep (saved pointer) into</span>
<span class="cm">	**      the TEMP register (actual pointer)</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">savep</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**      Initialize the status registers</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">status</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">scr0</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PREPARE2 &gt;---------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Initialize the msgout buffer with a NOOP message.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="n">NOP</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	SCR_COPY (1),</span>
<span class="c">		RADDR (scratcha),</span>
<span class="c">		NADDR (msgin),</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	**	Anticipate the COMMAND phase.</span>
<span class="cm">	**	This is the normal case for initial selection.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_COMMAND</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; COMMAND &gt;--------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	... and send the command</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_TBL</span> <span class="o">^</span> <span class="n">SCR_COMMAND</span><span class="p">,</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dsb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	If status is still HS_NEGOTIATE, negotiation failed.</span>
<span class="cm">	**	We check this here, since we want to do that </span>
<span class="cm">	**	only once.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">HS_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">HS_NEGOTIATE</span><span class="p">)),</span>
		<span class="n">SIR_NEGO_FAILED</span><span class="p">,</span>

<span class="p">}</span><span class="cm">/*-----------------------&lt; DISPATCH &gt;----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	MSG_IN is the only phase that shall be </span>
<span class="cm">	**	entered at least once for each (re)selection.</span>
<span class="cm">	**	So we test it first.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">msg_in</span><span class="p">),</span>

	<span class="n">SCR_RETURN</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">SCR_DATA_OUT</span><span class="p">)),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	DEL 397 - 53C875 Rev 3 - Part Number 609-0392410 - ITEM 4.</span>
<span class="cm">	**	Possible data corruption during Memory Write and Invalidate.</span>
<span class="cm">	**	This work-around resets the addressing logic prior to the </span>
<span class="cm">	**	start of the first MOVE of a DATA IN phase.</span>
<span class="cm">	**	(See Documentation/scsi/ncr53c8xx.txt for more information)</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">SCR_DATA_IN</span><span class="p">)),</span>
		<span class="mi">20</span><span class="p">,</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">),</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
 		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">SCR_STATUS</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">status</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">SCR_COMMAND</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">command</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">msg_out</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**      Discard one illegal phase byte, if required.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="n">XE_BAD_PHASE</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">xerr_st</span><span class="p">),</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">SCR_ILG_OUT</span><span class="p">)),</span>
		<span class="mi">8</span><span class="p">,</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_ILG_OUT</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">SCR_ILG_IN</span><span class="p">)),</span>
		<span class="mi">8</span><span class="p">,</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_ILG_IN</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; CLRACK &gt;----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Terminate possible pending message phase.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; NO_DATA &gt;--------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	The target wants to tranfer too much data</span>
<span class="cm">	**	or in the wrong direction.</span>
<span class="cm">	**      Remember that in extended error.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="n">XE_EXTRA_DATA</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">xerr_st</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**      Discard one data byte, if required.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_DATA_OUT</span><span class="p">)),</span>
		<span class="mi">8</span><span class="p">,</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_DATA_OUT</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">SCR_DATA_IN</span><span class="p">)),</span>
		<span class="mi">8</span><span class="p">,</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_DATA_IN</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**      .. and repeat as required.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_CALL</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">no_data</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; STATUS &gt;--------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	get the status</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_STATUS</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	save status to scsi_status.</span>
<span class="cm">	**	mark as complete.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_TO_REG</span> <span class="p">(</span><span class="n">SS_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">HS_REG</span><span class="p">,</span> <span class="n">HS_COMPLETE</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_IN &gt;--------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Get the first byte of the message</span>
<span class="cm">	**	and save it to SCRATCHA.</span>
<span class="cm">	**</span>
<span class="cm">	**	The script processor doesn&#39;t negate the</span>
<span class="cm">	**	ACK signal after this transfer.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgin</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_IN2 &gt;--------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Handle this message.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">COMMAND_COMPLETE</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">complete</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">DISCONNECT</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">disconnect</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">SAVE_POINTERS</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">save_dp</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">RESTORE_POINTERS</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">restore_dp</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">EXTENDED_MESSAGE</span><span class="p">)),</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">msg_extended</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">NOP</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">clrack</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">MESSAGE_REJECT</span><span class="p">)),</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">msg_reject</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">IGNORE_WIDE_RESIDUE</span><span class="p">)),</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">msg_ign_residue</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Rest of the messages left as</span>
<span class="cm">	**	an exercise ...</span>
<span class="cm">	**</span>
<span class="cm">	**	Unimplemented messages:</span>
<span class="cm">	**	fall through to MSG_BAD.</span>
<span class="cm">	*/</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_BAD &gt;------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	unimplemented message - reject it.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_REJECT_SENT</span><span class="p">,</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="n">MESSAGE_REJECT</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SETMSG &gt;----------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
	<span class="n">SCR_SET</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">clrack</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; CLEANUP &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**      dsa:    Pointer to ccb</span>
<span class="cm">	**	      or xxxxxxFF (no ccb)</span>
<span class="cm">	**</span>
<span class="cm">	**      HS_REG:   Host-Status (&lt;&gt;0!)</span>
<span class="cm">	*/</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">dsa</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="mh">0xff</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**      dsa is valid.</span>
<span class="cm">	**	complete the cleanup.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">cleanup_ok</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; COMPLETE &gt;-----------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Complete message.</span>
<span class="cm">	**</span>
<span class="cm">	**	Copy TEMP register to LASTP in header.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">lastp</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	When we terminate the cycle by clearing ACK,</span>
<span class="cm">	**	the target may disconnect immediately.</span>
<span class="cm">	**</span>
<span class="cm">	**	We don&#39;t want to be told of an</span>
<span class="cm">	**	&quot;unexpected disconnect&quot;,</span>
<span class="cm">	**	so we disable this feature.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	Terminate cycle ...</span>
<span class="cm">	*/</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="o">|</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	... and wait for the disconnect.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_WAIT_DISC</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; CLEANUP_OK &gt;----------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Save host status to header.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">scr0</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">status</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	and copy back the header to the ccb.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY_F</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">dsa</span><span class="p">),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">cleanup0</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Flush script prefetch if required</span>
<span class="cm">	*/</span>
	<span class="n">PREFETCH_FLUSH</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">head</span><span class="p">)),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; CLEANUP0 &gt;--------------------*/</span><span class="p">,{</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SIGNAL &gt;----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	if job not completed ...</span>
<span class="cm">	*/</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">HS_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	... start the next command.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">HS_DONEMASK</span><span class="o">|</span><span class="n">HS_SKIPMASK</span><span class="p">))),</span>
		<span class="n">PADDR</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	If command resulted in not GOOD status,</span>
<span class="cm">	**	call the C code if needed.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">SS_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CALL</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">S_GOOD</span><span class="p">)),</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">bad_status</span><span class="p">),</span>

<span class="cp">#ifndef	SCSI_NCR_CCB_DONE_SUPPORT</span>

	<span class="cm">/*</span>
<span class="cm">	**	... signal completion to the host</span>
<span class="cm">	*/</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_INTFLY</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	Auf zu neuen Schandtaten!</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>

<span class="cp">#else	</span><span class="cm">/* defined SCSI_NCR_CCB_DONE_SUPPORT */</span><span class="cp"></span>

	<span class="cm">/*</span>
<span class="cm">	**	... signal completion to the host</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*------------------------&lt; DONE_POS &gt;---------------------*/</span><span class="p">,{</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">done_queue</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*------------------------&lt; DONE_PLUG &gt;--------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_DONE_OVERFLOW</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*------------------------&lt; DONE_END &gt;---------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_INTFLY</span><span class="p">,</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">done_pos</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span>

<span class="cp">#endif	</span><span class="cm">/* SCSI_NCR_CCB_DONE_SUPPORT */</span><span class="cp"></span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; SAVE_DP &gt;------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	SAVE_DP message:</span>
<span class="cm">	**	Copy TEMP register to SAVEP in header.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">savep</span><span class="p">),</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESTORE_DP &gt;---------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	RESTORE_DP message:</span>
<span class="cm">	**	Copy SAVEP in header to TEMP register.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">savep</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">clrack</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; DISCONNECT &gt;---------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	DISCONNECTing  ...</span>
<span class="cm">	**</span>
<span class="cm">	**	disable the &quot;unexpected disconnect&quot; feature,</span>
<span class="cm">	**	and remove the ACK signal.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="o">|</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	Wait for the disconnect.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_WAIT_DISC</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	Status is: DISCONNECTED.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">HS_REG</span><span class="p">,</span> <span class="n">HS_DISCONNECT</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">cleanup_ok</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_OUT &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	The target requests a message.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_OUT</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">lastmsg</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	If it was no ABORT message ...</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">ABORT_TASK_SET</span><span class="p">)),</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">msg_out_abort</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	... wait for the next phase</span>
<span class="cm">	**	if it&#39;s a message out, send it again, ...</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">msg_out</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_OUT_DONE &gt;--------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	... else clear the message ...</span>
<span class="cm">	*/</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="n">NOP</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	... and process the next phase</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; IDLE &gt;------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Nothing to do?</span>
<span class="cm">	**	Wait for reselect.</span>
<span class="cm">	**	This NOP will be patched with LED OFF</span>
<span class="cm">	**	SCR_REG_REG (gpreg, SCR_OR, 0x01)</span>
<span class="cm">	*/</span>
	<span class="n">SCR_NO_OP</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESELECT &gt;--------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	make the DSA invalid.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_TRG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">HS_REG</span><span class="p">,</span> <span class="n">HS_IN_RESELECT</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	Sleep waiting for a reselection.</span>
<span class="cm">	**	If SIGP is set, special treatment.</span>
<span class="cm">	**</span>
<span class="cm">	**	Zu allem bereit ..</span>
<span class="cm">	*/</span>
	<span class="n">SCR_WAIT_RESEL</span><span class="p">,</span>
		<span class="n">PADDR</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESELECTED &gt;------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	This NOP will be patched with LED ON</span>
<span class="cm">	**	SCR_REG_REG (gpreg, SCR_AND, 0xfe)</span>
<span class="cm">	*/</span>
	<span class="n">SCR_NO_OP</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	... zu nichts zu gebrauchen ?</span>
<span class="cm">	**</span>
<span class="cm">	**      load the target id into the SFBR</span>
<span class="cm">	**	and jump to the control block.</span>
<span class="cm">	**</span>
<span class="cm">	**	Look at the declarations of</span>
<span class="cm">	**	- struct ncb</span>
<span class="cm">	**	- struct tcb</span>
<span class="cm">	**	- struct lcb</span>
<span class="cm">	**	- struct ccb</span>
<span class="cm">	**	to understand what&#39;s going on.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_REG_SFBR</span> <span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0x8F</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_TO_REG</span> <span class="p">(</span><span class="n">sdid</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">jump_tcb</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; RESEL_DSA &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Ack the IDENTIFY or TAG previously received.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**      The ncr doesn&#39;t have an indirect load</span>
<span class="cm">	**	or store command. So we have to</span>
<span class="cm">	**	copy part of the control block to a</span>
<span class="cm">	**	fixed place, where we can access it.</span>
<span class="cm">	**</span>
<span class="cm">	**	We patch the address part of a</span>
<span class="cm">	**	COPY command with the DSA-register.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY_F</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">dsa</span><span class="p">),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">loadpos1</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Flush script prefetch if required</span>
<span class="cm">	*/</span>
	<span class="n">PREFETCH_FLUSH</span>
	<span class="cm">/*</span>
<span class="cm">	**	then we do the actual copy.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">head</span><span class="p">)),</span>
	<span class="cm">/*</span>
<span class="cm">	**	continued after the next label ...</span>
<span class="cm">	*/</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; LOADPOS1 &gt;-------------------*/</span><span class="p">,{</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	The DSA contains the data structure address.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">prepare</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; RESEL_LUN &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	come back to this point</span>
<span class="cm">	**	to get an IDENTIFY message</span>
<span class="cm">	**	Wait for a msg_in phase.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">SIR_RESEL_NO_MSG_IN</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	message phase.</span>
<span class="cm">	**	Read the data directly from the BUS DATA lines.</span>
<span class="cm">	**	This helps to support very old SCSI devices that </span>
<span class="cm">	**	may reselect without sending an IDENTIFY.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">sbdl</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	It should be an Identify message.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESEL_TAG &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Read IDENTIFY + SIMPLE + TAG using a single MOVE.</span>
<span class="cm">	**	Aggressive optimization, is&#39;nt it?</span>
<span class="cm">	**	No need to test the SIMPLE TAG message, since the </span>
<span class="cm">	**	driver only supports conformant devices for tags. ;-)</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgin</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Read the TAG from the SIDL.</span>
<span class="cm">	**	Still an aggressive optimization. ;-)</span>
<span class="cm">	**	Compute the CCB indirect jump address which </span>
<span class="cm">	**	is (#TAG*2 &amp; 0xfc) due to tag numbering using </span>
<span class="cm">	**	1,3,5..MAXTAGS*2+1 actual values.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_REG_SFBR</span> <span class="p">(</span><span class="n">sidl</span><span class="p">,</span> <span class="n">SCR_SHL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_SFBR_REG</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0xfc</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; JUMP_TO_NEXUS &gt;-------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_COPY_F</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">nexus_indirect</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Flush script prefetch if required</span>
<span class="cm">	*/</span>
	<span class="n">PREFETCH_FLUSH</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; NEXUS_INDIRECT &gt;-------------------*/</span><span class="p">,{</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESEL_NOTAG &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	No tag expected.</span>
<span class="cm">	**	Read an throw away the IDENTIFY.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgin</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">jump_to_nexus</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATA_IN &gt;--------------------*/</span><span class="p">,{</span>
<span class="cm">/*</span>
<span class="cm">**	Because the size depends on the</span>
<span class="cm">**	#define MAX_SCATTERL parameter,</span>
<span class="cm">**	it is filled in at runtime.</span>
<span class="cm">**</span>
<span class="cm">**  ##===========&lt; i=0; i&lt;MAX_SCATTERL &gt;=========</span>
<span class="cm">**  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),</span>
<span class="cm">**  ||		PADDR (dispatch),</span>
<span class="cm">**  ||	SCR_MOVE_TBL ^ SCR_DATA_IN,</span>
<span class="cm">**  ||		offsetof (struct dsb, data[ i]),</span>
<span class="cm">**  ##==========================================</span>
<span class="cm">**</span>
<span class="cm">**---------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="mi">0</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATA_IN2 &gt;-------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_CALL</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">no_data</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATA_OUT &gt;--------------------*/</span><span class="p">,{</span>
<span class="cm">/*</span>
<span class="cm">**	Because the size depends on the</span>
<span class="cm">**	#define MAX_SCATTERL parameter,</span>
<span class="cm">**	it is filled in at runtime.</span>
<span class="cm">**</span>
<span class="cm">**  ##===========&lt; i=0; i&lt;MAX_SCATTERL &gt;=========</span>
<span class="cm">**  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)),</span>
<span class="cm">**  ||		PADDR (dispatch),</span>
<span class="cm">**  ||	SCR_MOVE_TBL ^ SCR_DATA_OUT,</span>
<span class="cm">**  ||		offsetof (struct dsb, data[ i]),</span>
<span class="cm">**  ##==========================================</span>
<span class="cm">**</span>
<span class="cm">**---------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="mi">0</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATA_OUT2 &gt;-------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_CALL</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">no_data</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*--------------------------------------------------------*/</span>
<span class="p">};</span>

<span class="k">static</span>	<span class="k">struct</span> <span class="n">scripth</span> <span class="n">scripth0</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/*-------------------------&lt; TRYLOOP &gt;---------------------*/</span><span class="p">{</span>
<span class="cm">/*</span>
<span class="cm">**	Start the next entry.</span>
<span class="cm">**	Called addresses point to the launch script in the CCB.</span>
<span class="cm">**	They are patched by the main processor.</span>
<span class="cm">**</span>
<span class="cm">**	Because the size depends on the</span>
<span class="cm">**	#define MAX_START parameter, it is filled</span>
<span class="cm">**	in at runtime.</span>
<span class="cm">**</span>
<span class="cm">**-----------------------------------------------------------</span>
<span class="cm">**</span>
<span class="cm">**  ##===========&lt; I=0; i&lt;MAX_START &gt;===========</span>
<span class="cm">**  ||	SCR_CALL,</span>
<span class="cm">**  ||		PADDR (idle),</span>
<span class="cm">**  ##==========================================</span>
<span class="cm">**</span>
<span class="cm">**-----------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="mi">0</span>
<span class="p">}</span><span class="cm">/*------------------------&lt; TRYLOOP2 &gt;---------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDRH</span><span class="p">(</span><span class="n">tryloop</span><span class="p">),</span>

<span class="cp">#ifdef SCSI_NCR_CCB_DONE_SUPPORT</span>

<span class="p">}</span><span class="cm">/*------------------------&lt; DONE_QUEUE &gt;-------------------*/</span><span class="p">,{</span>
<span class="cm">/*</span>
<span class="cm">**	Copy the CCB address to the next done entry.</span>
<span class="cm">**	Because the size depends on the</span>
<span class="cm">**	#define MAX_DONE parameter, it is filled</span>
<span class="cm">**	in at runtime.</span>
<span class="cm">**</span>
<span class="cm">**-----------------------------------------------------------</span>
<span class="cm">**</span>
<span class="cm">**  ##===========&lt; I=0; i&lt;MAX_DONE &gt;===========</span>
<span class="cm">**  ||	SCR_COPY (sizeof(struct ccb *),</span>
<span class="cm">**  ||		NADDR (header.cp),</span>
<span class="cm">**  ||		NADDR (ccb_done[i]),</span>
<span class="cm">**  ||	SCR_CALL,</span>
<span class="cm">**  ||		PADDR (done_end),</span>
<span class="cm">**  ##==========================================</span>
<span class="cm">**</span>
<span class="cm">**-----------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="mi">0</span>
<span class="p">}</span><span class="cm">/*------------------------&lt; DONE_QUEUE2 &gt;------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">done_queue</span><span class="p">),</span>

<span class="cp">#endif </span><span class="cm">/* SCSI_NCR_CCB_DONE_SUPPORT */</span><span class="cp"></span>
<span class="p">}</span><span class="cm">/*------------------------&lt; SELECT_NO_ATN &gt;-----------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Set Initiator mode.</span>
<span class="cm">	**      And try to select this target without ATN.</span>
<span class="cm">	*/</span>

	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_TRG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">HS_REG</span><span class="p">,</span> <span class="n">HS_SELECTING</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_SEL_TBL</span> <span class="o">^</span> <span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dsb</span><span class="p">,</span> <span class="n">select</span><span class="p">),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">reselect</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">select2</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; CANCEL &gt;------------------------*/</span><span class="p">,{</span>

	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="n">HS_ABORTED</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMPR</span><span class="p">,</span>
		<span class="mi">8</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SKIP &gt;------------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	This entry has been canceled.</span>
<span class="cm">	**	Next time use the next slot.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">startpos</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**      The ncr doesn&#39;t have an indirect load</span>
<span class="cm">	**	or store command. So we have to</span>
<span class="cm">	**	copy part of the control block to a</span>
<span class="cm">	**	fixed place, where we can access it.</span>
<span class="cm">	**</span>
<span class="cm">	**	We patch the address part of a</span>
<span class="cm">	**	COPY command with the DSA-register.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY_F</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">dsa</span><span class="p">),</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">skip2</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Flush script prefetch if required</span>
<span class="cm">	*/</span>
	<span class="n">PREFETCH_FLUSH</span>
	<span class="cm">/*</span>
<span class="cm">	**	then we do the actual copy.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">head</span><span class="p">)),</span>
	<span class="cm">/*</span>
<span class="cm">	**	continued after the next label ...</span>
<span class="cm">	*/</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SKIP2 &gt;---------------------*/</span><span class="p">,{</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**      Initialize the status registers</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">status</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">scr0</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Force host status.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">HS_DONEMASK</span><span class="p">)),</span>
		<span class="mi">16</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">HS_REG</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="n">HS_SKIPMASK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMPR</span><span class="p">,</span>
		<span class="mi">8</span><span class="p">,</span>
	<span class="n">SCR_TO_REG</span> <span class="p">(</span><span class="n">HS_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">SS_REG</span><span class="p">,</span> <span class="n">S_GOOD</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">cleanup_ok</span><span class="p">),</span>

<span class="p">},</span><span class="cm">/*-------------------------&lt; PAR_ERR_DATA_IN &gt;---------------*/</span><span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Ignore all data in byte, until next phase</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_DATA_IN</span><span class="p">)),</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">par_err_other</span><span class="p">),</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_DATA_IN</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span>
	<span class="n">SCR_JUMPR</span><span class="p">,</span>
		<span class="o">-</span><span class="mi">24</span><span class="p">,</span>
<span class="p">},</span><span class="cm">/*-------------------------&lt; PAR_ERR_OTHER &gt;------------------*/</span><span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	**	count it.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">PS_REG</span><span class="p">,</span> <span class="n">SCR_ADD</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	jump to dispatcher.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_REJECT &gt;---------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	If a negotiation was in progress,</span>
<span class="cm">	**	negotiation failed.</span>
<span class="cm">	**	Otherwise, let the C code print </span>
<span class="cm">	**	some message.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">HS_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">HS_NEGOTIATE</span><span class="p">)),</span>
		<span class="n">SIR_REJECT_RECEIVED</span><span class="p">,</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">HS_NEGOTIATE</span><span class="p">)),</span>
		<span class="n">SIR_NEGO_FAILED</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">clrack</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_IGN_RESIDUE &gt;----------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Terminate cycle</span>
<span class="cm">	*/</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	get residue size.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgin</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Size is 0 .. ignore message.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">clrack</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Size is not 1 .. have to interrupt.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
		<span class="mi">40</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	Check for residue byte in swide register</span>
<span class="cm">	*/</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">WSR</span><span class="p">,</span> <span class="n">WSR</span><span class="p">)),</span>
		<span class="mi">16</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	There IS data in the swide register.</span>
<span class="cm">	**	Discard it.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="n">WSR</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">clrack</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Load again the size to the sfbr register.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_IGN_RESIDUE</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">clrack</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_EXTENDED &gt;-------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Terminate cycle</span>
<span class="cm">	*/</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	get length.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgin</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
	<span class="cm">/*</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="mi">3</span><span class="p">)),</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">msg_ext_3</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">msg_bad</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_EXT_2 &gt;----------------*/</span><span class="p">,{</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	get extended message code.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgin</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">EXTENDED_WDTR</span><span class="p">)),</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">msg_wdtr</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	unknown extended message</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">msg_bad</span><span class="p">)</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_WDTR &gt;-----------------*/</span><span class="p">,{</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	get data bus width</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgin</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
	<span class="cm">/*</span>
<span class="cm">	**	let the host do the real work.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_NEGO_WIDE</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	let the target fetch our answer.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_SET</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">nego_bad_phase</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; SEND_WDTR &gt;----------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Send the EXTENDED_WDTR</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_OUT</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">lastmsg</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">msg_out_done</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_EXT_3 &gt;----------------*/</span><span class="p">,{</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	get extended message code.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgin</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">EXTENDED_SDTR</span><span class="p">)),</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">msg_sdtr</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	unknown extended message</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">msg_bad</span><span class="p">)</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_SDTR &gt;-----------------*/</span><span class="p">,{</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	get period and offset</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgin</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
	<span class="cm">/*</span>
<span class="cm">	**	let the host do the real work.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_NEGO_SYNC</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	let the target fetch our answer.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_SET</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">nego_bad_phase</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; SEND_SDTR &gt;-------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Send the EXTENDED_SDTR</span>
<span class="cm">	*/</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_OUT</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">lastmsg</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">msg_out_done</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; NEGO_BAD_PHASE &gt;------------*/</span><span class="p">,{</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_NEGO_PROTO</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_OUT_ABORT &gt;-------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	After ABORT message,</span>
<span class="cm">	**</span>
<span class="cm">	**	expect an immediate disconnect, ...</span>
<span class="cm">	*/</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="o">|</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_WAIT_DISC</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	... and set the status to &quot;ABORTED&quot;</span>
<span class="cm">	*/</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">HS_REG</span><span class="p">,</span> <span class="n">HS_ABORTED</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">cleanup</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; HDATA_IN &gt;-------------------*/</span><span class="p">,{</span>
<span class="cm">/*</span>
<span class="cm">**	Because the size depends on the</span>
<span class="cm">**	#define MAX_SCATTERH parameter,</span>
<span class="cm">**	it is filled in at runtime.</span>
<span class="cm">**</span>
<span class="cm">**  ##==&lt; i=MAX_SCATTERL; i&lt;MAX_SCATTERL+MAX_SCATTERH &gt;==</span>
<span class="cm">**  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),</span>
<span class="cm">**  ||		PADDR (dispatch),</span>
<span class="cm">**  ||	SCR_MOVE_TBL ^ SCR_DATA_IN,</span>
<span class="cm">**  ||		offsetof (struct dsb, data[ i]),</span>
<span class="cm">**  ##===================================================</span>
<span class="cm">**</span>
<span class="cm">**---------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="mi">0</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; HDATA_IN2 &gt;------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">data_in</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; HDATA_OUT &gt;-------------------*/</span><span class="p">,{</span>
<span class="cm">/*</span>
<span class="cm">**	Because the size depends on the</span>
<span class="cm">**	#define MAX_SCATTERH parameter,</span>
<span class="cm">**	it is filled in at runtime.</span>
<span class="cm">**</span>
<span class="cm">**  ##==&lt; i=MAX_SCATTERL; i&lt;MAX_SCATTERL+MAX_SCATTERH &gt;==</span>
<span class="cm">**  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)),</span>
<span class="cm">**  ||		PADDR (dispatch),</span>
<span class="cm">**  ||	SCR_MOVE_TBL ^ SCR_DATA_OUT,</span>
<span class="cm">**  ||		offsetof (struct dsb, data[ i]),</span>
<span class="cm">**  ##===================================================</span>
<span class="cm">**</span>
<span class="cm">**---------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="mi">0</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; HDATA_OUT2 &gt;------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">data_out</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; RESET &gt;----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**      Send a TARGET_RESET message if bad IDENTIFY </span>
<span class="cm">	**	received on reselection.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="n">ABORT_TASK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">abort_resel</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; ABORTTAG &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**      Abort a wrong tag received on reselection.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="n">ABORT_TASK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">abort_resel</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; ABORT &gt;----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**      Abort a reselection when no active CCB.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="n">ABORT_TASK_SET</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; ABORT_RESEL &gt;----------------*/</span><span class="p">,{</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
	<span class="n">SCR_SET</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	and send it.</span>
<span class="cm">	**	we expect an immediate disconnect</span>
<span class="cm">	*/</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_OUT</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">lastmsg</span><span class="p">),</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="o">|</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_WAIT_DISC</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESEND_IDENT &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	The target stays in MSG OUT phase after having acked </span>
<span class="cm">	**	Identify [+ Tag [+ Extended message ]]. Targets shall</span>
<span class="cm">	**	behave this way on parity error.</span>
<span class="cm">	**	We must send it again all the messages.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_SET</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span> <span class="cm">/* Shall be asserted 2 deskew delays before the  */</span>
		<span class="mi">0</span><span class="p">,</span>         <span class="cm">/* 1rst ACK = 90 ns. Hope the NCR is&#39;nt too fast */</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">send_ident</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; CLRATN_GO_ON &gt;-------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; NXTDSP_GO_ON &gt;-------------------*/</span><span class="p">,{</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SDATA_IN &gt;-------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_CALL</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_DATA_IN</span><span class="p">)),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="n">SCR_MOVE_TBL</span> <span class="o">^</span> <span class="n">SCR_DATA_IN</span><span class="p">,</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dsb</span><span class="p">,</span> <span class="n">sense</span><span class="p">),</span>
	<span class="n">SCR_CALL</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">no_data</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATA_IO &gt;--------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	We jump here if the data direction was unknown at the </span>
<span class="cm">	**	time we had to queue the command to the scripts processor.</span>
<span class="cm">	**	Pointers had been set as follow in this situation:</span>
<span class="cm">	**	  savep   --&gt;   DATA_IO</span>
<span class="cm">	**	  lastp   --&gt;   start pointer when DATA_IN</span>
<span class="cm">	**	  goalp   --&gt;   goal  pointer when DATA_IN</span>
<span class="cm">	**	  wlastp  --&gt;   start pointer when DATA_OUT</span>
<span class="cm">	**	  wgoalp  --&gt;   goal  pointer when DATA_OUT</span>
<span class="cm">	**	This script sets savep/lastp/goalp according to the </span>
<span class="cm">	**	direction chosen by the target.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_DATA_OUT</span><span class="p">)),</span>
		<span class="mi">32</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	Direction is DATA IN.</span>
<span class="cm">	**	Warning: we jump here, even when phase is DATA OUT.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">lastp</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">savep</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	**	Jump to the SCRIPTS according to actual direction.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">savep</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	**	Direction is DATA OUT.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">wlastp</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">lastp</span><span class="p">),</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">wgoalp</span><span class="p">),</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">goalp</span><span class="p">),</span>
	<span class="n">SCR_JUMPR</span><span class="p">,</span>
		<span class="o">-</span><span class="mi">64</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; BAD_IDENTIFY &gt;---------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	If message phase but not an IDENTIFY,</span>
<span class="cm">	**	get some help from the C code.</span>
<span class="cm">	**	Old SCSI device may behave so.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">)),</span>
		<span class="mi">16</span><span class="p">,</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_RESEL_NO_IDENTIFY</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">reset</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Message is an IDENTIFY, but lun is unknown.</span>
<span class="cm">	**	Read the message, since we got it directly </span>
<span class="cm">	**	from the SCSI BUS data lines.</span>
<span class="cm">	**	Signal problem to C code for logging the event.</span>
<span class="cm">	**	Send an ABORT_TASK_SET to clear all pending tasks.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_RESEL_BAD_LUN</span><span class="p">,</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgin</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">abort</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; BAD_I_T_L &gt;------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	We donnot have a task for that I_T_L.</span>
<span class="cm">	**	Signal problem to C code for logging the event.</span>
<span class="cm">	**	Send an ABORT_TASK_SET message.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_RESEL_BAD_I_T_L</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">abort</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; BAD_I_T_L_Q &gt;----------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	We donnot have a task that matches the tag.</span>
<span class="cm">	**	Signal problem to C code for logging the event.</span>
<span class="cm">	**	Send an ABORT_TASK message.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_RESEL_BAD_I_T_L_Q</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">aborttag</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; BAD_TARGET &gt;-----------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	We donnot know the target that reselected us.</span>
<span class="cm">	**	Grab the first message if any (IDENTIFY).</span>
<span class="cm">	**	Signal problem to C code for logging the event.</span>
<span class="cm">	**	TARGET_RESET message.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_RESEL_BAD_TARGET</span><span class="p">,</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="mi">8</span><span class="p">,</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">NADDR</span> <span class="p">(</span><span class="n">msgin</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">reset</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; BAD_STATUS &gt;-----------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	If command resulted in either QUEUE FULL,</span>
<span class="cm">	**	CHECK CONDITION or COMMAND TERMINATED,</span>
<span class="cm">	**	call the C code.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">S_QUEUE_FULL</span><span class="p">)),</span>
		<span class="n">SIR_BAD_STATUS</span><span class="p">,</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">S_CHECK_COND</span><span class="p">)),</span>
		<span class="n">SIR_BAD_STATUS</span><span class="p">,</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">S_TERMINATED</span><span class="p">)),</span>
		<span class="n">SIR_BAD_STATUS</span><span class="p">,</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; START_RAM &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Load the script into on-chip RAM, </span>
<span class="cm">	**	and jump to start point.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY_F</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">),</span>
		<span class="n">PADDRH</span> <span class="p">(</span><span class="n">start_ram0</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Flush script prefetch if required</span>
<span class="cm">	*/</span>
	<span class="n">PREFETCH_FLUSH</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">script</span><span class="p">)),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; START_RAM0 &gt;--------------------*/</span><span class="p">,{</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; STO_RESTART &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**</span>
<span class="cm">	**	Repair start queue (e.g. next time use the next slot) </span>
<span class="cm">	**	and jump to start point.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">startpos</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; WAIT_DMA &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	For HP Zalon/53c720 systems, the Zalon interface</span>
<span class="cm">	**	between CPU and 53c720 does prefetches, which causes</span>
<span class="cm">	**	problems with self modifying scripts.  The problem</span>
<span class="cm">	**	is overcome by calling a dummy subroutine after each</span>
<span class="cm">	**	modification, to force a refetch of the script on</span>
<span class="cm">	**	return from the subroutine.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SNOOPTEST &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	Read the variable.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">NADDR</span><span class="p">(</span><span class="n">ncr_cache</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Write the variable.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span>
		<span class="n">NADDR</span><span class="p">(</span><span class="n">ncr_cache</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	**	Read back the variable.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_COPY</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">NADDR</span><span class="p">(</span><span class="n">ncr_cache</span><span class="p">),</span>
		<span class="n">RADDR</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SNOOPEND &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	**	And stop.</span>
<span class="cm">	*/</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="mi">99</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*--------------------------------------------------------*/</span>
<span class="p">};</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	Fill in #define dependent parts of the script</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">ncr_script_fill</span> <span class="p">(</span><span class="k">struct</span> <span class="n">script</span> <span class="o">*</span> <span class="n">scr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scripth</span> <span class="o">*</span> <span class="n">scrh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>
	<span class="n">ncrcmd</span>	<span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">scrh</span><span class="o">-&gt;</span><span class="n">tryloop</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_START</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">SCR_CALL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">PADDR</span> <span class="p">(</span><span class="n">idle</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">u_long</span><span class="p">)</span><span class="n">p</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">scrh</span><span class="o">-&gt;</span><span class="n">tryloop</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">scrh</span><span class="o">-&gt;</span><span class="n">tryloop</span><span class="p">));</span>

<span class="cp">#ifdef SCSI_NCR_CCB_DONE_SUPPORT</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">scrh</span><span class="o">-&gt;</span><span class="n">done_queue</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_DONE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">SCR_COPY</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="p">));</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">NADDR</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">cp</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">NADDR</span> <span class="p">(</span><span class="n">ccb_done</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">SCR_CALL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">PADDR</span> <span class="p">(</span><span class="n">done_end</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">u_long</span><span class="p">)</span><span class="n">p</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">scrh</span><span class="o">-&gt;</span><span class="n">done_queue</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">scrh</span><span class="o">-&gt;</span><span class="n">done_queue</span><span class="p">));</span>

<span class="cp">#endif </span><span class="cm">/* SCSI_NCR_CCB_DONE_SUPPORT */</span><span class="cp"></span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">scrh</span><span class="o">-&gt;</span><span class="n">hdata_in</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_SCATTERH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">SCR_CALL</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_DATA_IN</span><span class="p">));</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">SCR_MOVE_TBL</span> <span class="o">^</span> <span class="n">SCR_DATA_IN</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dsb</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">u_long</span><span class="p">)</span><span class="n">p</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">scrh</span><span class="o">-&gt;</span><span class="n">hdata_in</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">scrh</span><span class="o">-&gt;</span><span class="n">hdata_in</span><span class="p">));</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">scr</span><span class="o">-&gt;</span><span class="n">data_in</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">MAX_SCATTERH</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_SCATTERH</span><span class="o">+</span><span class="n">MAX_SCATTERL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">SCR_CALL</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_DATA_IN</span><span class="p">));</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">SCR_MOVE_TBL</span> <span class="o">^</span> <span class="n">SCR_DATA_IN</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dsb</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">u_long</span><span class="p">)</span><span class="n">p</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">scr</span><span class="o">-&gt;</span><span class="n">data_in</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">scr</span><span class="o">-&gt;</span><span class="n">data_in</span><span class="p">));</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">scrh</span><span class="o">-&gt;</span><span class="n">hdata_out</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_SCATTERH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">SCR_CALL</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_DATA_OUT</span><span class="p">));</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">SCR_MOVE_TBL</span> <span class="o">^</span> <span class="n">SCR_DATA_OUT</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dsb</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">u_long</span><span class="p">)</span><span class="n">p</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">scrh</span><span class="o">-&gt;</span><span class="n">hdata_out</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">scrh</span><span class="o">-&gt;</span><span class="n">hdata_out</span><span class="p">));</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">scr</span><span class="o">-&gt;</span><span class="n">data_out</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">MAX_SCATTERH</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_SCATTERH</span><span class="o">+</span><span class="n">MAX_SCATTERL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">SCR_CALL</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_DATA_OUT</span><span class="p">));</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">PADDR</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">SCR_MOVE_TBL</span> <span class="o">^</span> <span class="n">SCR_DATA_OUT</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span><span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dsb</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">u_long</span><span class="p">)</span> <span class="n">p</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">scr</span><span class="o">-&gt;</span><span class="n">data_out</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">scr</span><span class="o">-&gt;</span><span class="n">data_out</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	Copy and rebind a script.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> 
<span class="nf">ncr_script_copy_and_bind</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">ncrcmd</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">ncrcmd</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ncrcmd</span>  <span class="n">opcode</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">;</span>
	<span class="n">ncrcmd</span>	<span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">relocs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">opchanged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">src</span> <span class="o">+</span> <span class="n">len</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">src</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">opcode</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">opcode</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		**	If we forget to change the length</span>
<span class="cm">		**	in struct script, a field will be</span>
<span class="cm">		**	padded with 0. This is an illegal</span>
<span class="cm">		**	command.</span>
<span class="cm">		*/</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: ERROR0 IN SCRIPT at %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">src</span><span class="o">-</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_SCRIPT</span><span class="p">)</span>
			<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%p:  &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">src</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">opcode</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		**	We don&#39;t have to decode ALL commands</span>
<span class="cm">		*/</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="mh">0xc</span>:
			<span class="cm">/*</span>
<span class="cm">			**	COPY has TWO arguments.</span>
<span class="cm">			*/</span>
			<span class="n">relocs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">tmp1</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="cp">#ifdef	RELOC_KVAR</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">tmp1</span> <span class="o">&amp;</span> <span class="n">RELOC_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">RELOC_KVAR</span><span class="p">)</span>
				<span class="n">tmp1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="n">tmp2</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="cp">#ifdef	RELOC_KVAR</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">tmp2</span> <span class="o">&amp;</span> <span class="n">RELOC_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">RELOC_KVAR</span><span class="p">)</span>
				<span class="n">tmp2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">tmp1</span> <span class="o">^</span> <span class="n">tmp2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span><span class="s">&quot;%s: ERROR1 IN SCRIPT at %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">src</span><span class="o">-</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
				<span class="n">mdelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			**	If PREFETCH feature not enabled, remove </span>
<span class="cm">			**	the NO FLUSH bit if present.</span>
<span class="cm">			*/</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">SCR_NO_FLUSH</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_PFEN</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dst</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SCR_NO_FLUSH</span><span class="p">);</span>
				<span class="o">++</span><span class="n">opchanged</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x0</span>:
			<span class="cm">/*</span>
<span class="cm">			**	MOVE (absolute address)</span>
<span class="cm">			*/</span>
			<span class="n">relocs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x8</span>:
			<span class="cm">/*</span>
<span class="cm">			**	JUMP / CALL</span>
<span class="cm">			**	don&#39;t relocate if relative :-)</span>
<span class="cm">			*/</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="mh">0x00800000</span><span class="p">)</span>
				<span class="n">relocs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">relocs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x4</span>:
		<span class="k">case</span> <span class="mh">0x5</span>:
		<span class="k">case</span> <span class="mh">0x6</span>:
		<span class="k">case</span> <span class="mh">0x7</span>:
			<span class="n">relocs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">relocs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">relocs</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">relocs</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">;</span>

				<span class="k">switch</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">RELOC_MASK</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">RELOC_REGISTER</span>:
					<span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RELOC_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">RELOC_LABEL</span>:
					<span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RELOC_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">p_script</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">RELOC_LABELH</span>:
					<span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RELOC_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">p_scripth</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">RELOC_SOFTC</span>:
					<span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RELOC_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">p_ncb</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef	RELOC_KVAR</span>
				<span class="k">case</span> <span class="n">RELOC_KVAR</span>:
					<span class="k">if</span> <span class="p">(((</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RELOC_MASK</span><span class="p">)</span> <span class="o">&lt;</span>
					     <span class="n">SCRIPT_KVAR_FIRST</span><span class="p">)</span> <span class="o">||</span>
					    <span class="p">((</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RELOC_MASK</span><span class="p">)</span> <span class="o">&gt;</span>
					     <span class="n">SCRIPT_KVAR_LAST</span><span class="p">))</span>
						<span class="n">panic</span><span class="p">(</span><span class="s">&quot;ncr KVAR out of range&quot;</span><span class="p">);</span>
					<span class="n">new</span> <span class="o">=</span> <span class="n">vtophys</span><span class="p">(</span><span class="n">script_kvars</span><span class="p">[</span><span class="n">old</span> <span class="o">&amp;</span>
					    <span class="o">~</span><span class="n">RELOC_MASK</span><span class="p">]);</span>
					<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
				<span class="k">case</span> <span class="mi">0</span>:
					<span class="cm">/* Don&#39;t relocate a 0 address. */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">new</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="cm">/* fall through */</span>
				<span class="nl">default:</span>
					<span class="n">panic</span><span class="p">(</span><span class="s">&quot;ncr_script_copy_and_bind: weird relocation %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">);</span>

	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">**	Linux host data structure</span>
<span class="cm">*/</span>

<span class="k">struct</span> <span class="n">host_data</span> <span class="p">{</span>
     <span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">ncb</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define PRINT_ADDR(cmd, arg...) dev_info(&amp;cmd-&gt;device-&gt;sdev_gendev , ## arg)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_print_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;%s: &quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">);</span>

	<span class="n">spi_print_msg</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	NCR chip clock divisor table.</span>
<span class="cm">**	Divisors are multiplied by 10,000,000 in order to make </span>
<span class="cm">**	calculations more simple.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="cp">#define _5M 5000000</span>
<span class="k">static</span> <span class="n">u_long</span> <span class="n">div_10M</span><span class="p">[]</span> <span class="o">=</span>
	<span class="p">{</span><span class="mi">2</span><span class="o">*</span><span class="n">_5M</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">_5M</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">_5M</span><span class="p">,</span> <span class="mi">6</span><span class="o">*</span><span class="n">_5M</span><span class="p">,</span> <span class="mi">8</span><span class="o">*</span><span class="n">_5M</span><span class="p">,</span> <span class="mi">12</span><span class="o">*</span><span class="n">_5M</span><span class="p">,</span> <span class="mi">16</span><span class="o">*</span><span class="n">_5M</span><span class="p">};</span>


<span class="cm">/*===============================================================</span>
<span class="cm">**</span>
<span class="cm">**	Prepare io register values used by ncr_init() according </span>
<span class="cm">**	to selected and supported features.</span>
<span class="cm">**</span>
<span class="cm">**	NCR chips allow burst lengths of 2, 4, 8, 16, 32, 64, 128 </span>
<span class="cm">**	transfers. 32,64,128 are only supported by 875 and 895 chips.</span>
<span class="cm">**	We use log base 2 (burst length) as internal code, with </span>
<span class="cm">**	value 0 meaning &quot;burst disabled&quot;.</span>
<span class="cm">**</span>
<span class="cm">**===============================================================</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm"> *	Burst length from burst code.</span>
<span class="cm"> */</span>
<span class="cp">#define burst_length(bc) (!(bc))? 0 : 1 &lt;&lt; (bc)</span>

<span class="cm">/*</span>
<span class="cm"> *	Burst code from io register bits.  Burst enable is ctest0 for c720</span>
<span class="cm"> */</span>
<span class="cp">#define burst_code(dmode, ctest0) \</span>
<span class="cp">	(ctest0) &amp; 0x80 ? 0 : (((dmode) &amp; 0xc0) &gt;&gt; 6) + 1</span>

<span class="cm">/*</span>
<span class="cm"> *	Set initial io register bits from burst code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ncr_init_burst</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">bc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span> <span class="o">*</span><span class="n">be</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">be</span>		<span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x80</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest5</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bc</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">be</span>		<span class="o">|=</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">--</span><span class="n">bc</span><span class="p">;</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span>	<span class="o">|=</span> <span class="p">((</span><span class="n">bc</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest5</span>	<span class="o">|=</span> <span class="p">(</span><span class="n">bc</span> <span class="o">&amp;</span> <span class="mh">0x4</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">ncr_prepare_setting</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span>	<span class="n">burst_max</span><span class="p">;</span>
	<span class="n">u_long</span>	<span class="n">period</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Save assumed BIOS setting</span>
<span class="cm">	*/</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_scntl0</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">nc_scntl0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0a</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_scntl3</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">nc_scntl3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dmode</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">nc_dmode</span><span class="p">)</span>  <span class="o">&amp;</span> <span class="mh">0xce</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dcntl</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">nc_dcntl</span><span class="p">)</span>  <span class="o">&amp;</span> <span class="mh">0xa8</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest0</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">nc_ctest0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x84</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest3</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">nc_ctest3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest4</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">nc_ctest4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest5</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">nc_ctest5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x24</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_gpcntl</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">nc_gpcntl</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_stest2</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">nc_stest2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_stest4</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">nc_stest4</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Wide ?</span>
<span class="cm">	*/</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span>	<span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_WIDE</span><span class="p">)</span><span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

 	<span class="cm">/*</span>
<span class="cm">	 *  Guess the frequency of the chip&#39;s clock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_ULTRA</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span> <span class="o">=</span> <span class="mi">80000</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span> <span class="o">=</span> <span class="mi">40000</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get the clock multiplier factor.</span>
<span class="cm"> 	 */</span>
	<span class="k">if</span>	<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_QUAD</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_DBLR</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Measure SCSI clock frequency for chips </span>
<span class="cm">	 *  it may vary from assumed one.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_VARCLK</span><span class="p">)</span>
		<span class="n">ncr_getclock</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Divisor to be used for async (timer pre-scaler).</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_divn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">10ul</span> <span class="o">*</span> <span class="n">SCSI_NCR_MIN_ASYNC</span> <span class="o">*</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span> <span class="o">&gt;</span> <span class="n">div_10M</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="o">++</span><span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl3</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Minimum synchronous period factor supported by the chip.</span>
<span class="cm">	 * Btw, &#39;period&#39; is in tenths of nanoseconds.</span>
<span class="cm">	 */</span>

	<span class="n">period</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">div_10M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span><span class="p">;</span>
	<span class="k">if</span>	<span class="p">(</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="mi">250</span><span class="p">)</span>		<span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="mi">303</span><span class="p">)</span>		<span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="mi">500</span><span class="p">)</span>		<span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="k">else</span>				<span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">=</span> <span class="p">(</span><span class="n">period</span> <span class="o">+</span> <span class="mi">40</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">40</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check against chip SCSI standard support (SCSI-2,ULTRA,ULTRA2).</span>
<span class="cm">	 */</span>

	<span class="k">if</span>	<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">&lt;</span> <span class="mi">25</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_ULTRA</span><span class="p">))</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Maximum synchronous period factor supported by the chip.</span>
<span class="cm">	 */</span>

	<span class="n">period</span> <span class="o">=</span> <span class="p">(</span><span class="mi">11</span> <span class="o">*</span> <span class="n">div_10M</span><span class="p">[</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_divn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">maxsync</span> <span class="o">=</span> <span class="n">period</span> <span class="o">&gt;</span> <span class="mi">2540</span> <span class="o">?</span> <span class="mi">254</span> <span class="o">:</span> <span class="n">period</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Prepare initial value of other IO registers</span>
<span class="cm">	*/</span>
<span class="cp">#if defined SCSI_NCR_TRUST_BIOS_SETTING</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl0</span>	<span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_scntl0</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span>	<span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dmode</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span>	<span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dcntl</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest0</span>	<span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest0</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest3</span>	<span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest3</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest4</span>	<span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest4</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest5</span>	<span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest5</span><span class="p">;</span>
	<span class="n">burst_max</span>	<span class="o">=</span> <span class="n">burst_code</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dmode</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest0</span><span class="p">);</span>
<span class="cp">#else</span>

	<span class="cm">/*</span>
<span class="cm">	**	Select burst length (dwords)</span>
<span class="cm">	*/</span>
	<span class="n">burst_max</span>	<span class="o">=</span> <span class="n">driver_setup</span><span class="p">.</span><span class="n">burst_max</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">burst_max</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span>
		<span class="n">burst_max</span> <span class="o">=</span> <span class="n">burst_code</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dmode</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">burst_max</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span>
		<span class="n">burst_max</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">burst_max</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxburst</span><span class="p">)</span>
		<span class="n">burst_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxburst</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Select all supported special features</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_ERL</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span>	<span class="o">|=</span> <span class="n">ERL</span><span class="p">;</span>		<span class="cm">/* Enable Read Line */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_BOF</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span>	<span class="o">|=</span> <span class="n">BOF</span><span class="p">;</span>		<span class="cm">/* Burst Opcode Fetch */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_ERMP</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span>	<span class="o">|=</span> <span class="n">ERMP</span><span class="p">;</span>	<span class="cm">/* Enable Read Multiple */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_PFEN</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span>	<span class="o">|=</span> <span class="n">PFEN</span><span class="p">;</span>	<span class="cm">/* Prefetch Enable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_CLSE</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span>	<span class="o">|=</span> <span class="n">CLSE</span><span class="p">;</span>	<span class="cm">/* Cache Line Size Enable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_WRIE</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest3</span>	<span class="o">|=</span> <span class="n">WRIE</span><span class="p">;</span>	<span class="cm">/* Write and Invalidate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_DFS</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest5</span>	<span class="o">|=</span> <span class="n">DFS</span><span class="p">;</span>		<span class="cm">/* Dma Fifo Size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_MUX</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest4</span>	<span class="o">|=</span> <span class="n">MUX</span><span class="p">;</span>		<span class="cm">/* Host bus multiplex mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_EA</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span>	<span class="o">|=</span> <span class="n">EA</span><span class="p">;</span>		<span class="cm">/* Enable ACK */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_EHP</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest0</span>	<span class="o">|=</span> <span class="n">EHP</span><span class="p">;</span>		<span class="cm">/* Even host parity */</span>

	<span class="cm">/*</span>
<span class="cm">	**	Select some other</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver_setup</span><span class="p">.</span><span class="n">master_parity</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest4</span>	<span class="o">|=</span> <span class="n">MPEE</span><span class="p">;</span>	<span class="cm">/* Master parity checking */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver_setup</span><span class="p">.</span><span class="n">scsi_parity</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl0</span>	<span class="o">|=</span> <span class="mh">0x0a</span><span class="p">;</span>	<span class="cm">/*  full arb., ena parity, par-&gt;ATN  */</span>

	<span class="cm">/*</span>
<span class="cm">	**  Get SCSI addr of host adapter (set by bios?).</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">nc_scid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span><span class="p">)</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span> <span class="o">=</span> <span class="n">SCSI_NCR_MYADDR</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* SCSI_NCR_TRUST_BIOS_SETTING */</span><span class="cp"></span>

	<span class="cm">/*</span>
<span class="cm">	 *	Prepare initial io register bits for burst length</span>
<span class="cm">	 */</span>
	<span class="n">ncr_init_burst</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">burst_max</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Set SCSI BUS mode.</span>
<span class="cm">	**</span>
<span class="cm">	**	- ULTRA2 chips (895/895A/896) report the current </span>
<span class="cm">	**	  BUS mode through the STEST4 IO register.</span>
<span class="cm">	**	- For previous generation chips (825/825A/875), </span>
<span class="cm">	**	  user has to tell us how to check against HVD, </span>
<span class="cm">	**	  since a 100% safe algorithm is not possible.</span>
<span class="cm">	*/</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">=</span> <span class="n">SMODE_SE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_DIFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">driver_setup</span><span class="p">.</span><span class="n">diff_support</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">4</span>:	<span class="cm">/* Trust previous settings if present, then GPIO3 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_scntl3</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_stest2</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span>
					<span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">=</span> <span class="n">SMODE_HVD</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="mi">3</span>:	<span class="cm">/* SYMBIOS controllers report HVD through GPIO3 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">nc_gpreg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x08</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:	<span class="cm">/* Set HVD unconditionally */</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">=</span> <span class="n">SMODE_HVD</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:	<span class="cm">/* Trust previous settings for HVD */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_stest2</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span>
				<span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">=</span> <span class="n">SMODE_HVD</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span><span class="cm">/* Don&#39;t care about HVD */</span>	
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">==</span> <span class="n">SMODE_HVD</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_stest2</span> <span class="o">|=</span> <span class="mh">0x20</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Set LED support from SCRIPTS.</span>
<span class="cm">	**	Ignore this feature for boards known to use a </span>
<span class="cm">	**	specific GPIO wiring and for the 895A or 896 </span>
<span class="cm">	**	that drive the LED directly.</span>
<span class="cm">	**	Also probe initial setting of GPIO0 as output.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">driver_setup</span><span class="p">.</span><span class="n">led_pin</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_LEDC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_gpcntl</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">))</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">FE_LED0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Set irq mode.</span>
<span class="cm">	*/</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">driver_setup</span><span class="p">.</span><span class="n">irqm</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span>	<span class="o">|=</span> <span class="n">IRQM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span>	<span class="o">|=</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dcntl</span> <span class="o">&amp;</span> <span class="n">IRQM</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Configure targets according to driver setup.</span>
<span class="cm">	**	Allow to override sync, wide and NOSCAN from </span>
<span class="cm">	**	boot command line.</span>
<span class="cm">	*/</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_TARGET</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrsync</span> <span class="o">=</span> <span class="n">driver_setup</span><span class="p">.</span><span class="n">default_sync</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrwide</span> <span class="o">=</span> <span class="n">driver_setup</span><span class="p">.</span><span class="n">max_wide</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrtags</span> <span class="o">=</span> <span class="n">MAX_TAGS</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver_setup</span><span class="p">.</span><span class="n">disconnection</span><span class="p">)</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">usrflag</span> <span class="o">=</span> <span class="n">UF_NODISC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Announce all that stuff to user.</span>
<span class="cm">	*/</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: ID %d, Fast-%d%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span><span class="p">,</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">&lt;</span> <span class="mi">12</span> <span class="o">?</span> <span class="mi">40</span> <span class="o">:</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">&lt;</span> <span class="mi">25</span> <span class="o">?</span> <span class="mi">20</span> <span class="o">:</span> <span class="mi">10</span><span class="p">),</span>
		<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl0</span> <span class="o">&amp;</span> <span class="mh">0xa</span><span class="p">)</span>	<span class="o">?</span> <span class="s">&quot;, Parity Checking&quot;</span>	<span class="o">:</span> <span class="s">&quot;, NO Parity&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_stest2</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span>	<span class="o">?</span> <span class="s">&quot;, Differential&quot;</span>	<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: initial SCNTL3/DMODE/DCNTL/CTEST3/4/5 = &quot;</span>
			<span class="s">&quot;(hex) %02x/%02x/%02x/%02x/%02x/%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_scntl3</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dmode</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dcntl</span><span class="p">,</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest3</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest4</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest5</span><span class="p">);</span>

		<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: final   SCNTL3/DMODE/DCNTL/CTEST3/4/5 = &quot;</span>
			<span class="s">&quot;(hex) %02x/%02x/%02x/%02x/%02x/%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl3</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span><span class="p">,</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest3</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest4</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest5</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span> <span class="o">&amp;&amp;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">paddr2</span><span class="p">)</span>
		<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: on-chip RAM at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">paddr2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	Done SCSI commands list management.</span>
<span class="cm">**</span>
<span class="cm">**	We donnot enter the scsi_done() callback immediately </span>
<span class="cm">**	after a command has been seen as completed but we </span>
<span class="cm">**	insert it into a list which is flushed outside any kind </span>
<span class="cm">**	of driver critical section.</span>
<span class="cm">**	This allows to do minimal stuff under interrupt and </span>
<span class="cm">**	inside critical sections and to also avoid locking up </span>
<span class="cm">**	on recursive calls to driver entry points under SMP.</span>
<span class="cm">**	In fact, the only kernel point which is entered by the </span>
<span class="cm">**	driver with a driver lock set is kmalloc(GFP_ATOMIC) </span>
<span class="cm">**	that shall not reenter the driver under any circumstances,</span>
<span class="cm">**	AFAIK.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ncr_queue_done_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unmap_scsi_data</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">done_list</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ncr_flush_done_cmds</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">lcmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">lcmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">lcmd</span><span class="p">;</span>
		<span class="n">lcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	Prepare the next negotiation message if needed.</span>
<span class="cm">**</span>
<span class="cm">**	Fill in the part of message buffer that contains the </span>
<span class="cm">**	negotiation and the nego_status field of the CCB.</span>
<span class="cm">**	Returns the size of the message in bytes.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">ncr_prepare_nego</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">msgptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">msglen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nego</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="p">;</span>

	<span class="cm">/* negotiate wide transfers ?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">widedone</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spi_support_wide</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">nego</span> <span class="o">=</span> <span class="n">NS_WIDE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">widedone</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* negotiate synchronous transfers?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nego</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spi_support_sync</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">nego</span> <span class="o">=</span> <span class="n">NS_SYNC</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span>  <span class="o">=</span><span class="mh">0xffff</span><span class="p">;</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;target did not report SYNC.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">nego</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NS_SYNC</span>:
		<span class="n">msglen</span> <span class="o">+=</span> <span class="n">spi_populate_sync_msg</span><span class="p">(</span><span class="n">msgptr</span> <span class="o">+</span> <span class="n">msglen</span><span class="p">,</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">maxoffs</span> <span class="o">?</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NS_WIDE</span>:
		<span class="n">msglen</span> <span class="o">+=</span> <span class="n">spi_populate_width_msg</span><span class="p">(</span><span class="n">msgptr</span> <span class="o">+</span> <span class="n">msglen</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrwide</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">=</span> <span class="n">nego</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nego</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">nego_cp</span> <span class="o">=</span> <span class="n">cp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ncr_print_msg</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">nego</span> <span class="o">==</span> <span class="n">NS_WIDE</span> <span class="o">?</span>
					  <span class="s">&quot;wide msgout&quot;</span><span class="o">:</span><span class="s">&quot;sync_msgout&quot;</span><span class="p">,</span> <span class="n">msgptr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">msglen</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	Start execution of a SCSI command.</span>
<span class="cm">**	This is called from the generic SCSI driver.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ncr_queue_command</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="kt">int</span>	<span class="n">segments</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">idmsg</span><span class="p">,</span> <span class="o">*</span><span class="n">msgptr</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">msglen</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">direction</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">lastp</span><span class="p">,</span> <span class="n">goalp</span><span class="p">;</span>

	<span class="cm">/*---------------------------------------------</span>
<span class="cm">	**</span>
<span class="cm">	**      Some shortcuts ...</span>
<span class="cm">	**</span>
<span class="cm">	**---------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span>	  <span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">MAX_TARGET</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span>    <span class="o">&gt;=</span> <span class="n">MAX_LUN</span>   <span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">(</span><span class="n">DID_BAD_TARGET</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*---------------------------------------------</span>
<span class="cm">	**</span>
<span class="cm">	**	Complete the 1st TEST UNIT READY command</span>
<span class="cm">	**	with error condition if the device is </span>
<span class="cm">	**	flagged NOSCAN, in order to speed up </span>
<span class="cm">	**	the boot.</span>
<span class="cm">	**</span>
<span class="cm">	**---------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x12</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
	    <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrflag</span> <span class="o">&amp;</span> <span class="n">UF_NOSCAN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrflag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UF_NOSCAN</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">DID_BAD_TARGET</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;CMD=%x &quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/*---------------------------------------------------</span>
<span class="cm">	**</span>
<span class="cm">	**	Assign a ccb / bind cmd.</span>
<span class="cm">	**	If resetting, shorten settle_time if necessary</span>
<span class="cm">	**	in order to avoid spurious timeouts.</span>
<span class="cm">	**	If resetting or no free ccb,</span>
<span class="cm">	**	insert cmd into the waiting list.</span>
<span class="cm">	**</span>
<span class="cm">	**----------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">settle_time</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">&gt;=</span> <span class="n">HZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_long</span> <span class="n">tlimit</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">-</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">settle_time</span><span class="p">,</span> <span class="n">tlimit</span><span class="p">))</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">settle_time</span> <span class="o">=</span> <span class="n">tlimit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">settle_time</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">cp</span><span class="o">=</span><span class="n">ncr_get_ccb</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">insert_into_waiting_list</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="n">DID_OK</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------</span>
<span class="cm">	**</span>
<span class="cm">	**	Build the identify / tag / sdtr message</span>
<span class="cm">	**</span>
<span class="cm">	**----------------------------------------------------</span>
<span class="cm">	*/</span>

	<span class="n">idmsg</span> <span class="o">=</span> <span class="n">IDENTIFY</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">-&gt;</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">NO_TAG</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">cp</span> <span class="o">!=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span> <span class="o">&amp;&amp;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">disc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrflag</span> <span class="o">&amp;</span> <span class="n">UF_NODISC</span><span class="p">)))</span>
		<span class="n">idmsg</span> <span class="o">|=</span> <span class="mh">0x40</span><span class="p">;</span>

	<span class="n">msgptr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_smsg</span><span class="p">;</span>
	<span class="n">msglen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msgptr</span><span class="p">[</span><span class="n">msglen</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">idmsg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">NO_TAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		**	Force ordered tag if necessary to avoid timeouts </span>
<span class="cm">		**	and to preserve interactivity.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span> <span class="o">&amp;&amp;</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_stime</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_smap</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">order</span> <span class="o">=</span> <span class="n">ORDERED_QUEUE_TAG</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TAGS</span><span class="p">)</span><span class="o">||</span><span class="n">bootverbose</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">){</span> 
					<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span>
						<span class="s">&quot;ordered tag forced.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_stime</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">HZ</span><span class="p">;</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_smap</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_umap</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			**	Ordered write ops, unordered read ops.</span>
<span class="cm">			*/</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x08</span>:  <span class="cm">/* READ_SMALL (6) */</span>
			<span class="k">case</span> <span class="mh">0x28</span>:  <span class="cm">/* READ_BIG  (10) */</span>
			<span class="k">case</span> <span class="mh">0xa8</span>:  <span class="cm">/* READ_HUGE (12) */</span>
				<span class="n">order</span> <span class="o">=</span> <span class="n">SIMPLE_QUEUE_TAG</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">order</span> <span class="o">=</span> <span class="n">ORDERED_QUEUE_TAG</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">msgptr</span><span class="p">[</span><span class="n">msglen</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		**	Actual tags are numbered 1,3,5,..2*MAXTAGS+1,</span>
<span class="cm">		**	since we may have to deal with devices that have </span>
<span class="cm">		**	problems with #TAG 0 or too great #TAG numbers.</span>
<span class="cm">		*/</span>
		<span class="n">msgptr</span><span class="p">[</span><span class="n">msglen</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*----------------------------------------------------</span>
<span class="cm">	**</span>
<span class="cm">	**	Build the data descriptors</span>
<span class="cm">	**</span>
<span class="cm">	**----------------------------------------------------</span>
<span class="cm">	*/</span>

	<span class="n">direction</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">!=</span> <span class="n">DMA_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">segments</span> <span class="o">=</span> <span class="n">ncr_scatter</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">segments</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ncr_free_ccb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">DID_ERROR</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">segments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*---------------------------------------------------</span>
<span class="cm">	**</span>
<span class="cm">	**	negotiation required?</span>
<span class="cm">	**</span>
<span class="cm">	**	(nego_status is filled by ncr_prepare_nego())</span>
<span class="cm">	**</span>
<span class="cm">	**---------------------------------------------------</span>
<span class="cm">	*/</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">widedone</span> <span class="o">||</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">nego_cp</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msglen</span> <span class="o">+=</span> <span class="n">ncr_prepare_nego</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">msgptr</span> <span class="o">+</span> <span class="n">msglen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*----------------------------------------------------</span>
<span class="cm">	**</span>
<span class="cm">	**	Determine xfer direction.</span>
<span class="cm">	**</span>
<span class="cm">	**----------------------------------------------------</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span>
		<span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_NONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	If data direction is BIDIRECTIONAL, speculate FROM_DEVICE</span>
<span class="cm">	**	but prepare alternate pointers for TO_DEVICE in case </span>
<span class="cm">	**	of our speculation will be just wrong.</span>
<span class="cm">	**	SCRIPTS will swap values if needed.</span>
<span class="cm">	*/</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DMA_BIDIRECTIONAL</span>:
	<span class="k">case</span> <span class="n">DMA_TO_DEVICE</span>:
		<span class="n">goalp</span> <span class="o">=</span> <span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">data_out2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">segments</span> <span class="o">&lt;=</span> <span class="n">MAX_SCATTERL</span><span class="p">)</span>
			<span class="n">lastp</span> <span class="o">=</span> <span class="n">goalp</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">-</span> <span class="p">(</span><span class="n">segments</span> <span class="o">*</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">lastp</span> <span class="o">=</span> <span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">hdata_out2</span><span class="p">);</span>
			<span class="n">lastp</span> <span class="o">-=</span> <span class="p">(</span><span class="n">segments</span> <span class="o">-</span> <span class="n">MAX_SCATTERL</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">!=</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wgoalp</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">goalp</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wlastp</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">lastp</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">DMA_FROM_DEVICE</span>:
		<span class="n">goalp</span> <span class="o">=</span> <span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">data_in2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">segments</span> <span class="o">&lt;=</span> <span class="n">MAX_SCATTERL</span><span class="p">)</span>
			<span class="n">lastp</span> <span class="o">=</span> <span class="n">goalp</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">-</span> <span class="p">(</span><span class="n">segments</span> <span class="o">*</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">lastp</span> <span class="o">=</span> <span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">hdata_in2</span><span class="p">);</span>
			<span class="n">lastp</span> <span class="o">-=</span> <span class="p">(</span><span class="n">segments</span> <span class="o">-</span> <span class="n">MAX_SCATTERL</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="n">DMA_NONE</span>:
		<span class="n">lastp</span> <span class="o">=</span> <span class="n">goalp</span> <span class="o">=</span> <span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">no_data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Set all pointers values needed by SCRIPTS.</span>
<span class="cm">	**	If direction is unknown, start at data_io.</span>
<span class="cm">	*/</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">lastp</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">lastp</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">goalp</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">goalp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">savep</span> <span class="o">=</span> 
			<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">data_io</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">savep</span><span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">lastp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Save the initial data pointer in order to be able </span>
<span class="cm">	**	to redo the command.</span>
<span class="cm">	*/</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">startp</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">savep</span><span class="p">;</span>

	<span class="cm">/*----------------------------------------------------</span>
<span class="cm">	**</span>
<span class="cm">	**	fill in ccb</span>
<span class="cm">	**</span>
<span class="cm">	**----------------------------------------------------</span>
<span class="cm">	**</span>
<span class="cm">	**</span>
<span class="cm">	**	physical -&gt; virtual backlink</span>
<span class="cm">	**	Generic SCSI command</span>
<span class="cm">	*/</span>

	<span class="cm">/*</span>
<span class="cm">	**	Startqueue</span>
<span class="cm">	*/</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">.</span><span class="n">schedule</span><span class="p">.</span><span class="n">l_paddr</span>   <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">select</span><span class="p">));</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">restart</span><span class="p">.</span><span class="n">schedule</span><span class="p">.</span><span class="n">l_paddr</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">resel_dsa</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	**	select</span>
<span class="cm">	*/</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">select</span><span class="p">.</span><span class="n">sel_id</span>		<span class="o">=</span> <span class="n">sdev_id</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">select</span><span class="p">.</span><span class="n">sel_scntl3</span>	<span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">wval</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">select</span><span class="p">.</span><span class="n">sel_sxfer</span>	<span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sval</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	**	message</span>
<span class="cm">	*/</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">smsg</span><span class="p">.</span><span class="n">addr</span>		<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">CCB_PHYS</span> <span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">scsi_smsg</span><span class="p">));</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">smsg</span><span class="p">.</span><span class="n">size</span>		<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">msglen</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	command</span>
<span class="cm">	*/</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cdb_buf</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cdb_buf</span><span class="p">)));</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">addr</span>		<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">CCB_PHYS</span> <span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">cdb_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">size</span>		<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	status</span>
<span class="cm">	*/</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">actualquirks</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span>			<span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">?</span> <span class="n">HS_NEGOTIATE</span> <span class="o">:</span> <span class="n">HS_BUSY</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span>			<span class="o">=</span> <span class="n">S_ILLEGAL</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">parity_status</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span>			<span class="o">=</span> <span class="n">XE_OK</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	cp-&gt;sync_status			= tp-&gt;sval;</span>
<span class="c">	cp-&gt;wide_status			= tp-&gt;wval;</span>
<span class="cp">#endif</span>

	<span class="cm">/*----------------------------------------------------</span>
<span class="cm">	**</span>
<span class="cm">	**	Critical region: start this job.</span>
<span class="cm">	**</span>
<span class="cm">	**----------------------------------------------------</span>
<span class="cm">	*/</span>

	<span class="cm">/* activate this job.  */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">magic</span>		<span class="o">=</span> <span class="n">CCB_MAGIC</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	insert next CCBs into start queue.</span>
<span class="cm">	**	2 max at a time is enough to flush the CCB wait queue.</span>
<span class="cm">	*/</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">auto_sense</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span>
		<span class="n">ncr_start_next_ccb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ncr_put_start_queue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>

	<span class="cm">/* Command is successfully queued.  */</span>

	<span class="k">return</span> <span class="n">DID_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	Insert a CCB into the start queue and wake up the </span>
<span class="cm">**	SCRIPTS processor.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_start_next_ccb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">qp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">held_ccb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">maxn</span><span class="o">--</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">queuedccbs</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">queuedepth</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qp</span> <span class="o">=</span> <span class="n">ncr_list_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">wait_ccbq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qp</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">queuedccbs</span><span class="p">;</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span><span class="p">,</span> <span class="n">link_ccbq</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">==</span> <span class="n">NO_TAG</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">CCB_PHYS</span> <span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">restart</span><span class="p">));</span>
		<span class="n">ncr_put_start_queue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_put_start_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span>	<span class="n">qidx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	insert into start queue.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">squeueput</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">squeueput</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">qidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">squeueput</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qidx</span> <span class="o">&gt;=</span> <span class="n">MAX_START</span> <span class="o">+</span> <span class="n">MAX_START</span><span class="p">)</span> <span class="n">qidx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth</span><span class="o">-&gt;</span><span class="n">tryloop</span> <span class="p">[</span><span class="n">qidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">idle</span><span class="p">));</span>
	<span class="n">MEMORY_BARRIER</span><span class="p">();</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth</span><span class="o">-&gt;</span><span class="n">tryloop</span> <span class="p">[</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">squeueput</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">CCB_PHYS</span> <span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">start</span><span class="p">));</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeueput</span> <span class="o">=</span> <span class="n">qidx</span><span class="p">;</span>
	<span class="o">++</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">queuedccbs</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">queued</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_QUEUE</span><span class="p">)</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: queuepos=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span> <span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">squeueput</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Script processor may be waiting for reselect.</span>
<span class="cm">	**	Wake it up.</span>
<span class="cm">	*/</span>
	<span class="n">MEMORY_BARRIER</span><span class="p">();</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_istat</span><span class="p">,</span> <span class="n">SIGP</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">ncr_reset_scsi_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enab_int</span><span class="p">,</span> <span class="kt">int</span> <span class="n">settle_delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">term</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">settle_time</span>	<span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">settle_delay</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: resetting, &quot;</span>
			<span class="s">&quot;command processing suspended for %d seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">settle_delay</span><span class="p">);</span>

	<span class="n">ncr_chip_reset</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>	<span class="cm">/* The 895 needs time for the bus mode to settle */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enab_int</span><span class="p">)</span>
		<span class="n">OUTW</span> <span class="p">(</span><span class="n">nc_sien</span><span class="p">,</span> <span class="n">RST</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	**	Enable Tolerant, reset IRQD if present and </span>
<span class="cm">	**	properly set IRQ mode, prior to resetting the bus.</span>
<span class="cm">	*/</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_stest3</span><span class="p">,</span> <span class="n">TE</span><span class="p">);</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_scntl1</span><span class="p">,</span> <span class="n">CRST</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver_setup</span><span class="p">.</span><span class="n">bus_check</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	**	Check for no terminators or SCSI bus shorts to ground.</span>
<span class="cm">	**	Read SCSI data bus, data parity bits and control signals.</span>
<span class="cm">	**	We are expecting RESET to be TRUE and other signals to be </span>
<span class="cm">	**	FALSE.</span>
<span class="cm">	*/</span>

	<span class="n">term</span> <span class="o">=</span>	<span class="n">INB</span><span class="p">(</span><span class="n">nc_sstat0</span><span class="p">);</span>
	<span class="n">term</span> <span class="o">=</span>	<span class="p">((</span><span class="n">term</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">term</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">);</span>	<span class="cm">/* rst sdp0 */</span>
	<span class="n">term</span> <span class="o">|=</span> <span class="p">((</span><span class="n">INB</span><span class="p">(</span><span class="n">nc_sstat2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/* sdp1     */</span>
		<span class="p">((</span><span class="n">INW</span><span class="p">(</span><span class="n">nc_sbdl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>   <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span>  <span class="o">|</span>	<span class="cm">/* d7-0     */</span>
		<span class="p">((</span><span class="n">INW</span><span class="p">(</span><span class="n">nc_sbdl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/* d15-8    */</span>
		<span class="n">INB</span><span class="p">(</span><span class="n">nc_sbcl</span><span class="p">);</span>	<span class="cm">/* req ack bsy sel atn msg cd io    */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_WIDE</span><span class="p">))</span>
		<span class="n">term</span> <span class="o">&amp;=</span> <span class="mh">0x3ffff</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">term</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: suspicious SCSI data while resetting the BUS.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: %sdp0,d7-0,rst,req,ack,bsy,sel,atn,msg,c/d,i/o = &quot;</span>
			<span class="s">&quot;0x%lx, expecting 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span>
			<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_WIDE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;dp1,d15-8,&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u_long</span><span class="p">)</span><span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)(</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">driver_setup</span><span class="p">.</span><span class="n">bus_check</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">retv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_scntl1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start reset process.</span>
<span class="cm"> * If reset in progress do nothing.</span>
<span class="cm"> * The interrupt handler will reinitialize the chip.</span>
<span class="cm"> * The timeout handler will wait for settle_time before </span>
<span class="cm"> * clearing it and so resuming command processing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_start_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">settle_time</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ncr_reset_scsi_bus</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">driver_setup</span><span class="p">.</span><span class="n">settle_delay</span><span class="p">);</span>
 	<span class="p">}</span>
<span class="p">}</span>
 
<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	Reset the SCSI BUS.</span>
<span class="cm">**	This is called from the generic SCSI driver.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ncr_reset_bus</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync_reset</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/*	struct scsi_device        *device    = cmd-&gt;device; */</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Return immediately if reset is in progress.</span>
<span class="cm"> */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">settle_time</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Start the reset process.</span>
<span class="cm"> * The script processor is then assumed to be stopped.</span>
<span class="cm"> * Commands will now be queued in the waiting list until a settle </span>
<span class="cm"> * delay of 2 seconds will be completed.</span>
<span class="cm"> */</span>
	<span class="n">ncr_start_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * First, look in the wakeup list</span>
<span class="cm"> */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">found</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">=</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span> <span class="n">cp</span><span class="p">;</span> <span class="n">cp</span><span class="o">=</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		**	look for the ccb of this command.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_IDLE</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Then, look in the waiting list</span>
<span class="cm"> */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span> <span class="o">&amp;&amp;</span> <span class="n">retrieve_from_waiting_list</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span>
		<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * Wake-up all awaiting commands with DID_RESET.</span>
<span class="cm"> */</span>
	<span class="n">reset_waiting_list</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * Wake-up all pending commands with HS_RESET -&gt; DID_RESET.</span>
<span class="cm"> */</span>
	<span class="n">ncr_wakeup</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_RESET</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * If the involved command was not in a driver queue, and the </span>
<span class="cm"> * scsi driver told us reset is synchronous, and the command is not </span>
<span class="cm"> * currently in the waiting list, complete it with DID_RESET status,</span>
<span class="cm"> * in order to keep it alive.</span>
<span class="cm"> */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span> <span class="o">&amp;&amp;</span> <span class="n">sync_reset</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">retrieve_from_waiting_list</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_RESET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ncr_queue_done_cmd</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"> /* unused and broken.. */</span>
<span class="c">/*==========================================================</span>
<span class="c">**</span>
<span class="c">**</span>
<span class="c">**	Abort an SCSI command.</span>
<span class="c">**	This is called from the generic SCSI driver.</span>
<span class="c">**</span>
<span class="c">**</span>
<span class="c">**==========================================================</span>
<span class="c">*/</span>
<span class="c">static int ncr_abort_command (struct ncb *np, struct scsi_cmnd *cmd)</span>
<span class="c">{</span>
<span class="c">/*	struct scsi_device        *device    = cmd-&gt;device; */</span>
<span class="c">	struct ccb *cp;</span>
<span class="c">	int found;</span>
<span class="c">	int retv;</span>

<span class="c">/*</span>
<span class="c"> * First, look for the scsi command in the waiting list</span>
<span class="c"> */</span>
<span class="c">	if (remove_from_waiting_list(np, cmd)) {</span>
<span class="c">		cmd-&gt;result = ScsiResult(DID_ABORT, 0);</span>
<span class="c">		ncr_queue_done_cmd(np, cmd);</span>
<span class="c">		return SCSI_ABORT_SUCCESS;</span>
<span class="c">	}</span>

<span class="c">/*</span>
<span class="c"> * Then, look in the wakeup list</span>
<span class="c"> */</span>
<span class="c">	for (found=0, cp=np-&gt;ccb; cp; cp=cp-&gt;link_ccb) {</span>
<span class="c">		/*</span>
<span class="c">		**	look for the ccb of this command.</span>
<span class="c">		*/</span>
<span class="c">		if (cp-&gt;host_status == HS_IDLE) continue;</span>
<span class="c">		if (cp-&gt;cmd == cmd) {</span>
<span class="c">			found = 1;</span>
<span class="c">			break;</span>
<span class="c">		}</span>
<span class="c">	}</span>

<span class="c">	if (!found) {</span>
<span class="c">		return SCSI_ABORT_NOT_RUNNING;</span>
<span class="c">	}</span>

<span class="c">	if (np-&gt;settle_time) {</span>
<span class="c">		return SCSI_ABORT_SNOOZE;</span>
<span class="c">	}</span>

<span class="c">	/*</span>
<span class="c">	**	If the CCB is active, patch schedule jumps for the </span>
<span class="c">	**	script to abort the command.</span>
<span class="c">	*/</span>

<span class="c">	switch(cp-&gt;host_status) {</span>
<span class="c">	case HS_BUSY:</span>
<span class="c">	case HS_NEGOTIATE:</span>
<span class="c">		printk (&quot;%s: abort ccb=%p (cancel)\n&quot;, ncr_name (np), cp);</span>
<span class="c">			cp-&gt;start.schedule.l_paddr =</span>
<span class="c">				cpu_to_scr(NCB_SCRIPTH_PHYS (np, cancel));</span>
<span class="c">		retv = SCSI_ABORT_PENDING;</span>
<span class="c">		break;</span>
<span class="c">	case HS_DISCONNECT:</span>
<span class="c">		cp-&gt;restart.schedule.l_paddr =</span>
<span class="c">				cpu_to_scr(NCB_SCRIPTH_PHYS (np, abort));</span>
<span class="c">		retv = SCSI_ABORT_PENDING;</span>
<span class="c">		break;</span>
<span class="c">	default:</span>
<span class="c">		retv = SCSI_ABORT_NOT_RUNNING;</span>
<span class="c">		break;</span>

<span class="c">	}</span>

<span class="c">	/*</span>
<span class="c">	**      If there are no requests, the script</span>
<span class="c">	**      processor will sleep on SEL_WAIT_RESEL.</span>
<span class="c">	**      Let&#39;s wake it up, since it may have to work.</span>
<span class="c">	*/</span>
<span class="c">	OUTB (nc_istat, SIGP);</span>

<span class="c">	return retv;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">lun</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">inst_name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="cm">/* Local copy so we don&#39;t access np after freeing it! */</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">inst_name</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inst_name</span><span class="p">));</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: releasing host resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm">**	Stop the ncr_timeout process</span>
<span class="cm">**	Set release_stage to 1 and wait that ncr_timeout() set it to 2.</span>
<span class="cm">*/</span>

<span class="cp">#ifdef DEBUG_NCR53C8XX</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: stopping the timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">release_stage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">50</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">release_stage</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">release_stage</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: the timer seems to be already stopped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
	<span class="k">else</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">release_stage</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">**	Disable chip interrupts</span>
<span class="cm">*/</span>

<span class="cp">#ifdef DEBUG_NCR53C8XX</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: disabling chip interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">OUTW</span> <span class="p">(</span><span class="n">nc_sien</span> <span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_dien</span> <span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Reset NCR chip</span>
<span class="cm">	**	Restore bios setting for automatic clock detection.</span>
<span class="cm">	*/</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: resetting chip</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
	<span class="n">ncr_chip_reset</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>

	<span class="n">OUTB</span><span class="p">(</span><span class="n">nc_dmode</span><span class="p">,</span>	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dmode</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">nc_dcntl</span><span class="p">,</span>	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dcntl</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">nc_ctest0</span><span class="p">,</span>	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest0</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">nc_ctest3</span><span class="p">,</span>	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest3</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">nc_ctest4</span><span class="p">,</span>	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest4</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">nc_ctest5</span><span class="p">,</span>	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest5</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">nc_gpcntl</span><span class="p">,</span>	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_gpcntl</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">nc_stest2</span><span class="p">,</span>	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_stest2</span><span class="p">);</span>

	<span class="n">ncr_selectclock</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_scntl3</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Free allocated ccb(s)</span>
<span class="cm">	*/</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">cp</span><span class="o">=</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">link_ccb</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">link_ccb</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: shall free an active ccb (host_status=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#ifdef DEBUG_NCR53C8XX</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: freeing ccb (%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">cp</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">m_free_dma</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="p">),</span> <span class="s">&quot;CCB&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Free allocated tp(s) */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">MAX_TARGET</span> <span class="p">;</span> <span class="n">target</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">=&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">lun</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">lun</span> <span class="o">&lt;</span> <span class="n">MAX_LUN</span> <span class="p">;</span> <span class="n">lun</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="n">lun</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG_NCR53C8XX</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: freeing lp (%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">lp</span><span class="p">);</span>
<span class="cp">#endif</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb_0</span><span class="p">)</span>
					<span class="n">m_free_dma</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb</span><span class="p">,</span><span class="mi">256</span><span class="p">,</span><span class="s">&quot;JUMP_CCB&quot;</span><span class="p">);</span>
				<span class="n">m_free_dma</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="p">),</span> <span class="s">&quot;LCB&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth0</span><span class="p">)</span>
		<span class="n">m_free_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scripth</span><span class="p">),</span> <span class="s">&quot;SCRIPTH&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span><span class="p">)</span>
		<span class="n">m_free_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">script</span><span class="p">),</span> <span class="s">&quot;SCRIPT&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">)</span>
		<span class="n">m_free_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccb</span><span class="p">),</span> <span class="s">&quot;CCB&quot;</span><span class="p">);</span>
	<span class="n">m_free_dma</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span><span class="p">),</span> <span class="s">&quot;NCB&quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: host resources successfully released</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inst_name</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	Complete execution of a SCSI command.</span>
<span class="cm">**	Signal completion to the generic SCSI driver.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="kt">void</span> <span class="nf">ncr_complete</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Sanity check</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span> <span class="o">||</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">CCB_MAGIC</span> <span class="o">||</span> <span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Print minimal debug information.</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;CCB=%lx STAT=%x/%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cp</span><span class="p">,</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="p">,</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Get command, target and lun pointers.</span>
<span class="cm">	*/</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	**	We donnot queue more than 1 ccb per target </span>
<span class="cm">	**	with negotiation at any time. If this ccb was </span>
<span class="cm">	**	used for negotiation, clear this info in the tcb.</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">nego_cp</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">nego_cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	If auto-sense performed, change scsi status.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">auto_sense</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">auto_sense</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	If we were recovering from queue full or performing </span>
<span class="cm">	**	auto-sense, requeue skipped CCBs to the wait queue.</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">held_ccb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">held_ccb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">skip_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">wait_ccbq</span><span class="p">);</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">held_ccb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Check for parity errors.</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">parity_status</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;%d parity error(s).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">parity_status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Check for extended errors.</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span> <span class="o">!=</span> <span class="n">XE_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">XE_EXTRA_DATA</span>:
			<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;extraneous data discarded.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XE_BAD_PHASE</span>:
			<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;invalid scsi phase (4/5).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;extended error %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="o">==</span><span class="n">HS_COMPLETE</span><span class="p">)</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">=</span> <span class="n">HS_FAIL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Print out any error for debugging purpose.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DEBUG_RESULT</span><span class="o">|</span><span class="n">DEBUG_TINY</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="o">!=</span><span class="n">HS_COMPLETE</span> <span class="o">||</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="o">!=</span><span class="n">S_GOOD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;ERROR: cmd=%x host_status=%x &quot;</span>
					<span class="s">&quot;scsi_status=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Check the status.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span>   <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_COMPLETE</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">==</span> <span class="n">S_GOOD</span> <span class="o">||</span>
		    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">==</span> <span class="n">S_COND_MET</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *	All went well (GOOD status).</span>
<span class="cm">		 *	CONDITION MET status is returned on </span>
<span class="cm">		 *	`Pre-Fetch&#39; or `Search data&#39; success.</span>
<span class="cm">		 */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_OK</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		**	@RESID@</span>
<span class="cm">		**	Could dig out the correct value for resid,</span>
<span class="cm">		**	but it would be quite complicated.</span>
<span class="cm">		*/</span>
		<span class="cm">/* if (cp-&gt;phys.header.lastp != cp-&gt;phys.header.goalp) */</span>

		<span class="cm">/*</span>
<span class="cm">		**	Allocate the lcb if not yet.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="p">)</span>
			<span class="n">ncr_alloc_lcb</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">bytes</span>     <span class="o">+=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">transfers</span> <span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		**	If tags was reduced due to queue full,</span>
<span class="cm">		**	increase tags if 1000 good status received.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">usetags</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">numtags</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">maxtags</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">num_good</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">num_good</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">num_good</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">numtags</span><span class="p">;</span>
				<span class="n">ncr_setup_tags</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_COMPLETE</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">==</span> <span class="n">S_CHECK_COND</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		**   Check condition code</span>
<span class="cm">		*/</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_OK</span><span class="p">,</span> <span class="n">S_CHECK_COND</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		**	Copy back sense data to caller&#39;s buffer.</span>
<span class="cm">		*/</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">sense_buf</span><span class="p">,</span>
		       <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">sense_buf</span><span class="p">)));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DEBUG_RESULT</span><span class="o">|</span><span class="n">DEBUG_TINY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">u_char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;sense data:&quot;</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">14</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; %x&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
			<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_COMPLETE</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">==</span> <span class="n">S_CONFLICT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		**   Reservation Conflict condition code</span>
<span class="cm">		*/</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_OK</span><span class="p">,</span> <span class="n">S_CONFLICT</span><span class="p">);</span>
	
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_COMPLETE</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">==</span> <span class="n">S_BUSY</span> <span class="o">||</span>
		    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">==</span> <span class="n">S_QUEUE_FULL</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		**   Target is busy.</span>
<span class="cm">		*/</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_OK</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_SEL_TIMEOUT</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_TIMEOUT</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		**   No response</span>
<span class="cm">		*/</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_TIME_OUT</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_RESET</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		**   SCSI bus reset</span>
<span class="cm">		*/</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_RESET</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_ABORTED</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		**   Transfer aborted</span>
<span class="cm">		*/</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_ABORT</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		**  Other protocol messes</span>
<span class="cm">		*/</span>
		<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;COMMAND FAILED (%x %x) @%p.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_ERROR</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	trace output</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrflag</span> <span class="o">&amp;</span> <span class="n">UF_TRACE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_char</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot; CMD:&quot;</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_char</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; %x&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="o">==</span><span class="n">HS_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">S_GOOD</span>:
				<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;  GOOD&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">S_CHECK_COND</span>:
				<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;  SENSE:&quot;</span><span class="p">);</span>
				<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_char</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">;</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">14</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
					<span class="n">printk</span> <span class="p">(</span><span class="s">&quot; %x&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;  STAT: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="n">printk</span> <span class="p">(</span><span class="s">&quot;  HOSTERROR: %x&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="p">);</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Free this ccb</span>
<span class="cm">	*/</span>
	<span class="n">ncr_free_ccb</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	requeue awaiting scsi commands for this lun.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">queuedccbs</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">queuedepth</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">wait_ccbq</span><span class="p">))</span>
		<span class="n">ncr_start_next_ccb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	requeue awaiting scsi commands for this controller.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">waiting_list</span><span class="p">)</span>
		<span class="n">requeue_waiting_list</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	signal completion to generic driver.</span>
<span class="cm">	*/</span>
	<span class="n">ncr_queue_done_cmd</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	Signal all (or one) control block done.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">**	This CCB has been skipped by the NCR.</span>
<span class="cm">**	Queue it in the corresponding unit queue.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_ccb_skipped</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span> <span class="o">&amp;&amp;</span> <span class="n">cp</span> <span class="o">!=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HS_SKIPMASK</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">.</span><span class="n">schedule</span><span class="p">.</span><span class="n">l_paddr</span> <span class="o">=</span> 
			<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">select</span><span class="p">));</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">skip_ccbq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">--</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">queuedccbs</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">--</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">queuedccbs</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">**	The NCR has completed CCBs.</span>
<span class="cm">**	Look at the DONE QUEUE if enabled, otherwise scan all CCBs</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">ncr_wakeup_done</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
<span class="cp">#ifdef SCSI_NCR_CCB_DONE_SUPPORT</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb_done_ic</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">MAX_DONE</span><span class="p">)</span>
			<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb_done</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CCB_DONE_VALID</span><span class="p">(</span><span class="n">cp</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb_done</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="p">)</span><span class="n">CCB_DONE_EMPTY</span><span class="p">;</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth</span><span class="o">-&gt;</span><span class="n">done_queue</span><span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">done_plug</span><span class="p">));</span>
		<span class="n">MEMORY_BARRIER</span><span class="p">();</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth</span><span class="o">-&gt;</span><span class="n">done_queue</span><span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">done_end</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">&amp;</span> <span class="n">HS_DONEMASK</span><span class="p">)</span>
			<span class="n">ncr_complete</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">&amp;</span> <span class="n">HS_SKIPMASK</span><span class="p">)</span>
			<span class="n">ncr_ccb_skipped</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>

		<span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb_done_ic</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">&amp;</span> <span class="n">HS_DONEMASK</span><span class="p">)</span>
			<span class="n">ncr_complete</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">&amp;</span> <span class="n">HS_SKIPMASK</span><span class="p">)</span>
			<span class="n">ncr_ccb_skipped</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccb</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">**	Complete all active CCBs.</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">ncr_wakeup</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">!=</span> <span class="n">HS_IDLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>
			<span class="n">ncr_complete</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccb</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Reset ncr chip.</span>
<span class="cm">*/</span>

<span class="cm">/* Some initialisation must be done immediately following reset, for 53c720,</span>
<span class="cm"> * at least.  EA (dcntl bit 5) isn&#39;t set here as it is set once only in</span>
<span class="cm"> * the _detect function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_chip_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_istat</span><span class="p">,</span>  <span class="n">SRST</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">delay</span><span class="p">);</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_istat</span><span class="p">,</span>  <span class="mi">0</span>   <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_EHP</span><span class="p">)</span>
		<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_ctest0</span><span class="p">,</span> <span class="n">EHP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_MUX</span><span class="p">)</span>
		<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_ctest4</span><span class="p">,</span> <span class="n">MUX</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	Start NCR chip.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="kt">void</span> <span class="nf">ncr_init</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reset</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">msg</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

 	<span class="cm">/*</span>
<span class="cm">	**	Reset chip if asked, otherwise just clear fifos.</span>
<span class="cm"> 	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_istat</span><span class="p">,</span>  <span class="n">SRST</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_stest3</span><span class="p">,</span> <span class="n">TE</span><span class="o">|</span><span class="n">CSF</span><span class="p">);</span>
		<span class="n">OUTONB</span> <span class="p">(</span><span class="n">nc_ctest3</span><span class="p">,</span> <span class="n">CLF</span><span class="p">);</span>
	<span class="p">}</span>
 
	<span class="cm">/*</span>
<span class="cm">	**	Message.</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="n">printk</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: restart (%s).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span> <span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">msg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Clear Start Queue</span>
<span class="cm">	*/</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">queuedepth</span> <span class="o">=</span> <span class="n">MAX_START</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* 1 entry needed as end marker */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_START</span> <span class="o">+</span> <span class="n">MAX_START</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth0</span><span class="o">-&gt;</span><span class="n">tryloop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">idle</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	**	Start at first entry.</span>
<span class="cm">	*/</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeueput</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span><span class="o">-&gt;</span><span class="n">startpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tryloop</span><span class="p">));</span>

<span class="cp">#ifdef SCSI_NCR_CCB_DONE_SUPPORT</span>
	<span class="cm">/*</span>
<span class="cm">	**	Clear Done Queue</span>
<span class="cm">	*/</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_DONE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb_done</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="p">)</span><span class="n">CCB_DONE_EMPTY</span><span class="p">;</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth0</span><span class="o">-&gt;</span><span class="n">done_queue</span><span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">done_end</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	**	Start at first entry.</span>
<span class="cm">	*/</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span><span class="o">-&gt;</span><span class="n">done_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span><span class="n">done_queue</span><span class="p">));</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb_done_ic</span> <span class="o">=</span> <span class="n">MAX_DONE</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth0</span><span class="o">-&gt;</span><span class="n">done_queue</span><span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">MAX_DONE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">done_plug</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	**	Wakeup all pending jobs.</span>
<span class="cm">	*/</span>
	<span class="n">ncr_wakeup</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Init chip.</span>
<span class="cm">	*/</span>

	<span class="cm">/*</span>
<span class="cm">	** Remove reset; big delay because the 895 needs time for the</span>
<span class="cm">	** bus mode to settle</span>
<span class="cm">	*/</span>
	<span class="n">ncr_chip_reset</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>

	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_scntl0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl0</span> <span class="o">|</span> <span class="mh">0xc0</span><span class="p">);</span>
					<span class="cm">/*  full arb., ena parity, par-&gt;ATN  */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_scntl1</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>		<span class="cm">/*  odd parity, and remove CRST!! */</span>

	<span class="n">ncr_selectclock</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl3</span><span class="p">);</span>	<span class="cm">/* Select SCSI clock */</span>

	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_scid</span>  <span class="p">,</span> <span class="n">RRE</span><span class="o">|</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span><span class="p">);</span>	<span class="cm">/* Adapter SCSI address */</span>
	<span class="n">OUTW</span> <span class="p">(</span><span class="n">nc_respid</span><span class="p">,</span> <span class="mi">1ul</span><span class="o">&lt;&lt;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span><span class="p">);</span>	<span class="cm">/* Id to respond to */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_istat</span> <span class="p">,</span> <span class="n">SIGP</span>	<span class="p">);</span>		<span class="cm">/*  Signal Process */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_dmode</span> <span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span><span class="p">);</span>		<span class="cm">/* Burst length, dma mode */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_ctest5</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest5</span><span class="p">);</span>	<span class="cm">/* Large fifo + large burst */</span>

	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_dcntl</span> <span class="p">,</span> <span class="n">NOCOM</span><span class="o">|</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span><span class="p">);</span>	<span class="cm">/* Protect SFBR */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_ctest0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest0</span><span class="p">);</span>	<span class="cm">/* 720: CDIS and EHP */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_ctest3</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest3</span><span class="p">);</span>	<span class="cm">/* Write and invalidate */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_ctest4</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest4</span><span class="p">);</span>	<span class="cm">/* Master parity checking */</span>

	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_stest2</span><span class="p">,</span> <span class="n">EXT</span><span class="o">|</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_stest2</span><span class="p">);</span>	<span class="cm">/* Extended Sreq/Sack filtering */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_stest3</span><span class="p">,</span> <span class="n">TE</span><span class="p">);</span>			<span class="cm">/* TolerANT enable */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_stime0</span><span class="p">,</span> <span class="mh">0x0c</span>	<span class="p">);</span>		<span class="cm">/* HTH disabled  STO 0.25 sec */</span>

	<span class="cm">/*</span>
<span class="cm">	**	Disable disconnects.</span>
<span class="cm">	*/</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">disc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**    Enable GPIO0 pin for writing if LED support.</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_LED0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTOFFB</span> <span class="p">(</span><span class="n">nc_gpcntl</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**      enable ints</span>
<span class="cm">	*/</span>

	<span class="n">OUTW</span> <span class="p">(</span><span class="n">nc_sien</span> <span class="p">,</span> <span class="n">STO</span><span class="o">|</span><span class="n">HTH</span><span class="o">|</span><span class="n">MA</span><span class="o">|</span><span class="n">SGE</span><span class="o">|</span><span class="n">UDC</span><span class="o">|</span><span class="n">RST</span><span class="o">|</span><span class="n">PAR</span><span class="p">);</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_dien</span> <span class="p">,</span> <span class="n">MDPE</span><span class="o">|</span><span class="n">BF</span><span class="o">|</span><span class="n">ABRT</span><span class="o">|</span><span class="n">SSI</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">IID</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Fill in target structure.</span>
<span class="cm">	**	Reinitialize usrsync.</span>
<span class="cm">	**	Reinitialize usrwide.</span>
<span class="cm">	**	Prepare sync negotiation according to actual SCSI bus mode.</span>
<span class="cm">	*/</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_TARGET</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sval</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">wval</span>    <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl3</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrsync</span> <span class="o">!=</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrsync</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxsync</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrsync</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrsync</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">else</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrsync</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrwide</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrwide</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**    Start script processor.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">paddr2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span>
			<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: Downloading SCSI SCRIPTS.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="n">OUTL</span> <span class="p">(</span><span class="n">nc_scratcha</span><span class="p">,</span> <span class="n">vtobus</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span><span class="p">));</span>
		<span class="n">OUTL_DSP</span> <span class="p">(</span><span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">start_ram</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">OUTL_DSP</span> <span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">start</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Prepare the negotiation values for wide and</span>
<span class="cm">**	synchronous transfers.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_negotiate</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span><span class="o">*</span> <span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcb</span><span class="o">*</span> <span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	**	minsync unit is 4ns !</span>
<span class="cm">	*/</span>

	<span class="n">u_long</span> <span class="n">minsync</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrsync</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	SCSI bus mode limit</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">&amp;&amp;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">==</span> <span class="n">SMODE_SE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">minsync</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="n">minsync</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	our limit ..</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">minsync</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">)</span>
		<span class="n">minsync</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	divider limit</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">minsync</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxsync</span><span class="p">)</span>
		<span class="n">minsync</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">maxoffs</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">maxoffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">;</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">=</span> <span class="n">minsync</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">maxoffs</span> <span class="o">=</span> <span class="p">(</span><span class="n">minsync</span><span class="o">&lt;</span><span class="mi">255</span> <span class="o">?</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">maxoffs</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	period=0: has to negotiate sync transfer</span>
<span class="cm">	*/</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	widedone=0: has to negotiate wide transfer</span>
<span class="cm">	*/</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">widedone</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Get clock factor and sync divisor for a given </span>
<span class="cm">**	synchronous factor period.</span>
<span class="cm">**	Returns the clock factor (in sxfer) and scntl3 </span>
<span class="cm">**	synchronous divisor field.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_getsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">sfac</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">fakp</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">scntl3p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_long</span>	<span class="n">clk</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span><span class="p">;</span>	<span class="cm">/* SCSI clock frequency in kHz	*/</span>
	<span class="kt">int</span>	<span class="n">div</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_divn</span><span class="p">;</span>	<span class="cm">/* Number of divisors supported	*/</span>
	<span class="n">u_long</span>	<span class="n">fak</span><span class="p">;</span>			<span class="cm">/* Sync factor in sxfer		*/</span>
	<span class="n">u_long</span>	<span class="n">per</span><span class="p">;</span>			<span class="cm">/* Period in tenths of ns	*/</span>
	<span class="n">u_long</span>	<span class="n">kpc</span><span class="p">;</span>			<span class="cm">/* (per * clk)			*/</span>

	<span class="cm">/*</span>
<span class="cm">	**	Compute the synchronous period in tenths of nano-seconds</span>
<span class="cm">	*/</span>
	<span class="k">if</span>	<span class="p">(</span><span class="n">sfac</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span>	<span class="n">per</span> <span class="o">=</span> <span class="mi">250</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">sfac</span> <span class="o">==</span> <span class="mi">11</span><span class="p">)</span>	<span class="n">per</span> <span class="o">=</span> <span class="mi">303</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">sfac</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span>	<span class="n">per</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
	<span class="k">else</span>			<span class="n">per</span> <span class="o">=</span> <span class="mi">40</span> <span class="o">*</span> <span class="n">sfac</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Look for the greatest clock divisor that allows an </span>
<span class="cm">	**	input speed faster than the period.</span>
<span class="cm">	*/</span>
	<span class="n">kpc</span> <span class="o">=</span> <span class="n">per</span> <span class="o">*</span> <span class="n">clk</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">div</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kpc</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">div_10M</span><span class="p">[</span><span class="n">div</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Calculate the lowest clock factor that allows an output </span>
<span class="cm">	**	speed not faster than the period.</span>
<span class="cm">	*/</span>
	<span class="n">fak</span> <span class="o">=</span> <span class="p">(</span><span class="n">kpc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">div_10M</span><span class="p">[</span><span class="n">div</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c">	/* This optimization does not seem very useful */</span>

<span class="c">	per = (fak * div_10M[div]) / clk;</span>

<span class="c">	/*</span>
<span class="c">	**	Why not to try the immediate lower divisor and to choose </span>
<span class="c">	**	the one that allows the fastest output speed ?</span>
<span class="c">	**	We don&#39;t want input speed too much greater than output speed.</span>
<span class="c">	*/</span>
<span class="c">	if (div &gt;= 1 &amp;&amp; fak &lt; 8) {</span>
<span class="c">		u_long fak2, per2;</span>
<span class="c">		fak2 = (kpc - 1) / div_10M[div-1] + 1;</span>
<span class="c">		per2 = (fak2 * div_10M[div-1]) / clk;</span>
<span class="c">		if (per2 &lt; per &amp;&amp; fak2 &lt;= 8) {</span>
<span class="c">			fak = fak2;</span>
<span class="c">			per = per2;</span>
<span class="c">			--div;</span>
<span class="c">		}</span>
<span class="c">	}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fak</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="n">fak</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>	<span class="cm">/* Should never happen, too bad ... */</span>

	<span class="cm">/*</span>
<span class="cm">	**	Compute and return sync parameters for the ncr</span>
<span class="cm">	*/</span>
	<span class="o">*</span><span class="n">fakp</span>		<span class="o">=</span> <span class="n">fak</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
	<span class="o">*</span><span class="n">scntl3p</span>	<span class="o">=</span> <span class="p">((</span><span class="n">div</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">sfac</span> <span class="o">&lt;</span> <span class="mi">25</span> <span class="o">?</span> <span class="mh">0x80</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Set actual values, sync status and patch all ccbs of </span>
<span class="cm">**	a target according to new sync/wide agreement.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_set_sync_wide_status</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	**	set actual value and sync_status</span>
<span class="cm">	*/</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_sxfer</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sval</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sync_st</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sval</span><span class="p">;</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_scntl3</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">wval</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">wide_st</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">wval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	patch ALL ccbs of this target.</span>
<span class="cm">	*/</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span> <span class="n">cp</span><span class="p">;</span> <span class="n">cp</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scmd_id</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">target</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		cp-&gt;sync_status = tp-&gt;sval;</span>
<span class="c">		cp-&gt;wide_status = tp-&gt;wval;</span>
<span class="cp">#endif</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">select</span><span class="p">.</span><span class="n">sel_scntl3</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">wval</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">select</span><span class="p">.</span><span class="n">sel_sxfer</span>  <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sval</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Switch sync mode for current job and it&#39;s target</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_setsync</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">scntl3</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">sxfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">target</span> <span class="o">=</span> <span class="n">INB</span> <span class="p">(</span><span class="n">nc_sdid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">idiv</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">target</span> <span class="o">!=</span> <span class="p">(</span><span class="n">scmd_id</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scntl3</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">sxfer</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">))</span>
		<span class="n">scntl3</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl3</span><span class="p">;</span>
	<span class="n">scntl3</span> <span class="o">=</span> <span class="p">(</span><span class="n">scntl3</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">wval</span> <span class="o">&amp;</span> <span class="n">EWS</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl3</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Deduce the value of controller sync period from scntl3.</span>
<span class="cm">	**	period is in tenths of nano-seconds.</span>
<span class="cm">	*/</span>

	<span class="n">idiv</span> <span class="o">=</span> <span class="p">((</span><span class="n">scntl3</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sxfer</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">idiv</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="p">(((</span><span class="n">sxfer</span><span class="o">&gt;&gt;</span><span class="mi">5</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">div_10M</span><span class="p">[</span><span class="n">idiv</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="cm">/* Stop there if sync parameters are unchanged */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">sval</span> <span class="o">==</span> <span class="n">sxfer</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">wval</span> <span class="o">==</span> <span class="n">scntl3</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sval</span> <span class="o">=</span> <span class="n">sxfer</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">wval</span> <span class="o">=</span> <span class="n">scntl3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sxfer</span> <span class="o">&amp;</span> <span class="mh">0x01f</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Disable extended Sreq/Sack filtering */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="mi">2000</span><span class="p">)</span>
			<span class="n">OUTOFFB</span><span class="p">(</span><span class="n">nc_stest2</span><span class="p">,</span> <span class="n">EXT</span><span class="p">);</span>
	<span class="p">}</span>
 
	<span class="n">spi_display_xfer_agreement</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	set actual value and sync_status</span>
<span class="cm">	**	patch ALL ccbs of this target.</span>
<span class="cm">	*/</span>
	<span class="n">ncr_set_sync_wide_status</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Switch wide mode for current job and it&#39;s target</span>
<span class="cm">**	SCSI specs say: a SCSI device that accepts a WDTR </span>
<span class="cm">**	message shall reset the synchronous agreement to </span>
<span class="cm">**	asynchronous mode.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_setwide</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">wide</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">ack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">target</span> <span class="o">=</span> <span class="n">INB</span> <span class="p">(</span><span class="n">nc_sdid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">scntl3</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">sxfer</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">target</span> <span class="o">!=</span> <span class="p">(</span><span class="n">scmd_id</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">widedone</span>  <span class="o">=</span>  <span class="n">wide</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">scntl3</span> <span class="o">=</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">wval</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">EWS</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">wide</span> <span class="o">?</span> <span class="n">EWS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">sxfer</span> <span class="o">=</span> <span class="n">ack</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	 Stop there if sync/wide parameters are unchanged</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">sval</span> <span class="o">==</span> <span class="n">sxfer</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">wval</span> <span class="o">==</span> <span class="n">scntl3</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sval</span> <span class="o">=</span> <span class="n">sxfer</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">wval</span> <span class="o">=</span> <span class="n">scntl3</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Bells and whistles   ;-)</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WIDE SCSI %sabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">scntl3</span> <span class="o">&amp;</span> <span class="n">EWS</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;en&quot;</span> <span class="o">:</span> <span class="s">&quot;dis&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	set actual value and sync_status</span>
<span class="cm">	**	patch ALL ccbs of this target.</span>
<span class="cm">	*/</span>
	<span class="n">ncr_set_sync_wide_status</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Switch tagged mode for a target.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_setup_tags</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tn</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">ln</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">tn</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="n">ln</span><span class="p">];</span>
	<span class="n">u_char</span>   <span class="n">reqtags</span><span class="p">,</span> <span class="n">maxdepth</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Just in case ...</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">tp</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">sdev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	If SCSI device queue depth is not yet set, leave here.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">scdev_depth</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Donnot allow more tags than the SCSI driver can queue </span>
<span class="cm">	**	for this device.</span>
<span class="cm">	**	Donnot allow more tags than we can handle.</span>
<span class="cm">	*/</span>
	<span class="n">maxdepth</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">scdev_depth</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxdepth</span> <span class="o">&gt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">maxnxs</span><span class="p">)</span>	<span class="n">maxdepth</span>    <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">maxnxs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">maxtags</span> <span class="o">&gt;</span> <span class="n">maxdepth</span><span class="p">)</span>	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">maxtags</span> <span class="o">=</span> <span class="n">maxdepth</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">numtags</span> <span class="o">&gt;</span> <span class="n">maxdepth</span><span class="p">)</span>	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">numtags</span> <span class="o">=</span> <span class="n">maxdepth</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	only devices conformant to ANSI Version &gt;= 2</span>
<span class="cm">	**	only devices capable of tagged commands</span>
<span class="cm">	**	only if enabled by user ..</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">numtags</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reqtags</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">numtags</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">reqtags</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Update max number of tags</span>
<span class="cm">	*/</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">numtags</span> <span class="o">=</span> <span class="n">reqtags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">numtags</span> <span class="o">&gt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">maxtags</span><span class="p">)</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">maxtags</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">numtags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	If we want to switch tag mode, we must wait </span>
<span class="cm">	**	for no CCB to be active.</span>
<span class="cm">	*/</span>
	<span class="k">if</span>	<span class="p">(</span><span class="n">reqtags</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">usetags</span><span class="p">)</span> <span class="p">{</span>	 <span class="cm">/* Stay in tagged mode    */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">queuedepth</span> <span class="o">==</span> <span class="n">reqtags</span><span class="p">)</span>	 <span class="cm">/* Already announced	   */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">queuedepth</span>	<span class="o">=</span> <span class="n">reqtags</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">reqtags</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">usetags</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Stay in untagged mode  */</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">queuedepth</span>	<span class="o">=</span> <span class="n">reqtags</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>					 <span class="cm">/* Want to switch tag mode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busyccbs</span><span class="p">)</span>		 <span class="cm">/* If not yet safe, return */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">queuedepth</span>	<span class="o">=</span> <span class="n">reqtags</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">usetags</span>	<span class="o">=</span> <span class="n">reqtags</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Patch the lun mini-script, according to tag mode.</span>
<span class="cm">	*/</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_tag</span><span class="p">.</span><span class="n">l_paddr</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">usetags</span><span class="o">?</span>
			<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">resel_tag</span><span class="p">))</span> <span class="o">:</span>
			<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">resel_notag</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	**	Announce change to user.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">usetags</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">,</span>
				<span class="s">&quot;tagged command queue depth set to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">reqtags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">,</span>
					<span class="s">&quot;tagged command queueing disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	ncr timeout handler.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Misused to keep the driver running when</span>
<span class="cm">**	interrupts are not configured correctly.</span>
<span class="cm">**</span>
<span class="cm">**----------------------------------------------------------</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_timeout</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_long</span>	<span class="n">thistime</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	If release process in progress, let&#39;s go</span>
<span class="cm">	**	Set the release stage from 1 to 2 to synchronize</span>
<span class="cm">	**	with the release process.</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">release_stage</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">release_stage</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">release_stage</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SCSI_NCR_TIMER_INTERVAL</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	If we are resetting the ncr, wait for settle_time before </span>
<span class="cm">	**	clearing it. Then command processing will be resumed.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">settle_time</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">settle_time</span> <span class="o">&lt;=</span> <span class="n">thistime</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: command processing resumed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">settle_time</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">disc</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">requeue_waiting_list</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Since the generic scsi driver only allows us 0.5 second </span>
<span class="cm">	**	to perform abort of a command, we must look at ccbs about </span>
<span class="cm">	**	every 0.25 second.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lasttime</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">HZ</span> <span class="o">&lt;</span> <span class="n">thistime</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		**	block ncr interrupts</span>
<span class="cm">		*/</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">lasttime</span> <span class="o">=</span> <span class="n">thistime</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef SCSI_NCR_BROKEN_INTR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">nc_istat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INTF</span><span class="o">|</span><span class="n">SIP</span><span class="o">|</span><span class="n">DIP</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		**	Process pending interrupts.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span> <span class="n">printk</span> <span class="p">(</span><span class="s">&quot;{&quot;</span><span class="p">);</span>
		<span class="n">ncr_exception</span> <span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span> <span class="n">printk</span> <span class="p">(</span><span class="s">&quot;}&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* SCSI_NCR_BROKEN_INTR */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	log message for real hard errors</span>
<span class="cm">**</span>
<span class="cm">**	&quot;ncr0 targ 0?: ERROR (ds:si) (so-si-sd) (sxfer/scntl3) @ name (dsp:dbc).&quot;</span>
<span class="cm">**	&quot;	      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf.&quot;</span>
<span class="cm">**</span>
<span class="cm">**	exception register:</span>
<span class="cm">**		ds:	dstat</span>
<span class="cm">**		si:	sist</span>
<span class="cm">**</span>
<span class="cm">**	SCSI bus lines:</span>
<span class="cm">**		so:	control lines as driver by NCR.</span>
<span class="cm">**		si:	control lines as seen by NCR.</span>
<span class="cm">**		sd:	scsi data lines as seen by NCR.</span>
<span class="cm">**</span>
<span class="cm">**	wide/fastmode:</span>
<span class="cm">**		sxfer:	(see the manual)</span>
<span class="cm">**		scntl3:	(see the manual)</span>
<span class="cm">**</span>
<span class="cm">**	current script command:</span>
<span class="cm">**		dsp:	script address (relative to start of script).</span>
<span class="cm">**		dbc:	first word of script command.</span>
<span class="cm">**</span>
<span class="cm">**	First 16 register of the chip:</span>
<span class="cm">**		r0..rf</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_log_hard_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u16</span> <span class="n">sist</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">dstat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">dsp</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">script_ofs</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">script_size</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">script_name</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="o">*</span><span class="n">script_base</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="n">dsp</span>	<span class="o">=</span> <span class="n">INL</span> <span class="p">(</span><span class="n">nc_dsp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dsp</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">p_script</span> <span class="o">&amp;&amp;</span> <span class="n">dsp</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">p_script</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">script</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">script_ofs</span>	<span class="o">=</span> <span class="n">dsp</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">p_script</span><span class="p">;</span>
		<span class="n">script_size</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">script</span><span class="p">);</span>
		<span class="n">script_base</span>	<span class="o">=</span> <span class="p">(</span><span class="n">u_char</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span><span class="p">;</span>
		<span class="n">script_name</span>	<span class="o">=</span> <span class="s">&quot;script&quot;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">p_scripth</span> <span class="o">&lt;</span> <span class="n">dsp</span> <span class="o">&amp;&amp;</span> 
		 <span class="n">dsp</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">p_scripth</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scripth</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">script_ofs</span>	<span class="o">=</span> <span class="n">dsp</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">p_scripth</span><span class="p">;</span>
		<span class="n">script_size</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scripth</span><span class="p">);</span>
		<span class="n">script_base</span>	<span class="o">=</span> <span class="p">(</span><span class="n">u_char</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth0</span><span class="p">;</span>
		<span class="n">script_name</span>	<span class="o">=</span> <span class="s">&quot;scripth&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">script_ofs</span>	<span class="o">=</span> <span class="n">dsp</span><span class="p">;</span>
		<span class="n">script_size</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">script_base</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">script_name</span>	<span class="o">=</span> <span class="s">&quot;mem&quot;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ncr_name</span> <span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB</span> <span class="p">(</span><span class="n">nc_sdid</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0f</span><span class="p">,</span> <span class="n">dstat</span><span class="p">,</span> <span class="n">sist</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB</span> <span class="p">(</span><span class="n">nc_socl</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB</span> <span class="p">(</span><span class="n">nc_sbcl</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB</span> <span class="p">(</span><span class="n">nc_sbdl</span><span class="p">),</span>
		<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB</span> <span class="p">(</span><span class="n">nc_sxfer</span><span class="p">),(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB</span> <span class="p">(</span><span class="n">nc_scntl3</span><span class="p">),</span> <span class="n">script_name</span><span class="p">,</span> <span class="n">script_ofs</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INL</span> <span class="p">(</span><span class="n">nc_dbc</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">script_ofs</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">script_ofs</span> <span class="o">&lt;</span> <span class="n">script_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: script cmd = %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span>
			<span class="n">scr_to_cpu</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="p">(</span><span class="n">ncrcmd</span> <span class="o">*</span><span class="p">)(</span><span class="n">script_base</span> <span class="o">+</span> <span class="n">script_ofs</span><span class="p">)));</span>
	<span class="p">}</span>

	<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: regdump:&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; %02x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB_OFF</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*============================================================</span>
<span class="cm">**</span>
<span class="cm">**	ncr chip exception handler.</span>
<span class="cm">**</span>
<span class="cm">**============================================================</span>
<span class="cm">**</span>
<span class="cm">**	In normal cases, interrupt conditions occur one at a </span>
<span class="cm">**	time. The ncr is able to stack in some extra registers </span>
<span class="cm">**	other interrupts that will occur after the first one.</span>
<span class="cm">**	But, several interrupts may occur at the same time.</span>
<span class="cm">**</span>
<span class="cm">**	We probably should only try to deal with the normal </span>
<span class="cm">**	case, but it seems that multiple interrupts occur in </span>
<span class="cm">**	some cases that are not abnormal at all.</span>
<span class="cm">**</span>
<span class="cm">**	The most frequent interrupt condition is Phase Mismatch.</span>
<span class="cm">**	We should want to service this interrupt quickly.</span>
<span class="cm">**	A SCSI parity error may be delivered at the same time.</span>
<span class="cm">**	The SIR interrupt is not very frequent in this driver, </span>
<span class="cm">**	since the INTFLY is likely used for command completion </span>
<span class="cm">**	signaling.</span>
<span class="cm">**	The Selection Timeout interrupt may be triggered with </span>
<span class="cm">**	IID and/or UDC.</span>
<span class="cm">**	The SBMC interrupt (SCSI Bus Mode Change) may probably </span>
<span class="cm">**	occur at any time.</span>
<span class="cm">**</span>
<span class="cm">**	This handler try to deal as cleverly as possible with all</span>
<span class="cm">**	the above.</span>
<span class="cm">**</span>
<span class="cm">**============================================================</span>
<span class="cm">*/</span>

<span class="kt">void</span> <span class="nf">ncr_exception</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span>	<span class="n">istat</span><span class="p">,</span> <span class="n">dstat</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">sist</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	interrupt on the fly ?</span>
<span class="cm">	**	Since the global header may be copied back to a CCB </span>
<span class="cm">	**	using a posted PCI memory write, the last operation on </span>
<span class="cm">	**	the istat register is a READ in order to flush posted </span>
<span class="cm">	**	PCI write commands.</span>
<span class="cm">	*/</span>
	<span class="n">istat</span> <span class="o">=</span> <span class="n">INB</span> <span class="p">(</span><span class="n">nc_istat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">istat</span> <span class="o">&amp;</span> <span class="n">INTF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_istat</span><span class="p">,</span> <span class="p">(</span><span class="n">istat</span> <span class="o">&amp;</span> <span class="n">SIGP</span><span class="p">)</span> <span class="o">|</span> <span class="n">INTF</span><span class="p">);</span>
		<span class="n">istat</span> <span class="o">=</span> <span class="n">INB</span> <span class="p">(</span><span class="n">nc_istat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span> <span class="n">printk</span> <span class="p">(</span><span class="s">&quot;F &quot;</span><span class="p">);</span>
		<span class="n">ncr_wakeup_done</span> <span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">istat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SIP</span><span class="o">|</span><span class="n">DIP</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">istat</span> <span class="o">&amp;</span> <span class="n">CABRT</span><span class="p">)</span>
		<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_istat</span><span class="p">,</span> <span class="n">CABRT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Steinbach&#39;s Guideline for Systems Programming:</span>
<span class="cm">	**	Never test for an error condition you don&#39;t know how to handle.</span>
<span class="cm">	*/</span>

	<span class="n">sist</span>  <span class="o">=</span> <span class="p">(</span><span class="n">istat</span> <span class="o">&amp;</span> <span class="n">SIP</span><span class="p">)</span> <span class="o">?</span> <span class="n">INW</span> <span class="p">(</span><span class="n">nc_sist</span><span class="p">)</span>  <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dstat</span> <span class="o">=</span> <span class="p">(</span><span class="n">istat</span> <span class="o">&amp;</span> <span class="n">DIP</span><span class="p">)</span> <span class="o">?</span> <span class="n">INB</span> <span class="p">(</span><span class="n">nc_dstat</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;&lt;%d|%x:%x|%x:%x&gt;&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">INB</span><span class="p">(</span><span class="n">nc_scr0</span><span class="p">),</span>
			<span class="n">dstat</span><span class="p">,</span><span class="n">sist</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INL</span><span class="p">(</span><span class="n">nc_dsp</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INL</span><span class="p">(</span><span class="n">nc_dbc</span><span class="p">));</span>

	<span class="cm">/*========================================================</span>
<span class="cm">	**	First, interrupts we want to service cleanly.</span>
<span class="cm">	**</span>
<span class="cm">	**	Phase mismatch is the most frequent interrupt, and </span>
<span class="cm">	**	so we have to service it as quickly and as cleanly </span>
<span class="cm">	**	as possible.</span>
<span class="cm">	**	Programmed interrupts are rarely used in this driver,</span>
<span class="cm">	**	but we must handle them cleanly anyway.</span>
<span class="cm">	**	We try to deal with PAR and SBMC combined with </span>
<span class="cm">	**	some other interrupt(s).</span>
<span class="cm">	**=========================================================</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sist</span>  <span class="o">&amp;</span> <span class="p">(</span><span class="n">STO</span><span class="o">|</span><span class="n">GEN</span><span class="o">|</span><span class="n">HTH</span><span class="o">|</span><span class="n">SGE</span><span class="o">|</span><span class="n">UDC</span><span class="o">|</span><span class="n">RST</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">dstat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MDPE</span><span class="o">|</span><span class="n">BF</span><span class="o">|</span><span class="n">ABRT</span><span class="o">|</span><span class="n">IID</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="n">SBMC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ncr_int_sbmc</span> <span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="n">PAR</span><span class="p">)</span>  <span class="o">&amp;&amp;</span> <span class="n">ncr_int_par</span>  <span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="n">MA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ncr_int_ma</span> <span class="p">(</span><span class="n">np</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dstat</span> <span class="o">&amp;</span> <span class="n">SIR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ncr_int_sir</span> <span class="p">(</span><span class="n">np</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		**  DEL 397 - 53C875 Rev 3 - Part Number 609-0392410 - ITEM 2.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SBMC</span><span class="o">|</span><span class="n">PAR</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">dstat</span> <span class="o">&amp;</span> <span class="n">SSI</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span>	<span class="s">&quot;%s: unknown interrupt(s) ignored, &quot;</span>
				<span class="s">&quot;ISTAT=%x DSTAT=%x SIST=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">istat</span><span class="p">,</span> <span class="n">dstat</span><span class="p">,</span> <span class="n">sist</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">OUTONB_STD</span> <span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*========================================================</span>
<span class="cm">	**	Now, interrupts that need some fixing up.</span>
<span class="cm">	**	Order and multiple interrupts is so less important.</span>
<span class="cm">	**</span>
<span class="cm">	**	If SRST has been asserted, we just reset the chip.</span>
<span class="cm">	**</span>
<span class="cm">	**	Selection is intirely handled by the chip. If the </span>
<span class="cm">	**	chip says STO, we trust it. Seems some other </span>
<span class="cm">	**	interrupts may occur at the same time (UDC, IID), so </span>
<span class="cm">	**	we ignore them. In any case we do enough fix-up </span>
<span class="cm">	**	in the service routine.</span>
<span class="cm">	**	We just exclude some fatal dma errors.</span>
<span class="cm">	**=========================================================</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="n">RST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ncr_init</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bootverbose</span> <span class="o">?</span> <span class="s">&quot;scsi reset&quot;</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">HS_RESET</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="n">STO</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">dstat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MDPE</span><span class="o">|</span><span class="n">BF</span><span class="o">|</span><span class="n">ABRT</span><span class="p">)))</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	**	DEL 397 - 53C875 Rev 3 - Part Number 609-0392410 - ITEM 1.</span>
<span class="cm">	*/</span>
		<span class="n">OUTONB</span> <span class="p">(</span><span class="n">nc_ctest3</span><span class="p">,</span> <span class="n">CLF</span><span class="p">);</span>

		<span class="n">ncr_int_sto</span> <span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*=========================================================</span>
<span class="cm">	**	Now, interrupts we are not able to recover cleanly.</span>
<span class="cm">	**	(At least for the moment).</span>
<span class="cm">	**</span>
<span class="cm">	**	Do the register dump.</span>
<span class="cm">	**	Log message for real hard errors.</span>
<span class="cm">	**	Clear all fifos.</span>
<span class="cm">	**	For MDPE, BF, ABORT, IID, SGE and HTH we reset the </span>
<span class="cm">	**	BUS and the chip.</span>
<span class="cm">	**	We are more soft for UDC.</span>
<span class="cm">	**=========================================================</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">regtime</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">regtime</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">HZ</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">regdump</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">regdump</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INB_OFF</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">regdump</span><span class="p">.</span><span class="n">nc_dstat</span> <span class="o">=</span> <span class="n">dstat</span><span class="p">;</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">regdump</span><span class="p">.</span><span class="n">nc_sist</span>  <span class="o">=</span> <span class="n">sist</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ncr_log_hard_error</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">sist</span><span class="p">,</span> <span class="n">dstat</span><span class="p">);</span>

	<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: have to clear fifos.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span> <span class="p">(</span><span class="n">np</span><span class="p">));</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_stest3</span><span class="p">,</span> <span class="n">TE</span><span class="o">|</span><span class="n">CSF</span><span class="p">);</span>
	<span class="n">OUTONB</span> <span class="p">(</span><span class="n">nc_ctest3</span><span class="p">,</span> <span class="n">CLF</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SGE</span><span class="p">))</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">dstat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MDPE</span><span class="o">|</span><span class="n">BF</span><span class="o">|</span><span class="n">ABRT</span><span class="o">|</span><span class="n">IID</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ncr_start_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="n">HTH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: handshake timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="n">ncr_start_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="n">UDC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: unexpected disconnect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="n">OUTB</span> <span class="p">(</span><span class="n">HS_PRT</span><span class="p">,</span> <span class="n">HS_UNEXPECTED</span><span class="p">);</span>
		<span class="n">OUTL_DSP</span> <span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cleanup</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*=========================================================</span>
<span class="cm">	**	We just miss the cause of the interrupt. :(</span>
<span class="cm">	**	Print a message. The timeout will do the real work.</span>
<span class="cm">	**=========================================================</span>
<span class="cm">	*/</span>
	<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: unknown interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	ncr chip exception handler for selection timeout</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	There seems to be a bug in the 53c810.</span>
<span class="cm">**	Although a STO-Interrupt is pending,</span>
<span class="cm">**	it continues executing script commands.</span>
<span class="cm">**	But it will fail and interrupt (IID) on</span>
<span class="cm">**	the next instruction where it&#39;s looking</span>
<span class="cm">**	for a valid phase.</span>
<span class="cm">**</span>
<span class="cm">**----------------------------------------------------------</span>
<span class="cm">*/</span>

<span class="kt">void</span> <span class="nf">ncr_int_sto</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_long</span> <span class="n">dsa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span> <span class="n">printk</span> <span class="p">(</span><span class="s">&quot;T&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	look for ccb and set the status.</span>
<span class="cm">	*/</span>

	<span class="n">dsa</span> <span class="o">=</span> <span class="n">INL</span> <span class="p">(</span><span class="n">nc_dsa</span><span class="p">);</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">CCB_PHYS</span> <span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">phys</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dsa</span><span class="p">))</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span> <span class="n">host_status</span> <span class="o">=</span> <span class="n">HS_SEL_TIMEOUT</span><span class="p">;</span>
		<span class="n">ncr_complete</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	repair start queue and jump to start point.</span>
<span class="cm">	*/</span>

	<span class="n">OUTL_DSP</span> <span class="p">(</span><span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">sto_restart</span><span class="p">));</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	ncr chip exception handler for SCSI bus mode change</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	spi2-r12 11.2.3 says a transceiver mode change must </span>
<span class="cm">**	generate a reset event and a device that detects a reset </span>
<span class="cm">**	event shall initiate a hard reset. It says also that a</span>
<span class="cm">**	device that detects a mode change shall set data transfer </span>
<span class="cm">**	mode to eight bit asynchronous, etc...</span>
<span class="cm">**	So, just resetting should be enough.</span>
<span class="cm">**	 </span>
<span class="cm">**</span>
<span class="cm">**----------------------------------------------------------</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ncr_int_sbmc</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span> <span class="n">scsi_mode</span> <span class="o">=</span> <span class="n">INB</span> <span class="p">(</span><span class="n">nc_stest4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SMODE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_mode</span> <span class="o">!=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: SCSI bus mode change from %x to %x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span><span class="p">,</span> <span class="n">scsi_mode</span><span class="p">);</span>

		<span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">=</span> <span class="n">scsi_mode</span><span class="p">;</span>


		<span class="cm">/*</span>
<span class="cm">		**	Suspend command processing for 1 second and </span>
<span class="cm">		**	reinitialize all except the chip.</span>
<span class="cm">		*/</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">settle_time</span>	<span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="n">ncr_init</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bootverbose</span> <span class="o">?</span> <span class="s">&quot;scsi mode change&quot;</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">HS_RESET</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	ncr chip exception handler for SCSI parity error.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**----------------------------------------------------------</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ncr_int_par</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span>	<span class="n">hsts</span>	<span class="o">=</span> <span class="n">INB</span> <span class="p">(</span><span class="n">HS_PRT</span><span class="p">);</span>
	<span class="n">u32</span>	<span class="n">dbc</span>	<span class="o">=</span> <span class="n">INL</span> <span class="p">(</span><span class="n">nc_dbc</span><span class="p">);</span>
	<span class="n">u_char</span>	<span class="n">sstat1</span>	<span class="o">=</span> <span class="n">INB</span> <span class="p">(</span><span class="n">nc_sstat1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">phase</span>	<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">msg</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">jmp</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: SCSI parity error detected: SCR1=%d DBC=%x SSTAT1=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">hsts</span><span class="p">,</span> <span class="n">dbc</span><span class="p">,</span> <span class="n">sstat1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Ignore the interrupt if the NCR is not connected </span>
<span class="cm">	 *	to the SCSI bus, since the right work should have  </span>
<span class="cm">	 *	been done on unexpected disconnection handling.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">INB</span> <span class="p">(</span><span class="n">nc_scntl1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ISCON</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	If the nexus is not clearly identified, reset the bus.</span>
<span class="cm">	 *	We will try to do better later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hsts</span> <span class="o">&amp;</span> <span class="n">HS_INVALMASK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset_all</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	If the SCSI parity error occurs in MSG IN phase, prepare a </span>
<span class="cm">	 *	MSG PARITY message. Otherwise, prepare a INITIATOR DETECTED </span>
<span class="cm">	 *	ERROR message and let the device decide to retry the command </span>
<span class="cm">	 *	or to terminate with check condition. If we were in MSG IN </span>
<span class="cm">	 *	phase waiting for the response of a negotiation, we will </span>
<span class="cm">	 *	get SIR_NEGO_FAILED at dispatch.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dbc</span> <span class="o">&amp;</span> <span class="mh">0xc0000000</span><span class="p">))</span>
		<span class="n">phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">dbc</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phase</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="n">MSG_PARITY_ERROR</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="n">INITIATOR_ERROR</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 *	If the NCR stopped on a MOVE ^ DATA_IN, we jump to a </span>
<span class="cm">	 *	script that will ignore all data in bytes until phase </span>
<span class="cm">	 *	change, since we are not sure the chip will wait the phase </span>
<span class="cm">	 *	change prior to delivering the interrupt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phase</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">jmp</span> <span class="o">=</span> <span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">par_err_data_in</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">jmp</span> <span class="o">=</span> <span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">par_err_other</span><span class="p">);</span>

	<span class="n">OUTONB</span> <span class="p">(</span><span class="n">nc_ctest3</span><span class="p">,</span> <span class="n">CLF</span> <span class="p">);</span>	<span class="cm">/* clear dma fifo  */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_stest3</span><span class="p">,</span> <span class="n">TE</span><span class="o">|</span><span class="n">CSF</span><span class="p">);</span>	<span class="cm">/* clear scsi fifo */</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
	<span class="n">OUTL_DSP</span> <span class="p">(</span><span class="n">jmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">reset_all:</span>
	<span class="n">ncr_start_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	ncr chip exception handler for phase errors.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	We have to construct a new transfer descriptor,</span>
<span class="cm">**	to transfer the rest of the current block.</span>
<span class="cm">**</span>
<span class="cm">**----------------------------------------------------------</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_int_ma</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">dbc</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">rest</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">dsp</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">dsa</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">nxtdsp</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">newtmp</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="o">*</span><span class="n">vdsp</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">oadr</span><span class="p">,</span> <span class="n">olen</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="o">*</span><span class="n">tblp</span><span class="p">;</span>
	<span class="n">ncrcmd</span> <span class="o">*</span><span class="n">newcmd</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">cmd</span><span class="p">,</span> <span class="n">sbcl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="n">dsp</span>	<span class="o">=</span> <span class="n">INL</span> <span class="p">(</span><span class="n">nc_dsp</span><span class="p">);</span>
	<span class="n">dbc</span>	<span class="o">=</span> <span class="n">INL</span> <span class="p">(</span><span class="n">nc_dbc</span><span class="p">);</span>
	<span class="n">sbcl</span>	<span class="o">=</span> <span class="n">INB</span> <span class="p">(</span><span class="n">nc_sbcl</span><span class="p">);</span>

	<span class="n">cmd</span>	<span class="o">=</span> <span class="n">dbc</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="n">rest</span>	<span class="o">=</span> <span class="n">dbc</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Take into account dma fifo and various buffers and latches,</span>
<span class="cm">	**	only if the interrupted phase is an OUTPUT phase.</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_char</span>	<span class="n">ctest5</span><span class="p">,</span> <span class="n">ss0</span><span class="p">,</span> <span class="n">ss2</span><span class="p">;</span>
		<span class="n">u16</span>	<span class="n">delta</span><span class="p">;</span>

		<span class="n">ctest5</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest5</span> <span class="o">&amp;</span> <span class="n">DFS</span><span class="p">)</span> <span class="o">?</span> <span class="n">INB</span> <span class="p">(</span><span class="n">nc_ctest5</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctest5</span> <span class="o">&amp;</span> <span class="n">DFS</span><span class="p">)</span>
			<span class="n">delta</span><span class="o">=</span><span class="p">(((</span><span class="n">ctest5</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">INB</span> <span class="p">(</span><span class="n">nc_dfifo</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">))</span> <span class="o">-</span> <span class="n">rest</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">delta</span><span class="o">=</span><span class="p">(</span><span class="n">INB</span> <span class="p">(</span><span class="n">nc_dfifo</span><span class="p">)</span> <span class="o">-</span> <span class="n">rest</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		**	The data in the dma fifo has not been transferred to</span>
<span class="cm">		**	the target -&gt; add the amount to the rest</span>
<span class="cm">		**	and clear the data.</span>
<span class="cm">		**	Check the sstat2 register in case of wide transfer.</span>
<span class="cm">		*/</span>

		<span class="n">rest</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">ss0</span>  <span class="o">=</span> <span class="n">INB</span> <span class="p">(</span><span class="n">nc_sstat0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss0</span> <span class="o">&amp;</span> <span class="n">OLF</span><span class="p">)</span> <span class="n">rest</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss0</span> <span class="o">&amp;</span> <span class="n">ORF</span><span class="p">)</span> <span class="n">rest</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">nc_scntl3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EWS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ss2</span> <span class="o">=</span> <span class="n">INB</span> <span class="p">(</span><span class="n">nc_sstat2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss2</span> <span class="o">&amp;</span> <span class="n">OLF1</span><span class="p">)</span> <span class="n">rest</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss2</span> <span class="o">&amp;</span> <span class="n">ORF1</span><span class="p">)</span> <span class="n">rest</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DEBUG_TINY</span><span class="o">|</span><span class="n">DEBUG_PHASE</span><span class="p">))</span>
			<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;P%x%x RL=%d D=%d SS0=%x &quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">,</span> <span class="n">sbcl</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">rest</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">delta</span><span class="p">,</span> <span class="n">ss0</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span>	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DEBUG_TINY</span><span class="o">|</span><span class="n">DEBUG_PHASE</span><span class="p">))</span>
			<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;P%x%x RL=%d &quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">,</span> <span class="n">sbcl</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">,</span> <span class="n">rest</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Clear fifos.</span>
<span class="cm">	*/</span>
	<span class="n">OUTONB</span> <span class="p">(</span><span class="n">nc_ctest3</span><span class="p">,</span> <span class="n">CLF</span> <span class="p">);</span>	<span class="cm">/* clear dma fifo  */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_stest3</span><span class="p">,</span> <span class="n">TE</span><span class="o">|</span><span class="n">CSF</span><span class="p">);</span>	<span class="cm">/* clear scsi fifo */</span>

	<span class="cm">/*</span>
<span class="cm">	**	locate matching cp.</span>
<span class="cm">	**	if the interrupted phase is DATA IN or DATA OUT,</span>
<span class="cm">	**	trust the global header.</span>
<span class="cm">	*/</span>
	<span class="n">dsa</span> <span class="o">=</span> <span class="n">INL</span> <span class="p">(</span><span class="n">nc_dsa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mi">6</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CCB_PHYS</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">phys</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dsa</span><span class="p">)</span>
			<span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cp</span>  <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">CCB_PHYS</span> <span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">phys</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dsa</span><span class="p">))</span>
			<span class="n">cp</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	try to find the interrupted script command,</span>
<span class="cm">	**	and the address at which to continue.</span>
<span class="cm">	*/</span>
	<span class="n">vdsp</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">nxtdsp</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span>	<span class="p">(</span><span class="n">dsp</span> <span class="o">&gt;</span>  <span class="n">np</span><span class="o">-&gt;</span><span class="n">p_script</span> <span class="o">&amp;&amp;</span>
		 <span class="n">dsp</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">p_script</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">script</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vdsp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span> <span class="o">+</span> <span class="p">(</span><span class="n">dsp</span><span class="o">-</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">p_script</span><span class="o">-</span><span class="mi">8</span><span class="p">));</span>
		<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">dsp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">dsp</span> <span class="o">&gt;</span>  <span class="n">np</span><span class="o">-&gt;</span><span class="n">p_scripth</span> <span class="o">&amp;&amp;</span>
		 <span class="n">dsp</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">p_scripth</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scripth</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vdsp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth0</span> <span class="o">+</span> <span class="p">(</span><span class="n">dsp</span><span class="o">-</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">p_scripth</span><span class="o">-</span><span class="mi">8</span><span class="p">));</span>
		<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">dsp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span>	<span class="p">(</span><span class="n">dsp</span> <span class="o">==</span> <span class="n">CCB_PHYS</span> <span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">patch</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">vdsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">vdsp</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dsp</span> <span class="o">==</span> <span class="n">CCB_PHYS</span> <span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">patch</span><span class="p">[</span><span class="mi">6</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">vdsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
			<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">vdsp</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	log the information</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_PHASE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">CP=%p CP2=%p DSP=%x NXT=%x VDSP=%p CMD=%x &quot;</span><span class="p">,</span>
			<span class="n">cp</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cp</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">dsp</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">nxtdsp</span><span class="p">,</span> <span class="n">vdsp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	cp=0 means that the DSA does not point to a valid control </span>
<span class="cm">	**	block. This should not happen since we donnot use multi-byte </span>
<span class="cm">	**	move while we are being reselected ot after command complete.</span>
<span class="cm">	**	We are not able to recover from such a phase error.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: SCSI phase error fixup: &quot;</span>
			<span class="s">&quot;CCB already dequeued (0x%08lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">ncr_name</span> <span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">reset_all</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	get old startaddress and old length.</span>
<span class="cm">	*/</span>

	<span class="n">oadr</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">vdsp</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Table indirect */</span>
		<span class="n">tblp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span> <span class="o">+</span> <span class="n">oadr</span><span class="p">);</span>
		<span class="n">olen</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">tblp</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">oadr</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">tblp</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tblp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">olen</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">vdsp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_PHASE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;OCMD=%x</span><span class="se">\n</span><span class="s">TBLP=%p OLEN=%x OADR=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="p">(</span><span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">vdsp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">),</span>
			<span class="n">tblp</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">olen</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">oadr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	check cmd against assumed interrupted script command.</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="p">(</span><span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">vdsp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;internal error: cmd=%02x != %02x=(vdsp[0] &quot;</span>
				<span class="s">&quot;&gt;&gt; 24)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">vdsp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">reset_all</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	cp != np-&gt;header.cp means that the header of the CCB </span>
<span class="cm">	**	currently being processed has not yet been copied to </span>
<span class="cm">	**	the global header area. That may happen if the device did </span>
<span class="cm">	**	not accept all our messages after having been selected.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">!=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: SCSI phase error fixup: &quot;</span>
			<span class="s">&quot;CCB address mismatch (0x%08lx != 0x%08lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">ncr_name</span> <span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">cp</span><span class="p">,</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	if old phase not dataphase, leave here.</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mh">0x06</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;phase change %x-%x %d@%08x resid=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">,</span> <span class="n">sbcl</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">olen</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">oadr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">rest</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unexpected_phase</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	choose the correct patch area.</span>
<span class="cm">	**	if savep points to one, choose the other.</span>
<span class="cm">	*/</span>

	<span class="n">newcmd</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">;</span>
	<span class="n">newtmp</span> <span class="o">=</span> <span class="n">CCB_PHYS</span> <span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">patch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newtmp</span> <span class="o">==</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">savep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">newcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">newtmp</span> <span class="o">=</span> <span class="n">CCB_PHYS</span> <span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">patch</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	fillin the commands</span>
<span class="cm">	*/</span>

	<span class="n">newcmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="n">rest</span><span class="p">);</span>
	<span class="n">newcmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">oadr</span> <span class="o">+</span> <span class="n">olen</span> <span class="o">-</span> <span class="n">rest</span><span class="p">);</span>
	<span class="n">newcmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_JUMP</span><span class="p">);</span>
	<span class="n">newcmd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">nxtdsp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_PHASE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;newcmd[%d] %x %x %x %x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">newcmd</span> <span class="o">-</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">newcmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">newcmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">newcmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">newcmd</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	**	fake the return address (to the patch).</span>
<span class="cm">	**	and restart script processor at dispatcher.</span>
<span class="cm">	*/</span>
	<span class="n">OUTL</span> <span class="p">(</span><span class="n">nc_temp</span><span class="p">,</span> <span class="n">newtmp</span><span class="p">);</span>
	<span class="n">OUTL_DSP</span> <span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dispatch</span><span class="p">));</span>
	<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Unexpected phase changes that occurs when the current phase </span>
<span class="cm">	**	is not a DATA IN or DATA OUT phase are due to error conditions.</span>
<span class="cm">	**	Such event may only happen when the SCRIPTS is using a </span>
<span class="cm">	**	multibyte SCSI MOVE.</span>
<span class="cm">	**</span>
<span class="cm">	**	Phase change		Some possible cause</span>
<span class="cm">	**</span>
<span class="cm">	**	COMMAND  --&gt; MSG IN	SCSI parity error detected by target.</span>
<span class="cm">	**	COMMAND  --&gt; STATUS	Bad command or refused by target.</span>
<span class="cm">	**	MSG OUT  --&gt; MSG IN     Message rejected by target.</span>
<span class="cm">	**	MSG OUT  --&gt; COMMAND    Bogus target that discards extended</span>
<span class="cm">	**				negotiation messages.</span>
<span class="cm">	**</span>
<span class="cm">	**	The code below does not care of the new phase and so </span>
<span class="cm">	**	trusts the target. Why to annoy it ?</span>
<span class="cm">	**	If the interrupted phase is COMMAND phase, we restart at</span>
<span class="cm">	**	dispatcher.</span>
<span class="cm">	**	If a target does not get all the messages after selection, </span>
<span class="cm">	**	the code assumes blindly that the target discards extended </span>
<span class="cm">	**	messages and clears the negotiation status.</span>
<span class="cm">	**	If the target does not want all our response to negotiation,</span>
<span class="cm">	**	we force a SIR_NEGO_PROTO interrupt (it is a hack that avoids </span>
<span class="cm">	**	bloat for such a should_not_happen situation).</span>
<span class="cm">	**	In all other situation, we reset the BUS.</span>
<span class="cm">	**	Are these assumptions reasonable ? (Wait and see ...)</span>
<span class="cm">	*/</span>
<span class="nl">unexpected_phase:</span>
	<span class="n">dsp</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">nxtdsp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">2</span>:	<span class="cm">/* COMMAND phase */</span>
		<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dispatch</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	case 3:	/* STATUS  phase */</span>
<span class="c">		nxtdsp = NCB_SCRIPT_PHYS (np, dispatch);</span>
<span class="c">		break;</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="mi">6</span>:	<span class="cm">/* MSG OUT phase */</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth</span><span class="o">-&gt;</span><span class="n">nxtdsp_go_on</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">dsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span>	<span class="p">(</span><span class="n">dsp</span> <span class="o">==</span> <span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">send_ident</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">=</span> <span class="n">HS_BUSY</span><span class="p">;</span>
			<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">clratn_go_on</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">dsp</span> <span class="o">==</span> <span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">send_wdtr</span><span class="p">)</span> <span class="o">||</span>
			 <span class="n">dsp</span> <span class="o">==</span> <span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">send_sdtr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nego_bad_phase</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	case 7:	/* MSG IN  phase */</span>
<span class="c">		nxtdsp = NCB_SCRIPT_PHYS (np, clrack);</span>
<span class="c">		break;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nxtdsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTL_DSP</span> <span class="p">(</span><span class="n">nxtdsp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">reset_all:</span>
	<span class="n">ncr_start_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_sir_to_redo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span>	<span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="n">lp</span>	<span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">qp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span>	<span class="n">cp2</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">disc_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">busy_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">startp</span><span class="p">;</span>
	<span class="n">u_char</span>		<span class="n">s_status</span> <span class="o">=</span> <span class="n">INB</span> <span class="p">(</span><span class="n">SS_PRT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Let the SCRIPTS processor skip all not yet started CCBs,</span>
<span class="cm">	**	and count disconnected CCBs. Since the busy queue is in </span>
<span class="cm">	**	the same order as the chip start queue, disconnected CCBs </span>
<span class="cm">	**	are before cp and busy ones after.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qp</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">qp</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cp2</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span><span class="p">,</span> <span class="n">link_ccbq</span><span class="p">);</span>
			<span class="n">qp</span>  <span class="o">=</span> <span class="n">qp</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
			<span class="o">++</span><span class="n">busy_cnt</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp2</span> <span class="o">==</span> <span class="n">cp</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">cp2</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">.</span><span class="n">schedule</span><span class="p">.</span><span class="n">l_paddr</span> <span class="o">=</span>
			<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">skip</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">held_ccb</span> <span class="o">=</span> <span class="n">cp</span><span class="p">;</span>	<span class="cm">/* Requeue when this one completes */</span>
		<span class="n">disc_cnt</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">queuedccbs</span> <span class="o">-</span> <span class="n">busy_cnt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">s_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>	<span class="cm">/* Just for safety, should never happen */</span>
	<span class="k">case</span> <span class="n">S_QUEUE_FULL</span>:
		<span class="cm">/*</span>
<span class="cm">		**	Decrease number of tags to the number of </span>
<span class="cm">		**	disconnected commands.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;QUEUE FULL! %d busy, %d disconnected &quot;</span>
					<span class="s">&quot;CCBs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">busy_cnt</span><span class="p">,</span> <span class="n">disc_cnt</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">disc_cnt</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">numtags</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">numtags</span>	<span class="o">=</span> <span class="n">disc_cnt</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">?</span> <span class="n">disc_cnt</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">num_good</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ncr_setup_tags</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		**	Requeue the command to the start queue.</span>
<span class="cm">		**	If any disconnected commands,</span>
<span class="cm">		**		Clear SIGP.</span>
<span class="cm">		**		Jump to reselect.</span>
<span class="cm">		*/</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">savep</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">startp</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">=</span> <span class="n">HS_BUSY</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">=</span> <span class="n">S_ILLEGAL</span><span class="p">;</span>

		<span class="n">ncr_put_start_queue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">disc_cnt</span><span class="p">)</span>
			<span class="n">INB</span> <span class="p">(</span><span class="n">nc_ctest2</span><span class="p">);</span>		<span class="cm">/* Clear SIGP */</span>
		<span class="n">OUTL_DSP</span> <span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">reselect</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_TERMINATED</span>:
	<span class="k">case</span> <span class="n">S_CHECK_COND</span>:
		<span class="cm">/*</span>
<span class="cm">		**	If we were requesting sense, give up.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">auto_sense</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		**	Device returned CHECK CONDITION status.</span>
<span class="cm">		**	Prepare all needed data strutures for getting </span>
<span class="cm">		**	sense data.</span>
<span class="cm">		**</span>
<span class="cm">		**	identify message</span>
<span class="cm">		*/</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_smsg2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">IDENTIFY</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">smsg</span><span class="p">.</span><span class="n">addr</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">CCB_PHYS</span> <span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">scsi_smsg2</span><span class="p">));</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">smsg</span><span class="p">.</span><span class="n">size</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		**	sense command</span>
<span class="cm">		*/</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">addr</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">CCB_PHYS</span> <span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">sensecmd</span><span class="p">));</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">size</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		**	patch requested size into sense command</span>
<span class="cm">		*/</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">sensecmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>		<span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">sensecmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>		<span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">sensecmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">sense_buf</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		**	sense data</span>
<span class="cm">		*/</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">sense_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">sense_buf</span><span class="p">));</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">sense</span><span class="p">.</span><span class="n">addr</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">CCB_PHYS</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span><span class="n">sense_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">sense</span><span class="p">.</span><span class="n">size</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">sense_buf</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		**	requeue the command.</span>
<span class="cm">		*/</span>
		<span class="n">startp</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">sdata_in</span><span class="p">));</span>

		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">savep</span>	<span class="o">=</span> <span class="n">startp</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">goalp</span>	<span class="o">=</span> <span class="n">startp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">lastp</span>	<span class="o">=</span> <span class="n">startp</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wgoalp</span>	<span class="o">=</span> <span class="n">startp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wlastp</span>	<span class="o">=</span> <span class="n">startp</span><span class="p">;</span>

		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">=</span> <span class="n">HS_BUSY</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">=</span> <span class="n">S_ILLEGAL</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">auto_sense</span>	<span class="o">=</span> <span class="n">s_status</span><span class="p">;</span>

		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">.</span><span class="n">schedule</span><span class="p">.</span><span class="n">l_paddr</span> <span class="o">=</span>
			<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">select</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		**	Select without ATN for quirky devices.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">select_no_atn</span><span class="p">)</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">.</span><span class="n">schedule</span><span class="p">.</span><span class="n">l_paddr</span> <span class="o">=</span>
			<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">select_no_atn</span><span class="p">));</span>

		<span class="n">ncr_put_start_queue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>

		<span class="n">OUTL_DSP</span> <span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">start</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">OUTONB_STD</span> <span class="p">();</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**      ncr chip exception handler for programmed interrupts.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="kt">void</span> <span class="nf">ncr_int_sir</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span> <span class="n">scntl3</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">chg</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="n">fak</span><span class="p">,</span> <span class="n">wide</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">num</span> <span class="o">=</span> <span class="n">INB</span> <span class="p">(</span><span class="n">nc_dsps</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u_long</span>	<span class="n">dsa</span>    <span class="o">=</span> <span class="n">INL</span> <span class="p">(</span><span class="n">nc_dsa</span><span class="p">);</span>
	<span class="n">u_char</span>	<span class="n">target</span> <span class="o">=</span> <span class="n">INB</span> <span class="p">(</span><span class="n">nc_sdid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span>     <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span> <span class="n">printk</span> <span class="p">(</span><span class="s">&quot;I#%d&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIR_INTFLY</span>:
		<span class="cm">/*</span>
<span class="cm">		**	This is used for HP Zalon/53c720 where INTFLY</span>
<span class="cm">		**	operation is currently broken.</span>
<span class="cm">		*/</span>
		<span class="n">ncr_wakeup_done</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
<span class="cp">#ifdef SCSI_NCR_CCB_DONE_SUPPORT</span>
		<span class="n">OUTL</span><span class="p">(</span><span class="n">nc_dsp</span><span class="p">,</span> <span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">done_end</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">OUTL</span><span class="p">(</span><span class="n">nc_dsp</span><span class="p">,</span> <span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">start</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIR_RESEL_NO_MSG_IN</span>:
	<span class="k">case</span> <span class="n">SIR_RESEL_NO_IDENTIFY</span>:
		<span class="cm">/*</span>
<span class="cm">		**	If devices reselecting without sending an IDENTIFY </span>
<span class="cm">		**	message still exist, this should help.</span>
<span class="cm">		**	We just assume lun=0, 1 CCB, no tag.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span> 
			<span class="n">OUTL_DSP</span> <span class="p">(</span><span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">jump_ccb</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">SIR_RESEL_BAD_TARGET</span>:	<span class="cm">/* Will send a TARGET RESET message */</span>
	<span class="k">case</span> <span class="n">SIR_RESEL_BAD_LUN</span>:		<span class="cm">/* Will send a TARGET RESET message */</span>
	<span class="k">case</span> <span class="n">SIR_RESEL_BAD_I_T_L_Q</span>:	<span class="cm">/* Will send an ABORT TAG message   */</span>
	<span class="k">case</span> <span class="n">SIR_RESEL_BAD_I_T_L</span>:	<span class="cm">/* Will send an ABORT message	    */</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s:%d: SIR %d, &quot;</span>
			<span class="s">&quot;incorrect nexus identification on reselection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ncr_name</span> <span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">target</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIR_DONE_OVERFLOW</span>:
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s:%d: SIR %d, &quot;</span>
			<span class="s">&quot;CCB done queue overflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ncr_name</span> <span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">target</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIR_BAD_STATUS</span>:
		<span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span> <span class="o">||</span> <span class="n">CCB_PHYS</span> <span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">phys</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dsa</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">ncr_sir_to_redo</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/*</span>
<span class="cm">		**	lookup the ccb</span>
<span class="cm">		*/</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">CCB_PHYS</span> <span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">phys</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dsa</span><span class="p">))</span>
			<span class="n">cp</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccb</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cp</span> <span class="o">!=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span> <span class="o">||</span> <span class="n">cp</span> <span class="o">!=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
<span class="cm">/*-----------------------------------------------------------------------------</span>
<span class="cm">**</span>
<span class="cm">**	Was Sie schon immer ueber transfermode negotiation wissen wollten ...</span>
<span class="cm">**	(&quot;Everything you&#39;ve always wanted to know about transfer mode</span>
<span class="cm">**	  negotiation&quot;)</span>
<span class="cm">**</span>
<span class="cm">**	We try to negotiate sync and wide transfer only after</span>
<span class="cm">**	a successful inquire command. We look at byte 7 of the</span>
<span class="cm">**	inquire data to determine the capabilities of the target.</span>
<span class="cm">**</span>
<span class="cm">**	When we try to negotiate, we append the negotiation message</span>
<span class="cm">**	to the identify and (maybe) simple tag message.</span>
<span class="cm">**	The host status field is set to HS_NEGOTIATE to mark this</span>
<span class="cm">**	situation.</span>
<span class="cm">**</span>
<span class="cm">**	If the target doesn&#39;t answer this message immediately</span>
<span class="cm">**	(as required by the standard), the SIR_NEGO_FAIL interrupt</span>
<span class="cm">**	will be raised eventually.</span>
<span class="cm">**	The handler removes the HS_NEGOTIATE status, and sets the</span>
<span class="cm">**	negotiated value to the default (async / nowide).</span>
<span class="cm">**</span>
<span class="cm">**	If we receive a matching answer immediately, we check it</span>
<span class="cm">**	for validity, and set the values.</span>
<span class="cm">**</span>
<span class="cm">**	If we receive a Reject message immediately, we assume the</span>
<span class="cm">**	negotiation has failed, and fall back to standard values.</span>
<span class="cm">**</span>
<span class="cm">**	If we receive a negotiation message while not in HS_NEGOTIATE</span>
<span class="cm">**	state, it&#39;s a target initiated negotiation. We prepare a</span>
<span class="cm">**	(hopefully) valid answer, set our parameters, and send back </span>
<span class="cm">**	this answer to the target.</span>
<span class="cm">**</span>
<span class="cm">**	If the target doesn&#39;t fetch the answer (no message out phase),</span>
<span class="cm">**	we assume the negotiation has failed, and fall back to default</span>
<span class="cm">**	settings.</span>
<span class="cm">**</span>
<span class="cm">**	When we set the values, we adjust them in all ccbs belonging </span>
<span class="cm">**	to this target, in the controller&#39;s register, and in the &quot;phys&quot;</span>
<span class="cm">**	field of the controller&#39;s struct ncb.</span>
<span class="cm">**</span>
<span class="cm">**	Possible cases:		   hs  sir   msg_in value  send   goto</span>
<span class="cm">**	We try to negotiate:</span>
<span class="cm">**	-&gt; target doesn&#39;t msgin    NEG FAIL  noop   defa.  -      dispatch</span>
<span class="cm">**	-&gt; target rejected our msg NEG FAIL  reject defa.  -      dispatch</span>
<span class="cm">**	-&gt; target answered  (ok)   NEG SYNC  sdtr   set    -      clrack</span>
<span class="cm">**	-&gt; target answered (!ok)   NEG SYNC  sdtr   defa.  REJ---&gt;msg_bad</span>
<span class="cm">**	-&gt; target answered  (ok)   NEG WIDE  wdtr   set    -      clrack</span>
<span class="cm">**	-&gt; target answered (!ok)   NEG WIDE  wdtr   defa.  REJ---&gt;msg_bad</span>
<span class="cm">**	-&gt; any other msgin	   NEG FAIL  noop   defa.  -      dispatch</span>
<span class="cm">**</span>
<span class="cm">**	Target tries to negotiate:</span>
<span class="cm">**	-&gt; incoming message	   --- SYNC  sdtr   set    SDTR   -</span>
<span class="cm">**	-&gt; incoming message	   --- WIDE  wdtr   set    WDTR   -</span>
<span class="cm">**      We sent our answer:</span>
<span class="cm">**	-&gt; target doesn&#39;t msgout   --- PROTO ?      defa.  -      dispatch</span>
<span class="cm">**</span>
<span class="cm">**-----------------------------------------------------------------------------</span>
<span class="cm">*/</span>

	<span class="k">case</span> <span class="n">SIR_NEGO_FAILED</span>:
		<span class="cm">/*-------------------------------------------------------</span>
<span class="cm">		**</span>
<span class="cm">		**	Negotiation failed.</span>
<span class="cm">		**	Target doesn&#39;t send an answer message,</span>
<span class="cm">		**	or target rejected our message.</span>
<span class="cm">		**</span>
<span class="cm">		**      Remove negotiation request.</span>
<span class="cm">		**</span>
<span class="cm">		**-------------------------------------------------------</span>
<span class="cm">		*/</span>
		<span class="n">OUTB</span> <span class="p">(</span><span class="n">HS_PRT</span><span class="p">,</span> <span class="n">HS_BUSY</span><span class="p">);</span>

		<span class="cm">/* fall through */</span>

	<span class="k">case</span> <span class="n">SIR_NEGO_PROTO</span>:
		<span class="cm">/*-------------------------------------------------------</span>
<span class="cm">		**</span>
<span class="cm">		**	Negotiation failed.</span>
<span class="cm">		**	Target doesn&#39;t fetch the answer message.</span>
<span class="cm">		**</span>
<span class="cm">		**-------------------------------------------------------</span>
<span class="cm">		*/</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;negotiation failed sir=%x &quot;</span>
					<span class="s">&quot;status=%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		**	any error in negotiation:</span>
<span class="cm">		**	fall back to default mode.</span>
<span class="cm">		*/</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">NS_SYNC</span>:
			<span class="n">spi_period</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spi_offset</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ncr_setsync</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xe0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">NS_WIDE</span>:
			<span class="n">spi_width</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ncr_setwide</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOP</span><span class="p">;</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOP</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIR_NEGO_SYNC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ncr_print_msg</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="s">&quot;sync msgin&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">chg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">per</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="n">ofs</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">per</span><span class="o">=</span><span class="mi">255</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		**      if target sends SDTR message,</span>
<span class="cm">		**	      it CAN transfer synch.</span>
<span class="cm">		*/</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;&amp;</span> <span class="n">starget</span><span class="p">)</span>
			<span class="n">spi_support_sync</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		**	check values against driver limits.</span>
<span class="cm">		*/</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">per</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">)</span>
			<span class="p">{</span><span class="n">chg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">per</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">;}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">per</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">)</span>
			<span class="p">{</span><span class="n">chg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">per</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">;}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">)</span>
			<span class="p">{</span><span class="n">chg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">;}</span>

		<span class="cm">/*</span>
<span class="cm">		**	Check against controller limits.</span>
<span class="cm">		*/</span>
		<span class="n">fak</span>	<span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">scntl3</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ncr_getsync</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fak</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scntl3</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fak</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">chg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fak</span>	<span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
			<span class="n">per</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">scntl3</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;sync: per=%d scntl3=0x%x ofs=%d &quot;</span>
				<span class="s">&quot;fak=%d chg=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="n">scntl3</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">fak</span><span class="p">,</span> <span class="n">chg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">INB</span> <span class="p">(</span><span class="n">HS_PRT</span><span class="p">)</span> <span class="o">==</span> <span class="n">HS_NEGOTIATE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">OUTB</span> <span class="p">(</span><span class="n">HS_PRT</span><span class="p">,</span> <span class="n">HS_BUSY</span><span class="p">);</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">case</span> <span class="n">NS_SYNC</span>:
				<span class="cm">/* This was an answer message */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">chg</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Answer wasn&#39;t acceptable.  */</span>
					<span class="n">spi_period</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">spi_offset</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">ncr_setsync</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xe0</span><span class="p">);</span>
					<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">msg_bad</span><span class="p">));</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* Answer is ok.  */</span>
					<span class="n">spi_period</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">per</span><span class="p">;</span>
					<span class="n">spi_offset</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">ofs</span><span class="p">;</span>
					<span class="n">ncr_setsync</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">scntl3</span><span class="p">,</span> <span class="p">(</span><span class="n">fak</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">)</span><span class="o">|</span><span class="n">ofs</span><span class="p">);</span>
					<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">clrack</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="k">return</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">NS_WIDE</span>:
				<span class="n">spi_width</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ncr_setwide</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		**	It was a request. Set value and</span>
<span class="cm">		**      prepare an answer message</span>
<span class="cm">		*/</span>

		<span class="n">spi_period</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">per</span><span class="p">;</span>
		<span class="n">spi_offset</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="n">ncr_setsync</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">scntl3</span><span class="p">,</span> <span class="p">(</span><span class="n">fak</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">)</span><span class="o">|</span><span class="n">ofs</span><span class="p">);</span>

		<span class="n">spi_populate_sync_msg</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">=</span> <span class="n">NS_SYNC</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ncr_print_msg</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="s">&quot;sync msgout&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ofs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">OUTL_DSP</span> <span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">msg_bad</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOP</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIR_NEGO_WIDE</span>:
		<span class="cm">/*</span>
<span class="cm">		**	Wide request message received.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ncr_print_msg</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="s">&quot;wide msgin&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		**	get requested values.</span>
<span class="cm">		*/</span>

		<span class="n">chg</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wide</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		**      if target sends WDTR message,</span>
<span class="cm">		**	      it CAN transfer wide.</span>
<span class="cm">		*/</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wide</span> <span class="o">&amp;&amp;</span> <span class="n">starget</span><span class="p">)</span>
			<span class="n">spi_support_wide</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		**	check values against driver limits.</span>
<span class="cm">		*/</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wide</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrwide</span><span class="p">)</span>
			<span class="p">{</span><span class="n">chg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">wide</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrwide</span><span class="p">;}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;wide: wide=%d chg=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wide</span><span class="p">,</span>
					<span class="n">chg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">INB</span> <span class="p">(</span><span class="n">HS_PRT</span><span class="p">)</span> <span class="o">==</span> <span class="n">HS_NEGOTIATE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">OUTB</span> <span class="p">(</span><span class="n">HS_PRT</span><span class="p">,</span> <span class="n">HS_BUSY</span><span class="p">);</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">case</span> <span class="n">NS_WIDE</span>:
				<span class="cm">/*</span>
<span class="cm">				**      This was an answer message</span>
<span class="cm">				*/</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">chg</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Answer wasn&#39;t acceptable.  */</span>
					<span class="n">spi_width</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">ncr_setwide</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
					<span class="n">OUTL_DSP</span> <span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">msg_bad</span><span class="p">));</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* Answer is ok.  */</span>
					<span class="n">spi_width</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">wide</span><span class="p">;</span>
					<span class="n">ncr_setwide</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">wide</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
					<span class="n">OUTL_DSP</span> <span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">clrack</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="k">return</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">NS_SYNC</span>:
				<span class="n">spi_period</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">spi_offset</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ncr_setsync</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xe0</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		**	It was a request, set value and</span>
<span class="cm">		**      prepare an answer message</span>
<span class="cm">		*/</span>

		<span class="n">spi_width</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">wide</span><span class="p">;</span>
		<span class="n">ncr_setwide</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">wide</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">spi_populate_width_msg</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">,</span> <span class="n">wide</span><span class="p">);</span>

		<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOP</span><span class="p">;</span>

		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">=</span> <span class="n">NS_WIDE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ncr_print_msg</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="s">&quot;wide msgout&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

<span class="cm">/*--------------------------------------------------------------------</span>
<span class="cm">**</span>
<span class="cm">**	Processing of special messages</span>
<span class="cm">**</span>
<span class="cm">**--------------------------------------------------------------------</span>
<span class="cm">*/</span>

	<span class="k">case</span> <span class="n">SIR_REJECT_RECEIVED</span>:
		<span class="cm">/*-----------------------------------------------</span>
<span class="cm">		**</span>
<span class="cm">		**	We received a MESSAGE_REJECT.</span>
<span class="cm">		**</span>
<span class="cm">		**-----------------------------------------------</span>
<span class="cm">		*/</span>

		<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;MESSAGE_REJECT received (%x:%x).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lastmsg</span><span class="p">),</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIR_REJECT_SENT</span>:
		<span class="cm">/*-----------------------------------------------</span>
<span class="cm">		**</span>
<span class="cm">		**	We received an unknown message</span>
<span class="cm">		**</span>
<span class="cm">		**-----------------------------------------------</span>
<span class="cm">		*/</span>

		<span class="n">ncr_print_msg</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="s">&quot;MESSAGE_REJECT sent for&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

<span class="cm">/*--------------------------------------------------------------------</span>
<span class="cm">**</span>
<span class="cm">**	Processing of special messages</span>
<span class="cm">**</span>
<span class="cm">**--------------------------------------------------------------------</span>
<span class="cm">*/</span>

	<span class="k">case</span> <span class="n">SIR_IGN_RESIDUE</span>:
		<span class="cm">/*-----------------------------------------------</span>
<span class="cm">		**</span>
<span class="cm">		**	We received an IGNORE RESIDUE message,</span>
<span class="cm">		**	which couldn&#39;t be handled by the script.</span>
<span class="cm">		**</span>
<span class="cm">		**-----------------------------------------------</span>
<span class="cm">		*/</span>

		<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;IGNORE_WIDE_RESIDUE received, but not yet &quot;</span>
				<span class="s">&quot;implemented.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	case SIR_MISSING_SAVE:</span>
<span class="c">		/*-----------------------------------------------</span>
<span class="c">		**</span>
<span class="c">		**	We received an DISCONNECT message,</span>
<span class="c">		**	but the datapointer wasn&#39;t saved before.</span>
<span class="c">		**</span>
<span class="c">		**-----------------------------------------------</span>
<span class="c">		*/</span>

<span class="c">		PRINT_ADDR(cp-&gt;cmd, &quot;DISCONNECT received, but datapointer &quot;</span>
<span class="c">				&quot;not saved: data=%x save=%x goal=%x.\n&quot;,</span>
<span class="c">			(unsigned) INL (nc_temp),</span>
<span class="c">			(unsigned) scr_to_cpu(np-&gt;header.savep),</span>
<span class="c">			(unsigned) scr_to_cpu(np-&gt;header.goalp));</span>
<span class="c">		break;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">OUTONB_STD</span> <span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	Acquire a control block</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="nf">ncr_get_ccb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span> <span class="n">tn</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">ln</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">tn</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="n">ln</span><span class="p">];</span>
	<span class="n">u_char</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">NO_TAG</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Lun structure available ?</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">qp</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		**	Keep from using more tags than we can handle.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">usetags</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">busyccbs</span> <span class="o">&gt;=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">maxnxs</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		**	Allocate a new CCB if needed.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">free_ccbq</span><span class="p">))</span>
			<span class="n">ncr_alloc_ccb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">ln</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		**	Look for free CCB</span>
<span class="cm">		*/</span>
		<span class="n">qp</span> <span class="o">=</span> <span class="n">ncr_list_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">free_ccbq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span><span class="p">,</span> <span class="n">link_ccbq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;ccb free list corrupted &quot;</span>
						<span class="s">&quot;(@%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
				<span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">list_add_tail</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">wait_ccbq</span><span class="p">);</span>
				<span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busyccbs</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		**	If a CCB is available,</span>
<span class="cm">		**	Get a tag for this nexus if required.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">usetags</span><span class="p">)</span>
				<span class="n">tag</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cb_tags</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">ia_tag</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">actccbs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	if nothing available, take the default.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Wait until available.</span>
<span class="cm">	*/</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	while (cp-&gt;magic) {</span>
<span class="c">		if (flags &amp; SCSI_NOSLEEP) break;</span>
<span class="c">		if (tsleep ((caddr_t)cp, PRIBIO|PCATCH, &quot;ncr&quot;, 0))</span>
<span class="c">			break;</span>
<span class="c">	}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Move to next available tag if tag used.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">NO_TAG</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">ia_tag</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">ia_tag</span> <span class="o">==</span> <span class="n">MAX_TAGS</span><span class="p">)</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">ia_tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_umap</span> <span class="o">|=</span> <span class="p">(((</span><span class="n">tagmap_t</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">tag</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Remember all informations needed to free this CCB.</span>
<span class="cm">	*/</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span>	   <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">tn</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span>    <span class="o">=</span> <span class="n">ln</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TAGS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;ccb @%p using tag %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	Release one control block</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_free_ccb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TAGS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PRINT_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;ccb @%p freeing tag %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	If lun control block available,</span>
<span class="cm">	**	decrement active commands and increment credit, </span>
<span class="cm">	**	free the tag if any and remove the JUMP for reselect.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">NO_TAG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cb_tags</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">if_tag</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">if_tag</span> <span class="o">==</span> <span class="n">MAX_TAGS</span><span class="p">)</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">if_tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_umap</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(((</span><span class="n">tagmap_t</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_smap</span> <span class="o">&amp;=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_umap</span><span class="p">;</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPTH_PHYS</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">bad_i_t_l_q</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPTH_PHYS</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">bad_i_t_l</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Make this CCB available.</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">!=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">)</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">free_ccbq</span><span class="p">);</span>
		<span class="o">--</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busyccbs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">--</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">queuedccbs</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cp</span> <span class="o">-&gt;</span> <span class="n">host_status</span> <span class="o">=</span> <span class="n">HS_IDLE</span><span class="p">;</span>
	<span class="n">cp</span> <span class="o">-&gt;</span> <span class="n">magic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">--</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">queuedccbs</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	if (cp == np-&gt;ccb)</span>
<span class="c">		wakeup ((caddr_t) cp);</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cp">#define ncr_reg_bus_addr(r) (np-&gt;paddr + offsetof (struct ncr_reg, r))</span>

<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm">**	Initialize the fixed part of a CCB structure.</span>
<span class="cm">**------------------------------------------------------------------------</span>
<span class="cm">**------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_init_ccb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ncrcmd</span> <span class="n">copy_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_PFEN</span> <span class="o">?</span> <span class="n">SCR_COPY</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">:</span> <span class="n">SCR_COPY_F</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Remember virtual and bus address of this ccb.</span>
<span class="cm">	*/</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">p_ccb</span> 	   <span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">cp</span> <span class="o">=</span> <span class="n">cp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	This allows list_del to work for the default ccb.</span>
<span class="cm">	*/</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Initialyze the start and restart launch script.</span>
<span class="cm">	**</span>
<span class="cm">	**	COPY(4) @(...p_phys), @(dsa)</span>
<span class="cm">	**	JUMP @(sched_point)</span>
<span class="cm">	*/</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">.</span><span class="n">setup_dsa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	 <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">copy_4</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">.</span><span class="n">setup_dsa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>	 <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">CCB_PHYS</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">start</span><span class="p">.</span><span class="n">p_phys</span><span class="p">));</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">.</span><span class="n">setup_dsa</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>	 <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">ncr_reg_bus_addr</span><span class="p">(</span><span class="n">nc_dsa</span><span class="p">));</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">.</span><span class="n">schedule</span><span class="p">.</span><span class="n">l_cmd</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_JUMP</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">.</span><span class="n">p_phys</span>	 <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">CCB_PHYS</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">phys</span><span class="p">));</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">restart</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">restart</span><span class="p">));</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">.</span><span class="n">schedule</span><span class="p">.</span><span class="n">l_paddr</span>   <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">idle</span><span class="p">));</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">restart</span><span class="p">.</span><span class="n">schedule</span><span class="p">.</span><span class="n">l_paddr</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">abort</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm">**	Allocate a CCB and initialize its fixed part.</span>
<span class="cm">**------------------------------------------------------------------------</span>
<span class="cm">**------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_alloc_ccb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tn</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">ln</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">tn</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="n">ln</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Allocate memory for this CCB.</span>
<span class="cm">	*/</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">m_calloc_dma</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccb</span><span class="p">),</span> <span class="s">&quot;CCB&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Count it and initialyze it.</span>
<span class="cm">	*/</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">actccbs</span><span class="o">++</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">actccbs</span><span class="o">++</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="p">));</span>
	<span class="n">ncr_init_ccb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Chain into wakeup list and free ccb queue and take it </span>
<span class="cm">	**	into account for tagged commands.</span>
<span class="cm">	*/</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccb</span>      <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">link_ccb</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">link_ccb</span> <span class="o">=</span> <span class="n">cp</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">free_ccbq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**      Allocation of resources for Targets/Luns/Tags.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm">**	Target control block initialisation.</span>
<span class="cm">**------------------------------------------------------------------------</span>
<span class="cm">**	This data structure is fully initialized after a SCSI command </span>
<span class="cm">**	has been successfully completed for this target.</span>
<span class="cm">**	It contains a SCRIPT that is called on target reselection.</span>
<span class="cm">**------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ncr_init_tcb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">tn</span><span class="p">];</span>
	<span class="n">ncrcmd</span> <span class="n">copy_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_PFEN</span> <span class="o">?</span> <span class="n">SCR_COPY</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">SCR_COPY_F</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">th</span> <span class="o">=</span> <span class="n">tn</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Jump to next tcb if SFBR does not match this target.</span>
<span class="cm">	**	JUMP  IF (SFBR != #target#), @(next tcb)</span>
<span class="cm">	*/</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">jump_tcb</span><span class="p">.</span><span class="n">l_cmd</span>   <span class="o">=</span>
		<span class="n">cpu_to_scr</span><span class="p">((</span><span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="mh">0x80</span> <span class="o">+</span> <span class="n">tn</span><span class="p">))));</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">jump_tcb</span><span class="p">.</span><span class="n">l_paddr</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">jump_tcb</span><span class="p">[</span><span class="n">th</span><span class="p">].</span><span class="n">l_paddr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Load the synchronous transfer register.</span>
<span class="cm">	**	COPY @(tp-&gt;sval), @(sxfer)</span>
<span class="cm">	*/</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">getscr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>	<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">copy_1</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">getscr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">sval</span><span class="p">));</span>
<span class="cp">#ifdef SCSI_NCR_BIG_ENDIAN</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">getscr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">ncr_reg_bus_addr</span><span class="p">(</span><span class="n">nc_sxfer</span><span class="p">)</span> <span class="o">^</span> <span class="mi">3</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">getscr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">ncr_reg_bus_addr</span><span class="p">(</span><span class="n">nc_sxfer</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	**	Load the timing register.</span>
<span class="cm">	**	COPY @(tp-&gt;wval), @(scntl3)</span>
<span class="cm">	*/</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">getscr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span>	<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">copy_1</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">getscr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">wval</span><span class="p">));</span>
<span class="cp">#ifdef SCSI_NCR_BIG_ENDIAN</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">getscr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">ncr_reg_bus_addr</span><span class="p">(</span><span class="n">nc_scntl3</span><span class="p">)</span> <span class="o">^</span> <span class="mi">3</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">getscr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">ncr_reg_bus_addr</span><span class="p">(</span><span class="n">nc_scntl3</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	**	Get the IDENTIFY message and the lun.</span>
<span class="cm">	**	CALL @script(resel_lun)</span>
<span class="cm">	*/</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">call_lun</span><span class="p">.</span><span class="n">l_cmd</span>   <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_CALL</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">call_lun</span><span class="p">.</span><span class="n">l_paddr</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">resel_lun</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	**	Look for the lun control block of this nexus.</span>
<span class="cm">	**	For i = 0 to 3</span>
<span class="cm">	**		JUMP ^ IFTRUE (MASK (i, 3)), @(next_lcb)</span>
<span class="cm">	*/</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">jump_lcb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">l_cmd</span>   <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">((</span><span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">))));</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">jump_lcb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">l_paddr</span> <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">bad_identify</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Link this target control block to the JUMP chain.</span>
<span class="cm">	*/</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">jump_tcb</span><span class="p">[</span><span class="n">th</span><span class="p">].</span><span class="n">l_paddr</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">jump_tcb</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	**	These assert&#39;s should be moved at driver initialisations.</span>
<span class="cm">	*/</span>
<span class="cp">#ifdef SCSI_NCR_BIG_ENDIAN</span>
	<span class="n">BUG_ON</span><span class="p">(((</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncr_reg</span><span class="p">,</span> <span class="n">nc_sxfer</span><span class="p">)</span> <span class="o">^</span>
		 <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcb</span>    <span class="p">,</span> <span class="n">sval</span>    <span class="p">))</span> <span class="o">&amp;</span><span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(((</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncr_reg</span><span class="p">,</span> <span class="n">nc_scntl3</span><span class="p">)</span> <span class="o">^</span>
		 <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcb</span>    <span class="p">,</span> <span class="n">wval</span>    <span class="p">))</span> <span class="o">&amp;</span><span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">BUG_ON</span><span class="p">(((</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncr_reg</span><span class="p">,</span> <span class="n">nc_sxfer</span><span class="p">)</span> <span class="o">^</span>
		 <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcb</span>    <span class="p">,</span> <span class="n">sval</span>    <span class="p">))</span> <span class="o">&amp;</span><span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(((</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncr_reg</span><span class="p">,</span> <span class="n">nc_scntl3</span><span class="p">)</span> <span class="o">^</span>
		 <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcb</span>    <span class="p">,</span> <span class="n">wval</span>    <span class="p">))</span> <span class="o">&amp;</span><span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm">**	Lun control block allocation and initialization.</span>
<span class="cm">**------------------------------------------------------------------------</span>
<span class="cm">**	This data structure is allocated and initialized after a SCSI </span>
<span class="cm">**	command has been successfully completed for this target/lun.</span>
<span class="cm">**------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="nf">ncr_alloc_lcb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tn</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">ln</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">tn</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="n">ln</span><span class="p">];</span>
	<span class="n">ncrcmd</span> <span class="n">copy_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_PFEN</span> <span class="o">?</span> <span class="n">SCR_COPY</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">:</span> <span class="n">SCR_COPY_F</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">lh</span> <span class="o">=</span> <span class="n">ln</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Already done, return.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">lp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Allocate the lcb.</span>
<span class="cm">	*/</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">m_calloc_dma</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lcb</span><span class="p">),</span> <span class="s">&quot;LCB&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="p">));</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="n">ln</span><span class="p">]</span> <span class="o">=</span> <span class="n">lp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	Initialize the target control block if not yet.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">jump_tcb</span><span class="p">.</span><span class="n">l_cmd</span><span class="p">)</span>
		<span class="n">ncr_init_tcb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tn</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Initialize the CCB queue headers.</span>
<span class="cm">	*/</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">free_ccbq</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">wait_ccbq</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">skip_ccbq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Set max CCBs to 1 and use the default 1 entry </span>
<span class="cm">	**	jump table by default.</span>
<span class="cm">	*/</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">maxnxs</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb_0</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">p_jump_ccb</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	**	Initilialyze the reselect script:</span>
<span class="cm">	**</span>
<span class="cm">	**	Jump to next lcb if SFBR does not match this lun.</span>
<span class="cm">	**	Load TEMP with the CCB direct jump table bus address.</span>
<span class="cm">	**	Get the SIMPLE TAG message and the tag.</span>
<span class="cm">	**</span>
<span class="cm">	**	JUMP  IF (SFBR != #lun#), @(next lcb)</span>
<span class="cm">	**	COPY @(lp-&gt;p_jump_ccb),	  @(temp)</span>
<span class="cm">	**	JUMP @script(resel_notag)</span>
<span class="cm">	*/</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_lcb</span><span class="p">.</span><span class="n">l_cmd</span>   <span class="o">=</span>
		<span class="n">cpu_to_scr</span><span class="p">((</span><span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="mh">0x80</span><span class="o">+</span><span class="n">ln</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">))));</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_lcb</span><span class="p">.</span><span class="n">l_paddr</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">jump_lcb</span><span class="p">[</span><span class="n">lh</span><span class="p">].</span><span class="n">l_paddr</span><span class="p">;</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">load_jump_ccb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">copy_4</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">load_jump_ccb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">p_jump_ccb</span><span class="p">));</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">load_jump_ccb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">ncr_reg_bus_addr</span><span class="p">(</span><span class="n">nc_temp</span><span class="p">));</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_tag</span><span class="p">.</span><span class="n">l_cmd</span>   <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_JUMP</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_tag</span><span class="p">.</span><span class="n">l_paddr</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPT_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">resel_notag</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	**	Link this lun control block to the JUMP chain.</span>
<span class="cm">	*/</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">jump_lcb</span><span class="p">[</span><span class="n">lh</span><span class="p">].</span><span class="n">l_paddr</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_lcb</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	**	Initialize command queuing control.</span>
<span class="cm">	*/</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">busyccbs</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">queuedccbs</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">queuedepth</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">lp</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm">**	Lun control block setup on INQUIRY data received.</span>
<span class="cm">**------------------------------------------------------------------------</span>
<span class="cm">**	We only support WIDE, SYNC for targets and CMDQ for logical units.</span>
<span class="cm">**	This setup is done on each INQUIRY since we are expecting user </span>
<span class="cm">**	will play with CHANGE DEFINITION commands. :-)</span>
<span class="cm">**------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="nf">ncr_setup_lcb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tn</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">ln</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">tn</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="n">ln</span><span class="p">];</span>

	<span class="cm">/* If no lcb, try to allocate it.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">lp</span> <span class="o">=</span> <span class="n">ncr_alloc_lcb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">ln</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	If unit supports tagged commands, allocate the </span>
<span class="cm">	**	CCB JUMP table if not yet.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb_0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb</span> <span class="o">=</span> <span class="n">m_calloc_dma</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="s">&quot;JUMP_CCB&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb_0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">p_jump_ccb</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb</span><span class="p">));</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">jump_ccb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">bad_i_t_l_q</span><span class="p">));</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_TAGS</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cb_tags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">maxnxs</span> <span class="o">=</span> <span class="n">MAX_TAGS</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_stime</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">HZ</span><span class="p">;</span>
		<span class="n">ncr_setup_tags</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">sdev</span><span class="p">);</span>
	<span class="p">}</span>


<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">lp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	Build Scatter Gather Block</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	The transfer area may be scattered among</span>
<span class="cm">**	several non adjacent physical pages.</span>
<span class="cm">**</span>
<span class="cm">**	We may use MAX_SCATTER blocks.</span>
<span class="cm">**</span>
<span class="cm">**----------------------------------------------------------</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">**	We try to reduce the number of interrupts caused</span>
<span class="cm">**	by unexpected phase changes due to disconnects.</span>
<span class="cm">**	A typical harddisk may disconnect before ANY block.</span>
<span class="cm">**	If we wanted to avoid unexpected phase changes at all</span>
<span class="cm">**	we had to use a break point every 512 bytes.</span>
<span class="cm">**	Of course the number of scatter/gather blocks is</span>
<span class="cm">**	limited.</span>
<span class="cm">**	Under Linux, the scatter/gatter blocks are provided by </span>
<span class="cm">**	the generic driver. We just have to copy addresses and </span>
<span class="cm">**	sizes to the data segment array.</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ncr_scatter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">segment</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_sg</span>	<span class="o">=</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">data_len</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">use_sg</span> <span class="o">=</span> <span class="n">map_scsi_sg_data</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_sg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">scr_tblmove</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">use_sg</span> <span class="o">&gt;</span> <span class="n">MAX_SCATTER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unmap_scsi_data</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">MAX_SCATTER</span> <span class="o">-</span> <span class="n">use_sg</span><span class="p">];</span>

		<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">,</span> <span class="n">segment</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_addr_t</span> <span class="n">baddr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>

			<span class="n">ncr_build_sge</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">segment</span><span class="p">],</span> <span class="n">baddr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">segment</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">segment</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**	Test the bus snoop logic :-(</span>
<span class="cm">**</span>
<span class="cm">**	Has to be called with interrupts disabled.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ncr_regtest</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span><span class="o">*</span> <span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="k">volatile</span> <span class="n">u32</span> <span class="n">data</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	**	ncr registers may NOT be cached.</span>
<span class="cm">	**	write 0xffffffff to a read only register area,</span>
<span class="cm">	**	and try to read it back.</span>
<span class="cm">	*/</span>
	<span class="n">data</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="n">OUTL_OFF</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncr_reg</span><span class="p">,</span> <span class="n">nc_dstat</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">INL_OFF</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncr_reg</span><span class="p">,</span> <span class="n">nc_dstat</span><span class="p">));</span>
<span class="cp">#if 1</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xe2f0fffd</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x02000080</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#endif</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;CACHE TEST FAILED: reg dstat-sstat2 readback %x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">ncr_snooptest</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span><span class="o">*</span> <span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">ncr_rd</span><span class="p">,</span> <span class="n">ncr_wr</span><span class="p">,</span> <span class="n">ncr_bk</span><span class="p">,</span> <span class="n">host_rd</span><span class="p">,</span> <span class="n">host_wr</span><span class="p">,</span> <span class="n">pc</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">ncr_regtest</span> <span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* init */</span>
	<span class="n">pc</span>  <span class="o">=</span> <span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">snooptest</span><span class="p">);</span>
	<span class="n">host_wr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ncr_wr</span>  <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	**	Set memory and register.</span>
<span class="cm">	*/</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">ncr_cache</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">host_wr</span><span class="p">);</span>
	<span class="n">OUTL</span> <span class="p">(</span><span class="n">nc_temp</span><span class="p">,</span> <span class="n">ncr_wr</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	**	Start script (exchange values)</span>
<span class="cm">	*/</span>
	<span class="n">OUTL_DSP</span> <span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	**	Wait &#39;til done (with timeout)</span>
<span class="cm">	*/</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NCR_SNOOP_TIMEOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">nc_istat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INTF</span><span class="o">|</span><span class="n">SIP</span><span class="o">|</span><span class="n">DIP</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	**	Save termination position.</span>
<span class="cm">	*/</span>
	<span class="n">pc</span> <span class="o">=</span> <span class="n">INL</span> <span class="p">(</span><span class="n">nc_dsp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	**	Read memory and register.</span>
<span class="cm">	*/</span>
	<span class="n">host_rd</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ncr_cache</span><span class="p">);</span>
	<span class="n">ncr_rd</span>  <span class="o">=</span> <span class="n">INL</span> <span class="p">(</span><span class="n">nc_scratcha</span><span class="p">);</span>
	<span class="n">ncr_bk</span>  <span class="o">=</span> <span class="n">INL</span> <span class="p">(</span><span class="n">nc_temp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	**	Reset ncr chip</span>
<span class="cm">	*/</span>
	<span class="n">ncr_chip_reset</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	**	check for timeout</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">NCR_SNOOP_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;CACHE TEST FAILED: timeout.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mh">0x20</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	**	Check termination position.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pc</span> <span class="o">!=</span> <span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">snoopend</span><span class="p">)</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;CACHE TEST FAILED: script execution failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;start=%08lx, pc=%08lx, end=%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">snooptest</span><span class="p">),</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">pc</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">snoopend</span><span class="p">)</span> <span class="o">+</span><span class="mi">8</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mh">0x40</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	**	Show results.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_wr</span> <span class="o">!=</span> <span class="n">ncr_rd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;CACHE TEST FAILED: host wrote %d, ncr read %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">host_wr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">ncr_rd</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_rd</span> <span class="o">!=</span> <span class="n">ncr_wr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;CACHE TEST FAILED: ncr wrote %d, host read %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">ncr_wr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">host_rd</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ncr_bk</span> <span class="o">!=</span> <span class="n">ncr_wr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;CACHE TEST FAILED: ncr wrote %d, read back %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">ncr_wr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">ncr_bk</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Determine the ncr&#39;s clock frequency.</span>
<span class="cm">**	This is essential for the negotiation</span>
<span class="cm">**	of the synchronous transfer rate.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Note: we have to return the correct value.</span>
<span class="cm">**	THERE IS NO SAFE DEFAULT VALUE.</span>
<span class="cm">**</span>
<span class="cm">**	Most NCR/SYMBIOS boards are delivered with a 40 Mhz clock.</span>
<span class="cm">**	53C860 and 53C875 rev. 1 support fast20 transfers but </span>
<span class="cm">**	do not have a clock doubler and so are provided with a </span>
<span class="cm">**	80 MHz clock. All other fast20 boards incorporate a doubler </span>
<span class="cm">**	and so should be delivered with a 40 MHz clock.</span>
<span class="cm">**	The future fast40 chips (895/895) use a 40 Mhz base clock </span>
<span class="cm">**	and provide a clock quadrupler (160 Mhz). The code below </span>
<span class="cm">**	tries to deal as cleverly as possible with all this stuff.</span>
<span class="cm">**</span>
<span class="cm">**----------------------------------------------------------</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm"> *	Select NCR SCSI clock frequency</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ncr_selectclock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">scntl3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">nc_scntl3</span><span class="p">,</span>	<span class="n">scntl3</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: enabling clock multiplier</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>

	<span class="n">OUTB</span><span class="p">(</span><span class="n">nc_stest1</span><span class="p">,</span> <span class="n">DBLEN</span><span class="p">);</span>	   <span class="cm">/* Enable clock multiplier		  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* Poll bit 5 of stest4 for quadrupler */</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">nc_stest4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LCKFRQ</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: the chip cannot lock the frequency</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span>			<span class="cm">/* Wait 20 micro-seconds for doubler	*/</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">nc_stest3</span><span class="p">,</span> <span class="n">HSC</span><span class="p">);</span>		<span class="cm">/* Halt the scsi clock		*/</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">nc_scntl3</span><span class="p">,</span>	<span class="n">scntl3</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">nc_stest1</span><span class="p">,</span> <span class="p">(</span><span class="n">DBLEN</span><span class="o">|</span><span class="n">DBLSEL</span><span class="p">));</span><span class="cm">/* Select clock multiplier	*/</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">nc_stest3</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>		<span class="cm">/* Restart scsi clock 		*/</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	calculate NCR SCSI clock frequency (in KHz)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">__init</span> <span class="n">ncrgetfreq</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Measure GEN timer delay in order </span>
<span class="cm">	 * to calculate SCSI clock frequency</span>
<span class="cm">	 *</span>
<span class="cm">	 * This code will never execute too</span>
<span class="cm">	 * many loop iterations (if DELAY is </span>
<span class="cm">	 * reasonably correct). It could get</span>
<span class="cm">	 * too low a delay (too high a freq.)</span>
<span class="cm">	 * if the CPU is slow executing the </span>
<span class="cm">	 * loop for some reason (an NMI, for</span>
<span class="cm">	 * example). For this reason we will</span>
<span class="cm">	 * if multiple measurements are to be </span>
<span class="cm">	 * performed trust the higher delay </span>
<span class="cm">	 * (lower frequency returned).</span>
<span class="cm">	 */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_stest1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* make sure clock doubler is OFF */</span>
	<span class="n">OUTW</span> <span class="p">(</span><span class="n">nc_sien</span> <span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* mask all scsi interrupts */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">INW</span> <span class="p">(</span><span class="n">nc_sist</span><span class="p">);</span>	<span class="cm">/* clear pending scsi interrupt */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_dien</span> <span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* mask all dma interrupts */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">INW</span> <span class="p">(</span><span class="n">nc_sist</span><span class="p">);</span>	<span class="cm">/* another one, just to be sure :) */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_scntl3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>	<span class="cm">/* set pre-scaler to divide by 3 */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_stime1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* disable general purpose timer */</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_stime1</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>	<span class="cm">/* set to nominal delay of 1&lt;&lt;gen * 125us */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">INW</span><span class="p">(</span><span class="n">nc_sist</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">GEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ms</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">count</span> <span class="o">++</span><span class="p">)</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>	<span class="cm">/* count ms */</span>
	<span class="p">}</span>
	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_stime1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* disable general purpose timer */</span>
 	<span class="cm">/*</span>
<span class="cm"> 	 * set prescaler to divide by whatever 0 means</span>
<span class="cm"> 	 * 0 ought to choose divide by 2, but appears</span>
<span class="cm"> 	 * to set divide by 3.5 mode in my 53c810 ...</span>
<span class="cm"> 	 */</span>
 	<span class="n">OUTB</span> <span class="p">(</span><span class="n">nc_scntl3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: Delay (GEN=%d): %u msec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">gen</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
  	<span class="cm">/*</span>
<span class="cm"> 	 * adjust for prescaler, and convert into KHz </span>
<span class="cm">  	 */</span>
	<span class="k">return</span> <span class="n">ms</span> <span class="o">?</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">gen</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4340</span><span class="p">)</span> <span class="o">/</span> <span class="n">ms</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Get/probe NCR SCSI clock frequency</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">ncr_getclock</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mult</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">scntl3</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">nc_scntl3</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">stest1</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">nc_stest1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">f1</span><span class="p">;</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">f1</span> <span class="o">=</span> <span class="mi">40000</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	**	True with 875 or 895 with clock multiplier selected</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mult</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">stest1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DBLEN</span><span class="o">+</span><span class="n">DBLSEL</span><span class="p">))</span> <span class="o">==</span> <span class="n">DBLEN</span><span class="o">+</span><span class="n">DBLSEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: clock multiplier found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span> <span class="o">=</span> <span class="n">mult</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	If multiplier not found or scntl3 not 7,5,3,</span>
<span class="cm">	**	reset chip and get frequency from general purpose timer.</span>
<span class="cm">	**	Otherwise trust scntl3 BIOS setting.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span> <span class="o">!=</span> <span class="n">mult</span> <span class="o">||</span> <span class="p">(</span><span class="n">scntl3</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">scntl3</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">f2</span><span class="p">;</span>

		<span class="n">ncr_chip_reset</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">ncrgetfreq</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>	<span class="cm">/* throw away first result */</span>
		<span class="n">f1</span> <span class="o">=</span> <span class="n">ncrgetfreq</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
		<span class="n">f2</span> <span class="o">=</span> <span class="n">ncrgetfreq</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span>
			<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: NCR clock is %uKHz, %uKHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">f1</span> <span class="o">&gt;</span> <span class="n">f2</span><span class="p">)</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">f2</span><span class="p">;</span>		<span class="cm">/* trust lower result	*/</span>

		<span class="k">if</span>	<span class="p">(</span><span class="n">f1</span> <span class="o">&lt;</span>	<span class="mi">45000</span><span class="p">)</span>		<span class="n">f1</span> <span class="o">=</span>  <span class="mi">40000</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">f1</span> <span class="o">&lt;</span>	<span class="mi">55000</span><span class="p">)</span>		<span class="n">f1</span> <span class="o">=</span>  <span class="mi">50000</span><span class="p">;</span>
		<span class="k">else</span>				<span class="n">f1</span> <span class="o">=</span>  <span class="mi">80000</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">f1</span> <span class="o">&lt;</span> <span class="mi">80000</span> <span class="o">&amp;&amp;</span> <span class="n">mult</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: clock multiplier assumed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span>	<span class="o">=</span> <span class="n">mult</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span>	<span class="p">((</span><span class="n">scntl3</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>	<span class="n">f1</span> <span class="o">=</span>  <span class="mi">40000</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">scntl3</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>	<span class="n">f1</span> <span class="o">=</span>  <span class="mi">80000</span><span class="p">;</span>
		<span class="k">else</span> 				<span class="n">f1</span> <span class="o">=</span> <span class="mi">160000</span><span class="p">;</span>

		<span class="n">f1</span> <span class="o">/=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	**	Compute controller synchronous parameters.</span>
<span class="cm">	*/</span>
	<span class="n">f1</span>		<span class="o">*=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span>	<span class="o">=</span> <span class="n">f1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*===================== LINUX ENTRY POINTS SECTION ==========================*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ncr53c8xx_slave_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ncr53c8xx_slave_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">[</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">numtags</span><span class="p">,</span> <span class="n">depth_to_use</span><span class="p">;</span>

	<span class="n">ncr_setup_lcb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Select queue depth from driver setup.</span>
<span class="cm">	**	Donnot use more than configured by user.</span>
<span class="cm">	**	Use at least 2.</span>
<span class="cm">	**	Donnot use more than our maximum.</span>
<span class="cm">	*/</span>
	<span class="n">numtags</span> <span class="o">=</span> <span class="n">device_queue_depth</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">unit</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">numtags</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrtags</span><span class="p">)</span>
		<span class="n">numtags</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrtags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">tagged_supported</span><span class="p">)</span>
		<span class="n">numtags</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">depth_to_use</span> <span class="o">=</span> <span class="n">numtags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">depth_to_use</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">depth_to_use</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">depth_to_use</span> <span class="o">&gt;</span> <span class="n">MAX_TAGS</span><span class="p">)</span>
		<span class="n">depth_to_use</span> <span class="o">=</span> <span class="n">MAX_TAGS</span><span class="p">;</span>

	<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">device</span><span class="p">,</span>
				<span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">tagged_supported</span> <span class="o">?</span>
				 <span class="n">MSG_SIMPLE_TAG</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
				<span class="n">depth_to_use</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	**	Since the queue depth is not tunable under Linux,</span>
<span class="cm">	**	we need to know this value in order not to </span>
<span class="cm">	**	announce stupid things to user.</span>
<span class="cm">	**</span>
<span class="cm">	**	XXX(hch): As of Linux 2.6 it certainly _is_ tunable..</span>
<span class="cm">	**		  In fact we just tuned it, or did I miss</span>
<span class="cm">	**		  something important? :)</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">numtags</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">maxtags</span> <span class="o">=</span> <span class="n">numtags</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">scdev_depth</span> <span class="o">=</span> <span class="n">depth_to_use</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ncr_setup_tags</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG_NCR53C8XX</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ncr53c8xx_select_queue_depth: host=%d, id=%d, lun=%d, depth=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">np</span><span class="o">-&gt;</span><span class="n">unit</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">depth_to_use</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spi_support_sync</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">spi_initial_dv</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">))</span>
		<span class="n">spi_dv_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ncr53c8xx_queue_command_lck</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
     <span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">;</span>
     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">sts</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_NCR53C8XX</span>
<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ncr53c8xx_queue_command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span>     <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">__data_mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">__data_mapping</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

     <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">smp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

     <span class="k">if</span> <span class="p">((</span><span class="n">sts</span> <span class="o">=</span> <span class="n">ncr_queue_command</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span> <span class="o">!=</span> <span class="n">DID_OK</span><span class="p">)</span> <span class="p">{</span>
	  <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">sts</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG_NCR53C8XX</span>
<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ncr53c8xx : command not queued - result=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sts</span><span class="p">);</span>
<span class="cp">#endif</span>
     <span class="p">}</span>
<span class="cp">#ifdef DEBUG_NCR53C8XX</span>
     <span class="k">else</span>
<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ncr53c8xx : command successfully queued</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

     <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">smp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

     <span class="k">if</span> <span class="p">(</span><span class="n">sts</span> <span class="o">!=</span> <span class="n">DID_OK</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">unmap_scsi_data</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
          <span class="n">done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	  <span class="n">sts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="k">return</span> <span class="n">sts</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">ncr53c8xx_queue_command</span><span class="p">)</span>

<span class="n">irqreturn_t</span> <span class="n">ncr53c8xx_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="n">host_data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">host_data</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">done_list</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_NCR53C8XX</span>
     <span class="n">printk</span><span class="p">(</span><span class="s">&quot;ncr53c8xx : interrupt received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

     <span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span> <span class="n">printk</span> <span class="p">(</span><span class="s">&quot;[&quot;</span><span class="p">);</span>

     <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">smp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
     <span class="n">ncr_exception</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
     <span class="n">done_list</span>     <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">;</span>
     <span class="n">np</span><span class="o">-&gt;</span><span class="n">done_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
     <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">smp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

     <span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span> <span class="n">printk</span> <span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

     <span class="k">if</span> <span class="p">(</span><span class="n">done_list</span><span class="p">)</span>
	     <span class="n">ncr_flush_done_cmds</span><span class="p">(</span><span class="n">done_list</span><span class="p">);</span>
     <span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ncr53c8xx_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="p">)</span> <span class="n">npref</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">done_list</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">smp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ncr_timeout</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="n">done_list</span>     <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">done_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">smp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">done_list</span><span class="p">)</span>
		<span class="n">ncr_flush_done_cmds</span><span class="p">(</span><span class="n">done_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ncr53c8xx_bus_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sts</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">done_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the mid-level driver told us reset is synchronous, it seems </span>
<span class="cm">	 * that we must call the done() callback for the involved command, </span>
<span class="cm">	 * even if this command was not queued to the low-level driver, </span>
<span class="cm">	 * before returning SUCCESS.</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">smp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sts</span> <span class="o">=</span> <span class="n">ncr_reset_bus</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">done_list</span>     <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">done_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">smp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ncr_flush_done_cmds</span><span class="p">(</span><span class="n">done_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sts</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"> /* unused and broken */</span>
<span class="c">static int ncr53c8xx_abort(struct scsi_cmnd *cmd)</span>
<span class="c">{</span>
<span class="c">	struct ncb *np = ((struct host_data *) cmd-&gt;device-&gt;host-&gt;hostdata)-&gt;ncb;</span>
<span class="c">	int sts;</span>
<span class="c">	unsigned long flags;</span>
<span class="c">	struct scsi_cmnd *done_list;</span>

<span class="c">	printk(&quot;ncr53c8xx_abort\n&quot;);</span>

<span class="c">	NCR_LOCK_NCB(np, flags);</span>

<span class="c">	sts = ncr_abort_command(np, cmd);</span>
<span class="c">out:</span>
<span class="c">	done_list     = np-&gt;done_list;</span>
<span class="c">	np-&gt;done_list = NULL;</span>
<span class="c">	NCR_UNLOCK_NCB(np, flags);</span>

<span class="c">	ncr_flush_done_cmds(done_list);</span>

<span class="c">	return sts;</span>
<span class="c">}</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm">**	Scsi command waiting list management.</span>
<span class="cm">**</span>
<span class="cm">**	It may happen that we cannot insert a scsi command into the start queue,</span>
<span class="cm">**	in the following circumstances.</span>
<span class="cm">** 		Too few preallocated ccb(s), </span>
<span class="cm">**		maxtags &lt; cmd_per_lun of the Linux host control block,</span>
<span class="cm">**		etc...</span>
<span class="cm">**	Such scsi commands are inserted into a waiting list.</span>
<span class="cm">**	When a scsi command complete, we try to requeue the commands of the</span>
<span class="cm">**	waiting list.</span>
<span class="cm">*/</span>

<span class="cp">#define next_wcmd host_scribble</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">insert_into_waiting_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">wcmd</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_WAITING_LIST</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: cmd %lx inserted into waiting list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">cmd</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">next_wcmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wcmd</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">waiting_list</span><span class="p">))</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">waiting_list</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">wcmd</span><span class="o">-&gt;</span><span class="n">next_wcmd</span><span class="p">)</span>
			<span class="n">wcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">wcmd</span><span class="o">-&gt;</span><span class="n">next_wcmd</span><span class="p">;</span>
		<span class="n">wcmd</span><span class="o">-&gt;</span><span class="n">next_wcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">retrieve_from_waiting_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">to_remove</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">**</span><span class="n">pcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">waiting_list</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">pcmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">to_remove</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">next_wcmd</span><span class="p">;</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">next_wcmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#ifdef DEBUG_WAITING_LIST</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: cmd %lx retrieved from waiting list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">cmd</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="k">return</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">pcmd</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next_wcmd</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">process_waiting_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">waiting_list</span><span class="p">,</span> <span class="o">*</span><span class="n">wcmd</span><span class="p">;</span>

	<span class="n">waiting_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">waiting_list</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">waiting_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_WAITING_LIST</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waiting_list</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: waiting_list=%lx processing sts=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">waiting_list</span><span class="p">,</span> <span class="n">sts</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">wcmd</span> <span class="o">=</span> <span class="n">waiting_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">waiting_list</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">wcmd</span><span class="o">-&gt;</span><span class="n">next_wcmd</span><span class="p">;</span>
		<span class="n">wcmd</span><span class="o">-&gt;</span><span class="n">next_wcmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sts</span> <span class="o">==</span> <span class="n">DID_OK</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG_WAITING_LIST</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: cmd %lx trying to requeue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">wcmd</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">sts</span> <span class="o">=</span> <span class="n">ncr_queue_command</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">wcmd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sts</span> <span class="o">!=</span> <span class="n">DID_OK</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG_WAITING_LIST</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: cmd %lx done forced sts=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">wcmd</span><span class="p">,</span> <span class="n">sts</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">wcmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">sts</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ncr_queue_done_cmd</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">wcmd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#undef next_wcmd</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">show_ncr53c8xx_revision</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="n">host_data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="p">)</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
  
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host_data</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="o">-&gt;</span><span class="n">revision_id</span><span class="p">);</span>
<span class="p">}</span>
  
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">ncr53c8xx_revision_attr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span>	<span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;revision&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">show_ncr53c8xx_revision</span><span class="p">,</span>
<span class="p">};</span>
  
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">ncr53c8xx_host_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">ncr53c8xx_revision_attr</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="cm">/*==========================================================</span>
<span class="cm">**</span>
<span class="cm">**	Boot command line.</span>
<span class="cm">**</span>
<span class="cm">**==========================================================</span>
<span class="cm">*/</span>
<span class="cp">#ifdef	MODULE</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">ncr53c8xx</span><span class="p">;</span>	<span class="cm">/* command line passed by insmod */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ncr53c8xx</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef MODULE</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">ncr53c8xx_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sym53c8xx__setup</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;ncr53c8xx=&quot;</span><span class="p">,</span> <span class="n">ncr53c8xx_setup</span><span class="p">);</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> *	Host attach and initialisations.</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate host data and ncb structure.</span>
<span class="cm"> *	Request IO region and remap MMIO region.</span>
<span class="cm"> *	Do chip initialization.</span>
<span class="cm"> *	If all is OK, install interrupt handling and</span>
<span class="cm"> *	start the timer daemon.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span> <span class="n">__init</span> <span class="n">ncr_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">tpnt</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">unit</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ncr_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="n">host_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u_long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">name</span>	<span class="o">=</span> <span class="n">SCSI_NCR_DRIVER_NAME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">shost_attrs</span><span class="p">)</span>
		<span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">shost_attrs</span> <span class="o">=</span> <span class="n">ncr53c8xx_host_attrs</span><span class="p">;</span>

	<span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">queuecommand</span>	<span class="o">=</span> <span class="n">ncr53c8xx_queue_command</span><span class="p">;</span>
	<span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">slave_configure</span>	<span class="o">=</span> <span class="n">ncr53c8xx_slave_configure</span><span class="p">;</span>
	<span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">slave_alloc</span>	<span class="o">=</span> <span class="n">ncr53c8xx_slave_alloc</span><span class="p">;</span>
	<span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">eh_bus_reset_handler</span> <span class="o">=</span> <span class="n">ncr53c8xx_bus_reset</span><span class="p">;</span>
	<span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">can_queue</span>		<span class="o">=</span> <span class="n">SCSI_NCR_CAN_QUEUE</span><span class="p">;</span>
	<span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">this_id</span>		<span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span>	<span class="o">=</span> <span class="n">SCSI_NCR_SG_TABLESIZE</span><span class="p">;</span>
	<span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span>	<span class="o">=</span> <span class="n">SCSI_NCR_CMD_PER_LUN</span><span class="p">;</span>
	<span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">use_clustering</span>	<span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">differential</span><span class="p">)</span>
		<span class="n">driver_setup</span><span class="p">.</span><span class="n">diff_support</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">differential</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;ncr53c720-%d: rev 0x%x irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">unit</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">revision_id</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">.</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">instance</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="n">tpnt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">host_data</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span>
	        <span class="k">goto</span> <span class="n">attach_error</span><span class="p">;</span>
	<span class="n">host_data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">np</span> <span class="o">=</span> <span class="n">__m_calloc_dma</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span><span class="p">),</span> <span class="s">&quot;NCB&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">attach_error</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">smp_lock</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">p_ncb</span> <span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="n">host_data</span><span class="o">-&gt;</span><span class="n">ncb</span> <span class="o">=</span> <span class="n">np</span><span class="p">;</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span> <span class="o">=</span> <span class="n">m_calloc_dma</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccb</span><span class="p">),</span> <span class="s">&quot;CCB&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">attach_error</span><span class="p">;</span>

	<span class="cm">/* Store input information in the host data structure.  */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">unit</span>	<span class="o">=</span> <span class="n">unit</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">verbose</span>	<span class="o">=</span> <span class="n">driver_setup</span><span class="p">.</span><span class="n">verbose</span><span class="p">;</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">inst_name</span><span class="p">,</span> <span class="s">&quot;ncr53c720-%d&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">unit</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">revision_id</span>	<span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">revision_id</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span>	<span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">features</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_divn</span>	<span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">nr_divisor</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs</span>	<span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">offset_max</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">maxburst</span>	<span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">burst_max</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span>	<span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">host_id</span><span class="p">;</span>

	<span class="cm">/* Allocate SCRIPTS areas.  */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span> <span class="o">=</span> <span class="n">m_calloc_dma</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">script</span><span class="p">),</span> <span class="s">&quot;SCRIPT&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">attach_error</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth0</span> <span class="o">=</span> <span class="n">m_calloc_dma</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scripth</span><span class="p">),</span> <span class="s">&quot;SCRIPTH&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">attach_error</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span>     <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">np</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">ncr53c8xx_timeout</span><span class="p">;</span>

	<span class="cm">/* Try to map the controller chip to virtual and physical memory. */</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">paddr</span>	<span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">.</span><span class="n">base</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">paddr2</span>	<span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_RAM</span><span class="p">)</span> <span class="o">?</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">.</span><span class="n">base_2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">.</span><span class="n">base_v</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">.</span><span class="n">base_v</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">.</span><span class="n">base_c</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;%s: can&#39;t map memory mapped IO region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">attach_error</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				<span class="s">&quot;%s: using memory mapped IO at virtual address 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Make the controller&#39;s registers available.  Now the INB INW INL</span>
<span class="cm">	 * OUTB OUTW OUTL macros can be used safely.</span>
<span class="cm">	 */</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ncr_reg</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">;</span>

	<span class="cm">/* Do chip dependent initialization.  */</span>
	<span class="n">ncr_prepare_setting</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">paddr2</span> <span class="o">&amp;&amp;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">script</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4096</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">paddr2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: script too large, NOT using on chip RAM.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_channel</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">this_id</span>       <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_id</span>	<span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_lun</span>	<span class="o">=</span> <span class="n">SCSI_NCR_MAX_LUN</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">base</span>		<span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq</span>		<span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">.</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">unique_id</span>	<span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">.</span><span class="n">base</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">dma_channel</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span>	<span class="o">=</span> <span class="n">MAX_TAGS</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">can_queue</span>	<span class="o">=</span> <span class="p">(</span><span class="n">MAX_START</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span>
	<span class="cm">/* This can happen if you forget to call ncr53c8xx_init from</span>
<span class="cm">	 * your module_init */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ncr53c8xx_transport_template</span><span class="p">);</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">transportt</span>	<span class="o">=</span> <span class="n">ncr53c8xx_transport_template</span><span class="p">;</span>

	<span class="cm">/* Patch script to physical addresses */</span>
	<span class="n">ncr_script_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">script0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scripth0</span><span class="p">);</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth</span>	<span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth0</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">p_scripth</span>	<span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">p_script</span>	<span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">paddr2</span><span class="p">)</span> <span class="o">?</span>  <span class="n">np</span><span class="o">-&gt;</span><span class="n">paddr2</span> <span class="o">:</span> <span class="n">vtobus</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span><span class="p">);</span>

	<span class="n">ncr_script_copy_and_bind</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="p">(</span><span class="n">ncrcmd</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">script0</span><span class="p">,</span>
			<span class="p">(</span><span class="n">ncrcmd</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">script</span><span class="p">));</span>
	<span class="n">ncr_script_copy_and_bind</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="p">(</span><span class="n">ncrcmd</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">scripth0</span><span class="p">,</span>
			<span class="p">(</span><span class="n">ncrcmd</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scripth</span><span class="p">));</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">p_ccb</span>	<span class="o">=</span> <span class="n">vtobus</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">);</span>

	<span class="cm">/* Patch the script for LED support.  */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_LED0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_REG_REG</span><span class="p">(</span><span class="n">gpreg</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span>  <span class="mh">0x01</span><span class="p">));</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span><span class="o">-&gt;</span><span class="n">reselected</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_REG_REG</span><span class="p">(</span><span class="n">gpreg</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0xfe</span><span class="p">));</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_REG_REG</span><span class="p">(</span><span class="n">gpreg</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0xfe</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look for the target control block of this nexus.</span>
<span class="cm">	 * For i = 0 to 3</span>
<span class="cm">	 *   JUMP ^ IFTRUE (MASK (i, 3)), @(next_lcb)</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">jump_tcb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">l_cmd</span>   <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">((</span><span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">))));</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">jump_tcb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">l_paddr</span> <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">NCB_SCRIPTH_PHYS</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">bad_target</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">ncr_chip_reset</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>

	<span class="cm">/* Now check the cache handling of the chipset.  */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ncr_snooptest</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;CACHE INCORRECTLY CONFIGURED.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">attach_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Install the interrupt handler.  */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">.</span><span class="n">irq</span><span class="p">;</span>

	<span class="cm">/* Initialize the fixed part of the default ccb.  */</span>
	<span class="n">ncr_init_ccb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * After SCSI devices have been opened, we cannot reset the bus</span>
<span class="cm">	 * safely, so we do it here.  Interrupt handler does the real work.</span>
<span class="cm">	 * Process the reset exception if interrupts are not enabled yet.</span>
<span class="cm">	 * Then enable disconnects.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">smp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ncr_reset_scsi_bus</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">driver_setup</span><span class="p">.</span><span class="n">settle_delay</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: FATAL ERROR: CHECK SCSI BUS - CABLES, TERMINATION, DEVICE POWER etc.!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">smp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">attach_error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ncr_exception</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">disc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The middle-level SCSI driver does not wait for devices to settle.</span>
<span class="cm">	 * Wait synchronously if more than 2 seconds.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver_setup</span><span class="p">.</span><span class="n">settle_delay</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: waiting %d seconds for scsi devices to settle...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">driver_setup</span><span class="p">.</span><span class="n">settle_delay</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="n">driver_setup</span><span class="p">.</span><span class="n">settle_delay</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* start the timeout daemon */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">lasttime</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">ncr_timeout</span> <span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="cm">/* use SIMPLE TAG messages by default */</span>
<span class="cp">#ifdef SCSI_NCR_ALWAYS_SIMPLE_TAG</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">=</span> <span class="n">SIMPLE_QUEUE_TAG</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">smp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">instance</span><span class="p">;</span>

 <span class="nl">attach_error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: detaching...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncr_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unregister</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth0</span><span class="p">)</span>
		<span class="n">m_free_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripth0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scripth</span><span class="p">),</span> <span class="s">&quot;SCRIPTH&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span><span class="p">)</span>
		<span class="n">m_free_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">script0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">script</span><span class="p">),</span> <span class="s">&quot;SCRIPT&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">)</span>
		<span class="n">m_free_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccb</span><span class="p">),</span> <span class="s">&quot;CCB&quot;</span><span class="p">);</span>
	<span class="n">m_free_dma</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ncb</span><span class="p">),</span> <span class="s">&quot;NCB&quot;</span><span class="p">);</span>
	<span class="n">host_data</span><span class="o">-&gt;</span><span class="n">ncb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

 <span class="nl">unregister:</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">ncr53c8xx_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="n">host_data</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG_NCR53C8XX</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ncr53c8xx: release</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_data</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">)</span>
		<span class="n">ncr_detach</span><span class="p">(</span><span class="n">host_data</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ncr53c8xx_set_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">period</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxsync</span><span class="p">)</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxsync</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">)</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">;</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrsync</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>

	<span class="n">ncr_negotiate</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ncr53c8xx_set_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">maxoffs</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">ncr_negotiate</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ncr53c8xx_set_width</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span><span class="p">)</span>
		<span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrwide</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>

	<span class="n">ncr_negotiate</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ncr53c8xx_get_signalling</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ncb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">host_data</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">spi_signal_type</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SMODE_SE</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">SPI_SIGNAL_SE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SMODE_HVD</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">SPI_SIGNAL_HVD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">SPI_SIGNAL_UNKNOWN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spi_signalling</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">spi_function_template</span> <span class="n">ncr53c8xx_transport_functions</span> <span class="o">=</span>  <span class="p">{</span>
	<span class="p">.</span><span class="n">set_period</span>	<span class="o">=</span> <span class="n">ncr53c8xx_set_period</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_period</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_offset</span>	<span class="o">=</span> <span class="n">ncr53c8xx_set_offset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_offset</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_width</span>	<span class="o">=</span> <span class="n">ncr53c8xx_set_width</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_width</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_signalling</span>	<span class="o">=</span> <span class="n">ncr53c8xx_get_signalling</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="n">ncr53c8xx_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ncr53c8xx_transport_template</span> <span class="o">=</span> <span class="n">spi_attach_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncr53c8xx_transport_functions</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ncr53c8xx_transport_template</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ncr53c8xx_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spi_release_transport</span><span class="p">(</span><span class="n">ncr53c8xx_transport_template</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
