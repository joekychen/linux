<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › fdomain.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>fdomain.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* fdomain.c -- Future Domain TMC-16x0 SCSI driver</span>
<span class="cm"> * Created: Sun May  3 18:53:19 1992 by faith@cs.unc.edu</span>
<span class="cm"> * Revised: Mon Dec 28 21:59:02 1998 by faith@acm.org</span>
<span class="cm"> * Author: Rickard E. Faith, faith@cs.unc.edu</span>
<span class="cm"> * Copyright 1992-1996, 1998 Rickard E. Faith (faith@acm.org)</span>
<span class="cm"> * Shared IRQ supported added 7/7/2001  Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;</span>

<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2, or (at your option) any</span>
<span class="cm"> * later version.</span>

<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>

<span class="cm"> * You should have received a copy of the GNU General Public License along</span>
<span class="cm"> * with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 675 Mass Ave, Cambridge, MA 02139, USA.</span>

<span class="cm"> **************************************************************************</span>

<span class="cm"> SUMMARY:</span>

<span class="cm"> Future Domain BIOS versions supported for autodetect:</span>
<span class="cm">    2.0, 3.0, 3.2, 3.4 (1.0), 3.5 (2.0), 3.6, 3.61</span>
<span class="cm"> Chips are supported:</span>
<span class="cm">    TMC-1800, TMC-18C50, TMC-18C30, TMC-36C70</span>
<span class="cm"> Boards supported:</span>
<span class="cm">    Future Domain TMC-1650, TMC-1660, TMC-1670, TMC-1680, TMC-1610M/MER/MEX</span>
<span class="cm">    Future Domain TMC-3260 (PCI)</span>
<span class="cm">    Quantum ISA-200S, ISA-250MG</span>
<span class="cm">    Adaptec AHA-2920A (PCI) [BUT *NOT* AHA-2920C -- use aic7xxx instead]</span>
<span class="cm">    IBM ?</span>
<span class="cm"> LILO/INSMOD command-line options:</span>
<span class="cm">    fdomain=&lt;PORT_BASE&gt;,&lt;IRQ&gt;[,&lt;ADAPTER_ID&gt;]</span>


<span class="cm">    </span>
<span class="cm"> NOTE:</span>

<span class="cm"> The Adaptec AHA-2920C has an Adaptec AIC-7850 chip on it.</span>
<span class="cm"> Use the aic7xxx driver for this board.</span>
<span class="cm">       </span>
<span class="cm"> The Adaptec AHA-2920A has a Future Domain chip on it, so this is the right</span>
<span class="cm"> driver for that card.  Unfortunately, the boxes will probably just say</span>
<span class="cm"> &quot;2920&quot;, so you&#39;ll have to look on the card for a Future Domain logo, or a</span>
<span class="cm"> letter after the 2920.</span>

<span class="cm"> </span>
<span class="cm"> </span>
<span class="cm"> THANKS:</span>

<span class="cm"> Thanks to Adaptec for providing PCI boards for testing.  This finally</span>
<span class="cm"> enabled me to test the PCI detection and correct it for PCI boards that do</span>
<span class="cm"> not have a BIOS at a standard ISA location.  For PCI boards, LILO/INSMOD</span>
<span class="cm"> command-line options should no longer be needed.  --RF 18Nov98</span>


<span class="cm"> </span>
<span class="cm"> DESCRIPTION:</span>
<span class="cm"> </span>
<span class="cm"> This is the Linux low-level SCSI driver for Future Domain TMC-1660/1680</span>
<span class="cm"> TMC-1650/1670, and TMC-3260 SCSI host adapters.  The 1650 and 1670 have a</span>
<span class="cm"> 25-pin external connector, whereas the 1660 and 1680 have a SCSI-2 50-pin</span>
<span class="cm"> high-density external connector.  The 1670 and 1680 have floppy disk</span>
<span class="cm"> controllers built in.  The TMC-3260 is a PCI bus card.</span>

<span class="cm"> Future Domain&#39;s older boards are based on the TMC-1800 chip, and this</span>
<span class="cm"> driver was originally written for a TMC-1680 board with the TMC-1800 chip.</span>
<span class="cm"> More recently, boards are being produced with the TMC-18C50 and TMC-18C30</span>
<span class="cm"> chips.  The latest and greatest board may not work with this driver.  If</span>
<span class="cm"> you have to patch this driver so that it will recognize your board&#39;s BIOS</span>
<span class="cm"> signature, then the driver may fail to function after the board is</span>
<span class="cm"> detected.</span>

<span class="cm"> Please note that the drive ordering that Future Domain implemented in BIOS</span>
<span class="cm"> versions 3.4 and 3.5 is the opposite of the order (currently) used by the</span>
<span class="cm"> rest of the SCSI industry.  If you have BIOS version 3.4 or 3.5, and have</span>
<span class="cm"> more than one drive, then the drive ordering will be the reverse of that</span>
<span class="cm"> which you see under DOS.  For example, under DOS SCSI ID 0 will be D: and</span>
<span class="cm"> SCSI ID 1 will be C: (the boot device).  Under Linux, SCSI ID 0 will be</span>
<span class="cm"> /dev/sda and SCSI ID 1 will be /dev/sdb.  The Linux ordering is consistent</span>
<span class="cm"> with that provided by all the other SCSI drivers for Linux.  If you want</span>
<span class="cm"> this changed, you will probably have to patch the higher level SCSI code.</span>
<span class="cm"> If you do so, please send me patches that are protected by #ifdefs.</span>

<span class="cm"> If you have a TMC-8xx or TMC-9xx board, then this is not the driver for</span>
<span class="cm"> your board.  Please refer to the Seagate driver for more information and</span>
<span class="cm"> possible support.</span>

<span class="cm"> </span>
<span class="cm"> </span>
<span class="cm"> HISTORY:</span>

<span class="cm"> Linux       Driver      Driver</span>
<span class="cm"> Version     Version     Date         Support/Notes</span>

<span class="cm">             0.0          3 May 1992  V2.0 BIOS; 1800 chip</span>
<span class="cm"> 0.97        1.9         28 Jul 1992</span>
<span class="cm"> 0.98.6      3.1         27 Nov 1992</span>
<span class="cm"> 0.99        3.2          9 Dec 1992</span>

<span class="cm"> 0.99.3      3.3         10 Jan 1993  V3.0 BIOS</span>
<span class="cm"> 0.99.5      3.5         18 Feb 1993</span>
<span class="cm"> 0.99.10     3.6         15 May 1993  V3.2 BIOS; 18C50 chip</span>
<span class="cm"> 0.99.11     3.17         3 Jul 1993  (now under RCS)</span>
<span class="cm"> 0.99.12     3.18        13 Aug 1993</span>
<span class="cm"> 0.99.14     5.6         31 Oct 1993  (reselection code removed)</span>

<span class="cm"> 0.99.15     5.9         23 Jan 1994  V3.4 BIOS (preliminary)</span>
<span class="cm"> 1.0.8/1.1.1 5.15         1 Apr 1994  V3.4 BIOS; 18C30 chip (preliminary)</span>
<span class="cm"> 1.0.9/1.1.3 5.16         7 Apr 1994  V3.4 BIOS; 18C30 chip</span>
<span class="cm"> 1.1.38      5.18        30 Jul 1994  36C70 chip (PCI version of 18C30)</span>
<span class="cm"> 1.1.62      5.20         2 Nov 1994  V3.5 BIOS</span>
<span class="cm"> 1.1.73      5.22         7 Dec 1994  Quantum ISA-200S board; V2.0 BIOS</span>

<span class="cm"> 1.1.82      5.26        14 Jan 1995  V3.5 BIOS; TMC-1610M/MER/MEX board</span>
<span class="cm"> 1.2.10      5.28         5 Jun 1995  Quantum ISA-250MG board; V2.0, V2.01 BIOS</span>
<span class="cm"> 1.3.4       5.31        23 Jun 1995  PCI BIOS-32 detection (preliminary)</span>
<span class="cm"> 1.3.7       5.33         4 Jul 1995  PCI BIOS-32 detection</span>
<span class="cm"> 1.3.28      5.36        17 Sep 1995  V3.61 BIOS; LILO command-line support</span>
<span class="cm"> 1.3.34      5.39        12 Oct 1995  V3.60 BIOS; /proc</span>
<span class="cm"> 1.3.72      5.39         8 Feb 1996  Adaptec AHA-2920 board</span>
<span class="cm"> 1.3.85      5.41         4 Apr 1996</span>
<span class="cm"> 2.0.12      5.44         8 Aug 1996  Use ID 7 for all PCI cards</span>
<span class="cm"> 2.1.1       5.45         2 Oct 1996  Update ROM accesses for 2.1.x</span>
<span class="cm"> 2.1.97      5.46	 23 Apr 1998  Rewritten PCI detection routines [mj]</span>
<span class="cm"> 2.1.11x     5.47	  9 Aug 1998  Touched for 8 SCSI disk majors support</span>
<span class="cm">             5.48        18 Nov 1998  BIOS no longer needed for PCI detection</span>
<span class="cm"> 2.2.0       5.50        28 Dec 1998  Support insmod parameters</span>
<span class="cm"> </span>

<span class="cm"> REFERENCES USED:</span>

<span class="cm"> &quot;TMC-1800 SCSI Chip Specification (FDC-1800T)&quot;, Future Domain Corporation,</span>
<span class="cm"> 1990.</span>

<span class="cm"> &quot;Technical Reference Manual: 18C50 SCSI Host Adapter Chip&quot;, Future Domain</span>
<span class="cm"> Corporation, January 1992.</span>

<span class="cm"> &quot;LXT SCSI Products: Specifications and OEM Technical Manual (Revision</span>
<span class="cm"> B/September 1991)&quot;, Maxtor Corporation, 1991.</span>

<span class="cm"> &quot;7213S product Manual (Revision P3)&quot;, Maxtor Corporation, 1992.</span>

<span class="cm"> &quot;Draft Proposed American National Standard: Small Computer System</span>
<span class="cm"> Interface - 2 (SCSI-2)&quot;, Global Engineering Documents. (X3T9.2/86-109,</span>
<span class="cm"> revision 10h, October 17, 1991)</span>

<span class="cm"> Private communications, Drew Eckhardt (drew@cs.colorado.edu) and Eric</span>
<span class="cm"> Youngdale (ericy@cais.com), 1992.</span>

<span class="cm"> Private communication, Tuong Le (Future Domain Engineering department),</span>
<span class="cm"> 1994. (Disk geometry computations for Future Domain BIOS version 3.4, and</span>
<span class="cm"> TMC-18C30 detection.)</span>

<span class="cm"> Hogan, Thom. The Programmer&#39;s PC Sourcebook. Microsoft Press, 1988. Page</span>
<span class="cm"> 60 (2.39: Disk Partition Table Layout).</span>

<span class="cm"> &quot;18C30 Technical Reference Manual&quot;, Future Domain Corporation, 1993, page</span>
<span class="cm"> 6-1.</span>


<span class="cm"> </span>
<span class="cm"> NOTES ON REFERENCES:</span>

<span class="cm"> The Maxtor manuals were free.  Maxtor telephone technical support is</span>
<span class="cm"> great!</span>

<span class="cm"> The Future Domain manuals were $25 and $35.  They document the chip, not</span>
<span class="cm"> the TMC-16x0 boards, so some information I had to guess at.  In 1992,</span>
<span class="cm"> Future Domain sold DOS BIOS source for $250 and the UN*X driver source was</span>
<span class="cm"> $750, but these required a non-disclosure agreement, so even if I could</span>
<span class="cm"> have afforded them, they would *not* have been useful for writing this</span>
<span class="cm"> publicly distributable driver.  Future Domain technical support has</span>
<span class="cm"> provided some information on the phone and have sent a few useful FAXs.</span>
<span class="cm"> They have been much more helpful since they started to recognize that the</span>
<span class="cm"> word &quot;Linux&quot; refers to an operating system :-).</span>

<span class="cm"> </span>

<span class="cm"> ALPHA TESTERS:</span>

<span class="cm"> There are many other alpha testers that come and go as the driver</span>
<span class="cm"> develops.  The people listed here were most helpful in times of greatest</span>
<span class="cm"> need (mostly early on -- I&#39;ve probably left out a few worthy people in</span>
<span class="cm"> more recent times):</span>

<span class="cm"> Todd Carrico (todd@wutc.wustl.edu), Dan Poirier (poirier@cs.unc.edu ), Ken</span>
<span class="cm"> Corey (kenc@sol.acs.unt.edu), C. de Bruin (bruin@bruin@sterbbs.nl), Sakari</span>
<span class="cm"> Aaltonen (sakaria@vipunen.hit.fi), John Rice (rice@xanth.cs.odu.edu), Brad</span>
<span class="cm"> Yearwood (brad@optilink.com), and Ray Toy (toy@soho.crd.ge.com).</span>

<span class="cm"> Special thanks to Tien-Wan Yang (twyang@cs.uh.edu), who graciously lent me</span>
<span class="cm"> his 18C50-based card for debugging.  He is the sole reason that this</span>
<span class="cm"> driver works with the 18C50 chip.</span>

<span class="cm"> Thanks to Dave Newman (dnewman@crl.com) for providing initial patches for</span>
<span class="cm"> the version 3.4 BIOS.</span>

<span class="cm"> Thanks to James T. McKinley (mckinley@msupa.pa.msu.edu) for providing</span>
<span class="cm"> patches that support the TMC-3260, a PCI bus card with the 36C70 chip.</span>
<span class="cm"> The 36C70 chip appears to be &quot;completely compatible&quot; with the 18C30 chip.</span>

<span class="cm"> Thanks to Eric Kasten (tigger@petroglyph.cl.msu.edu) for providing the</span>
<span class="cm"> patch for the version 3.5 BIOS.</span>

<span class="cm"> Thanks for Stephen Henson (shenson@nyx10.cs.du.edu) for providing the</span>
<span class="cm"> patch for the Quantum ISA-200S SCSI adapter.</span>
<span class="cm"> </span>
<span class="cm"> Thanks to Adam Bowen for the signature to the 1610M/MER/MEX scsi cards, to</span>
<span class="cm"> Martin Andrews (andrewm@ccfadm.eeg.ccf.org) for the signature to some</span>
<span class="cm"> random TMC-1680 repackaged by IBM; and to Mintak Ng (mintak@panix.com) for</span>
<span class="cm"> the version 3.61 BIOS signature.</span>

<span class="cm"> Thanks for Mark Singer (elf@netcom.com) and Richard Simpson</span>
<span class="cm"> (rsimpson@ewrcsdra.demon.co.uk) for more Quantum signatures and detective</span>
<span class="cm"> work on the Quantum RAM layout.</span>

<span class="cm"> Special thanks to James T. McKinley (mckinley@msupa.pa.msu.edu) for</span>
<span class="cm"> providing patches for proper PCI BIOS32-mediated detection of the TMC-3260</span>
<span class="cm"> card (a PCI bus card with the 36C70 chip).  Please send James PCI-related</span>
<span class="cm"> bug reports.</span>

<span class="cm"> Thanks to Tom Cavin (tec@usa1.com) for preliminary command-line option</span>
<span class="cm"> patches.</span>

<span class="cm"> New PCI detection code written by Martin Mares &lt;mj@atrey.karlin.mff.cuni.cz&gt;</span>

<span class="cm"> Insmod parameter code based on patches from Daniel Graham</span>
<span class="cm"> &lt;graham@balance.uoregon.edu&gt;. </span>
<span class="cm"> </span>
<span class="cm"> All of the alpha testers deserve much thanks.</span>



<span class="cm"> NOTES ON USER DEFINABLE OPTIONS:</span>

<span class="cm"> DEBUG: This turns on the printing of various debug information.</span>

<span class="cm"> ENABLE_PARITY: This turns on SCSI parity checking.  With the current</span>
<span class="cm"> driver, all attached devices must support SCSI parity.  If none of your</span>
<span class="cm"> devices support parity, then you can probably get the driver to work by</span>
<span class="cm"> turning this option off.  I have no way of testing this, however, and it</span>
<span class="cm"> would appear that no one ever uses this option.</span>

<span class="cm"> FIFO_COUNT: The host adapter has an 8K cache (host adapters based on the</span>
<span class="cm"> 18C30 chip have a 2k cache).  When this many 512 byte blocks are filled by</span>
<span class="cm"> the SCSI device, an interrupt will be raised.  Therefore, this could be as</span>
<span class="cm"> low as 0, or as high as 16.  Note, however, that values which are too high</span>
<span class="cm"> or too low seem to prevent any interrupts from occurring, and thereby lock</span>
<span class="cm"> up the machine.  I have found that 2 is a good number, but throughput may</span>
<span class="cm"> be increased by changing this value to values which are close to 2.</span>
<span class="cm"> Please let me know if you try any different values.</span>

<span class="cm"> RESELECTION: This is no longer an option, since I gave up trying to</span>
<span class="cm"> implement it in version 4.x of this driver.  It did not improve</span>
<span class="cm"> performance at all and made the driver unstable (because I never found one</span>
<span class="cm"> of the two race conditions which were introduced by the multiple</span>
<span class="cm"> outstanding command code).  The instability seems a very high price to pay</span>
<span class="cm"> just so that you don&#39;t have to wait for the tape to rewind.  If you want</span>
<span class="cm"> this feature implemented, send me patches.  I&#39;ll be happy to send a copy</span>
<span class="cm"> of my (broken) driver to anyone who would like to see a copy.</span>

<span class="cm"> **************************************************************************/</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;scsi/scsicam.h&gt;</span>


<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_ioctl.h&gt;</span>
<span class="cp">#include &quot;fdomain.h&quot;</span>

<span class="cp">#ifndef PCMCIA</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Rickard E. Faith&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Future domain SCSI driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

  
<span class="cp">#define VERSION          &quot;$Revision: 5.51 $&quot;</span>

<span class="cm">/* START OF USER DEFINABLE OPTIONS */</span>

<span class="cp">#define DEBUG            0	</span><span class="cm">/* Enable debugging output */</span><span class="cp"></span>
<span class="cp">#define ENABLE_PARITY    1	</span><span class="cm">/* Enable SCSI Parity */</span><span class="cp"></span>
<span class="cp">#define FIFO_COUNT       2	</span><span class="cm">/* Number of 512 byte blocks before INTR */</span><span class="cp"></span>

<span class="cm">/* END OF USER DEFINABLE OPTIONS */</span>

<span class="cp">#if DEBUG</span>
<span class="cp">#define EVERY_ACCESS     0	</span><span class="cm">/* Write a line on every scsi access */</span><span class="cp"></span>
<span class="cp">#define ERRORS_ONLY      1	</span><span class="cm">/* Only write a line if there is an error */</span><span class="cp"></span>
<span class="cp">#define DEBUG_DETECT     0	</span><span class="cm">/* Debug fdomain_16x0_detect() */</span><span class="cp"></span>
<span class="cp">#define DEBUG_MESSAGES   1	</span><span class="cm">/* Debug MESSAGE IN phase */</span><span class="cp"></span>
<span class="cp">#define DEBUG_ABORT      1	</span><span class="cm">/* Debug abort() routine */</span><span class="cp"></span>
<span class="cp">#define DEBUG_RESET      1	</span><span class="cm">/* Debug reset() routine */</span><span class="cp"></span>
<span class="cp">#define DEBUG_RACE       1      </span><span class="cm">/* Debug interrupt-driven race condition */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define EVERY_ACCESS     0	</span><span class="cm">/* LEAVE THESE ALONE--CHANGE THE ONES ABOVE */</span><span class="cp"></span>
<span class="cp">#define ERRORS_ONLY      0</span>
<span class="cp">#define DEBUG_DETECT     0</span>
<span class="cp">#define DEBUG_MESSAGES   0</span>
<span class="cp">#define DEBUG_ABORT      0</span>
<span class="cp">#define DEBUG_RESET      0</span>
<span class="cp">#define DEBUG_RACE       0</span>
<span class="cp">#endif</span>

<span class="cm">/* Errors are reported on the line, so we don&#39;t need to report them again */</span>
<span class="cp">#if EVERY_ACCESS</span>
<span class="cp">#undef ERRORS_ONLY</span>
<span class="cp">#define ERRORS_ONLY      0</span>
<span class="cp">#endif</span>

<span class="cp">#if ENABLE_PARITY</span>
<span class="cp">#define PARITY_MASK      0x08</span>
<span class="cp">#else</span>
<span class="cp">#define PARITY_MASK      0x00</span>
<span class="cp">#endif</span>

<span class="k">enum</span> <span class="n">chip_type</span> <span class="p">{</span>
   <span class="n">unknown</span>          <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
   <span class="n">tmc1800</span>          <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
   <span class="n">tmc18c50</span>         <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
   <span class="n">tmc18c30</span>         <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
   <span class="n">in_arbitration</span>   <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
   <span class="n">in_selection</span>     <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
   <span class="n">in_other</span>         <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
   <span class="n">disconnect</span>       <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
   <span class="n">aborted</span>          <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
   <span class="n">sent_ident</span>       <span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">in_port_type</span> <span class="p">{</span>
   <span class="n">Read_SCSI_Data</span>   <span class="o">=</span>  <span class="mi">0</span><span class="p">,</span>
   <span class="n">SCSI_Status</span>      <span class="o">=</span>  <span class="mi">1</span><span class="p">,</span>
   <span class="n">TMC_Status</span>       <span class="o">=</span>  <span class="mi">2</span><span class="p">,</span>
   <span class="n">FIFO_Status</span>      <span class="o">=</span>  <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* tmc18c50/tmc18c30 only */</span>
   <span class="n">Interrupt_Cond</span>   <span class="o">=</span>  <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* tmc18c50/tmc18c30 only */</span>
   <span class="n">LSB_ID_Code</span>      <span class="o">=</span>  <span class="mi">5</span><span class="p">,</span>
   <span class="n">MSB_ID_Code</span>      <span class="o">=</span>  <span class="mi">6</span><span class="p">,</span>
   <span class="n">Read_Loopback</span>    <span class="o">=</span>  <span class="mi">7</span><span class="p">,</span>
   <span class="n">SCSI_Data_NoACK</span>  <span class="o">=</span>  <span class="mi">8</span><span class="p">,</span>
   <span class="n">Interrupt_Status</span> <span class="o">=</span>  <span class="mi">9</span><span class="p">,</span>
   <span class="n">Configuration1</span>   <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
   <span class="n">Configuration2</span>   <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>	<span class="cm">/* tmc18c50/tmc18c30 only */</span>
   <span class="n">Read_FIFO</span>        <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
   <span class="n">FIFO_Data_Count</span>  <span class="o">=</span> <span class="mi">14</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">out_port_type</span> <span class="p">{</span>
   <span class="n">Write_SCSI_Data</span>  <span class="o">=</span>  <span class="mi">0</span><span class="p">,</span>
   <span class="n">SCSI_Cntl</span>        <span class="o">=</span>  <span class="mi">1</span><span class="p">,</span>
   <span class="n">Interrupt_Cntl</span>   <span class="o">=</span>  <span class="mi">2</span><span class="p">,</span>
   <span class="n">SCSI_Mode_Cntl</span>   <span class="o">=</span>  <span class="mi">3</span><span class="p">,</span>
   <span class="n">TMC_Cntl</span>         <span class="o">=</span>  <span class="mi">4</span><span class="p">,</span>
   <span class="n">Memory_Cntl</span>      <span class="o">=</span>  <span class="mi">5</span><span class="p">,</span>	<span class="cm">/* tmc18c50/tmc18c30 only */</span>
   <span class="n">Write_Loopback</span>   <span class="o">=</span>  <span class="mi">7</span><span class="p">,</span>
   <span class="n">IO_Control</span>       <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>	<span class="cm">/* tmc18c30 only */</span>
   <span class="n">Write_FIFO</span>       <span class="o">=</span> <span class="mi">12</span>
<span class="p">};</span>

<span class="cm">/* .bss will zero all the static variables below */</span>
<span class="k">static</span> <span class="kt">int</span>               <span class="n">port_base</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>     <span class="n">bios_base</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span>    <span class="n">bios_mem</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>               <span class="n">bios_major</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>               <span class="n">bios_minor</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>               <span class="n">PCI_bus</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_dev</span>	<span class="o">*</span><span class="n">PCI_dev</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">int</span>               <span class="n">Quantum</span><span class="p">;</span>	<span class="cm">/* Quantum board variant */</span>
<span class="k">static</span> <span class="kt">int</span>               <span class="n">interrupt_level</span><span class="p">;</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="kt">int</span>      <span class="n">in_command</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span>  <span class="o">*</span><span class="n">current_SC</span><span class="p">;</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">chip_type</span>    <span class="n">chip</span>              <span class="o">=</span> <span class="n">unknown</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>               <span class="n">adapter_mask</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>               <span class="n">this_id</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>               <span class="n">setup_called</span><span class="p">;</span>

<span class="cp">#if DEBUG_RACE</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="kt">int</span>      <span class="n">in_interrupt_flag</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span>               <span class="n">FIFO_Size</span> <span class="o">=</span> <span class="mh">0x2000</span><span class="p">;</span> <span class="cm">/* 8k FIFO for</span>
<span class="cm">						pre-tmc18c30 chips */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span>       <span class="n">do_fdomain_16x0_intr</span><span class="p">(</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span> <span class="p">);</span>
<span class="cm">/* Allow insmod parameters to be like LILO parameters.  For example:</span>
<span class="cm">   insmod fdomain fdomain=0x140,11 */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">fdomain</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">fdomain</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifndef PCMCIA</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addresses</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
   <span class="mh">0xc8000</span><span class="p">,</span>
   <span class="mh">0xca000</span><span class="p">,</span>
   <span class="mh">0xce000</span><span class="p">,</span>
   <span class="mh">0xde000</span><span class="p">,</span>
   <span class="mh">0xcc000</span><span class="p">,</span>		<span class="cm">/* Extra addresses for PCI boards */</span>
   <span class="mh">0xd0000</span><span class="p">,</span>
   <span class="mh">0xe0000</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define ADDRESS_COUNT ARRAY_SIZE(addresses)</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ports</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x140</span><span class="p">,</span> <span class="mh">0x150</span><span class="p">,</span> <span class="mh">0x160</span><span class="p">,</span> <span class="mh">0x170</span> <span class="p">};</span>
<span class="cp">#define PORT_COUNT ARRAY_SIZE(ports)</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ints</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* !PCMCIA */</span><span class="cp"></span>

<span class="cm">/*</span>

<span class="cm">  READ THIS BEFORE YOU ADD A SIGNATURE!</span>

<span class="cm">  READING THIS SHORT NOTE CAN SAVE YOU LOTS OF TIME!</span>

<span class="cm">  READ EVERY WORD, ESPECIALLY THE WORD *NOT*</span>

<span class="cm">  This driver works *ONLY* for Future Domain cards using the TMC-1800,</span>
<span class="cm">  TMC-18C50, or TMC-18C30 chip.  This includes models TMC-1650, 1660, 1670,</span>
<span class="cm">  and 1680.  These are all 16-bit cards.</span>

<span class="cm">  The following BIOS signature signatures are for boards which do *NOT*</span>
<span class="cm">  work with this driver (these TMC-8xx and TMC-9xx boards may work with the</span>
<span class="cm">  Seagate driver):</span>

<span class="cm">  FUTURE DOMAIN CORP. (C) 1986-1988 V4.0I 03/16/88</span>
<span class="cm">  FUTURE DOMAIN CORP. (C) 1986-1989 V5.0C2/14/89</span>
<span class="cm">  FUTURE DOMAIN CORP. (C) 1986-1989 V6.0A7/28/89</span>
<span class="cm">  FUTURE DOMAIN CORP. (C) 1986-1990 V6.0105/31/90</span>
<span class="cm">  FUTURE DOMAIN CORP. (C) 1986-1990 V6.0209/18/90</span>
<span class="cm">  FUTURE DOMAIN CORP. (C) 1986-1990 V7.009/18/90</span>
<span class="cm">  FUTURE DOMAIN CORP. (C) 1992 V8.00.004/02/92</span>

<span class="cm">  (The cards which do *NOT* work are all 8-bit cards -- although some of</span>
<span class="cm">  them have a 16-bit form-factor, the upper 8-bits are used only for IRQs</span>
<span class="cm">  and are *NOT* used for data.  You can tell the difference by following</span>
<span class="cm">  the tracings on the circuit board -- if only the IRQ lines are involved,</span>
<span class="cm">  you have a &quot;8-bit&quot; card, and should *NOT* use this driver.)</span>

<span class="cm">*/</span>

<span class="cp">#ifndef PCMCIA</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">signature</span> <span class="p">{</span>
   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">signature</span><span class="p">;</span>
   <span class="kt">int</span>  <span class="n">sig_offset</span><span class="p">;</span>
   <span class="kt">int</span>  <span class="n">sig_length</span><span class="p">;</span>
   <span class="kt">int</span>  <span class="n">major_bios_version</span><span class="p">;</span>
   <span class="kt">int</span>  <span class="n">minor_bios_version</span><span class="p">;</span>
   <span class="kt">int</span>  <span class="n">flag</span><span class="p">;</span> <span class="cm">/* 1 == PCI_bus, 2 == ISA_200S, 3 == ISA_250MG, 4 == ISA_200S */</span>
<span class="p">}</span> <span class="n">signatures</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
   <span class="cm">/*          1         2         3         4         5         6 */</span>
   <span class="cm">/* 123456789012345678901234567890123456789012345678901234567890 */</span>
   <span class="p">{</span> <span class="s">&quot;FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.07/28/89&quot;</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;FUTURE DOMAIN CORP. (C) 1986-1990 1800-V1.07/28/89&quot;</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.07/28/89&quot;</span><span class="p">,</span> <span class="mi">72</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.0&quot;</span><span class="p">,</span>        <span class="mi">73</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;FUTURE DOMAIN CORP. (C) 1991 1800-V2.0.&quot;</span><span class="p">,</span>            <span class="mi">72</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;FUTURE DOMAIN CORP. (C) 1992 V3.00.004/02/92&quot;</span><span class="p">,</span>        <span class="mi">5</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;FUTURE DOMAIN TMC-18XX (C) 1993 V3.203/12/93&quot;</span><span class="p">,</span>        <span class="mi">5</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;IBM F1 P2 BIOS v1.0104/29/93&quot;</span><span class="p">,</span>                        <span class="mi">5</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;Future Domain Corp. V1.0008/18/93&quot;</span><span class="p">,</span>                   <span class="mi">5</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;Future Domain Corp. V1.0008/18/93&quot;</span><span class="p">,</span>                  <span class="mi">26</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;Adaptec AHA-2920 PCI-SCSI Card&quot;</span><span class="p">,</span>                     <span class="mi">42</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;IBM F1 P264/32&quot;</span><span class="p">,</span>                                      <span class="mi">5</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>
				<span class="cm">/* This next signature may not be a 3.5 bios */</span>
   <span class="p">{</span> <span class="s">&quot;Future Domain Corp. V2.0108/18/93&quot;</span><span class="p">,</span>                   <span class="mi">5</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;FUTURE DOMAIN CORP.  V3.5008/18/93&quot;</span><span class="p">,</span>                  <span class="mi">5</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;FUTURE DOMAIN 18c30/18c50/1800 (C) 1994 V3.5&quot;</span><span class="p">,</span>        <span class="mi">5</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;FUTURE DOMAIN CORP.  V3.6008/18/93&quot;</span><span class="p">,</span>                  <span class="mi">5</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;FUTURE DOMAIN CORP.  V3.6108/18/93&quot;</span><span class="p">,</span>                  <span class="mi">5</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;FUTURE DOMAIN TMC-18XX&quot;</span><span class="p">,</span>                              <span class="mi">5</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>

   <span class="cm">/* READ NOTICE ABOVE *BEFORE* YOU WASTE YOUR TIME ADDING A SIGNATURE</span>
<span class="cm">    Also, fix the disk geometry code for your signature and send your</span>
<span class="cm">    changes for faith@cs.unc.edu.  Above all, do *NOT* change any old</span>
<span class="cm">    signatures!</span>

<span class="cm">    Note that the last line will match a &quot;generic&quot; 18XX bios.  Because</span>
<span class="cm">    Future Domain has changed the host SCSI ID and/or the location of the</span>
<span class="cm">    geometry information in the on-board RAM area for each of the first</span>
<span class="cm">    three BIOS&#39;s, it is still important to enter a fully qualified</span>
<span class="cm">    signature in the table for any new BIOS&#39;s (after the host SCSI ID and</span>
<span class="cm">    geometry location are verified). */</span>
<span class="p">};</span>

<span class="cp">#define SIGNATURE_COUNT ARRAY_SIZE(signatures)</span>

<span class="cp">#endif </span><span class="cm">/* !PCMCIA */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_banner</span><span class="p">(</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shpnt</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shpnt</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>		<span class="cm">/* This won&#39;t ever happen */</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">bios_major</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bios_minor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scsi%d: &lt;fdomain&gt; No BIOS; using scsi id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">shpnt</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">shpnt</span><span class="o">-&gt;</span><span class="n">this_id</span><span class="p">);</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scsi%d: &lt;fdomain&gt; BIOS version &quot;</span><span class="p">,</span> <span class="n">shpnt</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">bios_major</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d.&quot;</span><span class="p">,</span> <span class="n">bios_major</span><span class="p">);</span>
      <span class="k">else</span>                 <span class="n">printk</span><span class="p">(</span><span class="s">&quot;?.&quot;</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">bios_minor</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">bios_minor</span><span class="p">);</span>
      <span class="k">else</span>                 <span class="n">printk</span><span class="p">(</span><span class="s">&quot;?.&quot;</span><span class="p">);</span>

      <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; at 0x%lx using scsi id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">bios_base</span><span class="p">,</span> <span class="n">shpnt</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="p">);</span>
   <span class="p">}</span>

				<span class="cm">/* If this driver works for later FD PCI</span>
<span class="cm">				   boards, we will have to modify banner</span>
<span class="cm">				   for additional PCI cards, but for now if</span>
<span class="cm">				   it&#39;s PCI it&#39;s a TMC-3260 - JTM */</span>
   <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scsi%d: &lt;fdomain&gt; %s chip at 0x%x irq &quot;</span><span class="p">,</span>
	   <span class="n">shpnt</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span>
	   <span class="n">chip</span> <span class="o">==</span> <span class="n">tmc1800</span> <span class="o">?</span> <span class="s">&quot;TMC-1800&quot;</span> <span class="o">:</span> <span class="p">(</span><span class="n">chip</span> <span class="o">==</span> <span class="n">tmc18c50</span> <span class="o">?</span> <span class="s">&quot;TMC-18C50&quot;</span> <span class="o">:</span> <span class="p">(</span><span class="n">chip</span> <span class="o">==</span> <span class="n">tmc18c30</span> <span class="o">?</span> <span class="p">(</span><span class="n">PCI_bus</span> <span class="o">?</span> <span class="s">&quot;TMC-36C70 (PCI bus)&quot;</span> <span class="o">:</span> <span class="s">&quot;TMC-18C30&quot;</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;Unknown&quot;</span><span class="p">)),</span>
	   <span class="n">port_base</span><span class="p">);</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">interrupt_level</span><span class="p">)</span>
   	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">interrupt_level</span><span class="p">);</span>
   <span class="k">else</span>
        <span class="n">printk</span><span class="p">(</span><span class="s">&quot;&lt;none&gt;&quot;</span><span class="p">);</span>

   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fdomain_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ints</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">get_options</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ints</span><span class="p">),</span> <span class="n">ints</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">setup_called</span><span class="o">++</span> <span class="o">||</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scsi: &lt;fdomain&gt; Usage: fdomain=&lt;PORT_BASE&gt;,&lt;IRQ&gt;[,&lt;ADAPTER_ID&gt;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;scsi: &lt;fdomain&gt; Bad LILO/INSMOD parameters?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">port_base</span>       <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">interrupt_level</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">?</span> <span class="n">ints</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">this_id</span>         <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">?</span> <span class="n">ints</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
   
	<span class="n">bios_major</span> <span class="o">=</span> <span class="n">bios_minor</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Use geometry for BIOS version &gt;= 3.4 */</span>
	<span class="o">++</span><span class="n">setup_called</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;fdomain=&quot;</span><span class="p">,</span> <span class="n">fdomain_setup</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_pause</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">amount</span><span class="p">)</span>	<span class="cm">/* Pause for amount*10 milliseconds */</span>
<span class="p">{</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">amount</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fdomain_make_bus_idle</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Cntl</span><span class="p">);</span>
   <span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Mode_Cntl</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">==</span> <span class="n">tmc18c50</span> <span class="o">||</span> <span class="n">chip</span> <span class="o">==</span> <span class="n">tmc18c30</span><span class="p">)</span>
	 <span class="n">outb</span><span class="p">(</span><span class="mh">0x21</span> <span class="o">|</span> <span class="n">PARITY_MASK</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Cntl</span><span class="p">);</span> <span class="cm">/* Clear forced intr. */</span>
   <span class="k">else</span>
	 <span class="n">outb</span><span class="p">(</span><span class="mh">0x01</span> <span class="o">|</span> <span class="n">PARITY_MASK</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Cntl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdomain_is_valid_port</span><span class="p">(</span> <span class="kt">int</span> <span class="n">port</span> <span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if DEBUG_DETECT </span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; (%x%x),&quot;</span><span class="p">,</span>
	   <span class="n">inb</span><span class="p">(</span> <span class="n">port</span> <span class="o">+</span> <span class="n">MSB_ID_Code</span> <span class="p">),</span> <span class="n">inb</span><span class="p">(</span> <span class="n">port</span> <span class="o">+</span> <span class="n">LSB_ID_Code</span> <span class="p">)</span> <span class="p">);</span>
<span class="cp">#endif</span>

   <span class="cm">/* The MCA ID is a unique id for each MCA compatible board.  We</span>
<span class="cm">      are using ISA boards, but Future Domain provides the MCA ID</span>
<span class="cm">      anyway.  We can use this ID to ensure that this is a Future</span>
<span class="cm">      Domain TMC-1660/TMC-1680.</span>
<span class="cm">    */</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span> <span class="n">port</span> <span class="o">+</span> <span class="n">LSB_ID_Code</span> <span class="p">)</span> <span class="o">!=</span> <span class="mh">0xe9</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* test for 0x6127 id */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span> <span class="n">port</span> <span class="o">+</span> <span class="n">LSB_ID_Code</span> <span class="p">)</span> <span class="o">!=</span> <span class="mh">0x27</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span> <span class="n">port</span> <span class="o">+</span> <span class="n">MSB_ID_Code</span> <span class="p">)</span> <span class="o">!=</span> <span class="mh">0x61</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">chip</span> <span class="o">=</span> <span class="n">tmc1800</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>				    <span class="cm">/* test for 0xe960 id */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span> <span class="n">port</span> <span class="o">+</span> <span class="n">MSB_ID_Code</span> <span class="p">)</span> <span class="o">!=</span> <span class="mh">0x60</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">chip</span> <span class="o">=</span> <span class="n">tmc18c50</span><span class="p">;</span>

				<span class="cm">/* Try to toggle 32-bit mode.  This only</span>
<span class="cm">				   works on an 18c30 chip.  (User reports</span>
<span class="cm">				   say this works, so we should switch to</span>
<span class="cm">				   it in the near future.) */</span>

      <span class="n">outb</span><span class="p">(</span> <span class="mh">0x80</span><span class="p">,</span> <span class="n">port</span> <span class="o">+</span> <span class="n">IO_Control</span> <span class="p">);</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span> <span class="n">port</span> <span class="o">+</span> <span class="n">Configuration2</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
	 <span class="n">outb</span><span class="p">(</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">port</span> <span class="o">+</span> <span class="n">IO_Control</span> <span class="p">);</span>
	 <span class="k">if</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span> <span class="n">port</span> <span class="o">+</span> <span class="n">Configuration2</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">chip</span> <span class="o">=</span> <span class="n">tmc18c30</span><span class="p">;</span>
	    <span class="n">FIFO_Size</span> <span class="o">=</span> <span class="mh">0x800</span><span class="p">;</span>	<span class="cm">/* 2k FIFO */</span>
	 <span class="p">}</span>
      <span class="p">}</span>
				<span class="cm">/* If that failed, we are an 18c50. */</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdomain_test_loopback</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

   <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">255</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">outb</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Write_Loopback</span> <span class="p">);</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Read_Loopback</span> <span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">result</span><span class="p">)</span>
	    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef PCMCIA</span>

<span class="cm">/* fdomain_get_irq assumes that we have a valid MCA ID for a</span>
<span class="cm">   TMC-1660/TMC-1680 Future Domain board.  Now, check to be sure the</span>
<span class="cm">   bios_base matches these ports.  If someone was unlucky enough to have</span>
<span class="cm">   purchased more than one Future Domain board, then they will have to</span>
<span class="cm">   modify this code, as we only detect one board here.  [The one with the</span>
<span class="cm">   lowest bios_base.]</span>

<span class="cm">   Note that this routine is only used for systems without a PCI BIOS32</span>
<span class="cm">   (e.g., ISA bus).  For PCI bus systems, this routine will likely fail</span>
<span class="cm">   unless one of the IRQs listed in the ints array is used by the board.</span>
<span class="cm">   Sometimes it is possible to use the computer&#39;s BIOS setup screen to</span>
<span class="cm">   configure a PCI system so that one of these IRQs will be used by the</span>
<span class="cm">   Future Domain card. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdomain_get_irq</span><span class="p">(</span> <span class="kt">int</span> <span class="n">base</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">options</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">Configuration1</span><span class="p">);</span>

<span class="cp">#if DEBUG_DETECT</span>
   <span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi: &lt;fdomain&gt; Options = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="cp">#endif</span>
 
   <span class="cm">/* Check for board with lowest bios_base --</span>
<span class="cm">      this isn&#39;t valid for the 18c30 or for</span>
<span class="cm">      boards on the PCI bus, so just assume we</span>
<span class="cm">      have the right board. */</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">!=</span> <span class="n">tmc18c30</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PCI_bus</span> <span class="o">&amp;&amp;</span> <span class="n">addresses</span><span class="p">[(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span> <span class="p">]</span> <span class="o">!=</span> <span class="n">bios_base</span><span class="p">)</span>
   	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">return</span> <span class="n">ints</span><span class="p">[(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="mh">0x0e</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdomain_isa_detect</span><span class="p">(</span> <span class="kt">int</span> <span class="o">*</span><span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">iobase</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#if DEBUG_DETECT</span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; fdomain_isa_detect:&quot;</span> <span class="p">);</span>
<span class="cp">#endif</span>

   <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ADDRESS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">addresses</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mh">0x2000</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
	<span class="k">continue</span><span class="p">;</span>
<span class="cp">#if DEBUG_DETECT</span>
      <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; %lx(%lx),&quot;</span><span class="p">,</span> <span class="n">addresses</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bios_base</span> <span class="p">);</span>
<span class="cp">#endif</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">SIGNATURE_COUNT</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">check_signature</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">signatures</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">sig_offset</span><span class="p">,</span>
			     <span class="n">signatures</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">signature</span><span class="p">,</span>
			     <span class="n">signatures</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">sig_length</span> <span class="p">))</span> <span class="p">{</span>
	    <span class="n">bios_major</span> <span class="o">=</span> <span class="n">signatures</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">major_bios_version</span><span class="p">;</span>
	    <span class="n">bios_minor</span> <span class="o">=</span> <span class="n">signatures</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">minor_bios_version</span><span class="p">;</span>
	    <span class="n">PCI_bus</span>    <span class="o">=</span> <span class="p">(</span><span class="n">signatures</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	    <span class="n">Quantum</span>    <span class="o">=</span> <span class="p">(</span><span class="n">signatures</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">flag</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">signatures</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">flag</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	    <span class="n">bios_base</span>  <span class="o">=</span> <span class="n">addresses</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	    <span class="n">bios_mem</span>   <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	    <span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	 <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">iounmap</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
   <span class="p">}</span>
 
<span class="nl">found:</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">bios_major</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* The TMC-1660/TMC-1680 has a RAM area just after the BIOS ROM.</span>
<span class="cm">	 Assuming the ROM is enabled (otherwise we wouldn&#39;t have been</span>
<span class="cm">	 able to read the ROM signature :-), then the ROM sets up the</span>
<span class="cm">	 RAM area with some magic numbers, such as a list of port</span>
<span class="cm">	 base addresses and a list of the disk &quot;geometry&quot; reported to</span>
<span class="cm">	 DOS (this geometry has nothing to do with physical geometry).</span>
<span class="cm">       */</span>

      <span class="k">switch</span> <span class="p">(</span><span class="n">Quantum</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="mi">2</span>:			<span class="cm">/* ISA_200S */</span>
      <span class="k">case</span> <span class="mi">3</span>:			<span class="cm">/* ISA_250MG */</span>
	 <span class="n">base</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">bios_mem</span> <span class="o">+</span> <span class="mh">0x1fa2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">bios_mem</span> <span class="o">+</span> <span class="mh">0x1fa3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	 <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">4</span>:			<span class="cm">/* ISA_200S (another one) */</span>
	 <span class="n">base</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">bios_mem</span> <span class="o">+</span> <span class="mh">0x1fa3</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">bios_mem</span> <span class="o">+</span> <span class="mh">0x1fa4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	 <span class="k">break</span><span class="p">;</span>
      <span class="nl">default:</span>
	 <span class="n">base</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">bios_mem</span> <span class="o">+</span> <span class="mh">0x1fcc</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">bios_mem</span> <span class="o">+</span> <span class="mh">0x1fcd</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	 <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
   
<span class="cp">#if DEBUG_DETECT</span>
      <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; %x,&quot;</span><span class="p">,</span> <span class="n">base</span> <span class="p">);</span>
<span class="cp">#endif</span>

      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PORT_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="s">&quot;fdomain&quot;</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fdomain_is_valid_port</span><span class="p">(</span><span class="n">base</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">release_region</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">irq</span>    <span class="o">=</span> <span class="n">fdomain_get_irq</span><span class="p">(</span> <span class="n">base</span> <span class="p">);</span>
		<span class="o">*</span><span class="n">iobase</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="p">}</span>

      <span class="cm">/* This is a bad sign.  It usually means that someone patched the</span>
<span class="cm">	 BIOS signature list (the signatures variable) to contain a BIOS</span>
<span class="cm">	 signature for a board *OTHER THAN* the TMC-1660/TMC-1680. */</span>
      
<span class="cp">#if DEBUG_DETECT</span>
      <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; RAM FAILED, &quot;</span> <span class="p">);</span>
<span class="cp">#endif</span>
   <span class="p">}</span>

   <span class="cm">/* Anyway, the alternative to finding the address in the RAM is to just</span>
<span class="cm">      search through every possible port address for one that is attached</span>
<span class="cm">      to the Future Domain card.  Don&#39;t panic, though, about reading all</span>
<span class="cm">      these random port addresses -- there are rumors that the Future</span>
<span class="cm">      Domain BIOS does something very similar.</span>

<span class="cm">      Do not, however, check ports which the kernel knows are being used by</span>
<span class="cm">      another driver. */</span>

   <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PORT_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">base</span> <span class="o">=</span> <span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="s">&quot;fdomain&quot;</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#if DEBUG_DETECT</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; (%x inuse),&quot;</span><span class="p">,</span> <span class="n">base</span> <span class="p">);</span>
<span class="cp">#endif</span>
	 <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
<span class="cp">#if DEBUG_DETECT</span>
      <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; %x,&quot;</span><span class="p">,</span> <span class="n">base</span> <span class="p">);</span>
<span class="cp">#endif</span>
      <span class="n">flag</span> <span class="o">=</span> <span class="n">fdomain_is_valid_port</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span>
	<span class="k">break</span><span class="p">;</span>
      <span class="n">release_region</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
   <span class="p">}</span>

<span class="cp">#if DEBUG_DETECT</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; SUCCESS</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
   <span class="k">else</span>      <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; FAILURE</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
<span class="cp">#endif</span>

   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* iobase not found */</span>

   <span class="o">*</span><span class="n">irq</span>    <span class="o">=</span> <span class="n">fdomain_get_irq</span><span class="p">(</span> <span class="n">base</span> <span class="p">);</span>
   <span class="o">*</span><span class="n">iobase</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>

   <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* success */</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* PCMCIA */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdomain_isa_detect</span><span class="p">(</span> <span class="kt">int</span> <span class="o">*</span><span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">iobase</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span><span class="p">)</span>
		<span class="o">*</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iobase</span><span class="p">)</span>
		<span class="o">*</span><span class="n">iobase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !PCMCIA */</span><span class="cp"></span>


<span class="cm">/* PCI detection function: int fdomain_pci_bios_detect(int* irq, int*</span>
<span class="cm">   iobase) This function gets the Interrupt Level and I/O base address from</span>
<span class="cm">   the PCI configuration registers. */</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdomain_pci_bios_detect</span><span class="p">(</span> <span class="kt">int</span> <span class="o">*</span><span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">iobase</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">**</span><span class="n">ret_pdev</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="kt">unsigned</span> <span class="kt">int</span>     <span class="n">pci_irq</span><span class="p">;</span>                <span class="cm">/* PCI interrupt line */</span>
   <span class="kt">unsigned</span> <span class="kt">long</span>    <span class="n">pci_base</span><span class="p">;</span>               <span class="cm">/* PCI I/O base address */</span>
   <span class="k">struct</span> <span class="n">pci_dev</span>   <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cp">#if DEBUG_DETECT</span>
   <span class="cm">/* Tell how to print a list of the known PCI devices from bios32 and</span>
<span class="cm">      list vendor and device IDs being used if in debug mode.  */</span>
      
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; INFO: use lspci -v to see list of PCI devices</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; TMC-3260 detect:&quot;</span>
	   <span class="s">&quot; Using Vendor ID: 0x%x and Device ID: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">PCI_VENDOR_ID_FD</span><span class="p">,</span> 
	   <span class="n">PCI_DEVICE_ID_FD_36C70</span> <span class="p">);</span>
<span class="cp">#endif </span>

   <span class="k">if</span> <span class="p">((</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_FD</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_FD_36C70</span><span class="p">,</span> <span class="n">pdev</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
   	<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
       
<span class="cp">#if DEBUG_DETECT</span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; TMC-3260 detect:&quot;</span>
	   <span class="s">&quot; PCI bus %u, device %u, function %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
	   <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span>
	   <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">));</span>
<span class="cp">#endif</span>

   <span class="cm">/* We now have the appropriate device function for the FD board so we</span>
<span class="cm">      just read the PCI config info from the registers.  */</span>

   <span class="n">pci_base</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
   <span class="n">pci_irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span> <span class="n">pci_base</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="s">&quot;fdomain&quot;</span> <span class="p">))</span>
   	<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

   <span class="cm">/* Now we have the I/O base address and interrupt from the PCI</span>
<span class="cm">      configuration registers. */</span>

   <span class="o">*</span><span class="n">irq</span>    <span class="o">=</span> <span class="n">pci_irq</span><span class="p">;</span>
   <span class="o">*</span><span class="n">iobase</span> <span class="o">=</span> <span class="n">pci_base</span><span class="p">;</span>
   <span class="o">*</span><span class="n">ret_pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

<span class="cp">#if DEBUG_DETECT</span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; TMC-3260 detect:&quot;</span>
	   <span class="s">&quot; IRQ = %d, I/O base = 0x%x [0x%lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">irq</span><span class="p">,</span> <span class="o">*</span><span class="n">iobase</span><span class="p">,</span> <span class="n">pci_base</span> <span class="p">);</span>
<span class="cp">#endif</span>

   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fdomain_is_valid_port</span><span class="p">(</span><span class="n">pci_base</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;scsi: &lt;fdomain&gt; PCI card detected, but driver not loaded (invalid port)</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
      <span class="n">release_region</span><span class="p">(</span><span class="n">pci_base</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
      <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
   <span class="p">}</span>

				<span class="cm">/* Fill in a few global variables.  Ugh. */</span>
   <span class="n">bios_major</span> <span class="o">=</span> <span class="n">bios_minor</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
   <span class="n">PCI_bus</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">PCI_dev</span>    <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
   <span class="n">Quantum</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">bios_base</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   
   <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">fail:</span>
   <span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="nf">__fdomain_16x0_detect</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">tpnt</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="kt">int</span>              <span class="n">retcode</span><span class="p">;</span>
   <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shpnt</span><span class="p">;</span>
   <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">setup_called</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if DEBUG_DETECT</span>
      <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; No BIOS, using port_base = 0x%x, irq = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">port_base</span><span class="p">,</span> <span class="n">interrupt_level</span> <span class="p">);</span>
<span class="cp">#endif</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">port_base</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="s">&quot;fdomain&quot;</span><span class="p">))</span> <span class="p">{</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; port 0x%x is busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port_base</span> <span class="p">);</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; Bad LILO/INSMOD parameters?</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
	 <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fdomain_is_valid_port</span><span class="p">(</span> <span class="n">port_base</span> <span class="p">))</span> <span class="p">{</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; Cannot locate chip at port base 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">port_base</span> <span class="p">);</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; Bad LILO/INSMOD parameters?</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
	 <span class="n">release_region</span><span class="p">(</span><span class="n">port_base</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
	 <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PCI</span>
				<span class="cm">/* Try PCI detection first */</span>
      <span class="n">flag</span> <span class="o">=</span> <span class="n">fdomain_pci_bios_detect</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">interrupt_level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span> <span class="p">);</span>
<span class="cp">#endif</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Then try ISA bus detection */</span>
	 <span class="n">flag</span> <span class="o">=</span> <span class="n">fdomain_isa_detect</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">interrupt_level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_base</span> <span class="p">);</span>

	 <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; Detection failed (no card)</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
	    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	 <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="n">fdomain_16x0_bus_reset</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">fdomain_test_loopback</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>  <span class="s">&quot;scsi: &lt;fdomain&gt; Detection failed (loopback test failed at port base 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port_base</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">setup_called</span><span class="p">)</span> <span class="p">{</span>
	 <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;scsi: &lt;fdomain&gt; Bad LILO/INSMOD parameters?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">this_id</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_id</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">);</span>
      <span class="n">adapter_mask</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">this_id</span><span class="p">);</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">PCI_bus</span> <span class="o">||</span> <span class="p">(</span><span class="n">bios_major</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">bios_minor</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span> <span class="n">bios_major</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	 <span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	 <span class="n">adapter_mask</span>  <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	 <span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	 <span class="n">adapter_mask</span>  <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>

<span class="cm">/* Print out a banner here in case we can&#39;t</span>
<span class="cm">   get resources.  */</span>

   <span class="n">shpnt</span> <span class="o">=</span> <span class="n">scsi_register</span><span class="p">(</span> <span class="n">tpnt</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
   <span class="k">if</span><span class="p">(</span><span class="n">shpnt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">port_base</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
   	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="n">shpnt</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">interrupt_level</span><span class="p">;</span>
   <span class="n">shpnt</span><span class="o">-&gt;</span><span class="n">io_port</span> <span class="o">=</span> <span class="n">port_base</span><span class="p">;</span>
   <span class="n">shpnt</span><span class="o">-&gt;</span><span class="n">n_io_port</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>
   <span class="n">print_banner</span><span class="p">(</span> <span class="n">shpnt</span> <span class="p">);</span>

   <span class="cm">/* Log IRQ with kernel */</span>   
   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">interrupt_level</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;scsi: &lt;fdomain&gt; Card Detected, but driver not loaded (no IRQ)</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
      <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="cm">/* Register the IRQ with the kernel */</span>

      <span class="n">retcode</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span> <span class="n">interrupt_level</span><span class="p">,</span>
			     <span class="n">do_fdomain_16x0_intr</span><span class="p">,</span> <span class="n">pdev</span><span class="o">?</span><span class="n">IRQF_SHARED</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;fdomain&quot;</span><span class="p">,</span> <span class="n">shpnt</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">retcode</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">retcode</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;scsi: &lt;fdomain&gt; IRQ %d is bad!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">interrupt_level</span> <span class="p">);</span>
	    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;                This shouldn&#39;t happen!</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
	    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;                Send mail to faith@acm.org</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
	 <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retcode</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;scsi: &lt;fdomain&gt; IRQ %d is already in use!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">interrupt_level</span> <span class="p">);</span>
	    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;                Please use another IRQ!</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
	 <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;scsi: &lt;fdomain&gt; Error getting IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">interrupt_level</span> <span class="p">);</span>
	    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;                This shouldn&#39;t happen!</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
	    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;                Send mail to faith@acm.org</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
	 <span class="p">}</span>
	 <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;scsi: &lt;fdomain&gt; Detected, but driver not loaded (IRQ)</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
	 <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">shpnt</span><span class="p">;</span>
<span class="nl">fail:</span>
   <span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
   <span class="n">release_region</span><span class="p">(</span><span class="n">port_base</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
   <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdomain_16x0_detect</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">tpnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fdomain</span><span class="p">)</span>
		<span class="n">fdomain_setup</span><span class="p">(</span><span class="n">fdomain</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__fdomain_16x0_detect</span><span class="p">(</span><span class="n">tpnt</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">fdomain_16x0_info</span><span class="p">(</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">ignore</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="k">static</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
   <span class="kt">char</span>        <span class="o">*</span><span class="n">pt</span><span class="p">;</span>
   
   <span class="n">strcpy</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;Future Domain 16-bit SCSI Driver Version&quot;</span> <span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">strchr</span><span class="p">(</span> <span class="n">VERSION</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* Assume VERSION is an RCS Revision string */</span>
      <span class="n">strcat</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">strchr</span><span class="p">(</span> <span class="n">VERSION</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
      <span class="n">pt</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pt</span><span class="p">)</span>  		<span class="cm">/* Stripped RCS Revision string? */</span>
	    <span class="n">pt</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span> <span class="n">buffer</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pt</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
	    <span class="o">++</span><span class="n">pt</span><span class="p">;</span>
      <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>			<span class="cm">/* Assume VERSION is a number */</span>
      <span class="n">strcat</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="s">&quot; &quot;</span> <span class="n">VERSION</span> <span class="p">);</span>
   <span class="p">}</span>
      
   <span class="k">return</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static int fdomain_arbitrate( void )</span>
<span class="c">{</span>
<span class="c">   int           status = 0;</span>
<span class="c">   unsigned long timeout;</span>

<span class="cp">#if EVERY_ACCESS</span>
<span class="c">   printk( &quot;fdomain_arbitrate()\n&quot; );</span>
<span class="cp">#endif</span>
<span class="c">   </span>
<span class="c">   outb(0x00, port_base + SCSI_Cntl);              /* Disable data drivers */</span>
<span class="c">   outb(adapter_mask, port_base + SCSI_Data_NoACK); /* Set our id bit */</span>
<span class="c">   outb(0x04 | PARITY_MASK, port_base + TMC_Cntl); /* Start arbitration */</span>

<span class="c">   timeout = 500;</span>
<span class="c">   do {</span>
<span class="c">      status = inb(port_base + TMC_Status);        /* Read adapter status */</span>
<span class="c">      if (status &amp; 0x02)		      /* Arbitration complete */</span>
<span class="c">	    return 0;</span>
<span class="c">      mdelay(1);			/* Wait one millisecond */</span>
<span class="c">   } while (--timeout);</span>

<span class="c">   /* Make bus idle */</span>
<span class="c">   fdomain_make_bus_idle();</span>

<span class="cp">#if EVERY_ACCESS</span>
<span class="c">   printk( &quot;Arbitration failed, status = %x\n&quot;, status );</span>
<span class="cp">#endif</span>
<span class="cp">#if ERRORS_ONLY</span>
<span class="c">   printk( &quot;scsi: &lt;fdomain&gt; Arbitration failed, status = %x\n&quot;, status );</span>
<span class="cp">#endif</span>
<span class="c">   return 1;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdomain_select</span><span class="p">(</span> <span class="kt">int</span> <span class="n">target</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="kt">int</span>           <span class="n">status</span><span class="p">;</span>
   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
<span class="cp">#if ERRORS_ONLY</span>
   <span class="k">static</span> <span class="kt">int</span>    <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

   <span class="n">outb</span><span class="p">(</span><span class="mh">0x82</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Cntl</span><span class="p">);</span> <span class="cm">/* Bus Enable + Select */</span>
   <span class="n">outb</span><span class="p">(</span><span class="n">adapter_mask</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">target</span><span class="p">),</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Data_NoACK</span><span class="p">);</span>

   <span class="cm">/* Stop arbitration and enable parity */</span>
   <span class="n">outb</span><span class="p">(</span><span class="n">PARITY_MASK</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Cntl</span><span class="p">);</span> 

   <span class="n">timeout</span> <span class="o">=</span> <span class="mi">350</span><span class="p">;</span>			<span class="cm">/* 350 msec */</span>

   <span class="k">do</span> <span class="p">{</span>
      <span class="n">status</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Status</span><span class="p">);</span> <span class="cm">/* Read adapter status */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>			<span class="cm">/* Busy asserted */</span>
	 <span class="cm">/* Enable SCSI Bus (on error, should make bus idle with 0) */</span>
	 <span class="n">outb</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Cntl</span><span class="p">);</span>
	 <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>			<span class="cm">/* wait one msec */</span>
   <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">timeout</span><span class="p">);</span>
   <span class="cm">/* Make bus idle */</span>
   <span class="n">fdomain_make_bus_idle</span><span class="p">();</span>
<span class="cp">#if EVERY_ACCESS</span>
   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">target</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;Selection failed</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if ERRORS_ONLY</span>
   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span> <span class="cm">/* Skip first failure for all chips. */</span>
	    <span class="o">++</span><span class="n">flag</span><span class="p">;</span>
      <span class="k">else</span>
	    <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; Selection failed</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
   <span class="p">}</span>
<span class="cp">#endif</span>
   <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_done</span><span class="p">(</span><span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">in_command</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">in_command</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Interrupt_Cntl</span><span class="p">);</span>
      <span class="n">fdomain_make_bus_idle</span><span class="p">();</span>
      <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">)</span>
	    <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span> <span class="n">current_SC</span> <span class="p">);</span>
      <span class="k">else</span> <span class="n">panic</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; current_SC-&gt;scsi_done() == NULL&quot;</span> <span class="p">);</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">panic</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; my_done() called outside of command</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
   <span class="p">}</span>
<span class="cp">#if DEBUG_RACE</span>
   <span class="n">in_interrupt_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">do_fdomain_16x0_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
   <span class="kt">int</span>      <span class="n">status</span><span class="p">;</span>
   <span class="kt">int</span>      <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="kt">unsigned</span> <span class="n">data_count</span><span class="p">;</span>

				<span class="cm">/* The fdomain_16x0_intr is only called via</span>
<span class="cm">				   the interrupt handler.  The goal of the</span>
<span class="cm">				   sti() here is to allow other</span>
<span class="cm">				   interruptions while this routine is</span>
<span class="cm">				   running. */</span>

   <span class="cm">/* Check for other IRQ sources */</span>
   <span class="k">if</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
   	<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

   <span class="cm">/* It is our IRQ */</span>   	
   <span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Interrupt_Cntl</span><span class="p">);</span>

   <span class="cm">/* We usually have one spurious interrupt after each command.  Ignore it. */</span>
   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_command</span> <span class="o">||</span> <span class="o">!</span><span class="n">current_SC</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Spurious interrupt */</span>
<span class="cp">#if EVERY_ACCESS</span>
      <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;Spurious interrupt, in_command = %d, current_SC = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">in_command</span><span class="p">,</span> <span class="n">current_SC</span> <span class="p">);</span>
<span class="cp">#endif</span>
      <span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="cm">/* Abort calls my_done, so we do nothing here. */</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">&amp;</span> <span class="n">aborted</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if DEBUG_ABORT</span>
      <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; Interrupt after abort, ignoring</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
<span class="cp">#endif</span>
      <span class="cm">/*</span>
<span class="cm">      return IRQ_HANDLED; */</span>
   <span class="p">}</span>

<span class="cp">#if DEBUG_RACE</span>
   <span class="o">++</span><span class="n">in_interrupt_flag</span><span class="p">;</span>
<span class="cp">#endif</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">&amp;</span> <span class="n">in_arbitration</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">status</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Status</span><span class="p">);</span>        <span class="cm">/* Read adapter status */</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#if EVERY_ACCESS</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; AFAIL &quot;</span> <span class="p">);</span>
<span class="cp">#endif</span>
         <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	 <span class="n">my_done</span><span class="p">(</span> <span class="n">DID_BUS_BUSY</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="p">);</span>
         <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	 <span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">in_selection</span><span class="p">;</span>
      
      <span class="n">outb</span><span class="p">(</span><span class="mh">0x40</span> <span class="o">|</span> <span class="n">FIFO_COUNT</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Interrupt_Cntl</span><span class="p">);</span>

      <span class="n">outb</span><span class="p">(</span><span class="mh">0x82</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Cntl</span><span class="p">);</span> <span class="cm">/* Bus Enable + Select */</span>
      <span class="n">outb</span><span class="p">(</span><span class="n">adapter_mask</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">scmd_id</span><span class="p">(</span><span class="n">current_SC</span><span class="p">)),</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Data_NoACK</span><span class="p">);</span>
      
      <span class="cm">/* Stop arbitration and enable parity */</span>
      <span class="n">outb</span><span class="p">(</span><span class="mh">0x10</span> <span class="o">|</span> <span class="n">PARITY_MASK</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Cntl</span><span class="p">);</span>
<span class="cp">#if DEBUG_RACE</span>
      <span class="n">in_interrupt_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
      <span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">&amp;</span> <span class="n">in_selection</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">status</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Status</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">))</span> <span class="p">{</span>
	 <span class="cm">/* Try again, for slow devices */</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">fdomain_select</span><span class="p">(</span> <span class="n">scmd_id</span><span class="p">(</span><span class="n">current_SC</span><span class="p">)</span> <span class="p">))</span> <span class="p">{</span>
<span class="cp">#if EVERY_ACCESS</span>
	    <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; SFAIL &quot;</span> <span class="p">);</span>
<span class="cp">#endif</span>
            <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	    <span class="n">my_done</span><span class="p">(</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="p">);</span>
            <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	    <span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	 <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#if EVERY_ACCESS</span>
	    <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; AltSel &quot;</span> <span class="p">);</span>
<span class="cp">#endif</span>
	    <span class="cm">/* Stop arbitration and enable parity */</span>
	    <span class="n">outb</span><span class="p">(</span><span class="mh">0x10</span> <span class="o">|</span> <span class="n">PARITY_MASK</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Cntl</span><span class="p">);</span>
	 <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">in_other</span><span class="p">;</span>
      <span class="n">outb</span><span class="p">(</span><span class="mh">0x90</span> <span class="o">|</span> <span class="n">FIFO_COUNT</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Interrupt_Cntl</span><span class="p">);</span>
      <span class="n">outb</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Cntl</span><span class="p">);</span>
<span class="cp">#if DEBUG_RACE</span>
      <span class="n">in_interrupt_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
      <span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
   <span class="p">}</span>
   
   <span class="cm">/* current_SC-&gt;SCp.phase == in_other: this is the body of the routine */</span>
   
   <span class="n">status</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Status</span><span class="p">);</span>
   
   <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* REQ */</span>
      
      <span class="k">switch</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x0e</span><span class="p">)</span> <span class="p">{</span>
       
      <span class="k">case</span> <span class="mh">0x08</span>:		<span class="cm">/* COMMAND OUT */</span>
	 <span class="n">outb</span><span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">sent_command</span><span class="o">++</span><span class="p">],</span>
	      <span class="n">port_base</span> <span class="o">+</span> <span class="n">Write_SCSI_Data</span><span class="p">);</span>
<span class="cp">#if EVERY_ACCESS</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;CMD = %x,&quot;</span><span class="p">,</span>
		 <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">sent_command</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
<span class="cp">#endif</span>
	 <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mh">0x00</span>:		<span class="cm">/* DATA OUT -- tmc18c50/tmc18c30 only */</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">!=</span> <span class="n">tmc1800</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">have_data_in</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">have_data_in</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	    <span class="n">outb</span><span class="p">(</span><span class="mh">0xd0</span> <span class="o">|</span> <span class="n">PARITY_MASK</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Cntl</span><span class="p">);</span>
	 <span class="p">}</span>
	 <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mh">0x04</span>:		<span class="cm">/* DATA IN -- tmc18c50/tmc18c30 only */</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">!=</span> <span class="n">tmc1800</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">have_data_in</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">have_data_in</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	    <span class="n">outb</span><span class="p">(</span><span class="mh">0x90</span> <span class="o">|</span> <span class="n">PARITY_MASK</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Cntl</span><span class="p">);</span>
	 <span class="p">}</span>
	 <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mh">0x0c</span>:		<span class="cm">/* STATUS IN */</span>
	 <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">Read_SCSI_Data</span><span class="p">);</span>
<span class="cp">#if EVERY_ACCESS</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;Status = %x, &quot;</span><span class="p">,</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span> <span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if ERRORS_ONLY</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span>
	     <span class="o">&amp;&amp;</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span> <span class="o">!=</span> <span class="mi">2</span>
	     <span class="o">&amp;&amp;</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; target = %d, command = %x, status = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
		    <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		    <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span> <span class="p">);</span>
	 <span class="p">}</span>
<span class="cp">#endif</span>
	       <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mh">0x0a</span>:		<span class="cm">/* MESSAGE OUT */</span>
	 <span class="n">outb</span><span class="p">(</span><span class="n">MESSAGE_REJECT</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Write_SCSI_Data</span><span class="p">);</span> <span class="cm">/* Reject */</span>
	 <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mh">0x0e</span>:		<span class="cm">/* MESSAGE IN */</span>
	 <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Message</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">Read_SCSI_Data</span><span class="p">);</span>
<span class="cp">#if EVERY_ACCESS</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;Message = %x, &quot;</span><span class="p">,</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Message</span> <span class="p">);</span>
<span class="cp">#endif</span>
	 <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Message</span><span class="p">)</span> <span class="o">++</span><span class="n">done</span><span class="p">;</span>
<span class="cp">#if DEBUG_MESSAGES || EVERY_ACCESS</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Message</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; message = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Message</span> <span class="p">);</span>
	 <span class="p">}</span>
<span class="cp">#endif</span>
	 <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">==</span> <span class="n">tmc1800</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">have_data_in</span>
       <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">sent_command</span> <span class="o">&gt;=</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">))</span> <span class="p">{</span>
      
      <span class="k">if</span><span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
      <span class="p">{</span>
	 <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">have_data_in</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	 <span class="n">outb</span><span class="p">(</span><span class="mh">0xd0</span> <span class="o">|</span> <span class="n">PARITY_MASK</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Cntl</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span>
      <span class="p">{</span>
	 <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">have_data_in</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	 <span class="n">outb</span><span class="p">(</span><span class="mh">0x90</span> <span class="o">|</span> <span class="n">PARITY_MASK</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Cntl</span><span class="p">);</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">have_data_in</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* DATA OUT */</span>
      <span class="k">while</span> <span class="p">((</span><span class="n">data_count</span> <span class="o">=</span> <span class="n">FIFO_Size</span> <span class="o">-</span> <span class="n">inw</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">FIFO_Data_Count</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">512</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if EVERY_ACCESS</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;DC=%d, &quot;</span><span class="p">,</span> <span class="n">data_count</span> <span class="p">)</span> <span class="p">;</span>
<span class="cp">#endif</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">data_count</span> <span class="o">&gt;</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span><span class="p">)</span>
	       <span class="n">data_count</span> <span class="o">=</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span><span class="p">;</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">data_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if EVERY_ACCESS</span>
	    <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%d OUT, &quot;</span><span class="p">,</span> <span class="n">data_count</span> <span class="p">);</span>
<span class="cp">#endif</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">data_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
	       <span class="n">outb</span><span class="p">(</span><span class="o">*</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="o">++</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Write_FIFO</span><span class="p">);</span>
	       <span class="o">--</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span><span class="p">;</span>
	    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	       <span class="n">data_count</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	       <span class="n">outsw</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">Write_FIFO</span><span class="p">,</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span> <span class="n">data_count</span><span class="p">);</span>
	       <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">data_count</span><span class="p">;</span>
	       <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">data_count</span><span class="p">;</span>
	    <span class="p">}</span>
	 <span class="p">}</span>
	 <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span><span class="p">)</span> <span class="p">{</span>
	       <span class="o">--</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span><span class="p">;</span>
	       <span class="o">++</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span>
	       <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
	       <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">=</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	    <span class="p">}</span> <span class="k">else</span>
		  <span class="k">break</span><span class="p">;</span>
	 <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
   
   <span class="k">if</span> <span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">have_data_in</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* DATA IN */</span>
      <span class="k">while</span> <span class="p">((</span><span class="n">data_count</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">FIFO_Data_Count</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if EVERY_ACCESS</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;DC=%d, &quot;</span><span class="p">,</span> <span class="n">data_count</span> <span class="p">);</span>
<span class="cp">#endif</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">data_count</span> <span class="o">&gt;</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span><span class="p">)</span>
	       <span class="n">data_count</span> <span class="o">=</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span><span class="p">;</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">data_count</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if EVERY_ACCESS</span>
	    <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%d IN, &quot;</span><span class="p">,</span> <span class="n">data_count</span> <span class="p">);</span>
<span class="cp">#endif</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">data_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
	       <span class="o">*</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">Read_FIFO</span><span class="p">);</span>
	       <span class="o">--</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span><span class="p">;</span>
	    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	       <span class="n">data_count</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Number of words */</span>
	       <span class="n">insw</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">Read_FIFO</span><span class="p">,</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span> <span class="n">data_count</span><span class="p">);</span>
	       <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">data_count</span><span class="p">;</span>
	       <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">data_count</span><span class="p">;</span>
	    <span class="p">}</span>
	 <span class="p">}</span>
	 <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span>
	     <span class="o">&amp;&amp;</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span><span class="p">)</span> <span class="p">{</span>
	    <span class="o">--</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span><span class="p">;</span>
	    <span class="o">++</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span>
	    <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
	    <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span> <span class="o">=</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	 <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
   
   <span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if EVERY_ACCESS</span>
      <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; ** IN DONE %d ** &quot;</span><span class="p">,</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">have_data_in</span> <span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if ERRORS_ONLY</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span><span class="p">)</span> <span class="p">{</span>
	      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">current_SC</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="p">{</span>
	    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">key</span><span class="p">;</span>
	    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">code</span><span class="p">;</span>
	    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">qualifier</span><span class="p">;</span>

	    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
	    <span class="n">code</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">12</span><span class="p">));</span>
	    <span class="n">qualifier</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">13</span><span class="p">));</span>

	    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">!=</span> <span class="n">UNIT_ATTENTION</span>
		<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">NOT_READY</span>
		     <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">==</span> <span class="mh">0x04</span>
		     <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">qualifier</span> <span class="o">||</span> <span class="n">qualifier</span> <span class="o">==</span> <span class="mh">0x02</span> <span class="o">||</span> <span class="n">qualifier</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">))</span>
		<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">ILLEGAL_REQUEST</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="mh">0x25</span>
						<span class="o">||</span> <span class="n">code</span> <span class="o">==</span> <span class="mh">0x24</span>
						<span class="o">||</span> <span class="o">!</span><span class="n">code</span><span class="p">)))</span>
		  
		  <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; REQUEST SENSE&quot;</span>
			  <span class="s">&quot; Key = %x, Code = %x, Qualifier = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">key</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">qualifier</span> <span class="p">);</span>
	 <span class="p">}</span>
      <span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#if EVERY_ACCESS</span>
      <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;BEFORE MY_DONE. . .&quot;</span> <span class="p">);</span>
<span class="cp">#endif</span>
      <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
      <span class="n">my_done</span><span class="p">(</span> <span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
	       <span class="o">|</span> <span class="p">((</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Message</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">);</span>
      <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#if EVERY_ACCESS</span>
      <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;RETURNING.</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
<span class="cp">#endif</span>
      
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">&amp;</span> <span class="n">disconnect</span><span class="p">)</span> <span class="p">{</span>
	 <span class="n">outb</span><span class="p">(</span><span class="mh">0xd0</span> <span class="o">|</span> <span class="n">FIFO_COUNT</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Interrupt_Cntl</span><span class="p">);</span>
	 <span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Cntl</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	 <span class="n">outb</span><span class="p">(</span><span class="mh">0x90</span> <span class="o">|</span> <span class="n">FIFO_COUNT</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Interrupt_Cntl</span><span class="p">);</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="cp">#if DEBUG_RACE</span>
   <span class="n">in_interrupt_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
   <span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdomain_16x0_queue_lck</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">SCpnt</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">in_command</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">panic</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; fdomain_16x0_queue() NOT REENTRANT!</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
   <span class="p">}</span>
<span class="cp">#if EVERY_ACCESS</span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;queue: target = %d cmnd = 0x%02x pieces = %d size = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
	   <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span>
	   <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">),</span>
	   <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">));</span>
<span class="cp">#endif</span>

   <span class="n">fdomain_make_bus_idle</span><span class="p">();</span>

   <span class="n">current_SC</span>            <span class="o">=</span> <span class="n">SCpnt</span><span class="p">;</span> <span class="cm">/* Save this for the done function */</span>
   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>

   <span class="cm">/* Initialize static data */</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">current_SC</span><span class="p">))</span> <span class="p">{</span>
	   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">current_SC</span><span class="p">);</span>
	   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
	   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span>    <span class="o">=</span> <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span> <span class="o">=</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">current_SC</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span>              <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">this_residual</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span>           <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffers_residual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Status</span>              <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">Message</span>             <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">have_data_in</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">sent_command</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span>               <span class="o">=</span> <span class="n">in_arbitration</span><span class="p">;</span>

   <span class="cm">/* Start arbitration */</span>
   <span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Interrupt_Cntl</span><span class="p">);</span>
   <span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Cntl</span><span class="p">);</span>              <span class="cm">/* Disable data drivers */</span>
   <span class="n">outb</span><span class="p">(</span><span class="n">adapter_mask</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Data_NoACK</span><span class="p">);</span> <span class="cm">/* Set our id bit */</span>
   <span class="o">++</span><span class="n">in_command</span><span class="p">;</span>
   <span class="n">outb</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Interrupt_Cntl</span><span class="p">);</span>
   <span class="n">outb</span><span class="p">(</span><span class="mh">0x14</span> <span class="o">|</span> <span class="n">PARITY_MASK</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Cntl</span><span class="p">);</span> <span class="cm">/* Start arbitration */</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">fdomain_16x0_queue</span><span class="p">)</span>

<span class="cp">#if DEBUG_ABORT</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">print_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">SCpnt</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">imr</span><span class="p">;</span>
   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irr</span><span class="p">;</span>
   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">isr</span><span class="p">;</span>

   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SCpnt</span> <span class="o">||</span> <span class="o">!</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">||</span> <span class="o">!</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;scsi: &lt;fdomain&gt; Cannot provide detailed information</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
   <span class="p">}</span>
   
   <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fdomain_16x0_info</span><span class="p">(</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span> <span class="p">)</span> <span class="p">);</span>
   <span class="n">print_banner</span><span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
   <span class="k">switch</span> <span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">case</span> <span class="n">in_arbitration</span>: <span class="n">printk</span><span class="p">(</span><span class="s">&quot;arbitration&quot;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
   <span class="k">case</span> <span class="n">in_selection</span>:   <span class="n">printk</span><span class="p">(</span><span class="s">&quot;selection&quot;</span><span class="p">);</span>   <span class="k">break</span><span class="p">;</span>
   <span class="k">case</span> <span class="n">in_other</span>:       <span class="n">printk</span><span class="p">(</span><span class="s">&quot;other&quot;</span><span class="p">);</span>       <span class="k">break</span><span class="p">;</span>
   <span class="nl">default:</span>             <span class="n">printk</span><span class="p">(</span><span class="s">&quot;unknown&quot;</span><span class="p">);</span>     <span class="k">break</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; (%d), target = %d cmnd = 0x%02x pieces = %d size = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span><span class="p">,</span>
	   <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
	   <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span>
	   <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">),</span>
	   <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">));</span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;sent_command = %d, have_data_in = %d, timeout = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">sent_command</span><span class="p">,</span>
	   <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">have_data_in</span><span class="p">,</span>
	   <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="p">);</span>
<span class="cp">#if DEBUG_RACE</span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;in_interrupt_flag = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">in_interrupt_flag</span> <span class="p">);</span>
<span class="cp">#endif</span>

   <span class="n">imr</span> <span class="o">=</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span> <span class="mh">0x0a1</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">inb</span><span class="p">(</span> <span class="mh">0x21</span> <span class="p">);</span>
   <span class="n">outb</span><span class="p">(</span> <span class="mh">0x0a</span><span class="p">,</span> <span class="mh">0xa0</span> <span class="p">);</span>
   <span class="n">irr</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span> <span class="mh">0xa0</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
   <span class="n">outb</span><span class="p">(</span> <span class="mh">0x0a</span><span class="p">,</span> <span class="mh">0x20</span> <span class="p">);</span>
   <span class="n">irr</span> <span class="o">+=</span> <span class="n">inb</span><span class="p">(</span> <span class="mh">0x20</span> <span class="p">);</span>
   <span class="n">outb</span><span class="p">(</span> <span class="mh">0x0b</span><span class="p">,</span> <span class="mh">0xa0</span> <span class="p">);</span>
   <span class="n">isr</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span> <span class="mh">0xa0</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
   <span class="n">outb</span><span class="p">(</span> <span class="mh">0x0b</span><span class="p">,</span> <span class="mh">0x20</span> <span class="p">);</span>
   <span class="n">isr</span> <span class="o">+=</span> <span class="n">inb</span><span class="p">(</span> <span class="mh">0x20</span> <span class="p">);</span>

				<span class="cm">/* Print out interesting information */</span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;IMR = 0x%04x&quot;</span><span class="p">,</span> <span class="n">imr</span> <span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">imr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">interrupt_level</span><span class="p">))</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; (masked)&quot;</span> <span class="p">);</span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;, IRR = 0x%04x, ISR = 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irr</span><span class="p">,</span> <span class="n">isr</span> <span class="p">);</span>

   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;SCSI Status      = 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inb</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Status</span><span class="p">));</span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;TMC Status       = 0x%02x&quot;</span><span class="p">,</span> <span class="n">inb</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Status</span><span class="p">));</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">inb</span><span class="p">((</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; (interrupt)&quot;</span> <span class="p">);</span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
   <span class="n">printk</span><span class="p">(</span><span class="s">&quot;Interrupt Status = 0x%02x&quot;</span><span class="p">,</span> <span class="n">inb</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">Interrupt_Status</span><span class="p">));</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">Interrupt_Status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x08</span><span class="p">)</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; (enabled)&quot;</span> <span class="p">);</span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">==</span> <span class="n">tmc18c50</span> <span class="o">||</span> <span class="n">chip</span> <span class="o">==</span> <span class="n">tmc18c30</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printk</span><span class="p">(</span><span class="s">&quot;FIFO Status      = 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inb</span><span class="p">(</span><span class="n">port_base</span> <span class="o">+</span> <span class="n">FIFO_Status</span><span class="p">));</span>
      <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;Int. Condition   = 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">inb</span><span class="p">(</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Interrupt_Cond</span> <span class="p">)</span> <span class="p">);</span>
   <span class="p">}</span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;Configuration 1  = 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inb</span><span class="p">(</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Configuration1</span> <span class="p">)</span> <span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">==</span> <span class="n">tmc18c50</span> <span class="o">||</span> <span class="n">chip</span> <span class="o">==</span> <span class="n">tmc18c30</span><span class="p">)</span>
	 <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;Configuration 2  = 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">inb</span><span class="p">(</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">Configuration2</span> <span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdomain_16x0_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">SCpnt</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if EVERY_ACCESS || ERRORS_ONLY || DEBUG_ABORT</span>
   <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;scsi: &lt;fdomain&gt; abort &quot;</span> <span class="p">);</span>
<span class="cp">#endif</span>

   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_command</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if EVERY_ACCESS || ERRORS_ONLY</span>
      <span class="n">printk</span><span class="p">(</span> <span class="s">&quot; (not in command)</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
<span class="cp">#endif</span>
      <span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="n">printk</span><span class="p">(</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>

<span class="cp">#if DEBUG_ABORT</span>
   <span class="n">print_info</span><span class="p">(</span> <span class="n">SCpnt</span> <span class="p">);</span>
<span class="cp">#endif</span>

   <span class="n">fdomain_make_bus_idle</span><span class="p">();</span>
   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">|=</span> <span class="n">aborted</span><span class="p">;</span>
   <span class="n">current_SC</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
   
   <span class="cm">/* Aborts are not done well. . . */</span>
   <span class="n">my_done</span><span class="p">(</span><span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fdomain_16x0_bus_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">SCpnt</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

   <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

   <span class="n">outb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Cntl</span><span class="p">);</span>
   <span class="n">do_pause</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
   <span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Cntl</span><span class="p">);</span>
   <span class="n">do_pause</span><span class="p">(</span> <span class="mi">115</span> <span class="p">);</span>
   <span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">SCSI_Mode_Cntl</span><span class="p">);</span>
   <span class="n">outb</span><span class="p">(</span><span class="n">PARITY_MASK</span><span class="p">,</span> <span class="n">port_base</span> <span class="o">+</span> <span class="n">TMC_Cntl</span><span class="p">);</span>

   <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdomain_16x0_biosparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
		<span class="n">sector_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">info_array</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">int</span>              <span class="n">drive</span><span class="p">;</span>
   <span class="kt">int</span>		    <span class="n">size</span>      <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
   <span class="kt">unsigned</span> <span class="kt">long</span>    <span class="n">offset</span><span class="p">;</span>
   <span class="k">struct</span> <span class="n">drive_info</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cylinders</span><span class="p">;</span>
      <span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">heads</span><span class="p">;</span>
      <span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">sectors</span><span class="p">;</span>
   <span class="p">}</span> <span class="n">i</span><span class="p">;</span>
   
   <span class="cm">/* NOTES:</span>
<span class="cm">      The RAM area starts at 0x1f00 from the bios_base address.</span>

<span class="cm">      For BIOS Version 2.0:</span>
<span class="cm">      </span>
<span class="cm">      The drive parameter table seems to start at 0x1f30.</span>
<span class="cm">      The first byte&#39;s purpose is not known.</span>
<span class="cm">      Next is the cylinder, head, and sector information.</span>
<span class="cm">      The last 4 bytes appear to be the drive&#39;s size in sectors.</span>
<span class="cm">      The other bytes in the drive parameter table are unknown.</span>
<span class="cm">      If anyone figures them out, please send me mail, and I will</span>
<span class="cm">      update these notes.</span>

<span class="cm">      Tape drives do not get placed in this table.</span>

<span class="cm">      There is another table at 0x1fea:</span>
<span class="cm">      If the byte is 0x01, then the SCSI ID is not in use.</span>
<span class="cm">      If the byte is 0x18 or 0x48, then the SCSI ID is in use,</span>
<span class="cm">      although tapes don&#39;t seem to be in this table.  I haven&#39;t</span>
<span class="cm">      seen any other numbers (in a limited sample).</span>

<span class="cm">      0x1f2d is a drive count (i.e., not including tapes)</span>

<span class="cm">      The table at 0x1fcc are I/O ports addresses for the various</span>
<span class="cm">      operations.  I calculate these by hand in this driver code.</span>

<span class="cm">      </span>
<span class="cm">      </span>
<span class="cm">      For the ISA-200S version of BIOS Version 2.0:</span>

<span class="cm">      The drive parameter table starts at 0x1f33.</span>

<span class="cm">      WARNING: Assume that the table entry is 25 bytes long.  Someone needs</span>
<span class="cm">      to check this for the Quantum ISA-200S card.</span>

<span class="cm">      </span>
<span class="cm">      </span>
<span class="cm">      For BIOS Version 3.2:</span>

<span class="cm">      The drive parameter table starts at 0x1f70.  Each entry is</span>
<span class="cm">      0x0a bytes long.  Heads are one less than we need to report.</span>
<span class="cm">    */</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">MAJOR</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SCSI_DISK0_MAJOR</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi: &lt;fdomain&gt; fdomain_16x0_biosparam: too many disks&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="n">drive</span> <span class="o">=</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">bios_major</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="n">Quantum</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="mi">2</span>:			<span class="cm">/* ISA_200S */</span>
				<span class="cm">/* The value of 25 has never been verified.</span>
<span class="cm">				   It should probably be 15. */</span>
	 <span class="n">offset</span> <span class="o">=</span> <span class="mh">0x1f33</span> <span class="o">+</span> <span class="n">drive</span> <span class="o">*</span> <span class="mi">25</span><span class="p">;</span>
	 <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">3</span>:			<span class="cm">/* ISA_250MG */</span>
	 <span class="n">offset</span> <span class="o">=</span> <span class="mh">0x1f36</span> <span class="o">+</span> <span class="n">drive</span> <span class="o">*</span> <span class="mi">15</span><span class="p">;</span>
	 <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">4</span>:			<span class="cm">/* ISA_200S (another one) */</span>
	 <span class="n">offset</span> <span class="o">=</span> <span class="mh">0x1f34</span> <span class="o">+</span> <span class="n">drive</span> <span class="o">*</span> <span class="mi">15</span><span class="p">;</span>
	 <span class="k">break</span><span class="p">;</span>
      <span class="nl">default:</span>
	 <span class="n">offset</span> <span class="o">=</span> <span class="mh">0x1f31</span> <span class="o">+</span> <span class="n">drive</span> <span class="o">*</span> <span class="mi">25</span><span class="p">;</span>
	 <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">memcpy_fromio</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="n">bios_mem</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="k">struct</span> <span class="n">drive_info</span> <span class="p">)</span> <span class="p">);</span>
      <span class="n">info_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">heads</span><span class="p">;</span>
      <span class="n">info_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">sectors</span><span class="p">;</span>
      <span class="n">info_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">cylinders</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bios_major</span> <span class="o">==</span> <span class="mi">3</span>
	      <span class="o">&amp;&amp;</span> <span class="n">bios_minor</span> <span class="o">&gt;=</span> <span class="mi">0</span>
	      <span class="o">&amp;&amp;</span> <span class="n">bios_minor</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 3.0 and 3.2 BIOS */</span>
      <span class="n">memcpy_fromio</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="n">bios_mem</span> <span class="o">+</span> <span class="mh">0x1f71</span> <span class="o">+</span> <span class="n">drive</span> <span class="o">*</span> <span class="mi">10</span><span class="p">,</span>
		     <span class="k">sizeof</span><span class="p">(</span> <span class="k">struct</span> <span class="n">drive_info</span> <span class="p">)</span> <span class="p">);</span>
      <span class="n">info_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">heads</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">info_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">sectors</span><span class="p">;</span>
      <span class="n">info_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">cylinders</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>			<span class="cm">/* 3.4 BIOS (and up?) */</span>
      <span class="cm">/* This algorithm was provided by Future Domain (much thanks!). */</span>
      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">scsi_bios_ptable</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">[</span><span class="mi">65</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xaa</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x55</span> <span class="cm">/* Partition table valid */</span>
	  <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="p">{</span>			    <span class="cm">/* Partition type */</span>

	 <span class="cm">/* The partition table layout is as follows:</span>

<span class="cm">	    Start: 0x1b3h</span>
<span class="cm">	    Offset: 0 = partition status</span>
<span class="cm">		    1 = starting head</span>
<span class="cm">		    2 = starting sector and cylinder (word, encoded)</span>
<span class="cm">		    4 = partition type</span>
<span class="cm">		    5 = ending head</span>
<span class="cm">		    6 = ending sector and cylinder (word, encoded)</span>
<span class="cm">		    8 = starting absolute sector (double word)</span>
<span class="cm">		    c = number of sectors (double word)</span>
<span class="cm">	    Signature: 0x1fe = 0x55aa</span>

<span class="cm">	    So, this algorithm assumes:</span>
<span class="cm">	    1) the first partition table is in use,</span>
<span class="cm">	    2) the data in the first entry is correct, and</span>
<span class="cm">	    3) partitions never divide cylinders</span>

<span class="cm">	    Note that (1) may be FALSE for NetBSD (and other BSD flavors),</span>
<span class="cm">	    as well as for Linux.  Note also, that Linux doesn&#39;t pay any</span>
<span class="cm">	    attention to the fields that are used by this algorithm -- it</span>
<span class="cm">	    only uses the absolute sector data.  Recent versions of Linux&#39;s</span>
<span class="cm">	    fdisk(1) will fill this data in correctly, and forthcoming</span>
<span class="cm">	    versions will check for consistency.</span>

<span class="cm">	    Checking for a non-zero partition type is not part of the</span>
<span class="cm">	    Future Domain algorithm, but it seemed to be a reasonable thing</span>
<span class="cm">	    to do, especially in the Linux and BSD worlds. */</span>

	 <span class="n">info_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>	    <span class="cm">/* heads */</span>
	 <span class="n">info_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>	    <span class="cm">/* sectors */</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

 	 <span class="cm">/* Note that this new method guarantees that there will always be</span>
<span class="cm">	    less than 1024 cylinders on a platter.  This is good for drives</span>
<span class="cm">	    up to approximately 7.85GB (where 1GB = 1024 * 1024 kB). */</span>

	 <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mh">0x7e0000U</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">info_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span> <span class="cm">/* heads   = 255 */</span>
	    <span class="n">info_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x3f</span><span class="p">;</span> <span class="cm">/* sectors =  63 */</span>
	 <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mh">0x200000U</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">info_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="cm">/* heads   = 128 */</span>
	    <span class="n">info_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x3f</span><span class="p">;</span> <span class="cm">/* sectors =  63 */</span>
	 <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	    <span class="n">info_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span> <span class="cm">/* heads   =  64 */</span>
	    <span class="n">info_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span> <span class="cm">/* sectors =  32 */</span>
	 <span class="p">}</span>
      <span class="p">}</span>
				<span class="cm">/* For both methods, compute the cylinders */</span>
      <span class="n">info_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">size</span> <span class="o">/</span> <span class="p">(</span><span class="n">info_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">info_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
      <span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
   <span class="p">}</span>
   
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdomain_16x0_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shpnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shpnt</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">shpnt</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">shpnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shpnt</span><span class="o">-&gt;</span><span class="n">io_port</span> <span class="o">&amp;&amp;</span> <span class="n">shpnt</span><span class="o">-&gt;</span><span class="n">n_io_port</span><span class="p">)</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">shpnt</span><span class="o">-&gt;</span><span class="n">io_port</span><span class="p">,</span> <span class="n">shpnt</span><span class="o">-&gt;</span><span class="n">n_io_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PCI_bus</span><span class="p">)</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">PCI_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">fdomain_driver_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span>			<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;fdomain&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_name</span>		<span class="o">=</span> <span class="s">&quot;fdomain&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">detect</span>			<span class="o">=</span> <span class="n">fdomain_16x0_detect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span>			<span class="o">=</span> <span class="n">fdomain_16x0_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span>		<span class="o">=</span> <span class="n">fdomain_16x0_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_abort_handler</span>	<span class="o">=</span> <span class="n">fdomain_16x0_abort</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_bus_reset_handler</span>	<span class="o">=</span> <span class="n">fdomain_16x0_bus_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bios_param</span>		<span class="o">=</span> <span class="n">fdomain_16x0_biosparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">fdomain_16x0_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_queue</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">this_id</span>		<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sg_tablesize</span>		<span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmd_per_lun</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span>		<span class="o">=</span> <span class="n">DISABLE_CLUSTERING</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifndef PCMCIA</span>
<span class="cp">#ifdef CONFIG_PCI</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">fdomain_pci_tbl</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_FD</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_FD_36C70</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">fdomain_pci_tbl</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#define driver_template fdomain_driver_template</span>
<span class="cp">#include &quot;scsi_module.c&quot;</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
