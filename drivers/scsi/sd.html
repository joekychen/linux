<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › sd.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sd.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *      sd.c Copyright (C) 1992 Drew Eckhardt</span>
<span class="cm"> *           Copyright (C) 1993, 1994, 1995, 1999 Eric Youngdale</span>
<span class="cm"> *</span>
<span class="cm"> *      Linux scsi disk driver</span>
<span class="cm"> *              Initial versions: Drew Eckhardt</span>
<span class="cm"> *              Subsequent revisions: Eric Youngdale</span>
<span class="cm"> *	Modification history:</span>
<span class="cm"> *       - Drew Eckhardt &lt;drew@colorado.edu&gt; original</span>
<span class="cm"> *       - Eric Youngdale &lt;eric@andante.org&gt; add scatter-gather, multiple </span>
<span class="cm"> *         outstanding request, and other enhancements.</span>
<span class="cm"> *         Support loadable low-level scsi drivers.</span>
<span class="cm"> *       - Jirka Hanika &lt;geo@ff.cuni.cz&gt; support more scsi disks using </span>
<span class="cm"> *         eight major numbers.</span>
<span class="cm"> *       - Richard Gooch &lt;rgooch@atnf.csiro.au&gt; support devfs.</span>
<span class="cm"> *	 - Torben Mathiasen &lt;tmm@image.dk&gt; Resource allocation fixes in </span>
<span class="cm"> *	   sd_init and cleanups.</span>
<span class="cm"> *	 - Alex Davis &lt;letmein@erols.com&gt; Fix problem where partition info</span>
<span class="cm"> *	   not being read in sd_open. Fix problem where removable media </span>
<span class="cm"> *	   could be ejected after sd_open.</span>
<span class="cm"> *	 - Douglas Gilbert &lt;dgilbert@interlog.com&gt; cleanup for lk 2.5.x</span>
<span class="cm"> *	 - Badari Pulavarty &lt;pbadari@us.ibm.com&gt;, Matthew Wilcox </span>
<span class="cm"> *	   &lt;willy@debian.org&gt;, Kurt Garloff &lt;garloff@suse.de&gt;: </span>
<span class="cm"> *	   Support 32k/1M disks.</span>
<span class="cm"> *</span>
<span class="cm"> *	Logging policy (needs CONFIG_SCSI_LOGGING defined):</span>
<span class="cm"> *	 - setting up transfer: SCSI_LOG_HLQUEUE levels 1 and 2</span>
<span class="cm"> *	 - end of transfer (bh + scsi_lib): SCSI_LOG_HLCOMPLETE level 1</span>
<span class="cm"> *	 - entering sd_ioctl: SCSI_LOG_IOCTL level 1</span>
<span class="cm"> *	 - entering other commands: SCSI_LOG_HLQUEUE level 3</span>
<span class="cm"> *	Note: when the logging level is set by the user, it must be greater</span>
<span class="cm"> *	than the level indicated above to trigger output.	</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/genhd.h&gt;</span>
<span class="cp">#include &lt;linux/hdreg.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/blkpg.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/string_helpers.h&gt;</span>
<span class="cp">#include &lt;linux/async.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_dbg.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_driver.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_ioctl.h&gt;</span>
<span class="cp">#include &lt;scsi/scsicam.h&gt;</span>

<span class="cp">#include &quot;sd.h&quot;</span>
<span class="cp">#include &quot;scsi_priv.h&quot;</span>
<span class="cp">#include &quot;scsi_logging.h&quot;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Eric Youngdale&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;SCSI disk (sd) driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK0_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK1_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK2_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK3_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK4_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK5_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK6_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK7_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK8_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK9_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK10_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK11_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK12_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK13_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK14_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_DISK15_MAJOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_SCSI_DEVICE</span><span class="p">(</span><span class="n">TYPE_DISK</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_SCSI_DEVICE</span><span class="p">(</span><span class="n">TYPE_MOD</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_SCSI_DEVICE</span><span class="p">(</span><span class="n">TYPE_RBC</span><span class="p">);</span>

<span class="cp">#if !defined(CONFIG_DEBUG_BLOCK_EXT_DEVT)</span>
<span class="cp">#define SD_MINORS	16</span>
<span class="cp">#else</span>
<span class="cp">#define SD_MINORS	0</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sd_config_discard</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">sd_revalidate_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sd_unlock_native_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">sd_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">sd_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sd_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sd_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sd_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sd_rescan</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sd_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sd_eh_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sd_read_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">scsi_disk_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sd_print_sense_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sd_print_result</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">sd_index_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_IDA</span><span class="p">(</span><span class="n">sd_index_ida</span><span class="p">);</span>

<span class="cm">/* This semaphore is used to mediate the 0-&gt;1 reference get in the</span>
<span class="cm"> * face of object destruction (i.e. we can&#39;t allow a get on an</span>
<span class="cm"> * object after last put) */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">sd_ref_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">sd_cdb_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="n">mempool_t</span> <span class="o">*</span><span class="n">sd_cdb_pool</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sd_cache_types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;write through&quot;</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">,</span> <span class="s">&quot;write back&quot;</span><span class="p">,</span>
	<span class="s">&quot;write back, no read (daft)&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_store_cache_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ct</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">rcd</span><span class="p">,</span> <span class="n">wce</span><span class="p">,</span> <span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buffer_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_mode_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_DISK</span><span class="p">)</span>
		<span class="cm">/* no cache control on RBC devices; theoretically they</span>
<span class="cm">		 * can do it, but there&#39;s probably so many exceptions</span>
<span class="cm">		 * it&#39;s not worth the risk */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sd_cache_types</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sd_cache_types</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">sd_cache_types</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ct</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ct</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">rcd</span> <span class="o">=</span> <span class="n">ct</span> <span class="o">&amp;</span> <span class="mh">0x01</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wce</span> <span class="o">=</span> <span class="n">ct</span> <span class="o">&amp;</span> <span class="mh">0x02</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_mode_sense</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">SD_TIMEOUT</span><span class="p">,</span>
			    <span class="n">SD_MAX_RETRIES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">data</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">data</span><span class="p">.</span><span class="n">header_length</span> <span class="o">-</span>
		  <span class="n">data</span><span class="p">.</span><span class="n">block_descriptor_length</span><span class="p">);</span>
	<span class="n">buffer_data</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">data</span><span class="p">.</span><span class="n">header_length</span> <span class="o">+</span>
		<span class="n">data</span><span class="p">.</span><span class="n">block_descriptor_length</span><span class="p">;</span>
	<span class="n">buffer_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x05</span><span class="p">;</span>
	<span class="n">buffer_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="n">wce</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">|</span> <span class="n">rcd</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">buffer_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_mode_select</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">buffer_data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">SD_TIMEOUT</span><span class="p">,</span>
			     <span class="n">SD_MAX_RETRIES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_sense_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sshdr</span><span class="p">))</span>
			<span class="n">sd_print_sense_hdr</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">revalidate_disk</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_store_manage_start_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">manage_start_stop</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_store_allow_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_DISK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">allow_restart</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_show_cache_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		   <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">RCD</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">WCE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sd_cache_types</span><span class="p">[</span><span class="n">ct</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_show_fua</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">DPOFUA</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_show_manage_start_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">manage_start_stop</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_show_allow_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">allow_restart</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_show_protection_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">protection_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_show_protection_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dif</span><span class="p">,</span> <span class="n">dix</span><span class="p">;</span>

	<span class="n">dif</span> <span class="o">=</span> <span class="n">scsi_host_dif_capable</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">protection_type</span><span class="p">);</span>
	<span class="n">dix</span> <span class="o">=</span> <span class="n">scsi_host_dix_capable</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">protection_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dix</span> <span class="o">&amp;&amp;</span> <span class="n">scsi_host_dix_capable</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">SD_DIF_TYPE0_PROTECTION</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dif</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dix</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dif</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dix</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;none</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;%s%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dix</span> <span class="o">?</span> <span class="s">&quot;dix&quot;</span> <span class="o">:</span> <span class="s">&quot;dif&quot;</span><span class="p">,</span> <span class="n">dif</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_show_app_tag_own</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">ATO</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_show_thin_provisioning</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">lbpme</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lbp_mode</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">SD_LBP_FULL</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;full&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SD_LBP_UNMAP</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;unmap&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SD_LBP_WS16</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;writesame_16&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SD_LBP_WS10</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;writesame_10&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SD_LBP_ZERO</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;writesame_zero&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SD_LBP_DISABLE</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;disabled&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_show_provisioning_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lbp_mode</span><span class="p">[</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">provisioning_mode</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_store_provisioning_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_DISK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">lbp_mode</span><span class="p">[</span><span class="n">SD_LBP_UNMAP</span><span class="p">],</span> <span class="mi">20</span><span class="p">))</span>
		<span class="n">sd_config_discard</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">SD_LBP_UNMAP</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">lbp_mode</span><span class="p">[</span><span class="n">SD_LBP_WS16</span><span class="p">],</span> <span class="mi">20</span><span class="p">))</span>
		<span class="n">sd_config_discard</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">SD_LBP_WS16</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">lbp_mode</span><span class="p">[</span><span class="n">SD_LBP_WS10</span><span class="p">],</span> <span class="mi">20</span><span class="p">))</span>
		<span class="n">sd_config_discard</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">SD_LBP_WS10</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">lbp_mode</span><span class="p">[</span><span class="n">SD_LBP_ZERO</span><span class="p">],</span> <span class="mi">20</span><span class="p">))</span>
		<span class="n">sd_config_discard</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">SD_LBP_ZERO</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">lbp_mode</span><span class="p">[</span><span class="n">SD_LBP_DISABLE</span><span class="p">],</span> <span class="mi">20</span><span class="p">))</span>
		<span class="n">sd_config_discard</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">SD_LBP_DISABLE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_show_max_medium_access_timeouts</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">max_medium_access_timeouts</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sd_store_max_medium_access_timeouts</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kstrtouint</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">max_medium_access_timeouts</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">sd_disk_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cache_type</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">sd_show_cache_type</span><span class="p">,</span>
	       <span class="n">sd_store_cache_type</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">FUA</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">sd_show_fua</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">allow_restart</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">sd_show_allow_restart</span><span class="p">,</span>
	       <span class="n">sd_store_allow_restart</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">manage_start_stop</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">sd_show_manage_start_stop</span><span class="p">,</span>
	       <span class="n">sd_store_manage_start_stop</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">protection_type</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">sd_show_protection_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">protection_mode</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">sd_show_protection_mode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">app_tag_own</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">sd_show_app_tag_own</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">thin_provisioning</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">sd_show_thin_provisioning</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">provisioning_mode</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">sd_show_provisioning_mode</span><span class="p">,</span>
	       <span class="n">sd_store_provisioning_mode</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">max_medium_access_timeouts</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span>
	       <span class="n">sd_show_max_medium_access_timeouts</span><span class="p">,</span>
	       <span class="n">sd_store_max_medium_access_timeouts</span><span class="p">),</span>
	<span class="n">__ATTR_NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="n">sd_disk_class</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;scsi_disk&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_release</span>	<span class="o">=</span> <span class="n">scsi_disk_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_attrs</span>	<span class="o">=</span> <span class="n">sd_disk_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_driver</span> <span class="n">sd_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>			<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">gendrv</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;sd&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">sd_probe</span><span class="p">,</span>
		<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">sd_remove</span><span class="p">,</span>
		<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">sd_suspend</span><span class="p">,</span>
		<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">sd_resume</span><span class="p">,</span>
		<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">sd_shutdown</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">rescan</span>			<span class="o">=</span> <span class="n">sd_rescan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">done</span>			<span class="o">=</span> <span class="n">sd_done</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_action</span>		<span class="o">=</span> <span class="n">sd_eh_action</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Device no to disk mapping:</span>
<span class="cm"> * </span>
<span class="cm"> *       major         disc2     disc  p1</span>
<span class="cm"> *   |............|.............|....|....| &lt;- dev_t</span>
<span class="cm"> *    31        20 19          8 7  4 3  0</span>
<span class="cm"> * </span>
<span class="cm"> * Inside a major, we have 16k disks, however mapped non-</span>
<span class="cm"> * contiguously. The first 16 disks are for major0, the next</span>
<span class="cm"> * ones with major1, ... Disk 256 is for major0 again, disk 272 </span>
<span class="cm"> * for major1, ... </span>
<span class="cm"> * As we stay compatible with our numbering scheme, we can reuse </span>
<span class="cm"> * the well-know SCSI majors 8, 65--71, 136--143.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_major</span><span class="p">(</span><span class="kt">int</span> <span class="n">major_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">major_idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">return</span> <span class="n">SCSI_DISK0_MAJOR</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span> <span class="p">...</span> <span class="mi">7</span>:
		<span class="k">return</span> <span class="n">SCSI_DISK1_MAJOR</span> <span class="o">+</span> <span class="n">major_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span> <span class="p">...</span> <span class="mi">15</span>:
		<span class="k">return</span> <span class="n">SCSI_DISK8_MAJOR</span> <span class="o">+</span> <span class="n">major_idx</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* shut up gcc */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="nf">__scsi_disk_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_device_get</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">sdkp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sdkp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="nf">scsi_disk_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_ref_mutex</span><span class="p">);</span>
	<span class="n">sdkp</span> <span class="o">=</span> <span class="n">__scsi_disk_get</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_ref_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sdkp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="nf">scsi_disk_get_from_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_ref_mutex</span><span class="p">);</span>
	<span class="n">sdkp</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="p">)</span>
		<span class="n">sdkp</span> <span class="o">=</span> <span class="n">__scsi_disk_get</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_ref_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sdkp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_disk_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_ref_mutex</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_ref_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_prot_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prot_op</span> <span class="o">=</span> <span class="n">SCSI_PROT_NORMAL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dix</span> <span class="o">=</span> <span class="n">scsi_prot_sg_count</span><span class="p">(</span><span class="n">scmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dif</span> <span class="o">&amp;&amp;</span> <span class="n">dix</span><span class="p">)</span>
			<span class="n">prot_op</span> <span class="o">=</span> <span class="n">SCSI_PROT_READ_PASS</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dif</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dix</span><span class="p">)</span>
			<span class="n">prot_op</span> <span class="o">=</span> <span class="n">SCSI_PROT_READ_STRIP</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dif</span> <span class="o">&amp;&amp;</span> <span class="n">dix</span><span class="p">)</span>
			<span class="n">prot_op</span> <span class="o">=</span> <span class="n">SCSI_PROT_READ_INSERT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dif</span> <span class="o">&amp;&amp;</span> <span class="n">dix</span><span class="p">)</span>
			<span class="n">prot_op</span> <span class="o">=</span> <span class="n">SCSI_PROT_WRITE_PASS</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dif</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dix</span><span class="p">)</span>
			<span class="n">prot_op</span> <span class="o">=</span> <span class="n">SCSI_PROT_WRITE_INSERT</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dif</span> <span class="o">&amp;&amp;</span> <span class="n">dix</span><span class="p">)</span>
			<span class="n">prot_op</span> <span class="o">=</span> <span class="n">SCSI_PROT_WRITE_STRIP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scsi_set_prot_op</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span> <span class="n">prot_op</span><span class="p">);</span>
	<span class="n">scsi_set_prot_type</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span> <span class="n">dif</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_config_discard</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">logical_block_size</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_zeroes_data</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">lbprz</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_alignment</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">unmap_alignment</span> <span class="o">*</span>
		<span class="n">logical_block_size</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_granularity</span> <span class="o">=</span>
		<span class="n">max</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">physical_block_size</span><span class="p">,</span>
		    <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">unmap_granularity</span> <span class="o">*</span> <span class="n">logical_block_size</span><span class="p">);</span>

	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">provisioning_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">SD_LBP_DISABLE</span>:
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">max_discard_sectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">queue_flag_clear_unlocked</span><span class="p">(</span><span class="n">QUEUE_FLAG_DISCARD</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SD_LBP_UNMAP</span>:
		<span class="n">max_blocks</span> <span class="o">=</span> <span class="n">min_not_zero</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">max_unmap_blocks</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SD_LBP_WS16</span>:
		<span class="n">max_blocks</span> <span class="o">=</span> <span class="n">min_not_zero</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">max_ws_blocks</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SD_LBP_WS10</span>:
		<span class="n">max_blocks</span> <span class="o">=</span> <span class="n">min_not_zero</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">max_ws_blocks</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mh">0xffff</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SD_LBP_ZERO</span>:
		<span class="n">max_blocks</span> <span class="o">=</span> <span class="n">min_not_zero</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">max_ws_blocks</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mh">0xffff</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_zeroes_data</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">max_discard_sectors</span> <span class="o">=</span> <span class="n">max_blocks</span> <span class="o">*</span> <span class="p">(</span><span class="n">logical_block_size</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">queue_flag_set_unlocked</span><span class="p">(</span><span class="n">QUEUE_FLAG_DISCARD</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_setup_discard_cmnd - unmap blocks on thinly provisioned device</span>
<span class="cm"> * @sdp: scsi device to operate one</span>
<span class="cm"> * @rq: Request to prepare</span>
<span class="cm"> *</span>
<span class="cm"> * Will issue either UNMAP or WRITE SAME(16) depending on preference</span>
<span class="cm"> * indicated by target device.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scsi_setup_discard_cmnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_sectors</span> <span class="o">=</span> <span class="n">bio_sectors</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sector</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">nr_sectors</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">SD_TIMEOUT</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">BLKPREP_DEFER</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">provisioning_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SD_LBP_UNMAP</span>:
		<span class="n">buf</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">UNMAP</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>

		<span class="n">put_unaligned_be16</span><span class="p">(</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">put_unaligned_be16</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">put_unaligned_be64</span><span class="p">(</span><span class="n">sector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
		<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">nr_sectors</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>

		<span class="n">len</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SD_LBP_WS16</span>:
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">WRITE_SAME_16</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x8</span><span class="p">;</span> <span class="cm">/* UNMAP */</span>
		<span class="n">put_unaligned_be64</span><span class="p">(</span><span class="n">sector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">nr_sectors</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SD_LBP_WS10</span>:
	<span class="k">case</span> <span class="n">SD_LBP_ZERO</span>:
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">WRITE_SAME</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">provisioning_mode</span> <span class="o">==</span> <span class="n">SD_LBP_WS10</span><span class="p">)</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x8</span><span class="p">;</span> <span class="cm">/* UNMAP */</span>
		<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">sector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">put_unaligned_be16</span><span class="p">(</span><span class="n">nr_sectors</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">BLKPREP_KILL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">blk_add_request_payload</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_setup_blk_pc_cmnd</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">BLKPREP_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scsi_setup_flush_cmnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">SD_FLUSH_TIMEOUT</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">=</span> <span class="n">SD_MAX_RETRIES</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SYNCHRONIZE_CACHE</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">scsi_setup_blk_pc_cmnd</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_unprep_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sd_prep_fn - build a scsi (read or write) command from</span>
<span class="cm"> *	information in the request structure.</span>
<span class="cm"> *	@SCpnt: pointer to mid-level&#39;s per scsi command structure that</span>
<span class="cm"> *	contains request and into which the scsi command is written</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 1 if successful and 0 if error (or cannot be done now).</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_prep_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">SCpnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">block</span> <span class="o">=</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">sector_t</span> <span class="n">threshold</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">this_count</span> <span class="o">=</span> <span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">host_dif</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">protect</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Discard request come in as REQ_TYPE_FS but we turn them into</span>
<span class="cm">	 * block PC requests to make life easier.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_setup_discard_cmnd</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_FLUSH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_setup_flush_cmnd</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_BLOCK_PC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_setup_blk_pc_cmnd</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">!=</span> <span class="n">REQ_TYPE_FS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">BLKPREP_KILL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_setup_fs_cmnd</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">BLKPREP_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">SCpnt</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">;</span>
	<span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>

	<span class="cm">/* from here on until we&#39;re complete, any goto out</span>
<span class="cm">	 * is used for a killable error condition */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">BLKPREP_KILL</span><span class="p">;</span>

	<span class="n">SCSI_LOG_HLQUEUE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">,</span>
					<span class="s">&quot;sd_prep_fn: block=%llu, &quot;</span>
					<span class="s">&quot;count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="p">,</span>
					<span class="n">this_count</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdp</span> <span class="o">||</span> <span class="o">!</span><span class="n">scsi_device_online</span><span class="p">(</span><span class="n">sdp</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">block</span> <span class="o">+</span> <span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">get_capacity</span><span class="p">(</span><span class="n">disk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">SCSI_LOG_HLQUEUE</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">,</span>
						<span class="s">&quot;Finishing %u sectors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">)));</span>
		<span class="n">SCSI_LOG_HLQUEUE</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">,</span>
						<span class="s">&quot;Retry with 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">changed</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * quietly refuse to do anything to a changed disc until </span>
<span class="cm">		 * the changed bit has been reset</span>
<span class="cm">		 */</span>
		<span class="cm">/* printk(&quot;SCSI disk has been changed or is not present. Prohibiting further I/O.\n&quot;); */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some SD card readers can&#39;t handle multi-sector accesses which touch</span>
<span class="cm">	 * the last one or two hardware sectors.  Split accesses as needed.</span>
<span class="cm">	 */</span>
	<span class="n">threshold</span> <span class="o">=</span> <span class="n">get_capacity</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span> <span class="o">-</span> <span class="n">SD_LAST_BUGGY_SECTORS</span> <span class="o">*</span>
		<span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">/</span> <span class="mi">512</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">last_sector_bug</span> <span class="o">&amp;&amp;</span> <span class="n">block</span> <span class="o">+</span> <span class="n">this_count</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Access up to the threshold but not beyond */</span>
			<span class="n">this_count</span> <span class="o">=</span> <span class="n">threshold</span> <span class="o">-</span> <span class="n">block</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Access only a single hardware sector */</span>
			<span class="n">this_count</span> <span class="o">=</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">/</span> <span class="mi">512</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">SCSI_LOG_HLQUEUE</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">,</span> <span class="s">&quot;block=%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have a 1K hardware sectorsize, prevent access to single</span>
<span class="cm">	 * 512 byte sectors.  In theory we could handle this - in fact</span>
<span class="cm">	 * the scsi cdrom driver must be able to handle this because</span>
<span class="cm">	 * we typically use 1K blocksizes, and cdroms typically have</span>
<span class="cm">	 * 2K hardware sectorsizes.  Of course, things are simpler</span>
<span class="cm">	 * with the cdrom, since it is read-only.  For performance</span>
<span class="cm">	 * reasons, the filesystems should be able to handle this</span>
<span class="cm">	 * and not force the scsi disk driver to use bounce buffers</span>
<span class="cm">	 * for this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">==</span> <span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">block</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">,</span>
				    <span class="s">&quot;Bad block number requested</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">block</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">this_count</span> <span class="o">=</span> <span class="n">this_count</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">==</span> <span class="mi">2048</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">block</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">,</span>
				    <span class="s">&quot;Bad block number requested</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">block</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">this_count</span> <span class="o">=</span> <span class="n">this_count</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">block</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">,</span>
				    <span class="s">&quot;Bad block number requested</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">block</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">this_count</span> <span class="o">=</span> <span class="n">this_count</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq_data_dir</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">writeable</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">WRITE_6</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">blk_integrity_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sd_dif_prepare</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rq_data_dir</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">READ_6</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">,</span> <span class="s">&quot;Unknown command %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SCSI_LOG_HLQUEUE</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">,</span>
					<span class="s">&quot;%s %d/%u 512 byte blocks.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="n">rq_data_dir</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="o">?</span>
					<span class="s">&quot;writing&quot;</span> <span class="o">:</span> <span class="s">&quot;reading&quot;</span><span class="p">,</span> <span class="n">this_count</span><span class="p">,</span>
					<span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">)));</span>

	<span class="cm">/* Set RDPROTECT/WRPROTECT if disk is formatted with DIF */</span>
	<span class="n">host_dif</span> <span class="o">=</span> <span class="n">scsi_host_dif_capable</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">protection_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_dif</span><span class="p">)</span>
		<span class="n">protect</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">protect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host_dif</span> <span class="o">==</span> <span class="n">SD_DIF_TYPE2_PROTECTION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">sd_cdb_pool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">BLKPREP_DEFER</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="n">SD_EXT_CDB_SIZE</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">VARIABLE_LENGTH_CMD</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x18</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rq_data_dir</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="o">?</span> <span class="n">READ_32</span> <span class="o">:</span> <span class="n">WRITE_32</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">protect</span> <span class="o">|</span> <span class="p">((</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_FUA</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x8</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* LBA */</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">?</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">?</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">?</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">?</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">block</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="cm">/* Expected Indirect LBA */</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">22</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">block</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="cm">/* Transfer length */</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">28</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">this_count</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">29</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">this_count</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">this_count</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">this_count</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">READ_16</span> <span class="o">-</span> <span class="n">READ_6</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">protect</span> <span class="o">|</span> <span class="p">((</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_FUA</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x8</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">?</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">?</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">?</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">?</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">block</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">this_count</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">this_count</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">this_count</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">this_count</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">this_count</span> <span class="o">&gt;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;</span> <span class="mh">0x1fffff</span><span class="p">)</span> <span class="o">||</span>
		   <span class="n">scsi_device_protection</span><span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="o">||</span>
		   <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">use_10_for_rw</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this_count</span> <span class="o">&gt;</span> <span class="mh">0xffff</span><span class="p">)</span>
			<span class="n">this_count</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>

		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">READ_10</span> <span class="o">-</span> <span class="n">READ_6</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">protect</span> <span class="o">|</span> <span class="p">((</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_FUA</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x8</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">block</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">this_count</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">this_count</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_FUA</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This happens only if this drive failed</span>
<span class="cm">			 * 10byte rw command with ILLEGAL_REQUEST</span>
<span class="cm">			 * during operation and thus turned off</span>
<span class="cm">			 * use_10_for_rw.</span>
<span class="cm">			 */</span>
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">,</span>
				    <span class="s">&quot;FUA write on READ/WRITE(6) drive</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">((</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">((</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">block</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">this_count</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">sdb</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">this_count</span> <span class="o">*</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>

	<span class="cm">/* If DIF or DIX is enabled, tell HBA how to handle request */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_dif</span> <span class="o">||</span> <span class="n">scsi_prot_sg_count</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">))</span>
		<span class="n">sd_prot_op</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">,</span> <span class="n">host_dif</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We shouldn&#39;t disconnect in the middle of a sector, so with a dumb</span>
<span class="cm">	 * host adapter, it&#39;s safe to assume that we can at least transfer</span>
<span class="cm">	 * this many bytes between each connect / disconnect.</span>
<span class="cm">	 */</span>
	<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">transfersize</span> <span class="o">=</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>
	<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">underflow</span> <span class="o">=</span> <span class="n">this_count</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">allowed</span> <span class="o">=</span> <span class="n">SD_MAX_RETRIES</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This indicates that the command is ready from our end to be</span>
<span class="cm">	 * queued.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">BLKPREP_OK</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">scsi_prep_return</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sd_open - open a scsi disk device</span>
<span class="cm"> *	@inode: only i_rdev member may be used</span>
<span class="cm"> *	@filp: only f_mode and f_flags may be used</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 if successful. Returns a negated errno value in case </span>
<span class="cm"> *	of error.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: This can be called from a user context (e.g. fsck(1) )</span>
<span class="cm"> *	or from within the kernel (e.g. as a result of a mount(1) ).</span>
<span class="cm"> *	In the latter case @inode and @filp carry an abridged amount</span>
<span class="cm"> *	of information as noted above.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: called with bdev-&gt;bd_mutex held.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk_get</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdkp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">SCSI_LOG_HLQUEUE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;sd_open</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">scsi_autopm_get_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_autopm</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the device is in error recovery, wait until it is done.</span>
<span class="cm">	 * If the device is offline, then disallow any access to it.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_block_when_processing_errors</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">||</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">write_prot</span><span class="p">)</span>
		<span class="n">check_disk_change</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the drive is empty, just let the open fail.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEDIUM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">media_present</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_NDELAY</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the device has the write protect tab set, have the open fail</span>
<span class="cm">	 * if the user expects to be able to write to the thing.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">write_prot</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is possible that the disk changing stuff resulted in</span>
<span class="cm">	 * the device being taken offline.  If this is the case,</span>
<span class="cm">	 * report this to the user, and don&#39;t pretend that the</span>
<span class="cm">	 * open actually succeeded.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_device_online</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">openers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">removable</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_block_when_processing_errors</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span>
			<span class="n">scsi_set_medium_removal</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">SCSI_REMOVAL_PREVENT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_out:</span>
	<span class="n">scsi_autopm_put_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
<span class="nl">error_autopm:</span>
	<span class="n">scsi_disk_put</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>	
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sd_release - invoked when the (last) close(2) is called on this</span>
<span class="cm"> *	scsi disk.</span>
<span class="cm"> *	@inode: only i_rdev member may be used</span>
<span class="cm"> *	@filp: only f_mode and f_flags may be used</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0. </span>
<span class="cm"> *</span>
<span class="cm"> *	Note: may block (uninterruptible) if error recovery is underway</span>
<span class="cm"> *	on this disk.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: called with bdev-&gt;bd_mutex held.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="n">SCSI_LOG_HLQUEUE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;sd_release</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">openers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">removable</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_block_when_processing_errors</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span>
			<span class="n">scsi_set_medium_removal</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">SCSI_REMOVAL_ALLOW</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX and what if there are packets in flight and this close()</span>
<span class="cm">	 * XXX is followed by a &quot;rmmod sd_mod&quot;?</span>
<span class="cm">	 */</span>

	<span class="n">scsi_autopm_put_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">scsi_disk_put</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_getgeo</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hd_geometry</span> <span class="o">*</span><span class="n">geo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">diskinfo</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="cm">/* default to most commonly used values */</span>
        <span class="n">diskinfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>	<span class="cm">/* 1 &lt;&lt; 6 */</span>
       	<span class="n">diskinfo</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>	<span class="cm">/* 1 &lt;&lt; 5 */</span>
       	<span class="n">diskinfo</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">;</span>
	
	<span class="cm">/* override with calculated, extended default, or driver values */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">bios_param</span><span class="p">)</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">bios_param</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">bdev</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">,</span> <span class="n">diskinfo</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">scsicam_bios_param</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">,</span> <span class="n">diskinfo</span><span class="p">);</span>

	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">=</span> <span class="n">diskinfo</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">sectors</span> <span class="o">=</span> <span class="n">diskinfo</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">cylinders</span> <span class="o">=</span> <span class="n">diskinfo</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sd_ioctl - process an ioctl</span>
<span class="cm"> *	@inode: only i_rdev/i_bdev members may be used</span>
<span class="cm"> *	@filp: only f_mode and f_flags may be used</span>
<span class="cm"> *	@cmd: ioctl command number</span>
<span class="cm"> *	@arg: this is third argument given to ioctl(2) system call.</span>
<span class="cm"> *	Often contains a pointer.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 if successful (some ioctls return positive numbers on</span>
<span class="cm"> *	success as well). Returns a negated errno value in case of error.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: most ioctls are forward onto the block subsystem or further</span>
<span class="cm"> *	down in the scsi subsystem.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
    
	<span class="n">SCSI_LOG_IOCTL</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;sd_ioctl: disk=%s, &quot;</span>
				    <span class="s">&quot;cmd=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="n">cmd</span><span class="p">));</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_verify_blk_ioctl</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are in the middle of error recovery, don&#39;t let anyone</span>
<span class="cm">	 * else try and use this device.  Also, if error recovery fails, it</span>
<span class="cm">	 * may try and take the device offline, in which case all further</span>
<span class="cm">	 * access to the device is prohibited.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_nonblockable_ioctl</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
					<span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_NDELAY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_block_when_processing_errors</span><span class="p">(</span><span class="n">sdp</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send SCSI addressing ioctls directly to mid level, send other</span>
<span class="cm">	 * ioctls to block level and then onto mid level if they can&#39;t be</span>
<span class="cm">	 * resolved.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCSI_IOCTL_GET_IDLUN</span>:
		<span class="k">case</span> <span class="n">SCSI_IOCTL_GET_BUS_NUMBER</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_ioctl</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_cmd_blk_ioctl</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_ioctl</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_media_not_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">media_present</span><span class="p">)</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">removable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">media_present</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">media_not_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="n">sshdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_sense_valid</span><span class="p">(</span><span class="n">sshdr</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* not invoked for commands that could return deferred errors */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sshdr</span><span class="o">-&gt;</span><span class="n">sense_key</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UNIT_ATTENTION</span>:
	<span class="k">case</span> <span class="n">NOT_READY</span>:
		<span class="cm">/* medium not present */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="o">-&gt;</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x3A</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_media_not_present</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sd_check_events - check media events</span>
<span class="cm"> *	@disk: kernel device descriptor</span>
<span class="cm"> *	@clearing: disk events currently being cleared</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns mask of DISK_EVENT_*.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: this function is invoked from the block subsystem.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sd_check_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clearing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="n">sshdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">SCSI_LOG_HLQUEUE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;sd_check_events</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the device is offline, don&#39;t send any commands - just pretend as</span>
<span class="cm">	 * if the command failed.  If the device ever comes back online, we</span>
<span class="cm">	 * can deal with it then.  It is only because of unrecoverable errors</span>
<span class="cm">	 * that we would ever take a device offline in the first place.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_device_online</span><span class="p">(</span><span class="n">sdp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_media_not_present</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Using TEST_UNIT_READY enables differentiation between drive with</span>
<span class="cm">	 * no cartridge loaded - NOT READY, drive with changed cartridge -</span>
<span class="cm">	 * UNIT ATTENTION, or with same cartridge - GOOD STATUS.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Drives that auto spin down. eg iomega jaz 1G, will be started</span>
<span class="cm">	 * by sd_spinup_disk() from sd_revalidate_disk(), which happens whenever</span>
<span class="cm">	 * sd_revalidate() is called.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_block_when_processing_errors</span><span class="p">(</span><span class="n">sdp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">scsi_autopm_get_device</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">sshdr</span>  <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sshdr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">scsi_test_unit_ready</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">SD_TIMEOUT</span><span class="p">,</span> <span class="n">SD_MAX_RETRIES</span><span class="p">,</span>
					      <span class="n">sshdr</span><span class="p">);</span>
		<span class="n">scsi_autopm_put_device</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* failed to execute TUR, assume media not present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_byte</span><span class="p">(</span><span class="n">retval</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_media_not_present</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">media_not_present</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">sshdr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For removable scsi disk we have to recognise the presence</span>
<span class="cm">	 * of a disk in the drive.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">media_present</span><span class="p">)</span>
		<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">media_present</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="cm">/*</span>
<span class="cm">	 * sdp-&gt;changed is set under the following conditions:</span>
<span class="cm">	 *</span>
<span class="cm">	 *	Medium present state has changed in either direction.</span>
<span class="cm">	 *	Device has indicated UNIT_ATTENTION.</span>
<span class="cm">	 */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sshdr</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">?</span> <span class="n">DISK_EVENT_MEDIA_CHANGE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_sync_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retries</span><span class="p">,</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_device_online</span><span class="p">(</span><span class="n">sdp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>


	<span class="k">for</span> <span class="p">(</span><span class="n">retries</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">retries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">retries</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

		<span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SYNCHRONIZE_CACHE</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Leave the rest of the command zero to indicate</span>
<span class="cm">		 * flush everything.</span>
<span class="cm">		 */</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">scsi_execute_req</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">DMA_NONE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">,</span>
				       <span class="n">SD_FLUSH_TIMEOUT</span><span class="p">,</span> <span class="n">SD_MAX_RETRIES</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_print_result</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">driver_byte</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DRIVER_SENSE</span><span class="p">)</span>
			<span class="n">sd_print_sense_hdr</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_rescan</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk_get_from_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">revalidate_disk</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">);</span>
		<span class="n">scsi_disk_put</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="cm">/* </span>
<span class="cm"> * This gets directly called from VFS. When the ioctl </span>
<span class="cm"> * is not recognized we go back to the other translation paths. </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">scsi_disk</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_verify_blk_ioctl</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are in the middle of error recovery, don&#39;t let anyone</span>
<span class="cm">	 * else try and use this device.  Also, if error recovery fails, it</span>
<span class="cm">	 * may try and take the device offline, in which case all further</span>
<span class="cm">	 * access to the device is prohibited.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_block_when_processing_errors</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	       
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">compat_ioctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">compat_ioctl</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* </span>
<span class="cm">	 * Let the static ioctl translation table take care of it.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span> 
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">block_device_operations</span> <span class="n">sd_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>			<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>			<span class="o">=</span> <span class="n">sd_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">sd_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>			<span class="o">=</span> <span class="n">sd_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getgeo</span>			<span class="o">=</span> <span class="n">sd_getgeo</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>		<span class="o">=</span> <span class="n">sd_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">check_events</span>		<span class="o">=</span> <span class="n">sd_check_events</span><span class="p">,</span>
	<span class="p">.</span><span class="n">revalidate_disk</span>	<span class="o">=</span> <span class="n">sd_revalidate_disk</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlock_native_capacity</span>	<span class="o">=</span> <span class="n">sd_unlock_native_capacity</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	sd_eh_action - error handling callback</span>
<span class="cm"> *	@scmd:		sd-issued command that has failed</span>
<span class="cm"> *	@eh_cmnd:	The command that was sent during error handling</span>
<span class="cm"> *	@eh_cmnd_len:	Length of eh_cmnd in bytes</span>
<span class="cm"> *	@eh_disp:	The recovery disposition suggested by the midlayer</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called by the SCSI midlayer upon completion of</span>
<span class="cm"> *	an error handling command (TEST UNIT READY, START STOP UNIT,</span>
<span class="cm"> *	etc.) The command sent to the device by the error handler is</span>
<span class="cm"> *	stored in eh_cmnd. The result of sending the eh command is</span>
<span class="cm"> *	passed in eh_disp.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_eh_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">eh_cmnd</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">eh_cmnd_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eh_disp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_device_online</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">scsi_medium_access_command</span><span class="p">(</span><span class="n">scmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">eh_disp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The device has timed out executing a medium access command.</span>
<span class="cm">	 * However, the TEST UNIT READY command sent during error</span>
<span class="cm">	 * handling completed successfully. Either the device is in the</span>
<span class="cm">	 * process of recovering or has it suffered an internal failure</span>
<span class="cm">	 * that prevents access to the storage medium.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_byte</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="n">DID_TIME_OUT</span> <span class="o">&amp;&amp;</span> <span class="n">eh_disp</span> <span class="o">==</span> <span class="n">SUCCESS</span> <span class="o">&amp;&amp;</span>
	    <span class="n">eh_cmnd_len</span> <span class="o">&amp;&amp;</span> <span class="n">eh_cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">TEST_UNIT_READY</span><span class="p">)</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">medium_access_timed_out</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the device keeps failing read/write commands but TEST UNIT</span>
<span class="cm">	 * READY always completes successfully we assume that medium</span>
<span class="cm">	 * access is no longer possible and take the device offline.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">medium_access_timed_out</span> <span class="o">&gt;=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">max_medium_access_timeouts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">scmd</span><span class="p">,</span>
			    <span class="s">&quot;Medium access timeout failure. Offlining disk!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">SDEV_OFFLINE</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">eh_disp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sd_completed_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">start_lba</span> <span class="o">=</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">end_lba</span> <span class="o">=</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scmd</span><span class="p">)</span> <span class="o">/</span> <span class="mi">512</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">bad_lba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">info_valid</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * resid is optional but mostly filled in.  When it&#39;s unused,</span>
<span class="cm">	 * its value is zero, so we assume the whole buffer transferred</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">transferred</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scmd</span><span class="p">)</span> <span class="o">-</span> <span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">scmd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">good_bytes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">!=</span> <span class="n">REQ_TYPE_FS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">info_valid</span> <span class="o">=</span> <span class="n">scsi_get_sense_info_fld</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
					     <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">bad_lba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info_valid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scmd</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* only legitimate sector_size here is 256 */</span>
		<span class="n">start_lba</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">end_lba</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* be careful ... don&#39;t want any overflows */</span>
		<span class="n">u64</span> <span class="n">factor</span> <span class="o">=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">/</span> <span class="mi">512</span><span class="p">;</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">start_lba</span><span class="p">,</span> <span class="n">factor</span><span class="p">);</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">end_lba</span><span class="p">,</span> <span class="n">factor</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* The bad lba was reported incorrectly, we have no idea where</span>
<span class="cm">	 * the error is.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bad_lba</span> <span class="o">&lt;</span> <span class="n">start_lba</span>  <span class="o">||</span> <span class="n">bad_lba</span> <span class="o">&gt;=</span> <span class="n">end_lba</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* This computation should always be done in terms of</span>
<span class="cm">	 * the resolution of the device&#39;s medium.</span>
<span class="cm">	 */</span>
	<span class="n">good_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">bad_lba</span> <span class="o">-</span> <span class="n">start_lba</span><span class="p">)</span> <span class="o">*</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">good_bytes</span><span class="p">,</span> <span class="n">transferred</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sd_done - bottom half handler: called when the lower level</span>
<span class="cm"> *	driver has completed (successfully or otherwise) a scsi command.</span>
<span class="cm"> *	@SCpnt: mid-level&#39;s per command structure.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: potentially run from within an ISR. Must not block.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">SCpnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">good_bytes</span> <span class="o">=</span> <span class="n">result</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk</span><span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">sense_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sense_deferred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">op</span> <span class="o">=</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">result</span><span class="p">)</span>
		<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sense_valid</span> <span class="o">=</span> <span class="n">scsi_command_normalize_sense</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sense_valid</span><span class="p">)</span>
			<span class="n">sense_deferred</span> <span class="o">=</span> <span class="n">scsi_sense_is_deferred</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_SCSI_LOGGING</span>
	<span class="n">SCSI_LOG_HLCOMPLETE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">scsi_print_result</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sense_valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCSI_LOG_HLCOMPLETE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">,</span>
						   <span class="s">&quot;sd_done: sb[respc,sk,asc,&quot;</span>
						   <span class="s">&quot;ascq]=%x,%x,%x,%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						   <span class="n">sshdr</span><span class="p">.</span><span class="n">response_code</span><span class="p">,</span>
						   <span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span><span class="p">,</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span><span class="p">,</span>
						   <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver_byte</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DRIVER_SENSE</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">sense_valid</span> <span class="o">||</span> <span class="n">sense_deferred</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">medium_access_timed_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HARDWARE_ERROR</span>:
	<span class="k">case</span> <span class="n">MEDIUM_ERROR</span>:
		<span class="n">good_bytes</span> <span class="o">=</span> <span class="n">sd_completed_bytes</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECOVERED_ERROR</span>:
		<span class="n">good_bytes</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NO_SENSE</span>:
		<span class="cm">/* This indicates a false check condition, so ignore it.  An</span>
<span class="cm">		 * unknown amount of data was transferred so treat it as an</span>
<span class="cm">		 * error.</span>
<span class="cm">		 */</span>
		<span class="n">scsi_print_sense</span><span class="p">(</span><span class="s">&quot;sd&quot;</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">);</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ABORTED_COMMAND</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x10</span><span class="p">)</span>  <span class="cm">/* DIF: Target detected corruption */</span>
			<span class="n">good_bytes</span> <span class="o">=</span> <span class="n">sd_completed_bytes</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ILLEGAL_REQUEST</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x10</span><span class="p">)</span>  <span class="cm">/* DIX: Host detected corruption */</span>
			<span class="n">good_bytes</span> <span class="o">=</span> <span class="n">sd_completed_bytes</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">);</span>
		<span class="cm">/* INVALID COMMAND OPCODE or INVALID FIELD IN CDB */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x20</span> <span class="o">||</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x24</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">UNMAP</span> <span class="o">||</span> <span class="n">op</span> <span class="o">==</span> <span class="n">WRITE_SAME_16</span> <span class="o">||</span> <span class="n">op</span> <span class="o">==</span> <span class="n">WRITE_SAME</span><span class="p">))</span>
			<span class="n">sd_config_discard</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">SD_LBP_DISABLE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq_data_dir</span><span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span> <span class="o">&amp;&amp;</span> <span class="n">scsi_prot_sg_count</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">))</span>
		<span class="n">sd_dif_complete</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">,</span> <span class="n">good_bytes</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_host_dif_capable</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">protection_type</span><span class="p">)</span>
	    <span class="o">==</span> <span class="n">SD_DIF_TYPE2_PROTECTION</span> <span class="o">&amp;&amp;</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span> <span class="o">!=</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* We have to print a failed command here as the</span>
<span class="cm">		 * extended CDB gets freed before scsi_io_completion()</span>
<span class="cm">		 * is called.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="n">scsi_print_command</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">);</span>

		<span class="n">mempool_free</span><span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">sd_cdb_pool</span><span class="p">);</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">good_bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * spinup disk - called only in sd_revalidate_disk()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sd_spinup_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spintime_expire</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span><span class="p">,</span> <span class="n">spintime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">the_result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sense_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spintime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Spin up drives, as required.  Only do this at boot time */</span>
	<span class="cm">/* Spinup needs to be done for module loads too. */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">TEST_UNIT_READY</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>

			<span class="n">the_result</span> <span class="o">=</span> <span class="n">scsi_execute_req</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
						      <span class="n">DMA_NONE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">,</span> <span class="n">SD_TIMEOUT</span><span class="p">,</span>
						      <span class="n">SD_MAX_RETRIES</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the drive has indicated to us that it</span>
<span class="cm">			 * doesn&#39;t have any media in it, don&#39;t bother</span>
<span class="cm">			 * with any more polling.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">media_not_present</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">the_result</span><span class="p">)</span>
				<span class="n">sense_valid</span> <span class="o">=</span> <span class="n">scsi_sense_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>
			<span class="n">retries</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">retries</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> 
			 <span class="p">(</span><span class="o">!</span><span class="n">scsi_status_is_good</span><span class="p">(</span><span class="n">the_result</span><span class="p">)</span> <span class="o">||</span>
			  <span class="p">((</span><span class="n">driver_byte</span><span class="p">(</span><span class="n">the_result</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DRIVER_SENSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			  <span class="n">sense_valid</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">UNIT_ATTENTION</span><span class="p">)));</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">driver_byte</span><span class="p">(</span><span class="n">the_result</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DRIVER_SENSE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* no sense, TUR either succeeded or failed</span>
<span class="cm">			 * with a status error */</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">spintime</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">scsi_status_is_good</span><span class="p">(</span><span class="n">the_result</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Unit Not Ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">sd_print_result</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">the_result</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
					
		<span class="cm">/*</span>
<span class="cm">		 * The device does not want the automatic start to be issued.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">no_start_on_add</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sense_valid</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">NOT_READY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>	<span class="cm">/* manual intervention required */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span> <span class="o">==</span> <span class="mh">0xb</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>	<span class="cm">/* standby */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span> <span class="o">==</span> <span class="mh">0xc</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>	<span class="cm">/* unavailable */</span>
			<span class="cm">/*</span>
<span class="cm">			 * Issue command to spin up drive when not ready</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spintime</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Spinning up disk...&quot;</span><span class="p">);</span>
				<span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">START_STOP</span><span class="p">;</span>
				<span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Return immediately */</span>
				<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
				<span class="n">cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Start spin cycle */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">start_stop_pwr_cond</span><span class="p">)</span>
					<span class="n">cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
				<span class="n">scsi_execute_req</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">DMA_NONE</span><span class="p">,</span>
						 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">,</span>
						 <span class="n">SD_TIMEOUT</span><span class="p">,</span> <span class="n">SD_MAX_RETRIES</span><span class="p">,</span>
						 <span class="nb">NULL</span><span class="p">);</span>
				<span class="n">spintime_expire</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
				<span class="n">spintime</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Wait 1 second for next try */</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wait for USB flash devices with slow firmware.</span>
<span class="cm">		 * Yes, this sense key/ASC combination shouldn&#39;t</span>
<span class="cm">		 * occur here.  It&#39;s characteristic of these devices.</span>
<span class="cm">		 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sense_valid</span> <span class="o">&amp;&amp;</span>
				<span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">UNIT_ATTENTION</span> <span class="o">&amp;&amp;</span>
				<span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x28</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spintime</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spintime_expire</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
				<span class="n">spintime</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Wait 1 second for next try */</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* we don&#39;t understand the sense code, so it&#39;s</span>
<span class="cm">			 * probably pointless to loop */</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">spintime</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Unit Not Ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">sd_print_sense_hdr</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
				
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">spintime</span> <span class="o">&amp;&amp;</span> <span class="n">time_before_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">spintime_expire</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spintime</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_status_is_good</span><span class="p">(</span><span class="n">the_result</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;not responding...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Determine whether disk supports Data Integrity Field.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_read_protection_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_device_protection</span><span class="p">(</span><span class="n">sdp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="p">((</span><span class="n">buffer</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* P_TYPE 0 = Type 1 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">protection_type</span> <span class="o">||</span> <span class="o">!</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">first_scan</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">protection_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">SD_DIF_TYPE3_PROTECTION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;formatted with unsupported &quot;</span>	\
			  <span class="s">&quot;protection type %u. Disabling disk!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_host_dif_capable</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">type</span><span class="p">))</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span>
			  <span class="s">&quot;Enabling DIF Type %u protection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span>
			  <span class="s">&quot;Disabling DIF Type %u protection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_capacity_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="n">sshdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sense_valid</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">the_result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sd_print_result</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">the_result</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver_byte</span><span class="p">(</span><span class="n">the_result</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DRIVER_SENSE</span><span class="p">)</span>
		<span class="n">sd_print_sense_hdr</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">sshdr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Sense not available.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set dirty bit for removable devices if not ready -</span>
<span class="cm">	 * sometimes drives will not report this properly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sense_valid</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="o">-&gt;</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">NOT_READY</span><span class="p">)</span>
		<span class="n">set_media_not_present</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We used to set media_present to 0 here to indicate no media</span>
<span class="cm">	 * in the drive, but some drives fail read capacity even with</span>
<span class="cm">	 * media present, so we can&#39;t do that.</span>
<span class="cm">	 */</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* unknown mapped to zero - as usual */</span>
<span class="p">}</span>

<span class="cp">#define RC16_LEN 32</span>
<span class="cp">#if RC16_LEN &gt; SD_BUF_SIZE</span>
<span class="cp">#error RC16_LEN must not be more than SD_BUF_SIZE</span>
<span class="cp">#endif</span>

<span class="cp">#define READ_CAPACITY_RETRIES_ON_RESET	10</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_capacity_16</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sense_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">the_result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">reset_retries</span> <span class="o">=</span> <span class="n">READ_CAPACITY_RETRIES_ON_RESET</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alignment</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">lba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">sector_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">no_read_capacity_16</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SERVICE_ACTION_IN</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">SAI_READ_CAPACITY_16</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">RC16_LEN</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RC16_LEN</span><span class="p">);</span>

		<span class="n">the_result</span> <span class="o">=</span> <span class="n">scsi_execute_req</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">,</span>
					<span class="n">buffer</span><span class="p">,</span> <span class="n">RC16_LEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">,</span>
					<span class="n">SD_TIMEOUT</span><span class="p">,</span> <span class="n">SD_MAX_RETRIES</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">media_not_present</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">the_result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sense_valid</span> <span class="o">=</span> <span class="n">scsi_sense_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sense_valid</span> <span class="o">&amp;&amp;</span>
			    <span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">ILLEGAL_REQUEST</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x20</span> <span class="o">||</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x24</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span>
				<span class="cm">/* Invalid Command Operation Code or</span>
<span class="cm">				 * Invalid Field in CDB, just retry</span>
<span class="cm">				 * silently with RC10 */</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sense_valid</span> <span class="o">&amp;&amp;</span>
			    <span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">UNIT_ATTENTION</span> <span class="o">&amp;&amp;</span>
			    <span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x29</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span>
				<span class="cm">/* Device reset might occur several times,</span>
<span class="cm">				 * give it one more chance */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">reset_retries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">retries</span><span class="o">--</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">the_result</span> <span class="o">&amp;&amp;</span> <span class="n">retries</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">the_result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;READ CAPACITY(16) failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">read_capacity_error</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">sdp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">,</span> <span class="n">sense_valid</span><span class="p">,</span> <span class="n">the_result</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sector_size</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
	<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">sd_read_protection_type</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&gt;=</span> <span class="mh">0xffffffffULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Too big for this kernel. Use a &quot;</span>
			<span class="s">&quot;kernel compiled with support for large block &quot;</span>
			<span class="s">&quot;devices.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Logical blocks per physical block exponent */</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">physical_block_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">))</span> <span class="o">*</span> <span class="n">sector_size</span><span class="p">;</span>

	<span class="cm">/* Lowest aligned logical block */</span>
	<span class="n">alignment</span> <span class="o">=</span> <span class="p">((</span><span class="n">buffer</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">15</span><span class="p">])</span> <span class="o">*</span> <span class="n">sector_size</span><span class="p">;</span>
	<span class="n">blk_queue_alignment_offset</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">alignment</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alignment</span> <span class="o">&amp;&amp;</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">first_scan</span><span class="p">)</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span>
			  <span class="s">&quot;physical block alignment offset: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">alignment</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* LBPME */</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">lbpme</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span> <span class="cm">/* LBPRZ */</span>
			<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">lbprz</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">sd_config_discard</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">SD_LBP_WS16</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">lba</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sector_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_capacity_10</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sense_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">the_result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">reset_retries</span> <span class="o">=</span> <span class="n">READ_CAPACITY_RETRIES_ON_RESET</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">lba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">sector_size</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">READ_CAPACITY</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

		<span class="n">the_result</span> <span class="o">=</span> <span class="n">scsi_execute_req</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">,</span>
					<span class="n">buffer</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">,</span>
					<span class="n">SD_TIMEOUT</span><span class="p">,</span> <span class="n">SD_MAX_RETRIES</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">media_not_present</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">the_result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sense_valid</span> <span class="o">=</span> <span class="n">scsi_sense_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sense_valid</span> <span class="o">&amp;&amp;</span>
			    <span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">UNIT_ATTENTION</span> <span class="o">&amp;&amp;</span>
			    <span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x29</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span>
				<span class="cm">/* Device reset might occur several times,</span>
<span class="cm">				 * give it one more chance */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">reset_retries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">retries</span><span class="o">--</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">the_result</span> <span class="o">&amp;&amp;</span> <span class="n">retries</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">the_result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;READ CAPACITY failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">read_capacity_error</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">sdp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">,</span> <span class="n">sense_valid</span><span class="p">,</span> <span class="n">the_result</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sector_size</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
	<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">no_read_capacity_16</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lba</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Some buggy (usb cardreader) devices return an lba of</span>
<span class="cm">		   0xffffffff when the want to report a size of 0 (with</span>
<span class="cm">		   which they really mean no media is present) */</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">physical_block_size</span> <span class="o">=</span> <span class="n">sector_size</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">sector_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lba</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Too big for this kernel. Use a &quot;</span>
			<span class="s">&quot;kernel compiled with support for large block &quot;</span>
			<span class="s">&quot;devices.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">lba</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">physical_block_size</span> <span class="o">=</span> <span class="n">sector_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sector_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_try_rc16_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">try_rc_10_first</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">&gt;</span> <span class="n">SCSI_SPC_2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_device_protection</span><span class="p">(</span><span class="n">sdp</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * read disk capacity</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sd_read_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sector_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">old_capacity</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sd_try_rc16_first</span><span class="p">(</span><span class="n">sdp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sector_size</span> <span class="o">=</span> <span class="n">read_capacity_16</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">sdp</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">==</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">got_data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sector_size</span> <span class="o">=</span> <span class="n">read_capacity_10</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">sdp</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sector_size</span> <span class="o">=</span> <span class="n">read_capacity_10</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">sdp</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">==</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">got_data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">&gt;</span> <span class="mh">0xffffffffULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">old_sector_size</span> <span class="o">=</span> <span class="n">sector_size</span><span class="p">;</span>
			<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Very big device. &quot;</span>
					<span class="s">&quot;Trying to use READ CAPACITY(16).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sector_size</span> <span class="o">=</span> <span class="n">read_capacity_16</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">sdp</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span>
					<span class="s">&quot;Using 0xffffffff as device size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span> <span class="mh">0xffffffff</span><span class="p">;</span>
				<span class="n">sector_size</span> <span class="o">=</span> <span class="n">old_sector_size</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">got_data</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Some devices are known to return the total number of blocks,</span>
<span class="cm">	 * not the highest block number.  Some devices have versions</span>
<span class="cm">	 * which do this and others which do not.  Some devices we might</span>
<span class="cm">	 * suspect of doing this but we don&#39;t know for certain.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we know the reported capacity is wrong, decrement it.  If</span>
<span class="cm">	 * we can only guess, then assume the number of blocks is even</span>
<span class="cm">	 * (usually true but not always) and err on the side of lowering</span>
<span class="cm">	 * the capacity.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">fix_capacity</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">guess_capacity</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Adjusting the sector count &quot;</span>
				<span class="s">&quot;from its reported value: %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">);</span>
		<span class="o">--</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">got_data:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sector_size</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Sector size 0 reported, &quot;</span>
			  <span class="s">&quot;assuming 512.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">!=</span> <span class="mi">512</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sector_size</span> <span class="o">!=</span> <span class="mi">1024</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sector_size</span> <span class="o">!=</span> <span class="mi">2048</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sector_size</span> <span class="o">!=</span> <span class="mi">4096</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sector_size</span> <span class="o">!=</span> <span class="mi">256</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Unsupported sector size %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">sector_size</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The user might want to re-format the drive with</span>
<span class="cm">		 * a supported sectorsize.  Once this happens, it</span>
<span class="cm">		 * would be relatively trivial to set the thing up.</span>
<span class="cm">		 * For this reason, we leave the thing in the table.</span>
<span class="cm">		 */</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * set a bogus sector size so the normal read/write</span>
<span class="cm">		 * logic in the block layer will eventually refuse any</span>
<span class="cm">		 * request on this device without tripping over power</span>
<span class="cm">		 * of two sector size assumptions</span>
<span class="cm">		 */</span>
		<span class="n">sector_size</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">blk_queue_logical_block_size</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">sector_size</span><span class="p">);</span>

	<span class="p">{</span>
		<span class="kt">char</span> <span class="n">cap_str_2</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">cap_str_10</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
		<span class="n">u64</span> <span class="n">sz</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">&lt;&lt;</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">sector_size</span><span class="p">);</span>

		<span class="n">string_get_size</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">STRING_UNITS_2</span><span class="p">,</span> <span class="n">cap_str_2</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">cap_str_2</span><span class="p">));</span>
		<span class="n">string_get_size</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">STRING_UNITS_10</span><span class="p">,</span> <span class="n">cap_str_10</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">cap_str_10</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">first_scan</span> <span class="o">||</span> <span class="n">old_capacity</span> <span class="o">!=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span>
				  <span class="s">&quot;%llu %d-byte logical blocks: (%s/%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">,</span>
				  <span class="n">sector_size</span><span class="p">,</span> <span class="n">cap_str_10</span><span class="p">,</span> <span class="n">cap_str_2</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">physical_block_size</span> <span class="o">!=</span> <span class="n">sector_size</span><span class="p">)</span>
				<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span>
					  <span class="s">&quot;%u-byte physical blocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">physical_block_size</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Rescale capacity to 512-byte units */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">)</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">&lt;&lt;=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">==</span> <span class="mi">2048</span><span class="p">)</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">&lt;&lt;=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">==</span> <span class="mi">1024</span><span class="p">)</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">==</span> <span class="mi">256</span><span class="p">)</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">blk_queue_physical_block_size</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span>
				      <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">physical_block_size</span><span class="p">);</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">=</span> <span class="n">sector_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called with buffer of length 512 */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">sd_do_mode_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dbd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">modepage</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_mode_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="n">sshdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">scsi_mode_sense</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">dbd</span><span class="p">,</span> <span class="n">modepage</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
			       <span class="n">SD_TIMEOUT</span><span class="p">,</span> <span class="n">SD_MAX_RETRIES</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
			       <span class="n">sshdr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * read write protect setting, if possible - called only in sd_revalidate_disk()</span>
<span class="cm"> * called with buffer of length SD_BUF_SIZE</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sd_read_write_protect_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_mode_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_wp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">write_prot</span><span class="p">;</span>

	<span class="n">set_disk_ro</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">skip_ms_page_3f</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Assuming Write Enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">use_192_bytes_for_3f</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">sd_do_mode_sense</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x3F</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">192</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * First attempt: ask for all pages (0x3F), but only 4 bytes.</span>
<span class="cm">		 * We have to start carefully: some devices hang if we ask</span>
<span class="cm">		 * for more than is available.</span>
<span class="cm">		 */</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">sd_do_mode_sense</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x3F</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Second attempt: ask for page 0 When only page 0 is</span>
<span class="cm">		 * implemented, a request for page 3F may return Sense Key</span>
<span class="cm">		 * 5: Illegal Request, Sense Code 24: Invalid field in</span>
<span class="cm">		 * CDB.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_status_is_good</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">sd_do_mode_sense</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Third attempt: ask 255 bytes, as we did earlier.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_status_is_good</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">sd_do_mode_sense</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x3F</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_status_is_good</span><span class="p">(</span><span class="n">res</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span>
			  <span class="s">&quot;Test WP failed, assume Write Enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">write_prot</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">.</span><span class="n">device_specific</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">set_disk_ro</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">write_prot</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">first_scan</span> <span class="o">||</span> <span class="n">old_wp</span> <span class="o">!=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">write_prot</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Write Protect is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">write_prot</span> <span class="o">?</span> <span class="s">&quot;on&quot;</span> <span class="o">:</span> <span class="s">&quot;off&quot;</span><span class="p">);</span>
			<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span>
				  <span class="s">&quot;Mode Sense: %02x %02x %02x %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sd_read_cache_type - called only from sd_revalidate_disk()</span>
<span class="cm"> * called with buffer of length SD_BUF_SIZE</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sd_read_cache_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">dbd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">modepage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_mode_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_wce</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">WCE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_rcd</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">RCD</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_dpofua</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">DPOFUA</span><span class="p">;</span>

	<span class="n">first_len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">skip_ms_page_8</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_RBC</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">defaults</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">skip_ms_page_3f</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">defaults</span><span class="p">;</span>
			<span class="n">modepage</span> <span class="o">=</span> <span class="mh">0x3F</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">use_192_bytes_for_3f</span><span class="p">)</span>
				<span class="n">first_len</span> <span class="o">=</span> <span class="mi">192</span><span class="p">;</span>
			<span class="n">dbd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_RBC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">modepage</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="n">dbd</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">modepage</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">dbd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* cautiously ask */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">sd_do_mode_sense</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">dbd</span><span class="p">,</span> <span class="n">modepage</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">first_len</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_status_is_good</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad_sense</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">.</span><span class="n">header_length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">modepage</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="n">first_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Missing header in MODE_SENSE response</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* that went OK, now ask for the proper length */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re only interested in the first three bytes, actually.</span>
<span class="cm">	 * But the data cache page is defined for the first 20.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_sense</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">SD_BUF_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Truncating mode parameter &quot;</span>
			  <span class="s">&quot;data from %d to %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">SD_BUF_SIZE</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">SD_BUF_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">modepage</span> <span class="o">==</span> <span class="mh">0x3F</span> <span class="o">&amp;&amp;</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">use_192_bytes_for_3f</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">192</span><span class="p">;</span>

	<span class="cm">/* Get the data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">first_len</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">sd_do_mode_sense</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">dbd</span><span class="p">,</span> <span class="n">modepage</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_status_is_good</span><span class="p">(</span><span class="n">res</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">header_length</span> <span class="o">+</span> <span class="n">data</span><span class="p">.</span><span class="n">block_descriptor_length</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">page_code</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">spf</span>       <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">page_code</span> <span class="o">==</span> <span class="mi">8</span> <span class="o">||</span> <span class="n">page_code</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* We&#39;re interested only in the first 3 bytes.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Incomplete &quot;</span>
						  <span class="s">&quot;mode parameter data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">defaults</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">modepage</span> <span class="o">=</span> <span class="n">page_code</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">Page_found</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Go to the next page */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">spf</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
					<span class="n">offset</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span>
						<span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">3</span><span class="p">];</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spf</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
					<span class="n">offset</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Incomplete &quot;</span>
						  <span class="s">&quot;mode parameter data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">defaults</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">modepage</span> <span class="o">==</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;No Caching mode page &quot;</span>
				  <span class="s">&quot;present</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">defaults</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">!=</span> <span class="n">modepage</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Got wrong page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">defaults</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="nl">Page_found:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">modepage</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">WCE</span> <span class="o">=</span> <span class="p">((</span><span class="n">buffer</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x04</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">RCD</span> <span class="o">=</span> <span class="p">((</span><span class="n">buffer</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">WCE</span> <span class="o">=</span> <span class="p">((</span><span class="n">buffer</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">RCD</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">DPOFUA</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">device_specific</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">DPOFUA</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">use_10_for_rw</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span>
				  <span class="s">&quot;Uses READ/WRITE(6), disabling FUA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">DPOFUA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">first_scan</span> <span class="o">||</span> <span class="n">old_wce</span> <span class="o">!=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">WCE</span> <span class="o">||</span>
		    <span class="n">old_rcd</span> <span class="o">!=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">RCD</span> <span class="o">||</span> <span class="n">old_dpofua</span> <span class="o">!=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">DPOFUA</span><span class="p">)</span>
			<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span>
				  <span class="s">&quot;Write cache: %s, read cache: %s, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">WCE</span> <span class="o">?</span> <span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">,</span>
				  <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">RCD</span> <span class="o">?</span> <span class="s">&quot;disabled&quot;</span> <span class="o">:</span> <span class="s">&quot;enabled&quot;</span><span class="p">,</span>
				  <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">DPOFUA</span> <span class="o">?</span> <span class="s">&quot;supports DPO and FUA&quot;</span>
				  <span class="o">:</span> <span class="s">&quot;doesn&#39;t support DPO or FUA&quot;</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">bad_sense:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_sense_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sshdr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">ILLEGAL_REQUEST</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x24</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span>
		<span class="cm">/* Invalid field in CDB */</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Cache data unavailable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Asking for cache data failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">defaults:</span>
	<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Assuming drive cache: write through</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">WCE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">RCD</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">DPOFUA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The ATO bit indicates whether the DIF application tag is available</span>
<span class="cm"> * for use by the operating system.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_read_app_tag_own</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_mode_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_DISK</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">protection_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">scsi_mode_sense</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x0a</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="n">SD_TIMEOUT</span><span class="p">,</span>
			      <span class="n">SD_MAX_RETRIES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_status_is_good</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">data</span><span class="p">.</span><span class="n">header_length</span> <span class="o">||</span>
	    <span class="n">data</span><span class="p">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span>
			  <span class="s">&quot;getting Control mode page failed, assume no ATO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_sense_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sshdr</span><span class="p">))</span>
			<span class="n">sd_print_sense_hdr</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">header_length</span> <span class="o">+</span> <span class="n">data</span><span class="p">.</span><span class="n">block_descriptor_length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x0a</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;ATO Got wrong page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">buffer</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">ATO</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sd_read_block_limits - Query disk device for preferred I/O sizes.</span>
<span class="cm"> * @disk: disk to query</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_read_block_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sector_sz</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">vpd_len</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">vpd_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span> <span class="o">||</span>
	    <span class="cm">/* Block Limits VPD */</span>
	    <span class="n">scsi_get_vpd_page</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="mh">0xb0</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">vpd_len</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">blk_queue_io_min</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span>
			 <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">*</span> <span class="n">sector_sz</span><span class="p">);</span>
	<span class="n">blk_queue_io_opt</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span>
			 <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">12</span><span class="p">])</span> <span class="o">*</span> <span class="n">sector_sz</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x3c</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lba_count</span><span class="p">,</span> <span class="n">desc_count</span><span class="p">;</span>

		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">max_ws_blocks</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">min_not_zero</span><span class="p">(</span><span class="n">get_unaligned_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">36</span><span class="p">]),</span>
					   <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mh">0xffffffff</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">lbpme</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">lba_count</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">20</span><span class="p">]);</span>
		<span class="n">desc_count</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">24</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lba_count</span> <span class="o">&amp;&amp;</span> <span class="n">desc_count</span><span class="p">)</span>
			<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">max_unmap_blocks</span> <span class="o">=</span> <span class="n">lba_count</span><span class="p">;</span>

		<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">unmap_granularity</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">28</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span>
			<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">unmap_alignment</span> <span class="o">=</span>
				<span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">32</span><span class="p">])</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">lbpvpd</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* LBP VPD page not provided */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">max_unmap_blocks</span><span class="p">)</span>
				<span class="n">sd_config_discard</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">SD_LBP_UNMAP</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">sd_config_discard</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">SD_LBP_WS16</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* LBP VPD page tells us what to use */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">lbpu</span> <span class="o">&amp;&amp;</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">max_unmap_blocks</span><span class="p">)</span>
				<span class="n">sd_config_discard</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">SD_LBP_UNMAP</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">lbpws</span><span class="p">)</span>
				<span class="n">sd_config_discard</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">SD_LBP_WS16</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">lbpws10</span><span class="p">)</span>
				<span class="n">sd_config_discard</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">SD_LBP_WS10</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">sd_config_discard</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">SD_LBP_DISABLE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sd_read_block_characteristics - Query block dev. characteristics</span>
<span class="cm"> * @disk: disk to query</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_read_block_characteristics</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">rot</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">vpd_len</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">vpd_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span> <span class="o">||</span>
	    <span class="cm">/* Block Device Characteristics VPD */</span>
	    <span class="n">scsi_get_vpd_page</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="mh">0xb1</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">vpd_len</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rot</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rot</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">queue_flag_set_unlocked</span><span class="p">(</span><span class="n">QUEUE_FLAG_NONROT</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sd_read_block_provisioning - Query provisioning VPD page</span>
<span class="cm"> * @disk: disk to query</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_read_block_provisioning</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">vpd_len</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">lbpme</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">vpd_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span> <span class="o">||</span> <span class="n">scsi_get_vpd_page</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="mh">0xb2</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">vpd_len</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">lbpvpd</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">lbpu</span>	<span class="o">=</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* UNMAP */</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">lbpws</span>	<span class="o">=</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* WRITE SAME(16) with UNMAP */</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">lbpws10</span>	<span class="o">=</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* WRITE SAME(10) with UNMAP */</span>

 <span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_try_extended_inquiry</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Although VPD inquiries can go to SCSI-2 type devices,</span>
<span class="cm">	 * some USB ones crash on receiving them, and the pages</span>
<span class="cm">	 * we currently ask for are for SPC-3 and beyond</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">&gt;</span> <span class="n">SCSI_SPC_2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">skip_vpd_pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sd_revalidate_disk - called the first time a new disk is seen,</span>
<span class="cm"> *	performs disk spin up, read_capacity, etc.</span>
<span class="cm"> *	@disk: struct gendisk we care about</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_revalidate_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">SCSI_LOG_HLQUEUE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span>
				      <span class="s">&quot;sd_revalidate_disk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the device is offline, don&#39;t try and read capacity or any</span>
<span class="cm">	 * of the other niceties.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_device_online</span><span class="p">(</span><span class="n">sdp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">SD_BUF_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;sd_revalidate_disk: Memory &quot;</span>
			  <span class="s">&quot;allocation failure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sd_spinup_disk</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Without media there is no reason to ask; moreover, some devices</span>
<span class="cm">	 * react badly if we do.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">media_present</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_read_capacity</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sd_try_extended_inquiry</span><span class="p">(</span><span class="n">sdp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sd_read_block_provisioning</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
			<span class="n">sd_read_block_limits</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
			<span class="n">sd_read_block_characteristics</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">sd_read_write_protect_flag</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
		<span class="n">sd_read_cache_type</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
		<span class="n">sd_read_app_tag_own</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">first_scan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We now have all cache related info, determine how we deal</span>
<span class="cm">	 * with flush requests.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">WCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush</span> <span class="o">|=</span> <span class="n">REQ_FLUSH</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">DPOFUA</span><span class="p">)</span>
			<span class="n">flush</span> <span class="o">|=</span> <span class="n">REQ_FUA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">blk_queue_flush</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">flush</span><span class="p">);</span>

	<span class="n">set_capacity</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sd_unlock_native_capacity - unlock native capacity</span>
<span class="cm"> *	@disk: struct gendisk to set capacity for</span>
<span class="cm"> *</span>
<span class="cm"> *	Block layer calls this function if it detects that partitions</span>
<span class="cm"> *	on @disk reach beyond the end of the device.  If the SCSI host</span>
<span class="cm"> *	implements -&gt;unlock_native_capacity() method, it&#39;s invoked to</span>
<span class="cm"> *	give it a chance to adjust the device capacity.</span>
<span class="cm"> *</span>
<span class="cm"> *	CONTEXT:</span>
<span class="cm"> *	Defined by block layer.  Might sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_unlock_native_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">scsi_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">unlock_native_capacity</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">unlock_native_capacity</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sd_format_disk_name - format disk name</span>
<span class="cm"> *	@prefix: name prefix - ie. &quot;sd&quot; for SCSI disks</span>
<span class="cm"> *	@index: index of the disk to format name for</span>
<span class="cm"> *	@buf: output buffer</span>
<span class="cm"> *	@buflen: length of the output buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	SCSI disk names starts at sda.  The 26th device is sdz and the</span>
<span class="cm"> *	27th is sdaa.  The last one for two lettered suffix is sdzz</span>
<span class="cm"> *	which is followed by sdaaa.</span>
<span class="cm"> *</span>
<span class="cm"> *	This is basically 26 base counting with one extra &#39;nil&#39; entry</span>
<span class="cm"> *	at the beginning from the second digit on and can be</span>
<span class="cm"> *	determined using similar method as 26 base conversion with the</span>
<span class="cm"> *	index shifted -1 after each digit is computed.</span>
<span class="cm"> *</span>
<span class="cm"> *	CONTEXT:</span>
<span class="cm"> *	Don&#39;t care.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_format_disk_name</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="sc">&#39;z&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">begin</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">prefix</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">buflen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">unit</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">unit</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">begin</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="o">*--</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">index</span> <span class="o">%</span> <span class="n">unit</span><span class="p">);</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">/</span> <span class="n">unit</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">memmove</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">prefix</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The asynchronous part of sd_probe</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_probe_async</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">async_cookie_t</span> <span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">gd</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">;</span>

	<span class="n">gd</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">sd_major</span><span class="p">((</span><span class="n">index</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">gd</span><span class="o">-&gt;</span><span class="n">first_minor</span> <span class="o">=</span> <span class="p">((</span><span class="n">index</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">index</span> <span class="o">&amp;</span> <span class="mh">0xfff00</span><span class="p">);</span>
	<span class="n">gd</span><span class="o">-&gt;</span><span class="n">minors</span> <span class="o">=</span> <span class="n">SD_MINORS</span><span class="p">;</span>

	<span class="n">gd</span><span class="o">-&gt;</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sd_fops</span><span class="p">;</span>
	<span class="n">gd</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
	<span class="n">gd</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span>

	<span class="cm">/* defaults, until the device tells us otherwise */</span>
	<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">media_present</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">write_prot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">WCE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">RCD</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">ATO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">first_scan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">max_medium_access_timeouts</span> <span class="o">=</span> <span class="n">SD_MAX_MEDIUM_TIMEOUTS</span><span class="p">;</span>

	<span class="n">sd_revalidate_disk</span><span class="p">(</span><span class="n">gd</span><span class="p">);</span>

	<span class="n">blk_queue_prep_rq</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">sd_prep_fn</span><span class="p">);</span>
	<span class="n">blk_queue_unprep_rq</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">sd_unprep_fn</span><span class="p">);</span>

	<span class="n">gd</span><span class="o">-&gt;</span><span class="n">driverfs_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">;</span>
	<span class="n">gd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">GENHD_FL_EXT_DEVT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">removable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">GENHD_FL_REMOVABLE</span><span class="p">;</span>
		<span class="n">gd</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">DISK_EVENT_MEDIA_CHANGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">add_disk</span><span class="p">(</span><span class="n">gd</span><span class="p">);</span>
	<span class="n">sd_dif_config_host</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>

	<span class="n">sd_revalidate_disk</span><span class="p">(</span><span class="n">gd</span><span class="p">);</span>

	<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Attached SCSI %sdisk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">?</span> <span class="s">&quot;removable &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="n">scsi_autopm_put_device</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sd_probe - called during driver initialization and whenever a</span>
<span class="cm"> *	new scsi device is attached to the system. It is called once</span>
<span class="cm"> *	for each scsi device (not just disks) present.</span>
<span class="cm"> *	@dev: pointer to device object</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 if successful (or not interested in this scsi device </span>
<span class="cm"> *	(e.g. scanner)); 1 when there is an error.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: this function is invoked from the scsi mid-level.</span>
<span class="cm"> *	This function sets up the mapping between a given </span>
<span class="cm"> *	&lt;host,channel,id,lun&gt; (found in sdp) and new device name </span>
<span class="cm"> *	(e.g. /dev/sda). More precisely it is the block device major </span>
<span class="cm"> *	and minor number that is chosen here.</span>
<span class="cm"> *</span>
<span class="cm"> *	Assume sd_probe is not re-entrant (for time being)</span>
<span class="cm"> *	Also think about sd_probe() and sd_remove() running coincidentally.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_DISK</span> <span class="o">&amp;&amp;</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_MOD</span> <span class="o">&amp;&amp;</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_RBC</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">SCSI_LOG_HLQUEUE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdp</span><span class="p">,</span>
					<span class="s">&quot;sd_probe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">sdkp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sdkp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdkp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">gd</span> <span class="o">=</span> <span class="n">alloc_disk</span><span class="p">(</span><span class="n">SD_MINORS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gd</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ida_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_index_ida</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_index_lock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ida_get_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_index_ida</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_index_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;sd_probe: memory exhausted.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">sd_format_disk_name</span><span class="p">(</span><span class="s">&quot;sd&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">gd</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="n">DISK_NAME_LEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;SCSI disk (sd) name length exceeded.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_index</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">sdp</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sd_template</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">disk</span> <span class="o">=</span> <span class="n">gd</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">openers</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="o">-&gt;</span><span class="n">rq_timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_MOD</span><span class="p">)</span>
			<span class="n">blk_queue_rq_timeout</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">SD_TIMEOUT</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">blk_queue_rq_timeout</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span>
					     <span class="n">SD_MOD_TIMEOUT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">device_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sd_disk_class</span><span class="p">;</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free_index</span><span class="p">;</span>

	<span class="n">get_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">);</span>

	<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* prevent release before async_schedule */</span>
	<span class="n">async_schedule_domain</span><span class="p">(</span><span class="n">sd_probe_async</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scsi_sd_probe_domain</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_free_index:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_index_lock</span><span class="p">);</span>
	<span class="n">ida_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_index_ida</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_index_lock</span><span class="p">);</span>
 <span class="nl">out_put:</span>
	<span class="n">put_disk</span><span class="p">(</span><span class="n">gd</span><span class="p">);</span>
 <span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sd_remove - called whenever a scsi disk (previously recognized by</span>
<span class="cm"> *	sd_probe) is detached from the system. It is called (potentially</span>
<span class="cm"> *	multiple times) during sd module unload.</span>
<span class="cm"> *	@sdp: pointer to mid level scsi device object</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: this function is invoked from the scsi mid-level.</span>
<span class="cm"> *	This function potentially frees up a device name (e.g. /dev/sdc)</span>
<span class="cm"> *	that could be re-used by a subsequent sd_probe().</span>
<span class="cm"> *	This function is not called when the built-in sd driver is &quot;exit-ed&quot;.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">;</span>

	<span class="n">sdkp</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">scsi_autopm_get_device</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>

	<span class="n">async_synchronize_full_domain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scsi_sd_probe_domain</span><span class="p">);</span>
	<span class="n">blk_queue_prep_rq</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">scsi_prep_fn</span><span class="p">);</span>
	<span class="n">blk_queue_unprep_rq</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">del_gendisk</span><span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">);</span>
	<span class="n">sd_shutdown</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_ref_mutex</span><span class="p">);</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_ref_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	scsi_disk_release - Called to free the scsi_disk structure</span>
<span class="cm"> *	@dev: pointer to embedded class device</span>
<span class="cm"> *</span>
<span class="cm"> *	sd_ref_mutex must be held entering this routine.  Because it is</span>
<span class="cm"> *	called on last put, you should always use the scsi_disk_get()</span>
<span class="cm"> *	scsi_disk_put() helpers which manipulate the semaphore directly</span>
<span class="cm"> *	and never do a direct put_device.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_disk_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">to_scsi_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">;</span>
	
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_index_lock</span><span class="p">);</span>
	<span class="n">ida_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_index_ida</span><span class="p">,</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_index_lock</span><span class="p">);</span>

	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">put_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_start_stop_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">START_STOP</span> <span class="p">};</span>	<span class="cm">/* START_VALID */</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="p">)</span>
		<span class="n">cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* START */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">start_stop_pwr_cond</span><span class="p">)</span>
		<span class="n">cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">|=</span> <span class="n">start</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>	<span class="cm">/* Active or Standby */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_device_online</span><span class="p">(</span><span class="n">sdp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">scsi_execute_req</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">DMA_NONE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">,</span>
			       <span class="n">SD_TIMEOUT</span><span class="p">,</span> <span class="n">SD_MAX_RETRIES</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;START_STOP FAILED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sd_print_result</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">driver_byte</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DRIVER_SENSE</span><span class="p">)</span>
			<span class="n">sd_print_sense_hdr</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send a SYNCHRONIZE CACHE instruction down to the device through</span>
<span class="cm"> * the normal SCSI command structure.  Wait for the command to</span>
<span class="cm"> * complete.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk_get_from_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdkp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>         <span class="cm">/* this can happen */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm_runtime_suspended</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">WCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Synchronizing SCSI cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sd_sync_cache</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">system_state</span> <span class="o">!=</span> <span class="n">SYSTEM_RESTART</span> <span class="o">&amp;&amp;</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">manage_start_stop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Stopping disk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sd_start_stop_device</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">exit:</span>
	<span class="n">scsi_disk_put</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk_get_from_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdkp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* this can happen */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">WCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Synchronizing SCSI cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sd_sync_cache</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mesg</span><span class="p">.</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">PM_EVENT_SLEEP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">manage_start_stop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Stopping disk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sd_start_stop_device</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">scsi_disk_put</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk_get_from_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">manage_start_stop</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot;Starting disk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sd_start_stop_device</span><span class="p">(</span><span class="n">sdkp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">scsi_disk_put</span><span class="p">(</span><span class="n">sdkp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	init_sd - entry point for this driver (both when built in or when</span>
<span class="cm"> *	a module).</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: this function registers this driver with the scsi mid-level.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_sd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">majors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">SCSI_LOG_HLQUEUE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;init_sd: sd driver entry point</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SD_MAJORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">register_blkdev</span><span class="p">(</span><span class="n">sd_major</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s">&quot;sd&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">majors</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">majors</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_disk_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">scsi_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_template</span><span class="p">.</span><span class="n">gendrv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_class</span><span class="p">;</span>

	<span class="n">sd_cdb_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;sd_ext_cdb&quot;</span><span class="p">,</span> <span class="n">SD_EXT_CDB_SIZE</span><span class="p">,</span>
					 <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd_cdb_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;sd: can&#39;t init extended cdb cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_class</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sd_cdb_pool</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="n">SD_MEMPOOL_SIZE</span><span class="p">,</span> <span class="n">sd_cdb_cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd_cdb_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;sd: can&#39;t init extended cdb pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_cache</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_cache:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">sd_cdb_cache</span><span class="p">);</span>

<span class="nl">err_out_class:</span>
	<span class="n">class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_disk_class</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SD_MAJORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">unregister_blkdev</span><span class="p">(</span><span class="n">sd_major</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s">&quot;sd&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	exit_sd - exit point for this driver (when it is a module).</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: this function unregisters this driver from the scsi mid-level.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">exit_sd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">SCSI_LOG_HLQUEUE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;exit_sd: exiting sd driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">sd_cdb_pool</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">sd_cdb_cache</span><span class="p">);</span>

	<span class="n">scsi_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_template</span><span class="p">.</span><span class="n">gendrv</span><span class="p">);</span>
	<span class="n">class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_disk_class</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SD_MAJORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">unregister_blkdev</span><span class="p">(</span><span class="n">sd_major</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s">&quot;sd&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_sd</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">exit_sd</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_print_sense_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="n">sshdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="n">scsi_show_sense_hdr</span><span class="p">(</span><span class="n">sshdr</span><span class="p">);</span>
	<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="n">scsi_show_extd_sense</span><span class="p">(</span><span class="n">sshdr</span><span class="o">-&gt;</span><span class="n">asc</span><span class="p">,</span> <span class="n">sshdr</span><span class="o">-&gt;</span><span class="n">ascq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_print_result</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdkp</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="n">scsi_show_result</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
