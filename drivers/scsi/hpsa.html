<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › hpsa.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>hpsa.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *    Disk Array driver for HP Smart Array SAS controllers</span>
<span class="cm"> *    Copyright 2000, 2009 Hewlett-Packard Development Company, L.P.</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *    it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *    the Free Software Foundation; version 2 of the License.</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *    NON INFRINGEMENT.  See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *    You should have received a copy of the GNU General Public License</span>
<span class="cm"> *    along with this program; if not, write to the Free Software</span>
<span class="cm"> *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *    Questions/Comments/Bugfixes to iss_storagedev@hp.com</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/pci-aspm.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/blktrace_api.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &lt;linux/cciss_ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &quot;hpsa_cmd.h&quot;</span>
<span class="cp">#include &quot;hpsa.h&quot;</span>

<span class="cm">/* HPSA_DRIVER_VERSION must be 3 byte values (0-255) separated by &#39;.&#39; */</span>
<span class="cp">#define HPSA_DRIVER_VERSION &quot;2.0.2-1&quot;</span>
<span class="cp">#define DRIVER_NAME &quot;HP HPSA Driver (v &quot; HPSA_DRIVER_VERSION &quot;)&quot;</span>
<span class="cp">#define HPSA &quot;hpsa&quot;</span>

<span class="cm">/* How long to wait (in milliseconds) for board to go into simple mode */</span>
<span class="cp">#define MAX_CONFIG_WAIT 30000</span>
<span class="cp">#define MAX_IOCTL_CONFIG_WAIT 1000</span>

<span class="cm">/*define how many times we will try a command because of bus resets */</span>
<span class="cp">#define MAX_CMD_RETRIES 3</span>

<span class="cm">/* Embedded module documentation macros - see modules.h */</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Hewlett-Packard Company&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Driver for HP Smart Array Controller version &quot;</span> \
	<span class="n">HPSA_DRIVER_VERSION</span><span class="p">);</span>
<span class="n">MODULE_SUPPORTED_DEVICE</span><span class="p">(</span><span class="s">&quot;HP Smart Array Controllers&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">HPSA_DRIVER_VERSION</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hpsa_allow_any</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">hpsa_allow_any</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">hpsa_allow_any</span><span class="p">,</span>
		<span class="s">&quot;Allow hpsa driver to access unknown HP Smart Array hardware&quot;</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hpsa_simple_mode</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">hpsa_simple_mode</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">hpsa_simple_mode</span><span class="p">,</span>
	<span class="s">&quot;Use &#39;simple mode&#39; rather than &#39;performant mode&#39;&quot;</span><span class="p">);</span>

<span class="cm">/* define the PCI info for the cards we can control */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">hpsa_pci_device_id</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSE</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x3241</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSE</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x3243</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSE</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x3245</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSE</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x3247</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSE</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x3249</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSE</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x324a</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSE</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x324b</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSE</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x3233</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSF</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x3350</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSF</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x3351</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSF</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x3352</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSF</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x3353</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSF</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x3354</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSF</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x3355</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_DEVICE_ID_HP_CISSF</span><span class="p">,</span>     <span class="mh">0x103C</span><span class="p">,</span> <span class="mh">0x3356</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_HP</span><span class="p">,</span>     <span class="n">PCI_ANY_ID</span><span class="p">,</span>	<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">PCI_CLASS_STORAGE_RAID</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span> <span class="mh">0xffff</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">hpsa_pci_device_id</span><span class="p">);</span>

<span class="cm">/*  board_id = Subsystem Device ID &amp; Vendor ID</span>
<span class="cm"> *  product = Marketing Name for the board</span>
<span class="cm"> *  access = Address of the struct of function pointers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">board_type</span> <span class="n">products</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="mh">0x3241103C</span><span class="p">,</span> <span class="s">&quot;Smart Array P212&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x3243103C</span><span class="p">,</span> <span class="s">&quot;Smart Array P410&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x3245103C</span><span class="p">,</span> <span class="s">&quot;Smart Array P410i&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x3247103C</span><span class="p">,</span> <span class="s">&quot;Smart Array P411&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x3249103C</span><span class="p">,</span> <span class="s">&quot;Smart Array P812&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x324a103C</span><span class="p">,</span> <span class="s">&quot;Smart Array P712m&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x324b103C</span><span class="p">,</span> <span class="s">&quot;Smart Array P711m&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x3350103C</span><span class="p">,</span> <span class="s">&quot;Smart Array&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x3351103C</span><span class="p">,</span> <span class="s">&quot;Smart Array&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x3352103C</span><span class="p">,</span> <span class="s">&quot;Smart Array&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x3353103C</span><span class="p">,</span> <span class="s">&quot;Smart Array&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x3354103C</span><span class="p">,</span> <span class="s">&quot;Smart Array&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x3355103C</span><span class="p">,</span> <span class="s">&quot;Smart Array&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x3356103C</span><span class="p">,</span> <span class="s">&quot;Smart Array&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0xFFFF103C</span><span class="p">,</span> <span class="s">&quot;Unknown Smart Array&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SA5_access</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">number_of_controllers</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">hpsa_ctlr_list</span> <span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">hpsa_ctlr_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">spinlock_t</span> <span class="n">lockup_detector_lock</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">hpsa_lockup_detector</span><span class="p">;</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">do_hpsa_intr_intx</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">do_hpsa_intr_msi</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hpsa_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">start_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hpsa_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cmd_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">cmd_special_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">cmd_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">cmd_special_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fill_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">u8</span> <span class="n">page_code</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scsi3addr</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">cmd_type</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hpsa_scsi_queue_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hpsa_scan_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hpsa_scan_finished</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">sh</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elapsed_time</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hpsa_change_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">qdepth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hpsa_eh_device_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsicmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hpsa_eh_abort_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsicmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hpsa_slave_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hpsa_slave_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hpsa_update_scsi_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hostno</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">check_for_unit_attention</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">check_ioctl_unit_attention</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="cm">/* performant mode helper functions */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">calc_bucket_map</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">bucket</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_buckets</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">nsgs</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bucket_map</span><span class="p">);</span>
<span class="k">static</span> <span class="n">__devinit</span> <span class="kt">void</span> <span class="n">hpsa_put_ctlr_into_performant_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="n">next_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">u8</span> <span class="n">q</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="n">hpsa_find_cfg_addrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">cfg_base_addr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">cfg_base_addr_index</span><span class="p">,</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">cfg_offset</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="n">hpsa_pci_find_memory_BAR</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">memory_bar</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="n">hpsa_lookup_board_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">board_id</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="n">hpsa_wait_for_board_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait_for_ready</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">finish_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="cp">#define BOARD_NOT_READY 0</span>
<span class="cp">#define BOARD_READY 1</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="nf">sdev_to_hba</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="nf">shost_to_hba</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">sh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">sh</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_for_unit_attention</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">SenseInfo</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">UNIT_ATTENTION</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">SenseInfo</span><span class="p">[</span><span class="mi">12</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">STATE_CHANGED</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">HPSA</span> <span class="s">&quot;%d: a state change &quot;</span>
			<span class="s">&quot;detected, command retried</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ctlr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LUN_FAILED</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">HPSA</span> <span class="s">&quot;%d: LUN failure &quot;</span>
			<span class="s">&quot;detected, action required</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ctlr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">REPORT_LUNS_CHANGED</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">HPSA</span> <span class="s">&quot;%d: report LUN data &quot;</span>
			<span class="s">&quot;changed, action required</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ctlr</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note: this REPORT_LUNS_CHANGED condition only occurs on the external</span>
<span class="cm">	 * target (array) devices.</span>
<span class="cm">	 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">POWER_OR_RESET</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">HPSA</span> <span class="s">&quot;%d: a power on &quot;</span>
			<span class="s">&quot;or device reset detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ctlr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UNIT_ATTENTION_CLEARED</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">HPSA</span> <span class="s">&quot;%d: unit attention &quot;</span>
		    <span class="s">&quot;cleared by another initiator</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ctlr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">HPSA</span> <span class="s">&quot;%d: unknown &quot;</span>
			<span class="s">&quot;unit attention detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ctlr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_for_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">CommandStatus</span> <span class="o">!=</span> <span class="n">CMD_TARGET_STATUS</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">ScsiStatus</span> <span class="o">!=</span> <span class="n">SAM_STAT_BUSY</span> <span class="o">&amp;&amp;</span>
		 <span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">ScsiStatus</span> <span class="o">!=</span> <span class="n">SAM_STAT_TASK_SET_FULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">HPSA</span> <span class="s">&quot;device busy&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">host_store_rescan</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">shost_to_hba</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">hpsa_scan_start</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">host_show_firmware_revision</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fwrev</span><span class="p">;</span>

	<span class="n">h</span> <span class="o">=</span> <span class="n">shost_to_hba</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hba_inquiry_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fwrev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hba_inquiry_data</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;%c%c%c%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">fwrev</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fwrev</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fwrev</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">fwrev</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">host_show_commands_outstanding</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">shost_to_hba</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">commands_outstanding</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">host_show_transport_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">h</span> <span class="o">=</span> <span class="n">shost_to_hba</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">transMethod</span> <span class="o">&amp;</span> <span class="n">CFGTBL_Trans_Performant</span> <span class="o">?</span>
			<span class="s">&quot;performant&quot;</span> <span class="o">:</span> <span class="s">&quot;simple&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* List of controllers which cannot be hard reset on kexec with reset_devices */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">unresettable_controller</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x324a103C</span><span class="p">,</span> <span class="cm">/* Smart Array P712m */</span>
	<span class="mh">0x324b103C</span><span class="p">,</span> <span class="cm">/* SmartArray P711m */</span>
	<span class="mh">0x3223103C</span><span class="p">,</span> <span class="cm">/* Smart Array P800 */</span>
	<span class="mh">0x3234103C</span><span class="p">,</span> <span class="cm">/* Smart Array P400 */</span>
	<span class="mh">0x3235103C</span><span class="p">,</span> <span class="cm">/* Smart Array P400i */</span>
	<span class="mh">0x3211103C</span><span class="p">,</span> <span class="cm">/* Smart Array E200i */</span>
	<span class="mh">0x3212103C</span><span class="p">,</span> <span class="cm">/* Smart Array E200 */</span>
	<span class="mh">0x3213103C</span><span class="p">,</span> <span class="cm">/* Smart Array E200i */</span>
	<span class="mh">0x3214103C</span><span class="p">,</span> <span class="cm">/* Smart Array E200i */</span>
	<span class="mh">0x3215103C</span><span class="p">,</span> <span class="cm">/* Smart Array E200i */</span>
	<span class="mh">0x3237103C</span><span class="p">,</span> <span class="cm">/* Smart Array E500 */</span>
	<span class="mh">0x323D103C</span><span class="p">,</span> <span class="cm">/* Smart Array P700m */</span>
	<span class="mh">0x40800E11</span><span class="p">,</span> <span class="cm">/* Smart Array 5i */</span>
	<span class="mh">0x409C0E11</span><span class="p">,</span> <span class="cm">/* Smart Array 6400 */</span>
	<span class="mh">0x409D0E11</span><span class="p">,</span> <span class="cm">/* Smart Array 6400 EM */</span>
	<span class="mh">0x40700E11</span><span class="p">,</span> <span class="cm">/* Smart Array 5300 */</span>
	<span class="mh">0x40820E11</span><span class="p">,</span> <span class="cm">/* Smart Array 532 */</span>
	<span class="mh">0x40830E11</span><span class="p">,</span> <span class="cm">/* Smart Array 5312 */</span>
	<span class="mh">0x409A0E11</span><span class="p">,</span> <span class="cm">/* Smart Array 641 */</span>
	<span class="mh">0x409B0E11</span><span class="p">,</span> <span class="cm">/* Smart Array 642 */</span>
	<span class="mh">0x40910E11</span><span class="p">,</span> <span class="cm">/* Smart Array 6i */</span>
<span class="p">};</span>

<span class="cm">/* List of controllers which cannot even be soft reset */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">soft_unresettable_controller</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x40800E11</span><span class="p">,</span> <span class="cm">/* Smart Array 5i */</span>
	<span class="mh">0x40700E11</span><span class="p">,</span> <span class="cm">/* Smart Array 5300 */</span>
	<span class="mh">0x40820E11</span><span class="p">,</span> <span class="cm">/* Smart Array 532 */</span>
	<span class="mh">0x40830E11</span><span class="p">,</span> <span class="cm">/* Smart Array 5312 */</span>
	<span class="mh">0x409A0E11</span><span class="p">,</span> <span class="cm">/* Smart Array 641 */</span>
	<span class="mh">0x409B0E11</span><span class="p">,</span> <span class="cm">/* Smart Array 642 */</span>
	<span class="mh">0x40910E11</span><span class="p">,</span> <span class="cm">/* Smart Array 6i */</span>
	<span class="cm">/* Exclude 640x boards.  These are two pci devices in one slot</span>
<span class="cm">	 * which share a battery backed cache module.  One controls the</span>
<span class="cm">	 * cache, the other accesses the cache through the one that controls</span>
<span class="cm">	 * it.  If we reset the one controlling the cache, the other will</span>
<span class="cm">	 * likely not be happy.  Just forbid resetting this conjoined mess.</span>
<span class="cm">	 * The 640x isn&#39;t really supported by hpsa anyway.</span>
<span class="cm">	 */</span>
	<span class="mh">0x409C0E11</span><span class="p">,</span> <span class="cm">/* Smart Array 6400 */</span>
	<span class="mh">0x409D0E11</span><span class="p">,</span> <span class="cm">/* Smart Array 6400 EM */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ctlr_is_hard_resettable</span><span class="p">(</span><span class="n">u32</span> <span class="n">board_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">unresettable_controller</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unresettable_controller</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">board_id</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ctlr_is_soft_resettable</span><span class="p">(</span><span class="n">u32</span> <span class="n">board_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">soft_unresettable_controller</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">soft_unresettable_controller</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">board_id</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ctlr_is_resettable</span><span class="p">(</span><span class="n">u32</span> <span class="n">board_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ctlr_is_hard_resettable</span><span class="p">(</span><span class="n">board_id</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">ctlr_is_soft_resettable</span><span class="p">(</span><span class="n">board_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">host_show_resettable</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">h</span> <span class="o">=</span> <span class="n">shost_to_hba</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctlr_is_resettable</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">board_id</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_logical_dev_addr_mode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">scsi3addr</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">scsi3addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x40</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">raid_label</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;0&quot;</span><span class="p">,</span> <span class="s">&quot;4&quot;</span><span class="p">,</span> <span class="s">&quot;1(1+0)&quot;</span><span class="p">,</span> <span class="s">&quot;5&quot;</span><span class="p">,</span> <span class="s">&quot;5+1&quot;</span><span class="p">,</span> <span class="s">&quot;ADG&quot;</span><span class="p">,</span>
	<span class="s">&quot;1(ADM)&quot;</span><span class="p">,</span> <span class="s">&quot;UNKNOWN&quot;</span>
<span class="p">};</span>
<span class="cp">#define RAID_UNKNOWN (ARRAY_SIZE(raid_label) - 1)</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">raid_level_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">rlevel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">hdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">sdev_to_hba</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">hdev</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is this even a logical drive? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_logical_dev_addr_mode</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;N/A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rlevel</span> <span class="o">=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">raid_level</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rlevel</span> <span class="o">&gt;</span> <span class="n">RAID_UNKNOWN</span><span class="p">)</span>
		<span class="n">rlevel</span> <span class="o">=</span> <span class="n">RAID_UNKNOWN</span><span class="p">;</span>
	<span class="n">l</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;RAID %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">raid_label</span><span class="p">[</span><span class="n">rlevel</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">l</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">lunid_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">hdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lunid</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">sdev_to_hba</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">hdev</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">lunid</span><span class="p">,</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lunid</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;0x%02x%02x%02x%02x%02x%02x%02x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">lunid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lunid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">lunid</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">lunid</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
		<span class="n">lunid</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">lunid</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">lunid</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">lunid</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">unique_id_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">hdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sn</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">sdev_to_hba</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">hdev</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sn</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
			<span class="s">&quot;%02X%02X%02X%02X%02X%02X%02X%02X&quot;</span>
			<span class="s">&quot;%02X%02X%02X%02X%02X%02X%02X%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
			<span class="n">sn</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
			<span class="n">sn</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span>
			<span class="n">sn</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">15</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">raid_level</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">raid_level_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lunid</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lunid_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">unique_id</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">unique_id_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">rescan</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">host_store_rescan</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">firmware_revision</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
	<span class="n">host_show_firmware_revision</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">commands_outstanding</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
	<span class="n">host_show_commands_outstanding</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">transport_mode</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
	<span class="n">host_show_transport_mode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">resettable</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
	<span class="n">host_show_resettable</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">hpsa_sdev_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_raid_level</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lunid</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_unique_id</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">hpsa_shost_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_rescan</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_firmware_revision</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_commands_outstanding</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_transport_mode</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_resettable</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">hpsa_driver_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span>			<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="n">HPSA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_name</span>		<span class="o">=</span> <span class="n">HPSA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span>		<span class="o">=</span> <span class="n">hpsa_scsi_queue_command</span><span class="p">,</span>
	<span class="p">.</span><span class="n">scan_start</span>		<span class="o">=</span> <span class="n">hpsa_scan_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">scan_finished</span>		<span class="o">=</span> <span class="n">hpsa_scan_finished</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change_queue_depth</span>	<span class="o">=</span> <span class="n">hpsa_change_queue_depth</span><span class="p">,</span>
	<span class="p">.</span><span class="n">this_id</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span>		<span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_abort_handler</span>	<span class="o">=</span> <span class="n">hpsa_eh_abort_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_device_reset_handler</span> <span class="o">=</span> <span class="n">hpsa_eh_device_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>			<span class="o">=</span> <span class="n">hpsa_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_alloc</span>		<span class="o">=</span> <span class="n">hpsa_slave_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_destroy</span>		<span class="o">=</span> <span class="n">hpsa_slave_destroy</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>		<span class="o">=</span> <span class="n">hpsa_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">sdev_attrs</span> <span class="o">=</span> <span class="n">hpsa_sdev_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shost_attrs</span> <span class="o">=</span> <span class="n">hpsa_shost_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="mi">8192</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* Enqueuing and dequeuing functions for cmdlists. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">addQ</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">next_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">u8</span> <span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">a</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reply_pool</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_queue</span><span class="p">[</span><span class="n">q</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transMethod</span> <span class="o">&amp;</span> <span class="n">CFGTBL_Trans_Performant</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">.</span><span class="n">command_completed</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">[</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">current_entry</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">wraparound</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">[</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">current_entry</span><span class="p">];</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">current_entry</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">commands_outstanding</span><span class="o">--</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">FIFO_EMPTY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check for wraparound */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">current_entry</span> <span class="o">==</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_commands</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">current_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">wraparound</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* set_performant_mode: Modify the tag for cciss performant</span>
<span class="cm"> * set bit 0 for pull model, bits 3-1 for block fetch</span>
<span class="cm"> * register number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_performant_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transMethod</span> <span class="o">&amp;</span> <span class="n">CFGTBL_Trans_Performant</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">busaddr</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">|</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">blockFetchTable</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGList</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">msix_vector</span><span class="p">))</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">ReplyQueue</span> <span class="o">=</span>
				<span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">%</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nreply_queues</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_firmware_flash_cmd</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">cdb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">BMIC_WRITE</span> <span class="o">&amp;&amp;</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="n">BMIC_FLASH_FIRMWARE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * During firmware flash, the heartbeat register may not update as frequently</span>
<span class="cm"> * as it should.  So we dial down lockup detection during firmware flash. and</span>
<span class="cm"> * dial it back up when firmware flash completes.</span>
<span class="cm"> */</span>
<span class="cp">#define HEARTBEAT_SAMPLE_INTERVAL_DURING_FLASH (240 * HZ)</span>
<span class="cp">#define HEARTBEAT_SAMPLE_INTERVAL (30 * HZ)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dial_down_lockup_detection_during_fw_flash</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_firmware_flash_cmd</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">firmware_flash_in_progress</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">heartbeat_sample_interval</span> <span class="o">=</span> <span class="n">HEARTBEAT_SAMPLE_INTERVAL_DURING_FLASH</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dial_up_lockup_detection_on_fw_flash_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_firmware_flash_cmd</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">firmware_flash_in_progress</span><span class="p">))</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">heartbeat_sample_interval</span> <span class="o">=</span> <span class="n">HEARTBEAT_SAMPLE_INTERVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enqueue_cmd_and_start_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">set_performant_mode</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="n">dial_down_lockup_detection_during_fw_flash</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">addQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">reqQ</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">Qdepth</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">start_io</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">removeQ</span><span class="p">(</span><span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_hba_lunid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">scsi3addr</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="n">RAID_CTLR_LUNID</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_scsi_rev_5</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hba_inquiry_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hba_inquiry_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_find_target_lun</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">scsi3addr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* finds an unused bus, target, lun for a new physical device</span>
<span class="cm">	 * assumes h-&gt;devlock is held</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">lun_taken</span><span class="p">,</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">);</span>

	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">lun_taken</span><span class="p">,</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ndevices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="n">bus</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">lun_taken</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">lun_taken</span><span class="p">,</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* *bus = 1; */</span>
		<span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="o">*</span><span class="n">lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add an entry into h-&gt;dev[] array. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_scsi_add_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hostno</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">added</span><span class="p">[],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nadded</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* assumes h-&gt;devlock is held */</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ndevices</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr1</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">addr2</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;too many devices, some will be &quot;</span>
			<span class="s">&quot;inaccessible.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* physical devices do not have lun or target assigned until now. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="cm">/* Logical device, lun is already assigned. */</span>
		<span class="k">goto</span> <span class="n">lun_assigned</span><span class="p">;</span>

	<span class="cm">/* If this device a non-zero lun of a multi-lun device</span>
<span class="cm">	 * byte 4 of the 8-byte LUN addr will contain the logical</span>
<span class="cm">	 * unit no, zero otherise.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is not a non-zero lun of a multi-lun device */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_find_target_lun</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">,</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">lun_assigned</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This is a non-zero lun of a multi-lun device.</span>
<span class="cm">	 * Search through our list and find the device which</span>
<span class="cm">	 * has the same 8 byte LUN address, excepting byte 4.</span>
<span class="cm">	 * Assign the same bus and target for this new LUN.</span>
<span class="cm">	 * Use the logical unit number from the firmware.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">addr1</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">addr1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">addr2</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">addr2</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* differ only in byte 4? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">addr1</span><span class="p">,</span> <span class="n">addr2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">;</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;physical device with no LUN=0,&quot;</span>
			<span class="s">&quot; suspect firmware bug or unsupported hardware &quot;</span>
			<span class="s">&quot;configuration.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">lun_assigned:</span>

	<span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">ndevices</span><span class="o">++</span><span class="p">;</span>
	<span class="n">added</span><span class="p">[</span><span class="o">*</span><span class="n">nadded</span><span class="p">]</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">nadded</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* initially, (before registering with scsi layer) we don&#39;t</span>
<span class="cm">	 * know our hostno and we don&#39;t want to print anything first</span>
<span class="cm">	 * time anyway (the scsi layer&#39;s inquiries will show that info)</span>
<span class="cm">	 */</span>
	<span class="cm">/* if (hostno != -1) */</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s device c%db%dt%dl%d added.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">scsi_device_type</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">devtype</span><span class="p">),</span> <span class="n">hostno</span><span class="p">,</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Update an entry in h-&gt;dev[] array. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_scsi_update_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hostno</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">new_entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* assumes h-&gt;devlock is held */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">entry</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">entry</span> <span class="o">&gt;=</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">);</span>

	<span class="cm">/* Raid level changed. */</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">raid_level</span> <span class="o">=</span> <span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">raid_level</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s device c%db%dt%dl%d updated.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">scsi_device_type</span><span class="p">(</span><span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">devtype</span><span class="p">),</span> <span class="n">hostno</span><span class="p">,</span> <span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span>
		<span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Replace an entry from h-&gt;dev[] array. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_scsi_replace_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hostno</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">new_entry</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">added</span><span class="p">[],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nadded</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">removed</span><span class="p">[],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nremoved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* assumes h-&gt;devlock is held */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">entry</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">entry</span> <span class="o">&gt;=</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">);</span>
	<span class="n">removed</span><span class="p">[</span><span class="o">*</span><span class="n">nremoved</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
	<span class="p">(</span><span class="o">*</span><span class="n">nremoved</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * New physical devices won&#39;t have target/lun assigned yet</span>
<span class="cm">	 * so we need to preserve the values in the slot we are replacing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">;</span>
		<span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_entry</span><span class="p">;</span>
	<span class="n">added</span><span class="p">[</span><span class="o">*</span><span class="n">nadded</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_entry</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">nadded</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s device c%db%dt%dl%d changed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">scsi_device_type</span><span class="p">(</span><span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">devtype</span><span class="p">),</span> <span class="n">hostno</span><span class="p">,</span> <span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span>
			<span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Remove an entry from h-&gt;dev[] array. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_scsi_remove_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hostno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">removed</span><span class="p">[],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nremoved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* assumes h-&gt;devlock is held */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">entry</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">entry</span> <span class="o">&gt;=</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">);</span>

	<span class="n">sd</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
	<span class="n">removed</span><span class="p">[</span><span class="o">*</span><span class="n">nremoved</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
	<span class="p">(</span><span class="o">*</span><span class="n">nremoved</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ndevices</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">ndevices</span><span class="o">--</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s device c%db%dt%dl%d removed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">scsi_device_type</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">devtype</span><span class="p">),</span> <span class="n">hostno</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define SCSI3ADDR_EQ(a, b) ( \</span>
<span class="cp">	(a)[7] == (b)[7] &amp;&amp; \</span>
<span class="cp">	(a)[6] == (b)[6] &amp;&amp; \</span>
<span class="cp">	(a)[5] == (b)[5] &amp;&amp; \</span>
<span class="cp">	(a)[4] == (b)[4] &amp;&amp; \</span>
<span class="cp">	(a)[3] == (b)[3] &amp;&amp; \</span>
<span class="cp">	(a)[2] == (b)[2] &amp;&amp; \</span>
<span class="cp">	(a)[1] == (b)[1] &amp;&amp; \</span>
<span class="cp">	(a)[0] == (b)[0])</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_botched_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">added</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* called when scsi_add_device fails in order to re-adjust</span>
<span class="cm">	 * h-&gt;dev[] to match the mid layer&#39;s view.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ndevices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">added</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ndevices</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">ndevices</span><span class="o">--</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">added</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">device_is_the_same</span><span class="p">(</span><span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">dev1</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">dev2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* we compare everything except lun and target as these</span>
<span class="cm">	 * are not yet assigned.  Compare parts likely</span>
<span class="cm">	 * to differ first</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">dev1</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="n">dev2</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">dev1</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">dev1</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">,</span> <span class="n">dev2</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">dev1</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">dev1</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">,</span> <span class="n">dev2</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dev1</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">dev1</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">dev2</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dev1</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev1</span><span class="o">-&gt;</span><span class="n">devtype</span> <span class="o">!=</span> <span class="n">dev2</span><span class="o">-&gt;</span><span class="n">devtype</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev1</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="n">dev2</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">device_updated</span><span class="p">(</span><span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">dev1</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">dev2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Device attributes that can change, but don&#39;t mean</span>
<span class="cm">	 * that the device is a different device, nor that the OS</span>
<span class="cm">	 * needs to be told anything about the change.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev1</span><span class="o">-&gt;</span><span class="n">raid_level</span> <span class="o">!=</span> <span class="n">dev2</span><span class="o">-&gt;</span><span class="n">raid_level</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find needle in haystack.  If exact match found, return DEVICE_SAME,</span>
<span class="cm"> * and return needle location in *index.  If scsi3addr matches, but not</span>
<span class="cm"> * vendor, model, serial num, etc. return DEVICE_CHANGED, and return needle</span>
<span class="cm"> * location in *index.</span>
<span class="cm"> * In the case of a minor device attribute change, such as RAID level, just</span>
<span class="cm"> * return DEVICE_UPDATED, along with the updated device&#39;s location in index.</span>
<span class="cm"> * If needle not found, return DEVICE_NOT_FOUND.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_scsi_find_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">needle</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">haystack</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">haystack_size</span><span class="p">,</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#define DEVICE_NOT_FOUND 0</span>
<span class="cp">#define DEVICE_CHANGED 1</span>
<span class="cp">#define DEVICE_SAME 2</span>
<span class="cp">#define DEVICE_UPDATED 3</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">haystack_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="cm">/* previously removed. */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCSI3ADDR_EQ</span><span class="p">(</span><span class="n">needle</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">device_is_the_same</span><span class="p">(</span><span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">device_updated</span><span class="p">(</span><span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
					<span class="k">return</span> <span class="n">DEVICE_UPDATED</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">DEVICE_SAME</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">DEVICE_CHANGED</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">DEVICE_NOT_FOUND</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">adjust_hpsa_scsi_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hostno</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">sd</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">nsds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* sd contains scsi3 addresses and devtypes, and inquiry</span>
<span class="cm">	 * data.  This function takes what&#39;s in sd to be the current</span>
<span class="cm">	 * reality and updates h-&gt;dev[] to reflect that reality.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">device_change</span><span class="p">,</span> <span class="n">changes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">csd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">**</span><span class="n">added</span><span class="p">,</span> <span class="o">**</span><span class="n">removed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nadded</span><span class="p">,</span> <span class="n">nremoved</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">added</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">added</span><span class="p">)</span> <span class="o">*</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">removed</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">removed</span><span class="p">)</span> <span class="o">*</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">added</span> <span class="o">||</span> <span class="o">!</span><span class="n">removed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;out of memory in &quot;</span>
			<span class="s">&quot;adjust_hpsa_scsi_table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_and_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* find any devices in h-&gt;dev[] that are not in</span>
<span class="cm">	 * sd[] and remove them from h-&gt;dev[], and for any</span>
<span class="cm">	 * devices which have changed, remove the old device</span>
<span class="cm">	 * info and add the new device info.</span>
<span class="cm">	 * If minor device attributes change, just update</span>
<span class="cm">	 * the existing device structure.</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nremoved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nadded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ndevices</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">csd</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">device_change</span> <span class="o">=</span> <span class="n">hpsa_scsi_find_entry</span><span class="p">(</span><span class="n">csd</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">nsds</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device_change</span> <span class="o">==</span> <span class="n">DEVICE_NOT_FOUND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">changes</span><span class="o">++</span><span class="p">;</span>
			<span class="n">hpsa_scsi_remove_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">hostno</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">removed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nremoved</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span> <span class="cm">/* remove ^^^, hence i not incremented */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">device_change</span> <span class="o">==</span> <span class="n">DEVICE_CHANGED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">changes</span><span class="o">++</span><span class="p">;</span>
			<span class="n">hpsa_scsi_replace_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">hostno</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">sd</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span>
				<span class="n">added</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nadded</span><span class="p">,</span> <span class="n">removed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nremoved</span><span class="p">);</span>
			<span class="cm">/* Set it to NULL to prevent it from being freed</span>
<span class="cm">			 * at the bottom of hpsa_update_scsi_devices()</span>
<span class="cm">			 */</span>
			<span class="n">sd</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">device_change</span> <span class="o">==</span> <span class="n">DEVICE_UPDATED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hpsa_scsi_update_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">hostno</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">sd</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now, make sure every device listed in sd[] is also</span>
<span class="cm">	 * listed in h-&gt;dev[], adding them if they aren&#39;t found</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="cm">/* if already added above. */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">device_change</span> <span class="o">=</span> <span class="n">hpsa_scsi_find_entry</span><span class="p">(</span><span class="n">sd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">h</span><span class="o">-&gt;</span><span class="n">ndevices</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device_change</span> <span class="o">==</span> <span class="n">DEVICE_NOT_FOUND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">changes</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_scsi_add_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">hostno</span><span class="p">,</span> <span class="n">sd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				<span class="n">added</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nadded</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">sd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* prevent from being freed later. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">device_change</span> <span class="o">==</span> <span class="n">DEVICE_CHANGED</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* should never happen... */</span>
			<span class="n">changes</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;device unexpectedly changed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/* but if it does happen, we just ignore that device */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t notify scsi mid layer of any changes the first time through</span>
<span class="cm">	 * (or if there are no changes) scsi_scan_host will do it later the</span>
<span class="cm">	 * first time through.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hostno</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">changes</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_and_out</span><span class="p">;</span>

	<span class="n">sh</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">;</span>
	<span class="cm">/* Notify scsi mid layer of any removed devices */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nremoved</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span>
			<span class="n">scsi_device_lookup</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="n">removed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span>
				<span class="n">removed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">removed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
			<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* We don&#39;t expect to get here.</span>
<span class="cm">			 * future cmds to this device will get selection</span>
<span class="cm">			 * timeout as if the device was gone.</span>
<span class="cm">			 */</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;didn&#39;t find c%db%dt%dl%d &quot;</span>
				<span class="s">&quot; for removal.&quot;</span><span class="p">,</span> <span class="n">hostno</span><span class="p">,</span> <span class="n">removed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span>
				<span class="n">removed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">removed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">removed</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">removed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Notify scsi mid layer of any added devices */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nadded</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_add_device</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="n">added</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span>
			<span class="n">added</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">added</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;scsi_add_device c%db%dt%dl%d failed, &quot;</span>
			<span class="s">&quot;device not added.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hostno</span><span class="p">,</span> <span class="n">added</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span>
			<span class="n">added</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">added</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
		<span class="cm">/* now we have to remove it from h-&gt;dev,</span>
<span class="cm">		 * since it didn&#39;t get added to scsi mid layer</span>
<span class="cm">		 */</span>
		<span class="n">fixup_botched_add</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">added</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

<span class="nl">free_and_out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">added</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">removed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lookup bus/target/lun and retrun corresponding struct hpsa_scsi_dev_t *</span>
<span class="cm"> * Assume&#39;s h-&gt;devlock is held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="nf">lookup_hpsa_scsi_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ndevices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="n">bus</span> <span class="o">&amp;&amp;</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">==</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">==</span> <span class="n">lun</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sd</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* link sdev-&gt;hostdata to our per-device structure. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_slave_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>

	<span class="n">h</span> <span class="o">=</span> <span class="n">sdev_to_hba</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sd</span> <span class="o">=</span> <span class="n">lookup_hpsa_scsi_dev</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">sdev_channel</span><span class="p">(</span><span class="n">sdev</span><span class="p">),</span>
		<span class="n">sdev_id</span><span class="p">(</span><span class="n">sdev</span><span class="p">),</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">hostdata</span> <span class="o">=</span> <span class="n">sd</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_slave_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* nothing to do. */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_free_sg_chain_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_sg_list</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_sg_list</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_sg_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_allocate_sg_chain_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">chainsize</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_sg_list</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_sg_list</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span><span class="p">,</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_sg_list</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span>
						<span class="n">h</span><span class="o">-&gt;</span><span class="n">chainsize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">clean</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">clean:</span>
	<span class="n">hpsa_free_sg_chain_blocks</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_map_sg_chain_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">SGDescriptor</span> <span class="o">*</span><span class="n">chain_sg</span><span class="p">,</span> <span class="o">*</span><span class="n">chain_block</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">temp64</span><span class="p">;</span>

	<span class="n">chain_sg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">max_cmd_sg_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">chain_block</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_sg_list</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmdindex</span><span class="p">];</span>
	<span class="n">chain_sg</span><span class="o">-&gt;</span><span class="n">Ext</span> <span class="o">=</span> <span class="n">HPSA_SG_CHAIN</span><span class="p">;</span>
	<span class="n">chain_sg</span><span class="o">-&gt;</span><span class="n">Len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chain_sg</span><span class="p">)</span> <span class="o">*</span>
		<span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGTotal</span> <span class="o">-</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_cmd_sg_entries</span><span class="p">);</span>
	<span class="n">temp64</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">chain_block</span><span class="p">,</span> <span class="n">chain_sg</span><span class="o">-&gt;</span><span class="n">Len</span><span class="p">,</span>
				<span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
	<span class="n">chain_sg</span><span class="o">-&gt;</span><span class="n">Addr</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">temp64</span> <span class="o">&amp;</span> <span class="mh">0x0FFFFFFFFULL</span><span class="p">);</span>
	<span class="n">chain_sg</span><span class="o">-&gt;</span><span class="n">Addr</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">((</span><span class="n">temp64</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0FFFFFFFFULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_unmap_sg_chain_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">SGDescriptor</span> <span class="o">*</span><span class="n">chain_sg</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">u64bit</span> <span class="n">temp64</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGTotal</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_cmd_sg_entries</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">chain_sg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">max_cmd_sg_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">temp64</span><span class="p">.</span><span class="n">val32</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">chain_sg</span><span class="o">-&gt;</span><span class="n">Addr</span><span class="p">.</span><span class="n">lower</span><span class="p">;</span>
	<span class="n">temp64</span><span class="p">.</span><span class="n">val32</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">chain_sg</span><span class="o">-&gt;</span><span class="n">Addr</span><span class="p">.</span><span class="n">upper</span><span class="p">;</span>
	<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">temp64</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">chain_sg</span><span class="o">-&gt;</span><span class="n">Len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">complete_scsi_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ErrorInfo</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sense_key</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">asc</span><span class="p">;</span>      <span class="cm">/* additional sense code */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ascq</span><span class="p">;</span>     <span class="cm">/* additional sense code qualifier */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sense_data_size</span><span class="p">;</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">;</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="p">;</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">;</span>

	<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span> <span class="cm">/* undo the DMA mappings */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGTotal</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_cmd_sg_entries</span><span class="p">)</span>
		<span class="n">hpsa_unmap_sg_chain_block</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span> 		<span class="cm">/* host byte */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">COMMAND_COMPLETE</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>	<span class="cm">/* msg byte */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">ScsiStatus</span><span class="p">;</span>

	<span class="cm">/* copy the sense data whether we need to or not. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SCSI_SENSE_BUFFERSIZE</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">SenseInfo</span><span class="p">))</span>
		<span class="n">sense_data_size</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sense_data_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">SenseInfo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">SenseLen</span> <span class="o">&lt;</span> <span class="n">sense_data_size</span><span class="p">)</span>
		<span class="n">sense_data_size</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">SenseLen</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">SenseInfo</span><span class="p">,</span> <span class="n">sense_data_size</span><span class="p">);</span>
	<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">ResidualCnt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">CommandStatus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* an error has occurred */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">CommandStatus</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">CMD_TARGET_STATUS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">ScsiStatus</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Get sense key */</span>
			<span class="n">sense_key</span> <span class="o">=</span> <span class="mh">0xf</span> <span class="o">&amp;</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">SenseInfo</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
			<span class="cm">/* Get additional sense code */</span>
			<span class="n">asc</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">SenseInfo</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
			<span class="cm">/* Get addition sense code qualifier */</span>
			<span class="n">ascq</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">SenseInfo</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">ScsiStatus</span> <span class="o">==</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">check_for_unit_attention</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">cp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_SOFT_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * SCSI REPORT_LUNS is commonly unsupported on</span>
<span class="cm">				 * Smart Array.  Suppress noisy complaint.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REPORT_LUNS</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="cm">/* If ASC/ASCQ indicate Logical Unit</span>
<span class="cm">				 * Not Supported condition,</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x25</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ascq</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p &quot;</span>
						<span class="s">&quot;has check condition</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">NOT_READY</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* If Sense is Not Ready, Logical Unit</span>
<span class="cm">				 * Not ready, Manual Intervention</span>
<span class="cm">				 * required</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x04</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ascq</span> <span class="o">==</span> <span class="mh">0x03</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p &quot;</span>
						<span class="s">&quot;has check condition: unit &quot;</span>
						<span class="s">&quot;not ready, manual &quot;</span>
						<span class="s">&quot;intervention required</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">ABORTED_COMMAND</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Aborted command is retryable */</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p &quot;</span>
					<span class="s">&quot;has check condition: aborted command: &quot;</span>
					<span class="s">&quot;ASC: 0x%x, ASCQ: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">cp</span><span class="p">,</span> <span class="n">asc</span><span class="p">,</span> <span class="n">ascq</span><span class="p">);</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_SOFT_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Must be some other type of check condition */</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p has check condition: &quot;</span>
					<span class="s">&quot;unknown type: &quot;</span>
					<span class="s">&quot;Sense: 0x%x, ASC: 0x%x, ASCQ: 0x%x, &quot;</span>
					<span class="s">&quot;Returning result: 0x%x, &quot;</span>
					<span class="s">&quot;cmd=[%02x %02x %02x %02x %02x &quot;</span>
					<span class="s">&quot;%02x %02x %02x %02x %02x %02x &quot;</span>
					<span class="s">&quot;%02x %02x %02x %02x %02x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">cp</span><span class="p">,</span> <span class="n">sense_key</span><span class="p">,</span> <span class="n">asc</span><span class="p">,</span> <span class="n">ascq</span><span class="p">,</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">,</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">15</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>


		<span class="cm">/* Problem was not a check condition</span>
<span class="cm">		 * Pass it up to the upper layers...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">ScsiStatus</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p has status 0x%x &quot;</span>
				<span class="s">&quot;Sense: 0x%x, ASC: 0x%x, ASCQ: 0x%x, &quot;</span>
				<span class="s">&quot;Returning result: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cp</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">ScsiStatus</span><span class="p">,</span>
				<span class="n">sense_key</span><span class="p">,</span> <span class="n">asc</span><span class="p">,</span> <span class="n">ascq</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="cm">/* scsi status is zero??? How??? */</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p SCSI status was 0. &quot;</span>
				<span class="s">&quot;Returning no connection.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">),</span>

			<span class="cm">/* Ordinarily, this case should never happen,</span>
<span class="cm">			 * but there is a bug in some released firmware</span>
<span class="cm">			 * revisions that allows it to happen if, for</span>
<span class="cm">			 * example, a 4100 backplane loses power and</span>
<span class="cm">			 * the tape drive is in it.  We assume that</span>
<span class="cm">			 * it&#39;s a fatal error of some kind because we</span>
<span class="cm">			 * can&#39;t show that it wasn&#39;t. We will make it</span>
<span class="cm">			 * look like selection timeout since that is</span>
<span class="cm">			 * the most common reason for this to occur,</span>
<span class="cm">			 * and it&#39;s severe enough.</span>
<span class="cm">			 */</span>

			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CMD_DATA_UNDERRUN</span>: <span class="cm">/* let mid layer handle it. */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_DATA_OVERRUN</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p has&quot;</span>
			<span class="s">&quot; completed with data overrun &quot;</span>
			<span class="s">&quot;reported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_INVALID</span>: <span class="p">{</span>
		<span class="cm">/* print_bytes(cp, sizeof(*cp), 1, 0);</span>
<span class="cm">		print_cmd(cp); */</span>
		<span class="cm">/* We get CMD_INVALID if you address a non-existent device</span>
<span class="cm">		 * instead of a selection timeout (no response).  You will</span>
<span class="cm">		 * see this if you yank out a drive, then try to access it.</span>
<span class="cm">		 * This is kind of a shame because it means that any other</span>
<span class="cm">		 * CMD_INVALID (e.g. driver bug) will get interpreted as a</span>
<span class="cm">		 * missing target. */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_PROTOCOL_ERR</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p has &quot;</span>
			<span class="s">&quot;protocol error </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_HARDWARE_ERR</span>:
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p had  hardware error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_CONNECTION_LOST</span>:
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p had connection lost</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_ABORTED</span>:
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p was aborted with status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cp</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">ScsiStatus</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_ABORT_FAILED</span>:
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p reports abort failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_UNSOLICITED_ABORT</span>:
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_SOFT_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="cm">/* retry the command */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p aborted due to an unsolicited &quot;</span>
			<span class="s">&quot;abort</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_TIMEOUT</span>:
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_TIME_OUT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p timedout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_UNABORTABLE</span>:
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Command unabortable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cp %p returned unknown status %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cp</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">CommandStatus</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">cmd_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_pci_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sg_used</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">u64bit</span> <span class="n">addr64</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sg_used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr64</span><span class="p">.</span><span class="n">val32</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Addr</span><span class="p">.</span><span class="n">lower</span><span class="p">;</span>
		<span class="n">addr64</span><span class="p">.</span><span class="n">val32</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Addr</span><span class="p">.</span><span class="n">upper</span><span class="p">;</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="n">addr64</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Len</span><span class="p">,</span>
			<span class="n">data_direction</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_map_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">buflen</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">data_direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">addr64</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">data_direction</span> <span class="o">==</span> <span class="n">PCI_DMA_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGList</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGTotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">addr64</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="n">data_direction</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Addr</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span>
	  <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">addr64</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="mh">0x00000000FFFFFFFF</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Addr</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span>
	  <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">((</span><span class="n">addr64</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="mh">0x00000000FFFFFFFF</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Len</span> <span class="o">=</span> <span class="n">buflen</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGList</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="mi">1</span><span class="p">;</span>   <span class="cm">/* no. SGs contig in this cmd */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGTotal</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* total sgs in this cmd list */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hpsa_scsi_do_simple_cmd_core</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">waiting</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">;</span>
	<span class="n">enqueue_cmd_and_start_io</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_scsi_do_simple_cmd_core_if_no_lockup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* If controller lockup detected, fake a hardware error. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lockup_detected</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">CommandStatus</span> <span class="o">=</span> <span class="n">CMD_HARDWARE_ERR</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">hpsa_scsi_do_simple_cmd_core</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define MAX_DRIVER_CMD_RETRIES 25</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_scsi_do_simple_cmd_with_retry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">backoff_time</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">));</span>
		<span class="n">hpsa_scsi_do_simple_cmd_core</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="n">retry_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retry_count</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="n">backoff_time</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">backoff_time</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span>
				<span class="n">backoff_time</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">check_for_unit_attention</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">check_for_busy</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			<span class="n">retry_count</span> <span class="o">&lt;=</span> <span class="n">MAX_DRIVER_CMD_RETRIES</span><span class="p">);</span>
	<span class="n">hpsa_pci_unmap</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data_direction</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_scsi_interpret_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ErrorInfo</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">CommandStatus</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CMD_TARGET_STATUS</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;cmd %p has completed with errors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;cmd %p has SCSI Status = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span>
				<span class="n">ei</span><span class="o">-&gt;</span><span class="n">ScsiStatus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">ScsiStatus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;SCSI status is abnormally zero.  &quot;</span>
			<span class="s">&quot;(probably indicates selection timeout &quot;</span>
			<span class="s">&quot;reported incorrectly due to a known &quot;</span>
			<span class="s">&quot;firmware bug, circa July, 2001.)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_DATA_UNDERRUN</span>: <span class="cm">/* let mid layer handle it. */</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;UNDERRUN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_DATA_OVERRUN</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;cp %p has completed with data overrun</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_INVALID</span>: <span class="p">{</span>
		<span class="cm">/* controller unfortunately reports SCSI passthru&#39;s</span>
<span class="cm">		 * to non-existent targets as invalid commands.</span>
<span class="cm">		 */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;cp %p is reported invalid (probably means &quot;</span>
			<span class="s">&quot;target device no longer present)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="cm">/* print_bytes((unsigned char *) cp, sizeof(*cp), 1, 0);</span>
<span class="cm">		print_cmd(cp);  */</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_PROTOCOL_ERR</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;cp %p has protocol error </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_HARDWARE_ERR</span>:
		<span class="cm">/* cmd-&gt;result = DID_ERROR &lt;&lt; 16; */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;cp %p had hardware error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_CONNECTION_LOST</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;cp %p had connection lost</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_ABORTED</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;cp %p was aborted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_ABORT_FAILED</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;cp %p reports abort failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_UNSOLICITED_ABORT</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;cp %p aborted due to an unsolicited abort</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_TIMEOUT</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;cp %p timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_UNABORTABLE</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;Command unabortable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&quot;cp %p returned unknown status %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span>
				<span class="n">ei</span><span class="o">-&gt;</span><span class="n">CommandStatus</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_scsi_do_inquiry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scsi3addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bufsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">IO_OK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ErrorInfo</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">cmd_special_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>			<span class="cm">/* trouble... */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cmd_special_alloc returned NULL!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fill_cmd</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">HPSA_INQUIRY</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="n">TYPE_CMD</span><span class="p">);</span>
	<span class="n">hpsa_scsi_do_simple_cmd_with_retry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">CommandStatus</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">CommandStatus</span> <span class="o">!=</span> <span class="n">CMD_DATA_UNDERRUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpsa_scsi_interpret_error</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmd_special_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_send_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scsi3addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">IO_OK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ErrorInfo</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">cmd_special_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>			<span class="cm">/* trouble... */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cmd_special_alloc returned NULL!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fill_cmd</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">HPSA_DEVICE_RESET_MSG</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="n">TYPE_MSG</span><span class="p">);</span>
	<span class="n">hpsa_scsi_do_simple_cmd_core</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="cm">/* no unmap needed here because no data xfer. */</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">CommandStatus</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpsa_scsi_interpret_error</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmd_special_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_get_raid_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">raid_level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="o">*</span><span class="n">raid_level</span> <span class="o">=</span> <span class="n">RAID_UNKNOWN</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_scsi_do_inquiry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="mh">0xC1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">raid_level</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">raid_level</span> <span class="o">&gt;</span> <span class="n">RAID_UNKNOWN</span><span class="p">)</span>
		<span class="o">*</span><span class="n">raid_level</span> <span class="o">=</span> <span class="n">RAID_UNKNOWN</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the device id from inquiry page 0x83 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_get_device_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scsi3addr</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">device_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">buflen</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_scsi_do_inquiry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">device_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">buflen</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_scsi_do_report_luns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">logical</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ReportLUNdata</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">extended_response</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">IO_OK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">scsi3addr</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ErrorInfo</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">cmd_special_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>			<span class="cm">/* trouble... */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cmd_special_alloc returned NULL!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* address the controller */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scsi3addr</span><span class="p">));</span>
	<span class="n">fill_cmd</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">logical</span> <span class="o">?</span> <span class="n">HPSA_REPORT_LOG</span> <span class="o">:</span> <span class="n">HPSA_REPORT_PHYS</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
		<span class="n">buf</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="n">TYPE_CMD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extended_response</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">extended_response</span><span class="p">;</span>
	<span class="n">hpsa_scsi_do_simple_cmd_with_retry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">CommandStatus</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ei</span><span class="o">-&gt;</span><span class="n">CommandStatus</span> <span class="o">!=</span> <span class="n">CMD_DATA_UNDERRUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpsa_scsi_interpret_error</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmd_special_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hpsa_scsi_do_report_phys_luns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ReportLUNdata</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">bufsize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">extended_response</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hpsa_scsi_do_report_luns</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="n">extended_response</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hpsa_scsi_do_report_log_luns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ReportLUNdata</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hpsa_scsi_do_report_luns</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hpsa_set_bus_target_lun</span><span class="p">(</span><span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="p">;</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">lun</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_update_device_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">scsi3addr</span><span class="p">[],</span> <span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">this_device</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">is_OBDR_device</span><span class="p">)</span>
<span class="p">{</span>

<span class="cp">#define OBDR_SIG_OFFSET 43</span>
<span class="cp">#define OBDR_TAPE_SIG &quot;$DR-10&quot;</span>
<span class="cp">#define OBDR_SIG_LEN (sizeof(OBDR_TAPE_SIG) - 1)</span>
<span class="cp">#define OBDR_TAPE_INQ_SIZE (OBDR_SIG_OFFSET + OBDR_SIG_LEN)</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">inq_buff</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">obdr_sig</span><span class="p">;</span>

	<span class="n">inq_buff</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">OBDR_TAPE_INQ_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inq_buff</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail_out</span><span class="p">;</span>

	<span class="cm">/* Do an inquiry to the device to see what it is. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_scsi_do_inquiry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inq_buff</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">OBDR_TAPE_INQ_SIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Inquiry failed (msg printed already) */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;hpsa_update_device_info: inquiry failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">this_device</span><span class="o">-&gt;</span><span class="n">devtype</span> <span class="o">=</span> <span class="p">(</span><span class="n">inq_buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">this_device</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">this_device</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inq_buff</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">this_device</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">this_device</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inq_buff</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">this_device</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">this_device</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">this_device</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">));</span>
	<span class="n">hpsa_get_device_id</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="n">this_device</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">this_device</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this_device</span><span class="o">-&gt;</span><span class="n">devtype</span> <span class="o">==</span> <span class="n">TYPE_DISK</span> <span class="o">&amp;&amp;</span>
		<span class="n">is_logical_dev_addr_mode</span><span class="p">(</span><span class="n">scsi3addr</span><span class="p">))</span>
		<span class="n">hpsa_get_raid_level</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this_device</span><span class="o">-&gt;</span><span class="n">raid_level</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">this_device</span><span class="o">-&gt;</span><span class="n">raid_level</span> <span class="o">=</span> <span class="n">RAID_UNKNOWN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_OBDR_device</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* See if this is a One-Button-Disaster-Recovery device</span>
<span class="cm">		 * by looking for &quot;$DR-10&quot; at offset 43 in inquiry data.</span>
<span class="cm">		 */</span>
		<span class="n">obdr_sig</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inq_buff</span><span class="p">[</span><span class="n">OBDR_SIG_OFFSET</span><span class="p">];</span>
		<span class="o">*</span><span class="n">is_OBDR_device</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_device</span><span class="o">-&gt;</span><span class="n">devtype</span> <span class="o">==</span> <span class="n">TYPE_ROM</span> <span class="o">&amp;&amp;</span>
					<span class="n">strncmp</span><span class="p">(</span><span class="n">obdr_sig</span><span class="p">,</span> <span class="n">OBDR_TAPE_SIG</span><span class="p">,</span>
						<span class="n">OBDR_SIG_LEN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">inq_buff</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bail_out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">inq_buff</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ext_target_model</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;MSA2012&quot;</span><span class="p">,</span>
	<span class="s">&quot;MSA2024&quot;</span><span class="p">,</span>
	<span class="s">&quot;MSA2312&quot;</span><span class="p">,</span>
	<span class="s">&quot;MSA2324&quot;</span><span class="p">,</span>
	<span class="s">&quot;P2000 G3 SAS&quot;</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_ext_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ext_target_model</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">,</span> <span class="n">ext_target_model</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
			<span class="n">strlen</span><span class="p">(</span><span class="n">ext_target_model</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper function to assign bus, target, lun mapping of devices.</span>
<span class="cm"> * Puts non-external target logical volumes on bus 0, external target logical</span>
<span class="cm"> * volumes on bus 1, physical devices on bus 2. and the hba on bus 3.</span>
<span class="cm"> * Logical drive target and lun are assigned at this time, but</span>
<span class="cm"> * physical device lun and target assignment are deferred (assigned</span>
<span class="cm"> * in hpsa_find_target_lun, called by hpsa_scsi_add_entry.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">figure_bus_target_lun</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">lunaddrbytes</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">lunid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">lunaddrbytes</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_logical_dev_addr_mode</span><span class="p">(</span><span class="n">lunaddrbytes</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* physical device, target and lun filled in later */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_hba_lunid</span><span class="p">(</span><span class="n">lunaddrbytes</span><span class="p">))</span>
			<span class="n">hpsa_set_bus_target_lun</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lunid</span> <span class="o">&amp;</span> <span class="mh">0x3fff</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="cm">/* defer target, lun assignment for physical devices */</span>
			<span class="n">hpsa_set_bus_target_lun</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* It&#39;s a logical device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ext_target</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">device</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* external target way, put logicals on bus 1</span>
<span class="cm">		 * and match target/lun numbers box</span>
<span class="cm">		 * reports, other smart array, bus 0, target 0, match lunid</span>
<span class="cm">		 */</span>
		<span class="n">hpsa_set_bus_target_lun</span><span class="p">(</span><span class="n">device</span><span class="p">,</span>
			<span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">lunid</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3fff</span><span class="p">,</span> <span class="n">lunid</span> <span class="o">&amp;</span> <span class="mh">0x00ff</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hpsa_set_bus_target_lun</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lunid</span> <span class="o">&amp;</span> <span class="mh">0x3fff</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If there is no lun 0 on a target, linux won&#39;t find any devices.</span>
<span class="cm"> * For the external targets (arrays), we have to manually detect the enclosure</span>
<span class="cm"> * which is at lun zero, as CCISS_REPORT_PHYSICAL_LUNS doesn&#39;t report</span>
<span class="cm"> * it for some reason.  *tmpdevice is the target we&#39;re adding,</span>
<span class="cm"> * this_device is a pointer into the current element of currentsd[]</span>
<span class="cm"> * that we&#39;re building up in update_scsi_devices(), below.</span>
<span class="cm"> * lunzerobits is a bitmap that tracks which targets already have a</span>
<span class="cm"> * lun 0 assigned.</span>
<span class="cm"> * Returns 1 if an enclosure was added, 0 if not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_ext_target_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">tmpdevice</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">this_device</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">lunaddrbytes</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lunzerobits</span><span class="p">[],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n_ext_target_devs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">scsi3addr</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">tmpdevice</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">lunzerobits</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* There is already a lun 0 on this target. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_logical_dev_addr_mode</span><span class="p">(</span><span class="n">lunaddrbytes</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* It&#39;s the logical targets that may lack lun 0. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_ext_target</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">tmpdevice</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Only external target devices have this problem. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmpdevice</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* if lun is 0, then we have a lun 0. */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">scsi3addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmpdevice</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_hba_lunid</span><span class="p">(</span><span class="n">scsi3addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Don&#39;t add the RAID controller here. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_scsi_rev_5</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* p1210m doesn&#39;t need to do this. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">n_ext_target_devs</span> <span class="o">&gt;=</span> <span class="n">MAX_EXT_TARGETS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Maximum number of external &quot;</span>
			<span class="s">&quot;target devices exceeded.  Check your hardware &quot;</span>
			<span class="s">&quot;configuration.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_update_device_info</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="n">this_device</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">n_ext_target_devs</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="n">hpsa_set_bus_target_lun</span><span class="p">(</span><span class="n">this_device</span><span class="p">,</span>
				<span class="n">tmpdevice</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">tmpdevice</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">tmpdevice</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">lunzerobits</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do CISS_REPORT_PHYS and CISS_REPORT_LOG.  Data is returned in physdev,</span>
<span class="cm"> * logdev.  The number of luns in physdev and logdev are returned in</span>
<span class="cm"> * *nphysicals and *nlogicals, respectively.</span>
<span class="cm"> * Returns 0 on success, -1 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_gather_lun_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">reportlunsize</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ReportLUNdata</span> <span class="o">*</span><span class="n">physdev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">nphysicals</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ReportLUNdata</span> <span class="o">*</span><span class="n">logdev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">nlogicals</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_scsi_do_report_phys_luns</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">physdev</span><span class="p">,</span> <span class="n">reportlunsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;report physical LUNs failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">nphysicals</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">physdev</span><span class="o">-&gt;</span><span class="n">LUNListLength</span><span class="p">))</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">nphysicals</span> <span class="o">&gt;</span> <span class="n">HPSA_MAX_PHYS_LUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;maximum physical LUNs (%d) exceeded.&quot;</span>
			<span class="s">&quot;  %d LUNs ignored.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HPSA_MAX_PHYS_LUN</span><span class="p">,</span>
			<span class="o">*</span><span class="n">nphysicals</span> <span class="o">-</span> <span class="n">HPSA_MAX_PHYS_LUN</span><span class="p">);</span>
		<span class="o">*</span><span class="n">nphysicals</span> <span class="o">=</span> <span class="n">HPSA_MAX_PHYS_LUN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_scsi_do_report_log_luns</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">logdev</span><span class="p">,</span> <span class="n">reportlunsize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;report logical LUNs failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">nlogicals</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span> <span class="n">logdev</span><span class="o">-&gt;</span><span class="n">LUNListLength</span><span class="p">))</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="cm">/* Reject Logicals in excess of our max capability. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">nlogicals</span> <span class="o">&gt;</span> <span class="n">HPSA_MAX_LUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;maximum logical LUNs (%d) exceeded.  &quot;</span>
			<span class="s">&quot;%d LUNs ignored.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HPSA_MAX_LUN</span><span class="p">,</span>
			<span class="o">*</span><span class="n">nlogicals</span> <span class="o">-</span> <span class="n">HPSA_MAX_LUN</span><span class="p">);</span>
			<span class="o">*</span><span class="n">nlogicals</span> <span class="o">=</span> <span class="n">HPSA_MAX_LUN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">nlogicals</span> <span class="o">+</span> <span class="o">*</span><span class="n">nphysicals</span> <span class="o">&gt;</span> <span class="n">HPSA_MAX_PHYS_LUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;maximum logical + physical LUNs (%d) exceeded. &quot;</span>
			<span class="s">&quot;%d LUNs ignored.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HPSA_MAX_PHYS_LUN</span><span class="p">,</span>
			<span class="o">*</span><span class="n">nphysicals</span> <span class="o">+</span> <span class="o">*</span><span class="n">nlogicals</span> <span class="o">-</span> <span class="n">HPSA_MAX_PHYS_LUN</span><span class="p">);</span>
		<span class="o">*</span><span class="n">nlogicals</span> <span class="o">=</span> <span class="n">HPSA_MAX_PHYS_LUN</span> <span class="o">-</span> <span class="o">*</span><span class="n">nphysicals</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u8</span> <span class="o">*</span><span class="nf">figure_lunaddrbytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">raid_ctlr_position</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">nphysicals</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nlogicals</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ReportLUNdata</span> <span class="o">*</span><span class="n">physdev_list</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ReportLUNdata</span> <span class="o">*</span><span class="n">logdev_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Helper function, figure out where the LUN ID info is coming from</span>
<span class="cm">	 * given index i, lists of physical and logical devices, where in</span>
<span class="cm">	 * the list the raid controller is supposed to appear (first or last)</span>
<span class="cm">	 */</span>

	<span class="kt">int</span> <span class="n">logicals_start</span> <span class="o">=</span> <span class="n">nphysicals</span> <span class="o">+</span> <span class="p">(</span><span class="n">raid_ctlr_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">last_device</span> <span class="o">=</span> <span class="n">nphysicals</span> <span class="o">+</span> <span class="n">nlogicals</span> <span class="o">+</span> <span class="p">(</span><span class="n">raid_ctlr_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">raid_ctlr_position</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RAID_CTLR_LUNID</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">logicals_start</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">physdev_list</span><span class="o">-&gt;</span><span class="n">LUN</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">raid_ctlr_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)][</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">last_device</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">logdev_list</span><span class="o">-&gt;</span><span class="n">LUN</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">nphysicals</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">raid_ctlr_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)][</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_update_scsi_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hostno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* the idea here is we could get notified</span>
<span class="cm">	 * that some devices have changed, so we do a report</span>
<span class="cm">	 * physical luns and report logical luns cmd, and adjust</span>
<span class="cm">	 * our list of devices accordingly.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The scsi3addr&#39;s of devices won&#39;t change so long as the</span>
<span class="cm">	 * adapter is not reset.  That means we can rescan and</span>
<span class="cm">	 * tell which devices we already know about, vs. new</span>
<span class="cm">	 * devices, vs.  disappearing devices.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ReportLUNdata</span> <span class="o">*</span><span class="n">physdev_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ReportLUNdata</span> <span class="o">*</span><span class="n">logdev_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nphysicals</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nlogicals</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ndev_allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">**</span><span class="n">currentsd</span><span class="p">,</span> <span class="o">*</span><span class="n">this_device</span><span class="p">,</span> <span class="o">*</span><span class="n">tmpdevice</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ncurrent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reportlunsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">physdev_list</span><span class="p">)</span> <span class="o">+</span> <span class="n">HPSA_MAX_PHYS_LUN</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n_ext_target_devs</span><span class="p">,</span> <span class="n">ndevs_to_allocate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">raid_ctlr_position</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">lunzerobits</span><span class="p">,</span> <span class="n">MAX_EXT_TARGETS</span><span class="p">);</span>

	<span class="n">currentsd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">currentsd</span><span class="p">)</span> <span class="o">*</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">physdev_list</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">reportlunsize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">logdev_list</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">reportlunsize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">tmpdevice</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tmpdevice</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">currentsd</span> <span class="o">||</span> <span class="o">!</span><span class="n">physdev_list</span> <span class="o">||</span> <span class="o">!</span><span class="n">logdev_list</span> <span class="o">||</span> <span class="o">!</span><span class="n">tmpdevice</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">lunzerobits</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lunzerobits</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_gather_lun_info</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">reportlunsize</span><span class="p">,</span> <span class="n">physdev_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nphysicals</span><span class="p">,</span>
			<span class="n">logdev_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nlogicals</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* We might see up to the maximum number of logical and physical disks</span>
<span class="cm">	 * plus external target devices, and a device for the local RAID</span>
<span class="cm">	 * controller.</span>
<span class="cm">	 */</span>
	<span class="n">ndevs_to_allocate</span> <span class="o">=</span> <span class="n">nphysicals</span> <span class="o">+</span> <span class="n">nlogicals</span> <span class="o">+</span> <span class="n">MAX_EXT_TARGETS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Allocate the per device structures */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndevs_to_allocate</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;maximum devices (%d) exceeded.&quot;</span>
				<span class="s">&quot;  %d devices ignored.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">,</span>
				<span class="n">ndevs_to_allocate</span> <span class="o">-</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">currentsd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">currentsd</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">currentsd</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;out of memory at %s:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ndev_allocated</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_scsi_rev_5</span><span class="p">(</span><span class="n">h</span><span class="p">)))</span>
		<span class="n">raid_ctlr_position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">raid_ctlr_position</span> <span class="o">=</span> <span class="n">nphysicals</span> <span class="o">+</span> <span class="n">nlogicals</span><span class="p">;</span>

	<span class="cm">/* adjust our table of devices */</span>
	<span class="n">n_ext_target_devs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nphysicals</span> <span class="o">+</span> <span class="n">nlogicals</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">lunaddrbytes</span><span class="p">,</span> <span class="n">is_OBDR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Figure out where the LUN ID info is coming from */</span>
		<span class="n">lunaddrbytes</span> <span class="o">=</span> <span class="n">figure_lunaddrbytes</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">raid_ctlr_position</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span> <span class="n">nphysicals</span><span class="p">,</span> <span class="n">nlogicals</span><span class="p">,</span> <span class="n">physdev_list</span><span class="p">,</span> <span class="n">logdev_list</span><span class="p">);</span>
		<span class="cm">/* skip masked physical devices. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lunaddrbytes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xC0</span> <span class="o">&amp;&amp;</span>
			<span class="n">i</span> <span class="o">&lt;</span> <span class="n">nphysicals</span> <span class="o">+</span> <span class="p">(</span><span class="n">raid_ctlr_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Get device type, vendor, model, device id */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_update_device_info</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">lunaddrbytes</span><span class="p">,</span> <span class="n">tmpdevice</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">is_OBDR</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span> <span class="cm">/* skip it if we can&#39;t talk to it. */</span>
		<span class="n">figure_bus_target_lun</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">lunaddrbytes</span><span class="p">,</span> <span class="n">tmpdevice</span><span class="p">);</span>
		<span class="n">this_device</span> <span class="o">=</span> <span class="n">currentsd</span><span class="p">[</span><span class="n">ncurrent</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * For external target devices, we have to insert a LUN 0 which</span>
<span class="cm">		 * doesn&#39;t show up in CCISS_REPORT_PHYSICAL data, but there</span>
<span class="cm">		 * is nonetheless an enclosure device there.  We have to</span>
<span class="cm">		 * present that otherwise linux won&#39;t find anything if</span>
<span class="cm">		 * there is no lun 0.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">add_ext_target_dev</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">tmpdevice</span><span class="p">,</span> <span class="n">this_device</span><span class="p">,</span>
				<span class="n">lunaddrbytes</span><span class="p">,</span> <span class="n">lunzerobits</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">n_ext_target_devs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ncurrent</span><span class="o">++</span><span class="p">;</span>
			<span class="n">this_device</span> <span class="o">=</span> <span class="n">currentsd</span><span class="p">[</span><span class="n">ncurrent</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">this_device</span> <span class="o">=</span> <span class="o">*</span><span class="n">tmpdevice</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">this_device</span><span class="o">-&gt;</span><span class="n">devtype</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TYPE_ROM</span>:
			<span class="cm">/* We don&#39;t *really* support actual CD-ROM devices,</span>
<span class="cm">			 * just &quot;One Button Disaster Recovery&quot; tape drive</span>
<span class="cm">			 * which temporarily pretends to be a CD-ROM drive.</span>
<span class="cm">			 * So we check that the device is really an OBDR tape</span>
<span class="cm">			 * device by checking for &quot;$DR-10&quot; in bytes 43-48 of</span>
<span class="cm">			 * the inquiry data.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_OBDR</span><span class="p">)</span>
				<span class="n">ncurrent</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TYPE_DISK</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nphysicals</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">ncurrent</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TYPE_TAPE</span>:
		<span class="k">case</span> <span class="n">TYPE_MEDIUM_CHANGER</span>:
			<span class="n">ncurrent</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TYPE_RAID</span>:
			<span class="cm">/* Only present the Smartarray HBA as a RAID controller.</span>
<span class="cm">			 * If it&#39;s a RAID controller other than the HBA itself</span>
<span class="cm">			 * (an external RAID controller, MSA500 or similar)</span>
<span class="cm">			 * don&#39;t present it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_hba_lunid</span><span class="p">(</span><span class="n">lunaddrbytes</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">ncurrent</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ncurrent</span> <span class="o">&gt;=</span> <span class="n">HPSA_MAX_DEVICES</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">adjust_hpsa_scsi_table</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">hostno</span><span class="p">,</span> <span class="n">currentsd</span><span class="p">,</span> <span class="n">ncurrent</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tmpdevice</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndev_allocated</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">currentsd</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">currentsd</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">physdev_list</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">logdev_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* hpsa_scatter_gather takes a struct scsi_cmnd, (cmd), and does the pci</span>
<span class="cm"> * dma mapping  and fills in the scatter gather entries of the</span>
<span class="cm"> * hpsa command, cp.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_scatter_gather</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">addr64</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_sg</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">sg_index</span><span class="p">,</span> <span class="n">chained</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">SGDescriptor</span> <span class="o">*</span><span class="n">curr_sg</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">maxsgentries</span><span class="p">);</span>

	<span class="n">use_sg</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_sg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">use_sg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">use_sg</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">sglist_finished</span><span class="p">;</span>

	<span class="n">curr_sg</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">;</span>
	<span class="n">chained</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sg_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_cmd_sg_entries</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
			<span class="n">use_sg</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_cmd_sg_entries</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chained</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">curr_sg</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_sg_list</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmdindex</span><span class="p">];</span>
			<span class="n">sg_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">addr64</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">len</span>  <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">curr_sg</span><span class="o">-&gt;</span><span class="n">Addr</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">addr64</span> <span class="o">&amp;</span> <span class="mh">0x0FFFFFFFFULL</span><span class="p">);</span>
		<span class="n">curr_sg</span><span class="o">-&gt;</span><span class="n">Addr</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">((</span><span class="n">addr64</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0FFFFFFFFULL</span><span class="p">);</span>
		<span class="n">curr_sg</span><span class="o">-&gt;</span><span class="n">Len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">curr_sg</span><span class="o">-&gt;</span><span class="n">Ext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* we are not chaining */</span>
		<span class="n">curr_sg</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_sg</span> <span class="o">+</span> <span class="n">chained</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">maxSG</span><span class="p">)</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">maxSG</span> <span class="o">=</span> <span class="n">use_sg</span> <span class="o">+</span> <span class="n">chained</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chained</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGList</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_cmd_sg_entries</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGTotal</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="n">use_sg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">hpsa_map_sg_chain_block</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">sglist_finished:</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGList</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">use_sg</span><span class="p">;</span>   <span class="cm">/* no. SGs contig in this cmd */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGTotal</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">use_sg</span><span class="p">;</span> <span class="cm">/* total sgs in this cmd list */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_scsi_queue_command_lck</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">scsi3addr</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Get the ptr to our adapter structure out of cmd-&gt;host. */</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">sdev_to_hba</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scsi3addr</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lockup_detected</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">cmd_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>			<span class="cm">/* trouble... */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cmd_alloc returned NULL!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fill in the command list header */</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>    <span class="cm">/* save this for use by completion code */</span>

	<span class="cm">/* save c in case we have to abort it  */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">c</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">CMD_SCSI</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">ReplyQueue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* unused in simple mode */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">LUN</span><span class="p">.</span><span class="n">LunAddrBytes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">scsi3addr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmdindex</span> <span class="o">&lt;&lt;</span> <span class="n">DIRECT_LOOKUP_SHIFT</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span> <span class="o">|=</span> <span class="n">DIRECT_LOOKUP_BIT</span><span class="p">;</span>

	<span class="cm">/* Fill in the request block... */</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">));</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDBLen</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">TYPE_CMD</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Attribute</span> <span class="o">=</span> <span class="n">ATTR_SIMPLE</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DMA_TO_DEVICE</span>:
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">=</span> <span class="n">XFER_WRITE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_FROM_DEVICE</span>:
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">=</span> <span class="n">XFER_READ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_NONE</span>:
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">=</span> <span class="n">XFER_NONE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_BIDIRECTIONAL</span>:
		<span class="cm">/* This can happen if a buggy application does a scsi passthru</span>
<span class="cm">		 * and sets both inlen and outlen to non-zero. ( see</span>
<span class="cm">		 * ../scsi/scsi_ioctl.c:scsi_ioctl_send_command() )</span>
<span class="cm">		 */</span>

		<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">=</span> <span class="n">XFER_RSVD</span><span class="p">;</span>
		<span class="cm">/* This is technically wrong, and hpsa controllers should</span>
<span class="cm">		 * reject it with CMD_INVALID, which is the most correct</span>
<span class="cm">		 * response, but non-fibre backends appear to let it</span>
<span class="cm">		 * slide by, and give the same results as if this field</span>
<span class="cm">		 * were set correctly.  Either way is acceptable for</span>
<span class="cm">		 * our purposes here.</span>
<span class="cm">		 */</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unknown data direction: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_scatter_gather</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Fill SG list */</span>
		<span class="n">cmd_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">enqueue_cmd_and_start_io</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="cm">/* the cmd&#39;ll come back via intr handler in complete_scsi_command()  */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">hpsa_scsi_queue_command</span><span class="p">)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hpsa_scan_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">sh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">shost_to_hba</span><span class="p">(</span><span class="n">sh</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* wait until any scan already in progress is finished. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_finished</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_wait_queue</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_finished</span><span class="p">);</span>
		<span class="cm">/* Note: We don&#39;t need to worry about a race between this</span>
<span class="cm">		 * thread and driver unload because the midlayer will</span>
<span class="cm">		 * have incremented the reference count, so unload won&#39;t</span>
<span class="cm">		 * happen if we&#39;re in here.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_finished</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* mark scan as in progress */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">hpsa_update_scsi_devices</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_finished</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* mark scan as finished. */</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_wait_queue</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_scan_finished</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">sh</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elapsed_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">shost_to_hba</span><span class="p">(</span><span class="n">sh</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">finished</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">finished</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_finished</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">finished</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_change_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">qdepth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">sdev_to_hba</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">!=</span> <span class="n">SCSI_QDEPTH_DEFAULT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qdepth</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">qdepth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qdepth</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span><span class="p">)</span>
			<span class="n">qdepth</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span><span class="p">;</span>
	<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">scsi_get_tag_type</span><span class="p">(</span><span class="n">sdev</span><span class="p">),</span> <span class="n">qdepth</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_unregister_scsi</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* we are being forcibly unloaded, and may not refuse. */</span>
	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_host</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_register_scsi</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">sh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">sh</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpsa_driver_template</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">sh</span><span class="o">-&gt;</span><span class="n">io_port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sh</span><span class="o">-&gt;</span><span class="n">n_io_port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sh</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">sh</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">sh</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">=</span> <span class="n">MAX_COMMAND_SIZE</span><span class="p">;</span>
	<span class="n">sh</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="n">HPSA_MAX_LUN</span><span class="p">;</span>
	<span class="n">sh</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="n">HPSA_MAX_LUN</span><span class="p">;</span>
	<span class="n">sh</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span><span class="p">;</span>
	<span class="n">sh</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span><span class="p">;</span>
	<span class="n">sh</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">maxsgentries</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_host</span> <span class="o">=</span> <span class="n">sh</span><span class="p">;</span>
	<span class="n">sh</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">h</span><span class="p">;</span>
	<span class="n">sh</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">];</span>
	<span class="n">sh</span><span class="o">-&gt;</span><span class="n">unique_id</span> <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_add_host</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_host_put</span><span class="p">;</span>
	<span class="n">scsi_scan_host</span><span class="p">(</span><span class="n">sh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail_host_put:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: scsi_add_host&quot;</span>
		<span class="s">&quot; failed for controller %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ctlr</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">sh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
 <span class="nl">fail:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: scsi_host_alloc&quot;</span>
		<span class="s">&quot; failed for controller %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ctlr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_for_device_to_become_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lunaddr</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">waittime</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* seconds */</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">cmd_special_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;out of memory in &quot;</span>
			<span class="s">&quot;wait_for_device_to_become_ready.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IO_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Send test unit ready until device ready, or give up. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">HPSA_TUR_RETRY_LIMIT</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Wait for a bit.  do this first, because if we send</span>
<span class="cm">		 * the TUR right away, the reset will just abort it.</span>
<span class="cm">		 */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="n">waittime</span><span class="p">);</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Increase wait time with each try, up to a point. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waittime</span> <span class="o">&lt;</span> <span class="n">HPSA_MAX_WAIT_INTERVAL_SECS</span><span class="p">)</span>
			<span class="n">waittime</span> <span class="o">=</span> <span class="n">waittime</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

		<span class="cm">/* Send the Test Unit Ready */</span>
		<span class="n">fill_cmd</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">TEST_UNIT_READY</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lunaddr</span><span class="p">,</span> <span class="n">TYPE_CMD</span><span class="p">);</span>
		<span class="n">hpsa_scsi_do_simple_cmd_core</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="cm">/* no unmap needed here because no data xfer. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">CommandStatus</span> <span class="o">==</span> <span class="n">CMD_SUCCESS</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">CommandStatus</span> <span class="o">==</span> <span class="n">CMD_TARGET_STATUS</span> <span class="o">&amp;&amp;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">ScsiStatus</span> <span class="o">==</span> <span class="n">SAM_STAT_CHECK_CONDITION</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">SenseInfo</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">NO_SENSE</span> <span class="o">||</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">SenseInfo</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">UNIT_ATTENTION</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;waiting %d secs &quot;</span>
			<span class="s">&quot;for device to become ready.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">waittime</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* device not ready. */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;giving up on device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device is ready.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">cmd_special_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Need at least one of these error handlers to keep ../scsi/hosts.c from</span>
<span class="cm"> * complaining.  Doing a host- or bus-reset can&#39;t do anything good here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_eh_device_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsicmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* find the controller to which the command to be aborted was sent */</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">sdev_to_hba</span><span class="p">(</span><span class="n">scsicmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="cm">/* paranoia */</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">scsicmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hpsa_eh_device_reset_handler: &quot;</span>
			<span class="s">&quot;device lookup failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;resetting device %d:%d:%d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="cm">/* send a reset to the SCSI LUN which the command was sent to */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_send_reset</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wait_for_device_to_become_ready</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>

	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;resetting device failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swizzle_abort_tag</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">original_tag</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">original_tag</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_tag</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">tag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_tag</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">tag</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_tag</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">tag</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_tag</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">tag</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_tag</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
	<span class="n">tag</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_tag</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">tag</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_tag</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">tag</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_tag</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_send_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scsi3addr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">abort</span><span class="p">,</span> <span class="kt">int</span> <span class="n">swizzle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">IO_OK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ErrorInfo</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">cmd_special_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* trouble... */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cmd_special_alloc returned NULL!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fill_cmd</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">HPSA_ABORT_MSG</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">abort</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="n">TYPE_MSG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swizzle</span><span class="p">)</span>
		<span class="n">swizzle_abort_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
	<span class="n">hpsa_scsi_do_simple_cmd_core</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Tag:0x%08x:%08x: do_simple_cmd_core completed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">abort</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">upper</span><span class="p">,</span> <span class="n">abort</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span><span class="p">);</span>
	<span class="cm">/* no unmap needed here because no data xfer. */</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">CommandStatus</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CMD_SUCCESS</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_UNABORTABLE</span>: <span class="cm">/* Very common, don&#39;t make noise. */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Tag:0x%08x:%08x: interpreting error.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">abort</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">upper</span><span class="p">,</span>
			<span class="n">abort</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span><span class="p">);</span>
		<span class="n">hpsa_scsi_interpret_error</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmd_special_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Tag:0x%08x:%08x: Finished.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">abort</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">upper</span><span class="p">,</span> <span class="n">abort</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * hpsa_find_cmd_in_queue</span>
<span class="cm"> *</span>
<span class="cm"> * Used to determine whether a command (find) is still present</span>
<span class="cm"> * in queue_head.   Optionally excludes the last element of queue_head.</span>
<span class="cm"> *</span>
<span class="cm"> * This is used to avoid unnecessary aborts.  Commands in h-&gt;reqQ have</span>
<span class="cm"> * not yet been submitted, and so can be aborted by the driver without</span>
<span class="cm"> * sending an abort to the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns pointer to command if found in queue, NULL otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="nf">hpsa_find_cmd_in_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">find</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">queue_head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* ptr into cmpQ */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">find</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">queue_head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="cm">/* e.g.: passthru ioctl */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span> <span class="o">==</span> <span class="n">find</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="nf">hpsa_find_cmd_in_queue_by_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
					<span class="n">u8</span> <span class="o">*</span><span class="n">tag</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">queue_head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">queue_head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Some Smart Arrays need the abort tag swizzled, and some don&#39;t.  It&#39;s hard to</span>
<span class="cm"> * tell which kind we&#39;re dealing with, so we send the abort both ways.  There</span>
<span class="cm"> * shouldn&#39;t be any collisions between swizzled and unswizzled tags due to the</span>
<span class="cm"> * way we construct our tags but we check anyway in case the assumptions which</span>
<span class="cm"> * make this true someday become false.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_send_abort_both_ways</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">abort</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">swizzled_tag</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rc2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* we do not expect to find the swizzled tag in our queue, but</span>
<span class="cm">	 * check anyway just to be sure the assumptions which make this</span>
<span class="cm">	 * the case haven&#39;t become wrong.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">swizzled_tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">abort</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">swizzle_abort_tag</span><span class="p">(</span><span class="n">swizzled_tag</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">hpsa_find_cmd_in_queue_by_tag</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">swizzled_tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmpQ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unexpectedly found byte-swapped tag in completion queue.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">hpsa_send_abort</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="n">abort</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_send_abort</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="n">abort</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* if the command is still in our queue, we can&#39;t conclude that it was</span>
<span class="cm">	 * aborted (it might have just completed normally) but in any case</span>
<span class="cm">	 * we don&#39;t need to try to abort it another way.</span>
<span class="cm">	 */</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">hpsa_find_cmd_in_queue</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">abort</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmpQ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span>
		<span class="n">rc2</span> <span class="o">=</span> <span class="n">hpsa_send_abort</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="n">abort</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">rc2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Send an abort for the specified command.</span>
<span class="cm"> *	If the device and controller support it,</span>
<span class="cm"> *		send a task abort request.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_eh_abort_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hpsa_scsi_dev_t</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">abort</span><span class="p">;</span> <span class="cm">/* pointer to command to be aborted */</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">found</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">as</span><span class="p">;</span>	<span class="cm">/* ptr to scsi cmd inside aborted command. */</span>
	<span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>		<span class="cm">/* For debug messaging. */</span>
	<span class="kt">int</span> <span class="n">ml</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Find the controller of the command to be aborted */</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">sdev_to_hba</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="n">h</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="s">&quot;ABORT REQUEST FAILED, Controller lookup failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>

	<span class="cm">/* Check that controller supports some kind of task abort */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">HPSATMF_PHYS_TASK_ABORT</span> <span class="o">&amp;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">TMFSupportFlags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">HPSATMF_LOG_TASK_ABORT</span> <span class="o">&amp;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">TMFSupportFlags</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
	<span class="n">ml</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="o">+</span><span class="n">ml</span><span class="p">,</span> <span class="s">&quot;ABORT REQUEST on C%d:B%d:T%d:L%d &quot;</span><span class="p">,</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="cm">/* Find the device of the command to be aborted */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s FAILED, Device lookup failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">msg</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get SCSI command to be aborted */</span>
	<span class="n">abort</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="p">)</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">abort</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s FAILED, Command to abort is NULL.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">msg</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ml</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="o">+</span><span class="n">ml</span><span class="p">,</span> <span class="s">&quot;Tag:0x%08x:%08x &quot;</span><span class="p">,</span>
		<span class="n">abort</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">upper</span><span class="p">,</span> <span class="n">abort</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span><span class="p">);</span>
	<span class="n">as</span>  <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span> <span class="n">abort</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">as</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">ml</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="o">+</span><span class="n">ml</span><span class="p">,</span> <span class="s">&quot;Command:0x%x SN:0x%lx &quot;</span><span class="p">,</span>
			<span class="n">as</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">serial_number</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Abort request on C%d:B%d:T%d:L%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="cm">/* Search reqQ to See if command is queued but not submitted,</span>
<span class="cm">	 * if so, complete the command with aborted status and remove</span>
<span class="cm">	 * it from the reqQ.</span>
<span class="cm">	 */</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">hpsa_find_cmd_in_queue</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">reqQ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">found</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">CommandStatus</span> <span class="o">=</span> <span class="n">CMD_ABORTED</span><span class="p">;</span>
		<span class="n">finish_cmd</span><span class="p">(</span><span class="n">found</span><span class="p">);</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s Request SUCCEEDED (driver queue).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">msg</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* not in reqQ, if also not in cmpQ, must have already completed */</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">hpsa_find_cmd_in_queue</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmpQ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>  <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s Request FAILED (not known to driver).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">msg</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Command is in flight, or possibly already completed</span>
<span class="cm">	 * by the firmware (but not to the scsi mid layer) but we can&#39;t</span>
<span class="cm">	 * distinguish which.  Send the abort down.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_send_abort_both_ways</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="n">abort</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s Request FAILED.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;FAILED abort on device C%d:B%d:T%d:L%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s REQUEST SUCCEEDED.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="cm">/* If the abort(s) above completed and actually aborted the</span>
<span class="cm">	 * command, then the command to be aborted should already be</span>
<span class="cm">	 * completed.  If not, wait around a bit more to see if they</span>
<span class="cm">	 * manage to complete normally.</span>
<span class="cm">	 */</span>
<span class="cp">#define ABORT_COMPLETE_WAIT_SECS 30</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ABORT_COMPLETE_WAIT_SECS</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">found</span> <span class="o">=</span> <span class="n">hpsa_find_cmd_in_queue</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmpQ</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s FAILED. Aborted command has not completed after %d seconds.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">msg</span><span class="p">,</span> <span class="n">ABORT_COMPLETE_WAIT_SECS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * For operations that cannot sleep, a command block is allocated at init,</span>
<span class="cm"> * and managed by cmd_alloc() and cmd_free() using a simple bitmap to track</span>
<span class="cm"> * which ones are free or in use.  Lock must be held when calling this.</span>
<span class="cm"> * cmd_free() is the complement.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="nf">cmd_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">u64bit</span> <span class="n">temp64</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">cmd_dma_handle</span><span class="p">,</span> <span class="n">err_dma_handle</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool_bits</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span>
		 <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
		  <span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool_bits</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_allocs</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">));</span>
	<span class="n">cmd_dma_handle</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool_dhandle</span>
	    <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">errinfo_pool</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">));</span>
	<span class="n">err_dma_handle</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">errinfo_pool_dhandle</span>
	    <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmdindex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">busaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">cmd_dma_handle</span><span class="p">;</span>
	<span class="n">temp64</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">err_dma_handle</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ErrDesc</span><span class="p">.</span><span class="n">Addr</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">temp64</span><span class="p">.</span><span class="n">val32</span><span class="p">.</span><span class="n">lower</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ErrDesc</span><span class="p">.</span><span class="n">Addr</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">temp64</span><span class="p">.</span><span class="n">val32</span><span class="p">.</span><span class="n">upper</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ErrDesc</span><span class="p">.</span><span class="n">Len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* For operations that can wait for kmalloc to possibly sleep,</span>
<span class="cm"> * this routine can be called. Lock need not be held to call</span>
<span class="cm"> * cmd_special_alloc. cmd_special_free() is the complement.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="nf">cmd_special_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">u64bit</span> <span class="n">temp64</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">cmd_dma_handle</span><span class="p">,</span> <span class="n">err_dma_handle</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cmd_dma_handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">));</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmdindex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">),</span>
		    <span class="o">&amp;</span><span class="n">err_dma_handle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">),</span> <span class="n">c</span><span class="p">,</span> <span class="n">cmd_dma_handle</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">));</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">busaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">cmd_dma_handle</span><span class="p">;</span>
	<span class="n">temp64</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">err_dma_handle</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ErrDesc</span><span class="p">.</span><span class="n">Addr</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">temp64</span><span class="p">.</span><span class="n">val32</span><span class="p">.</span><span class="n">lower</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ErrDesc</span><span class="p">.</span><span class="n">Addr</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">temp64</span><span class="p">.</span><span class="n">val32</span><span class="p">.</span><span class="n">upper</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ErrDesc</span><span class="p">.</span><span class="n">Len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cmd_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
		  <span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool_bits</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">));</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_frees</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cmd_special_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">u64bit</span> <span class="n">temp64</span><span class="p">;</span>

	<span class="n">temp64</span><span class="p">.</span><span class="n">val32</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ErrDesc</span><span class="p">.</span><span class="n">Addr</span><span class="p">.</span><span class="n">lower</span><span class="p">;</span>
	<span class="n">temp64</span><span class="p">.</span><span class="n">val32</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ErrDesc</span><span class="p">.</span><span class="n">Addr</span><span class="p">.</span><span class="n">upper</span><span class="p">;</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">),</span>
			    <span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">,</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="n">temp64</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">),</span>
			    <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">busaddr</span> <span class="o">&amp;</span> <span class="n">DIRECT_LOOKUP_MASK</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_ioctl32_passthru</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IOCTL32_Command_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg32</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">IOCTL32_Command_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">IOCTL_Command_struct</span> <span class="n">arg64</span><span class="p">;</span>
	<span class="n">IOCTL_Command_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arg64</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cp</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg64</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arg64</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg64</span><span class="p">.</span><span class="n">LUN_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">LUN_info</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="n">arg64</span><span class="p">.</span><span class="n">LUN_info</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg64</span><span class="p">.</span><span class="n">Request</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="n">arg64</span><span class="p">.</span><span class="n">Request</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg64</span><span class="p">.</span><span class="n">error_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">error_info</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="n">arg64</span><span class="p">.</span><span class="n">error_info</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">arg64</span><span class="p">.</span><span class="n">buf_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">arg64</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arg64</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">hpsa_ioctl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CCISS_PASSTHRU</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">error_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">error_info</span><span class="p">,</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">error_info</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_ioctl32_big_passthru</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BIG_IOCTL32_Command_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg32</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">BIG_IOCTL32_Command_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">BIG_IOCTL_Command_struct</span> <span class="n">arg64</span><span class="p">;</span>
	<span class="n">BIG_IOCTL_Command_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span>
	    <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arg64</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cp</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg64</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arg64</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg64</span><span class="p">.</span><span class="n">LUN_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">LUN_info</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="n">arg64</span><span class="p">.</span><span class="n">LUN_info</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg64</span><span class="p">.</span><span class="n">Request</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="n">arg64</span><span class="p">.</span><span class="n">Request</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg64</span><span class="p">.</span><span class="n">error_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">error_info</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="n">arg64</span><span class="p">.</span><span class="n">error_info</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">arg64</span><span class="p">.</span><span class="n">buf_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">arg64</span><span class="p">.</span><span class="n">malloc_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">malloc_size</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">arg64</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arg64</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">hpsa_ioctl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CCISS_BIG_PASSTHRU</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">error_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">error_info</span><span class="p">,</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="n">arg32</span><span class="o">-&gt;</span><span class="n">error_info</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CCISS_GETPCIINFO</span>:
	<span class="k">case</span> <span class="n">CCISS_GETINTINFO</span>:
	<span class="k">case</span> <span class="n">CCISS_SETINTINFO</span>:
	<span class="k">case</span> <span class="n">CCISS_GETNODENAME</span>:
	<span class="k">case</span> <span class="n">CCISS_SETNODENAME</span>:
	<span class="k">case</span> <span class="n">CCISS_GETHEARTBEAT</span>:
	<span class="k">case</span> <span class="n">CCISS_GETBUSTYPES</span>:
	<span class="k">case</span> <span class="n">CCISS_GETFIRMVER</span>:
	<span class="k">case</span> <span class="n">CCISS_GETDRIVVER</span>:
	<span class="k">case</span> <span class="n">CCISS_REVALIDVOLS</span>:
	<span class="k">case</span> <span class="n">CCISS_DEREGDISK</span>:
	<span class="k">case</span> <span class="n">CCISS_REGNEWDISK</span>:
	<span class="k">case</span> <span class="n">CCISS_REGNEWD</span>:
	<span class="k">case</span> <span class="n">CCISS_RESCANDISK</span>:
	<span class="k">case</span> <span class="n">CCISS_GETLUNINFO</span>:
		<span class="k">return</span> <span class="n">hpsa_ioctl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">CCISS_PASSTHRU32</span>:
		<span class="k">return</span> <span class="n">hpsa_ioctl32_passthru</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">CCISS_BIG_PASSTHRU32</span>:
		<span class="k">return</span> <span class="n">hpsa_ioctl32_big_passthru</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_getpciinfo_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hpsa_pci_info</span> <span class="n">pciinfo</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">argp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pciinfo</span><span class="p">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">pciinfo</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="n">pciinfo</span><span class="p">.</span><span class="n">dev_fn</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
	<span class="n">pciinfo</span><span class="p">.</span><span class="n">board_id</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">board_id</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pciinfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pciinfo</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_getdrivver_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DriverVer_type</span> <span class="n">DriverVer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">vmaj</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vsubmin</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">HPSA_DRIVER_VERSION</span><span class="p">,</span> <span class="s">&quot;%hhu.%hhu.%hhu&quot;</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">vmaj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmin</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsubmin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;driver version string &#39;%s&#39; &quot;</span>
			<span class="s">&quot;unrecognized.&quot;</span><span class="p">,</span> <span class="n">HPSA_DRIVER_VERSION</span><span class="p">);</span>
		<span class="n">vmaj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">vmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">vsubmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DriverVer</span> <span class="o">=</span> <span class="p">(</span><span class="n">vmaj</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">vmin</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">vsubmin</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">argp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DriverVer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DriverVer_type</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_passthru_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IOCTL_Command_struct</span> <span class="n">iocommand</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">u64bit</span> <span class="n">temp64</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">argp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RAWIO</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocommand</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">iocommand</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iocommand</span><span class="p">.</span><span class="n">buf_size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">iocommand</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">!=</span> <span class="n">XFER_NONE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iocommand</span><span class="p">.</span><span class="n">buf_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buff</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">iocommand</span><span class="p">.</span><span class="n">buf_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buff</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iocommand</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">==</span> <span class="n">XFER_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Copy the data into the buffer we created */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">iocommand</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span>
				<span class="n">iocommand</span><span class="p">.</span><span class="n">buf_size</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iocommand</span><span class="p">.</span><span class="n">buf_size</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">cmd_special_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Fill in the command type */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">CMD_IOCTL_PEND</span><span class="p">;</span>
	<span class="cm">/* Fill in Command Header */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">ReplyQueue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* unused in simple mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iocommand</span><span class="p">.</span><span class="n">buf_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* buffer to fill */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGList</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGTotal</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>	<span class="p">{</span> <span class="cm">/* no buffers to fill */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGList</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGTotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">LUN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocommand</span><span class="p">.</span><span class="n">LUN_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">LUN</span><span class="p">));</span>
	<span class="cm">/* use the kernel address the cmd block for tag */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">busaddr</span><span class="p">;</span>

	<span class="cm">/* Fill in Request block */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocommand</span><span class="p">.</span><span class="n">Request</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">));</span>

	<span class="cm">/* Fill in the scatter gather information */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iocommand</span><span class="p">.</span><span class="n">buf_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp64</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span>
			<span class="n">iocommand</span><span class="p">.</span><span class="n">buf_size</span><span class="p">,</span> <span class="n">PCI_DMA_BIDIRECTIONAL</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Addr</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">temp64</span><span class="p">.</span><span class="n">val32</span><span class="p">.</span><span class="n">lower</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Addr</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">temp64</span><span class="p">.</span><span class="n">val32</span><span class="p">.</span><span class="n">upper</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Len</span> <span class="o">=</span> <span class="n">iocommand</span><span class="p">.</span><span class="n">buf_size</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Ext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* we are not chaining*/</span>
	<span class="p">}</span>
	<span class="n">hpsa_scsi_do_simple_cmd_core_if_no_lockup</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iocommand</span><span class="p">.</span><span class="n">buf_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hpsa_pci_unmap</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PCI_DMA_BIDIRECTIONAL</span><span class="p">);</span>
	<span class="n">check_ioctl_unit_attention</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

	<span class="cm">/* Copy the error information out */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocommand</span><span class="p">.</span><span class="n">error_info</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">iocommand</span><span class="p">.</span><span class="n">error_info</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocommand</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">iocommand</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>
		<span class="n">cmd_special_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iocommand</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">==</span> <span class="n">XFER_READ</span> <span class="o">&amp;&amp;</span>
		<span class="n">iocommand</span><span class="p">.</span><span class="n">buf_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Copy the data out of the buffer we created */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">iocommand</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">iocommand</span><span class="p">.</span><span class="n">buf_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>
			<span class="n">cmd_special_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>
	<span class="n">cmd_special_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_big_passthru_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BIG_IOCTL_Command_struct</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">buff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">buff_size</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">u64bit</span> <span class="n">temp64</span><span class="p">;</span>
	<span class="n">BYTE</span> <span class="n">sg_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">left</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sz</span><span class="p">;</span>
	<span class="n">BYTE</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data_ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">argp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RAWIO</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">ioc</span> <span class="o">=</span> <span class="p">(</span><span class="n">BIG_IOCTL_Command_struct</span> <span class="o">*</span><span class="p">)</span>
	    <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ioc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ioc</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">!=</span> <span class="n">XFER_NONE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check kmalloc limits  using all SGs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">malloc_size</span> <span class="o">&gt;</span> <span class="n">MAX_KMALLOC_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">&gt;</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">malloc_size</span> <span class="o">*</span> <span class="n">SG_ENTRIES_IN_CMD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buff</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">SG_ENTRIES_IN_CMD</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buff_size</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">SG_ENTRIES_IN_CMD</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buff_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">left</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">;</span>
	<span class="n">data_ptr</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sz</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">malloc_size</span><span class="p">)</span> <span class="o">?</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">malloc_size</span> <span class="o">:</span> <span class="n">left</span><span class="p">;</span>
		<span class="n">buff_size</span><span class="p">[</span><span class="n">sg_used</span><span class="p">]</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span>
		<span class="n">buff</span><span class="p">[</span><span class="n">sg_used</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="n">sg_used</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">==</span> <span class="n">XFER_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="n">sg_used</span><span class="p">],</span> <span class="n">data_ptr</span><span class="p">,</span> <span class="n">sz</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="n">sg_used</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
		<span class="n">left</span> <span class="o">-=</span> <span class="n">sz</span><span class="p">;</span>
		<span class="n">data_ptr</span> <span class="o">+=</span> <span class="n">sz</span><span class="p">;</span>
		<span class="n">sg_used</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">cmd_special_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">CMD_IOCTL_PEND</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">ReplyQueue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGList</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGTotal</span> <span class="o">=</span> <span class="n">sg_used</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">LUN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">LUN_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">LUN</span><span class="p">));</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">busaddr</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sg_used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">temp64</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				    <span class="n">buff_size</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">PCI_DMA_BIDIRECTIONAL</span><span class="p">);</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Addr</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">temp64</span><span class="p">.</span><span class="n">val32</span><span class="p">.</span><span class="n">lower</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Addr</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">temp64</span><span class="p">.</span><span class="n">val32</span><span class="p">.</span><span class="n">upper</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Len</span> <span class="o">=</span> <span class="n">buff_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="cm">/* we are not chaining */</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">SG</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Ext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">hpsa_scsi_do_simple_cmd_core_if_no_lockup</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sg_used</span><span class="p">)</span>
		<span class="n">hpsa_pci_unmap</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">sg_used</span><span class="p">,</span> <span class="n">PCI_DMA_BIDIRECTIONAL</span><span class="p">);</span>
	<span class="n">check_ioctl_unit_attention</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="cm">/* Copy the error information out */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">error_info</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">error_info</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="n">ioc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ioc</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">cmd_special_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">==</span> <span class="n">XFER_READ</span> <span class="o">&amp;&amp;</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Copy the data out of the buffer we created */</span>
		<span class="n">BYTE</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sg_used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">buff_size</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">cmd_special_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ptr</span> <span class="o">+=</span> <span class="n">buff_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cmd_special_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">cleanup1:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buff</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sg_used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buff_size</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_ioctl_unit_attention</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">CommandStatus</span> <span class="o">==</span> <span class="n">CMD_TARGET_STATUS</span> <span class="o">&amp;&amp;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">ScsiStatus</span> <span class="o">!=</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">)</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">check_for_unit_attention</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * ioctl</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="n">h</span> <span class="o">=</span> <span class="n">sdev_to_hba</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CCISS_DEREGDISK</span>:
	<span class="k">case</span> <span class="n">CCISS_REGNEWDISK</span>:
	<span class="k">case</span> <span class="n">CCISS_REGNEWD</span>:
		<span class="n">hpsa_scan_start</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CCISS_GETPCIINFO</span>:
		<span class="k">return</span> <span class="n">hpsa_getpciinfo_ioctl</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">CCISS_GETDRIVVER</span>:
		<span class="k">return</span> <span class="n">hpsa_getdrivver_ioctl</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">CCISS_PASSTHRU</span>:
		<span class="k">return</span> <span class="n">hpsa_passthru_ioctl</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">CCISS_BIG_PASSTHRU</span>:
		<span class="k">return</span> <span class="n">hpsa_big_passthru_ioctl</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hpsa_send_host_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scsi3addr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reset_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">cmd_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">fill_cmd</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">HPSA_DEVICE_RESET_MSG</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">RAID_CTLR_LUNID</span><span class="p">,</span> <span class="n">TYPE_MSG</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reset_type</span><span class="p">;</span> <span class="cm">/* fill_cmd defaults to target reset */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">waiting</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">enqueue_cmd_and_start_io</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="cm">/* Don&#39;t wait for completion, the reset won&#39;t complete.  Don&#39;t free</span>
<span class="cm">	 * the command either.  This is the last command we will send before</span>
<span class="cm">	 * re-initializing everything, so it doesn&#39;t matter and won&#39;t leak.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">u8</span> <span class="n">page_code</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scsi3addr</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">cmd_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pci_dir</span> <span class="o">=</span> <span class="n">XFER_NONE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span> <span class="cm">/* for commands to be aborted */</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">CMD_IOCTL_PEND</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">ReplyQueue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buff</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGList</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGTotal</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGList</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">SGTotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">busaddr</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">LUN</span><span class="p">.</span><span class="n">LunAddrBytes</span><span class="p">,</span> <span class="n">scsi3addr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">cmd_type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">TYPE_CMD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">HPSA_INQUIRY</span>:
			<span class="cm">/* are we trying to read a vital product page */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">page_code</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDBLen</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Attribute</span> <span class="o">=</span> <span class="n">ATTR_SIMPLE</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">=</span> <span class="n">XFER_READ</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">HPSA_INQUIRY</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HPSA_REPORT_LOG</span>:
		<span class="k">case</span> <span class="n">HPSA_REPORT_PHYS</span>:
			<span class="cm">/* Talking to controller so It&#39;s a physical command</span>
<span class="cm">			   mode = 00 target = 0.  Nothing to write.</span>
<span class="cm">			 */</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDBLen</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Attribute</span> <span class="o">=</span> <span class="n">ATTR_SIMPLE</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">=</span> <span class="n">XFER_READ</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span> <span class="cm">/* MSB */</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HPSA_CACHE_FLUSH</span>:
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDBLen</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Attribute</span> <span class="o">=</span> <span class="n">ATTR_SIMPLE</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">=</span> <span class="n">XFER_WRITE</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">BMIC_WRITE</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">BMIC_CACHE_FLUSH</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TEST_UNIT_READY</span>:
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDBLen</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Attribute</span> <span class="o">=</span> <span class="n">ATTR_SIMPLE</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">=</span> <span class="n">XFER_NONE</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unknown command 0x%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">TYPE_MSG</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span>  <span class="n">HPSA_DEVICE_RESET_MSG</span>:
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDBLen</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Type</span> <span class="o">=</span>  <span class="mi">1</span><span class="p">;</span> <span class="cm">/* It is a MSG not a CMD */</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Attribute</span> <span class="o">=</span> <span class="n">ATTR_SIMPLE</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">=</span> <span class="n">XFER_NONE</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Don&#39;t time out */</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">));</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>  <span class="n">cmd</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span>  <span class="cm">/* Reset target above */</span>
			<span class="cm">/* If bytes 4-7 are zero, it means reset the */</span>
			<span class="cm">/* LunID device */</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span>  <span class="n">HPSA_ABORT_MSG</span>:
			<span class="n">a</span> <span class="o">=</span> <span class="n">buff</span><span class="p">;</span>       <span class="cm">/* point to command to be aborted */</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Abort Tag:0x%08x:%08x using request Tag:0x%08x:%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">a</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">upper</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span><span class="p">,</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">upper</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span><span class="p">);</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDBLen</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">TYPE_MSG</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Attribute</span> <span class="o">=</span> <span class="n">ATTR_SIMPLE</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">=</span> <span class="n">XFER_WRITE</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Don&#39;t time out */</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">HPSA_TASK_MANAGEMENT</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">HPSA_TMF_ABORT_TASK</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* reserved */</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* reserved */</span>
			<span class="cm">/* Tag to abort goes in CDB[4]-CDB[11] */</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">upper</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">upper</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">upper</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Header</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">upper</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* reserved */</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* reserved */</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* reserved */</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* reserved */</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unknown message type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cmd</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unknown command type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd_type</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFER_READ</span>:
		<span class="n">pci_dir</span> <span class="o">=</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFER_WRITE</span>:
		<span class="n">pci_dir</span> <span class="o">=</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFER_NONE</span>:
		<span class="n">pci_dir</span> <span class="o">=</span> <span class="n">PCI_DMA_NONE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pci_dir</span> <span class="o">=</span> <span class="n">PCI_DMA_BIDIRECTIONAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hpsa_map_one</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pci_dir</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Map (physical) PCI mem into (virtual) kernel space</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">remap_pci_mem</span><span class="p">(</span><span class="n">ulong</span> <span class="n">base</span><span class="p">,</span> <span class="n">ulong</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ulong</span> <span class="n">page_base</span> <span class="o">=</span> <span class="p">((</span><span class="n">ulong</span><span class="p">)</span> <span class="n">base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">ulong</span> <span class="n">page_offs</span> <span class="o">=</span> <span class="p">((</span><span class="n">ulong</span><span class="p">)</span> <span class="n">base</span><span class="p">)</span> <span class="o">-</span> <span class="n">page_base</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">page_remapped</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">page_base</span><span class="p">,</span> <span class="n">page_offs</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">page_remapped</span> <span class="o">?</span> <span class="p">(</span><span class="n">page_remapped</span> <span class="o">+</span> <span class="n">page_offs</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Takes cmds off the submission queue and sends them to the hardware,</span>
<span class="cm"> * then puts them on the queue of cmds waiting for completion.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">reqQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">reqQ</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">CommandList</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="cm">/* can&#39;t do anything if fifo is full */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">.</span><span class="n">fifo_full</span><span class="p">(</span><span class="n">h</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fifo full</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Get the first entry from the Request Q */</span>
		<span class="n">removeQ</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">Qdepth</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* Put job onto the completed Q */</span>
		<span class="n">addQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmpQ</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

		<span class="cm">/* Must increment commands_outstanding before unlocking</span>
<span class="cm">		 * and submitting to avoid race checking for fifo full</span>
<span class="cm">		 * condition.</span>
<span class="cm">		 */</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">commands_outstanding</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">commands_outstanding</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_outstanding</span><span class="p">)</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">max_outstanding</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">commands_outstanding</span><span class="p">;</span>

		<span class="cm">/* Tell the controller execute command */</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">.</span><span class="n">submit_command</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_next_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">u8</span> <span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">.</span><span class="n">command_completed</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">interrupt_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">.</span><span class="n">intr_pending</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">interrupt_not_for_us</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">.</span><span class="n">intr_pending</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">interrupts_enabled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bad_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tag_index</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">raw_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tag_index</span> <span class="o">&gt;=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bad tag 0x%08x ignored.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">raw_tag</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">finish_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">removeQ</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dial_up_lockup_detection_on_fw_flash_complete</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">CMD_SCSI</span><span class="p">))</span>
		<span class="n">complete_scsi_command</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">CMD_IOCTL_PEND</span><span class="p">)</span>
		<span class="n">complete</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">waiting</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hpsa_tag_contains_index</span><span class="p">(</span><span class="n">u32</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tag</span> <span class="o">&amp;</span> <span class="n">DIRECT_LOOKUP_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hpsa_tag_to_index</span><span class="p">(</span><span class="n">u32</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tag</span> <span class="o">&gt;&gt;</span> <span class="n">DIRECT_LOOKUP_SHIFT</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hpsa_tag_discard_error_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define HPSA_PERF_ERROR_BITS ((1 &lt;&lt; DIRECT_LOOKUP_SHIFT) - 1)</span>
<span class="cp">#define HPSA_SIMPLE_ERROR_BITS 0x03</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transMethod</span> <span class="o">&amp;</span> <span class="n">CFGTBL_Trans_Performant</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">tag</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPSA_SIMPLE_ERROR_BITS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tag</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPSA_PERF_ERROR_BITS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* process completion of an indexed (&quot;direct lookup&quot;) command */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">process_indexed_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">raw_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tag_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">tag_index</span> <span class="o">=</span> <span class="n">hpsa_tag_to_index</span><span class="p">(</span><span class="n">raw_tag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bad_tag</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">tag_index</span><span class="p">,</span> <span class="n">raw_tag</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool</span> <span class="o">+</span> <span class="n">tag_index</span><span class="p">;</span>
		<span class="n">finish_cmd</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* process completion of a non-indexed command */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">process_nonindexed_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">raw_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">tag</span> <span class="o">=</span> <span class="n">hpsa_tag_discard_error_bits</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">raw_tag</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmpQ</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">busaddr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFE0</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">tag</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFE0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">finish_cmd</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">bad_tag</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">raw_tag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Some controllers, like p400, will give us one interrupt</span>
<span class="cm"> * after a soft reset, even if we turned interrupts off.</span>
<span class="cm"> * Only need to check for this in the hpsa_xxx_discard_completions</span>
<span class="cm"> * functions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ignore_bogus_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">reset_devices</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">interrupts_enabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Received interrupt while interrupts disabled &quot;</span>
		<span class="s">&quot;(known firmware bug.)  Ignoring.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert &amp;h-&gt;q[x] (passed to interrupt handlers) back to h.</span>
<span class="cm"> * Relies on (h-q[x] == x) being true for x such that</span>
<span class="cm"> * 0 &lt;= x &lt; MAX_REPLY_QUEUES.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="nf">queue_to_hba</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">((</span><span class="n">queue</span> <span class="o">-</span> <span class="o">*</span><span class="n">queue</span><span class="p">),</span> <span class="k">struct</span> <span class="n">ctlr_info</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">hpsa_intx_discard_completions</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">queue_to_hba</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">queue</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">raw_tag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ignore_bogus_interrupt</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">interrupt_not_for_us</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">last_intr_timestamp</span> <span class="o">=</span> <span class="n">get_jiffies_64</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">interrupt_pending</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">raw_tag</span> <span class="o">=</span> <span class="n">get_next_completion</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">raw_tag</span> <span class="o">!=</span> <span class="n">FIFO_EMPTY</span><span class="p">)</span>
			<span class="n">raw_tag</span> <span class="o">=</span> <span class="n">next_command</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">hpsa_msix_discard_completions</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">queue_to_hba</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">raw_tag</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ignore_bogus_interrupt</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">h</span><span class="o">-&gt;</span><span class="n">last_intr_timestamp</span> <span class="o">=</span> <span class="n">get_jiffies_64</span><span class="p">();</span>
	<span class="n">raw_tag</span> <span class="o">=</span> <span class="n">get_next_completion</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">raw_tag</span> <span class="o">!=</span> <span class="n">FIFO_EMPTY</span><span class="p">)</span>
		<span class="n">raw_tag</span> <span class="o">=</span> <span class="n">next_command</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">do_hpsa_intr_intx</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">queue_to_hba</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">queue</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">raw_tag</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">interrupt_not_for_us</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">last_intr_timestamp</span> <span class="o">=</span> <span class="n">get_jiffies_64</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">interrupt_pending</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">raw_tag</span> <span class="o">=</span> <span class="n">get_next_completion</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">raw_tag</span> <span class="o">!=</span> <span class="n">FIFO_EMPTY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">hpsa_tag_contains_index</span><span class="p">(</span><span class="n">raw_tag</span><span class="p">)))</span>
				<span class="n">process_indexed_cmd</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">raw_tag</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">process_nonindexed_cmd</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">raw_tag</span><span class="p">);</span>
			<span class="n">raw_tag</span> <span class="o">=</span> <span class="n">next_command</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">do_hpsa_intr_msi</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">queue_to_hba</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">raw_tag</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">queue</span><span class="p">;</span>

	<span class="n">h</span><span class="o">-&gt;</span><span class="n">last_intr_timestamp</span> <span class="o">=</span> <span class="n">get_jiffies_64</span><span class="p">();</span>
	<span class="n">raw_tag</span> <span class="o">=</span> <span class="n">get_next_completion</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">raw_tag</span> <span class="o">!=</span> <span class="n">FIFO_EMPTY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">hpsa_tag_contains_index</span><span class="p">(</span><span class="n">raw_tag</span><span class="p">)))</span>
			<span class="n">process_indexed_cmd</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">raw_tag</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">process_nonindexed_cmd</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">raw_tag</span><span class="p">);</span>
		<span class="n">raw_tag</span> <span class="o">=</span> <span class="n">next_command</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Send a message CDB to the firmware. Careful, this only works</span>
<span class="cm"> * in simple mode, not performant mode due to the tag lookup.</span>
<span class="cm"> * We only ever use this immediately after a controller reset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__devinit</span> <span class="kt">int</span> <span class="nf">hpsa_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">opcode</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Command</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">CommandListHeader</span> <span class="n">CommandHeader</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">RequestBlock</span> <span class="n">Request</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ErrDescriptor</span> <span class="n">ErrorDescriptor</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">Command</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">cmd_sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">)</span> <span class="o">+</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ErrorDescriptor</span><span class="p">);</span>
	<span class="n">dma_addr_t</span> <span class="n">paddr64</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">paddr32</span><span class="p">,</span> <span class="n">tag</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">pci_ioremap_bar</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* The Inbound Post Queue only accepts 32-bit physical addresses for the</span>
<span class="cm">	 * CCISS commands, so they must be allocated from the lower 4GiB of</span>
<span class="cm">	 * memory.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cmd_sz</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">paddr64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This must fit, because of the 32-bit consistent DMA mask.  Also,</span>
<span class="cm">	 * although there&#39;s no guarantee, we assume that the address is at</span>
<span class="cm">	 * least 4-byte aligned (most likely, it&#39;s page-aligned).</span>
<span class="cm">	 */</span>
	<span class="n">paddr32</span> <span class="o">=</span> <span class="n">paddr64</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">CommandHeader</span><span class="p">.</span><span class="n">ReplyQueue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">CommandHeader</span><span class="p">.</span><span class="n">SGList</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">CommandHeader</span><span class="p">.</span><span class="n">SGTotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">CommandHeader</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">paddr32</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">CommandHeader</span><span class="p">.</span><span class="n">Tag</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">CommandHeader</span><span class="p">.</span><span class="n">LUN</span><span class="p">.</span><span class="n">LunAddrBytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDBLen</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">TYPE_MSG</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Attribute</span> <span class="o">=</span> <span class="n">ATTR_HEADOFQUEUE</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="n">Direction</span> <span class="o">=</span> <span class="n">XFER_NONE</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">Timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Don&#39;t time out */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">opcode</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">.</span><span class="n">CDB</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span> <span class="cm">/* rest of the CDB is reserved */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ErrorDescriptor</span><span class="p">.</span><span class="n">Addr</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">paddr32</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ErrorDescriptor</span><span class="p">.</span><span class="n">Addr</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ErrorDescriptor</span><span class="p">.</span><span class="n">Len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ErrorInfo</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">paddr32</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">SA5_REQUEST_PORT_OFFSET</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HPSA_MSG_SEND_RETRY_LIMIT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">SA5_REPLY_PORT_OFFSET</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tag</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPSA_SIMPLE_ERROR_BITS</span><span class="p">)</span> <span class="o">==</span> <span class="n">paddr32</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="n">HPSA_MSG_SEND_RETRY_INTERVAL_MSECS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>

	<span class="cm">/* we leak the DMA buffer here ... no choice since the controller could</span>
<span class="cm">	 *  still complete the command.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">HPSA_MSG_SEND_RETRY_LIMIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;controller message %02x:%02x timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">opcode</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cmd_sz</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">paddr64</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">&amp;</span> <span class="n">HPSA_ERROR_BIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;controller message %02x:%02x failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">opcode</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;controller message %02x:%02x succeeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">opcode</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define hpsa_noop(p) hpsa_message(p, 3, 0)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_controller_hard_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span> <span class="n">__iomem</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">use_doorbell</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">pmcsr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_doorbell</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* For everything after the P600, the PCI power state method</span>
<span class="cm">		 * of resetting the controller doesn&#39;t work, so we have this</span>
<span class="cm">		 * other way using the doorbell register.</span>
<span class="cm">		 */</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;using doorbell to reset controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">use_doorbell</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">SA5_DOORBELL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* Try to do it the PCI power state way */</span>

		<span class="cm">/* Quoting from the Open CISS Specification: &quot;The Power</span>
<span class="cm">		 * Management Control/Status Register (CSR) controls the power</span>
<span class="cm">		 * state of the device.  The normal operating state is D0,</span>
<span class="cm">		 * CSR=00h.  The software off state is D3, CSR=03h.  To reset</span>
<span class="cm">		 * the controller, place the interface device in D3 then to D0,</span>
<span class="cm">		 * this causes a secondary PCI reset which will reset the</span>
<span class="cm">		 * controller.&quot; */</span>

		<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_PM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;hpsa_reset_controller: &quot;</span>
				<span class="s">&quot;PCI PM not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;using PCI PM to reset controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* enter the D3hot power management state */</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmcsr</span><span class="p">);</span>
		<span class="n">pmcsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">;</span>
		<span class="n">pmcsr</span> <span class="o">|=</span> <span class="n">PCI_D3hot</span><span class="p">;</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="n">pmcsr</span><span class="p">);</span>

		<span class="n">msleep</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>

		<span class="cm">/* enter the D0 power management state */</span>
		<span class="n">pmcsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">;</span>
		<span class="n">pmcsr</span> <span class="o">|=</span> <span class="n">PCI_D0</span><span class="p">;</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="n">pmcsr</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The P600 requires a small delay when changing states.</span>
<span class="cm">		 * Otherwise we may think the board did not reset and we bail.</span>
<span class="cm">		 * This for kdump only and is particular to the P600.</span>
<span class="cm">		 */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__devinit</span> <span class="kt">void</span> <span class="nf">init_driver_version</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">driver_version</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">driver_version</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">driver_version</span><span class="p">,</span> <span class="n">HPSA</span> <span class="s">&quot; &quot;</span> <span class="n">HPSA_DRIVER_VERSION</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__devinit</span> <span class="kt">int</span> <span class="nf">write_driver_ver_to_cfgtable</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">CfgTable</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">cfgtable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">driver_version</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">driver_version</span><span class="p">);</span>

	<span class="n">driver_version</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver_version</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">init_driver_version</span><span class="p">(</span><span class="n">driver_version</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">driver_version</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">driver_version</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">driver_version</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__devinit</span> <span class="kt">void</span> <span class="nf">read_driver_ver_from_cfgtable</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">CfgTable</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">cfgtable</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver_ver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">driver_version</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">driver_ver</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">driver_version</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__devinit</span> <span class="kt">int</span> <span class="nf">controller_reset_failed</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">CfgTable</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">cfgtable</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">driver_ver</span><span class="p">,</span> <span class="o">*</span><span class="n">old_driver_ver</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">driver_version</span><span class="p">);</span>

	<span class="n">old_driver_ver</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_driver_ver</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">driver_ver</span> <span class="o">=</span> <span class="n">old_driver_ver</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* After a reset, the 32 bytes of &quot;driver version&quot; in the cfgtable</span>
<span class="cm">	 * should have been changed, otherwise we know the reset failed.</span>
<span class="cm">	 */</span>
	<span class="n">init_driver_version</span><span class="p">(</span><span class="n">old_driver_ver</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">read_driver_ver_from_cfgtable</span><span class="p">(</span><span class="n">cfgtable</span><span class="p">,</span> <span class="n">driver_ver</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">driver_ver</span><span class="p">,</span> <span class="n">old_driver_ver</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">old_driver_ver</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* This does a hard reset of the controller using PCI power management</span>
<span class="cm"> * states or the using the doorbell register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__devinit</span> <span class="kt">int</span> <span class="nf">hpsa_kdump_hard_reset_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">cfg_offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cfg_base_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cfg_base_addr_index</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">misc_fw_support</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">CfgTable</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">cfgtable</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">use_doorbell</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">board_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">command_register</span><span class="p">;</span>

	<span class="cm">/* For controllers as old as the P600, this is very nearly</span>
<span class="cm">	 * the same thing as</span>
<span class="cm">	 *</span>
<span class="cm">	 * pci_save_state(pci_dev);</span>
<span class="cm">	 * pci_set_power_state(pci_dev, PCI_D3hot);</span>
<span class="cm">	 * pci_set_power_state(pci_dev, PCI_D0);</span>
<span class="cm">	 * pci_restore_state(pci_dev);</span>
<span class="cm">	 *</span>
<span class="cm">	 * For controllers newer than the P600, the pci power state</span>
<span class="cm">	 * method of resetting doesn&#39;t work so we have another way</span>
<span class="cm">	 * using the doorbell register.</span>
<span class="cm">	 */</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_lookup_board_id</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">board_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">ctlr_is_resettable</span><span class="p">(</span><span class="n">board_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Not resetting device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if controller is soft- but not hard resettable... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctlr_is_hard_resettable</span><span class="p">(</span><span class="n">board_id</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span> <span class="cm">/* try soft reset later. */</span>

	<span class="cm">/* Save the PCI command register */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">command_register</span><span class="p">);</span>
	<span class="cm">/* Turn the board off.  This is so that later pci_restore_state()</span>
<span class="cm">	 * won&#39;t turn the board on before the rest of config space is ready.</span>
<span class="cm">	 */</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* find the first memory BAR, so we can find the cfg table */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_pci_find_memory_BAR</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">paddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">remap_pci_mem</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="mh">0x250</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vaddr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* find cfgtable in order to check if reset via doorbell is supported */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_find_cfg_addrs</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg_base_addr</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">cfg_base_addr_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unmap_vaddr</span><span class="p">;</span>
	<span class="n">cfgtable</span> <span class="o">=</span> <span class="n">remap_pci_mem</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
		       <span class="n">cfg_base_addr_index</span><span class="p">)</span> <span class="o">+</span> <span class="n">cfg_offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cfgtable</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfgtable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unmap_vaddr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">write_driver_ver_to_cfgtable</span><span class="p">(</span><span class="n">cfgtable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unmap_vaddr</span><span class="p">;</span>

	<span class="cm">/* If reset via doorbell register is supported, use that.</span>
<span class="cm">	 * There are two such methods.  Favor the newest method.</span>
<span class="cm">	 */</span>
	<span class="n">misc_fw_support</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">misc_fw_support</span><span class="p">);</span>
	<span class="n">use_doorbell</span> <span class="o">=</span> <span class="n">misc_fw_support</span> <span class="o">&amp;</span> <span class="n">MISC_FW_DOORBELL_RESET2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_doorbell</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">use_doorbell</span> <span class="o">=</span> <span class="n">DOORBELL_CTLR_RESET2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">use_doorbell</span> <span class="o">=</span> <span class="n">misc_fw_support</span> <span class="o">&amp;</span> <span class="n">MISC_FW_DOORBELL_RESET</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use_doorbell</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Soft reset not supported. &quot;</span>
				<span class="s">&quot;Firmware update is required.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span> <span class="cm">/* try soft reset */</span>
			<span class="k">goto</span> <span class="n">unmap_cfgtable</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_controller_hard_reset</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">use_doorbell</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unmap_cfgtable</span><span class="p">;</span>

	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to enable device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unmap_cfgtable</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">command_register</span><span class="p">);</span>

	<span class="cm">/* Some devices (notably the HP Smart Array 5i Controller)</span>
<span class="cm">	   need a little pause here */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="n">HPSA_POST_RESET_PAUSE_MSECS</span><span class="p">);</span>

	<span class="cm">/* Wait for board to become not ready, then ready. */</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Waiting for board to reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_wait_for_board_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">BOARD_NOT_READY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;failed waiting for board to reset.&quot;</span>
			<span class="s">&quot; Will try soft reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span> <span class="cm">/* Not expected, but try soft reset later */</span>
		<span class="k">goto</span> <span class="n">unmap_cfgtable</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_wait_for_board_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">BOARD_READY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;failed waiting for board to become ready &quot;</span>
			<span class="s">&quot;after hard reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unmap_cfgtable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">controller_reset_failed</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unmap_cfgtable</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to successfully reset &quot;</span>
			<span class="s">&quot;controller. Will try soft reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;board ready after hard reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">unmap_cfgtable:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">cfgtable</span><span class="p">);</span>

<span class="nl">unmap_vaddr:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  We cannot read the structure directly, for portability we must use</span>
<span class="cm"> *   the io functions.</span>
<span class="cm"> *   This is for debug only.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_cfg_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">CfgTable</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef HPSA_DEBUG</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">temp_name</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Controller Configuration information</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;------------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">temp_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">Signature</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="n">temp_name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;   Signature = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">temp_name</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;   Spec Number = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">SpecValence</span><span class="p">)));</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;   Transport methods supported = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">TransportSupport</span><span class="p">)));</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;   Transport methods active = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">TransportActive</span><span class="p">)));</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;   Requested transport Method = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">HostWrite</span><span class="p">.</span><span class="n">TransportRequest</span><span class="p">)));</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;   Coalesce Interrupt Delay = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">HostWrite</span><span class="p">.</span><span class="n">CoalIntDelay</span><span class="p">)));</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;   Coalesce Interrupt Count = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">HostWrite</span><span class="p">.</span><span class="n">CoalIntCount</span><span class="p">)));</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;   Max outstanding commands = 0x%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CmdsOutMax</span><span class="p">)));</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;   Bus Types = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">BusTypes</span><span class="p">)));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">temp_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">ServerName</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="n">temp_name</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;   Server Name = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">temp_name</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;   Heartbeat Counter = 0x%x</span><span class="se">\n\n\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">HeartBeat</span><span class="p">)));</span>
<span class="cp">#endif				</span><span class="cm">/* HPSA_DEBUG */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_PCI_BAR_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_bar_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">mem_type</span><span class="p">,</span> <span class="n">bar_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_bar_addr</span> <span class="o">==</span> <span class="n">PCI_BASE_ADDRESS_0</span><span class="p">)</span>	<span class="cm">/* looking for BAR zero? */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DEVICE_COUNT_RESOURCE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bar_type</span> <span class="o">=</span> <span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PCI_BASE_ADDRESS_SPACE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bar_type</span> <span class="o">==</span> <span class="n">PCI_BASE_ADDRESS_SPACE_IO</span><span class="p">)</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">mem_type</span> <span class="o">=</span> <span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span>
			    <span class="n">PCI_BASE_ADDRESS_MEM_TYPE_MASK</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">mem_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">PCI_BASE_ADDRESS_MEM_TYPE_32</span>:
			<span class="k">case</span> <span class="n">PCI_BASE_ADDRESS_MEM_TYPE_1M</span>:
				<span class="n">offset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>	<span class="cm">/* 32 bit */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">PCI_BASE_ADDRESS_MEM_TYPE_64</span>:
				<span class="n">offset</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>	<span class="cm">/* reserved in PCI 2.2 */</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				       <span class="s">&quot;base address is invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">pci_bar_addr</span> <span class="o">-</span> <span class="n">PCI_BASE_ADDRESS_0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If MSI/MSI-X is supported by the kernel we will try to enable it on</span>
<span class="cm"> * controllers that are capable. If not, we use IO-APIC mode.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">hpsa_interrupt_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PCI_MSI</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msix_entry</span> <span class="n">hpsa_msix_entries</span><span class="p">[</span><span class="n">MAX_REPLY_QUEUES</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_REPLY_QUEUES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpsa_msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hpsa_msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Some boards advertise MSI but don&#39;t really support it */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">board_id</span> <span class="o">==</span> <span class="mh">0x40700E11</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">board_id</span> <span class="o">==</span> <span class="mh">0x40800E11</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">board_id</span> <span class="o">==</span> <span class="mh">0x40820E11</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">board_id</span> <span class="o">==</span> <span class="mh">0x40830E11</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">default_int_mode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_find_capability</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_MSIX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MSIX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">hpsa_msix_entries</span><span class="p">,</span>
						<span class="n">MAX_REPLY_QUEUES</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_REPLY_QUEUES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">h</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hpsa_msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">;</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">msix_vector</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;only %d MSI-X vectors &quot;</span>
			       <span class="s">&quot;available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">default_int_mode</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MSI-X init failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">err</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">default_int_mode</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_find_capability</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_MSI</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MSI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">))</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">msi_vector</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MSI init failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">default_int_mode:</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_PCI_MSI */</span><span class="cp"></span>
	<span class="cm">/* if we get here we&#39;re going to use the default interrupt mode */</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hpsa_lookup_board_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">board_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">subsystem_vendor_id</span><span class="p">,</span> <span class="n">subsystem_device_id</span><span class="p">;</span>

	<span class="n">subsystem_vendor_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span><span class="p">;</span>
	<span class="n">subsystem_device_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">;</span>
	<span class="o">*</span><span class="n">board_id</span> <span class="o">=</span> <span class="p">((</span><span class="n">subsystem_device_id</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">|</span>
		    <span class="n">subsystem_vendor_id</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">products</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">board_id</span> <span class="o">==</span> <span class="n">products</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">board_id</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">subsystem_vendor_id</span> <span class="o">!=</span> <span class="n">PCI_VENDOR_ID_HP</span> <span class="o">&amp;&amp;</span>
		<span class="n">subsystem_vendor_id</span> <span class="o">!=</span> <span class="n">PCI_VENDOR_ID_COMPAQ</span><span class="p">)</span> <span class="o">||</span>
		<span class="o">!</span><span class="n">hpsa_allow_any</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unrecognized board ID: &quot;</span>
			<span class="s">&quot;0x%08x, ignoring.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">board_id</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">products</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* generic unknown smart array */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hpsa_pci_find_memory_BAR</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">memory_bar</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DEVICE_COUNT_RESOURCE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* addressing mode bits already removed */</span>
			<span class="o">*</span><span class="n">memory_bar</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;memory BAR = %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="o">*</span><span class="n">memory_bar</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no memory BAR found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hpsa_wait_for_board_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait_for_ready</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">iterations</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">scratchpad</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait_for_ready</span><span class="p">)</span>
		<span class="n">iterations</span> <span class="o">=</span> <span class="n">HPSA_BOARD_READY_ITERATIONS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">iterations</span> <span class="o">=</span> <span class="n">HPSA_BOARD_NOT_READY_ITERATIONS</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scratchpad</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">SA5_SCRATCHPAD_OFFSET</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_for_ready</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scratchpad</span> <span class="o">==</span> <span class="n">HPSA_FIRMWARE_READY</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scratchpad</span> <span class="o">!=</span> <span class="n">HPSA_FIRMWARE_READY</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msleep</span><span class="p">(</span><span class="n">HPSA_BOARD_READY_POLL_INTERVAL_MSECS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;board not ready, timed out.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hpsa_find_cfg_addrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">cfg_base_addr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">cfg_base_addr_index</span><span class="p">,</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">cfg_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">cfg_base_addr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">SA5_CTCFG_OFFSET</span><span class="p">);</span>
	<span class="o">*</span><span class="n">cfg_offset</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">SA5_CTMEM_OFFSET</span><span class="p">);</span>
	<span class="o">*</span><span class="n">cfg_base_addr</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="mh">0x0000ffff</span><span class="p">;</span>
	<span class="o">*</span><span class="n">cfg_base_addr_index</span> <span class="o">=</span> <span class="n">find_PCI_BAR_index</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">*</span><span class="n">cfg_base_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cfg_base_addr_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot find cfg_base_addr_index</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hpsa_find_cfgtables</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">cfg_offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cfg_base_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cfg_base_addr_index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">trans_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_find_cfg_addrs</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg_base_addr</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">cfg_base_addr_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span> <span class="o">=</span> <span class="n">remap_pci_mem</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
		       <span class="n">cfg_base_addr_index</span><span class="p">)</span> <span class="o">+</span> <span class="n">cfg_offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">write_driver_ver_to_cfgtable</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="cm">/* Find performant mode table. */</span>
	<span class="n">trans_offset</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">TransMethodOffset</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span> <span class="o">=</span> <span class="n">remap_pci_mem</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				<span class="n">cfg_base_addr_index</span><span class="p">)</span><span class="o">+</span><span class="n">cfg_offset</span><span class="o">+</span><span class="n">trans_offset</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">hpsa_get_max_perf_mode_cmds</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">max_commands</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">MaxPerformantModeCommands</span><span class="p">));</span>

	<span class="cm">/* Limit commands in memory limited kdump scenario. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reset_devices</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_commands</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">)</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">max_commands</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">max_commands</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Controller reports &quot;</span>
			<span class="s">&quot;max supported commands of %d, an obvious lie. &quot;</span>
			<span class="s">&quot;Using 16.  Ensure that firmware is up to date.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">max_commands</span><span class="p">);</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">max_commands</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Interrogate the hardware for some limits:</span>
<span class="cm"> * max commands, max SG elements without chaining, and with chaining,</span>
<span class="cm"> * SG chain block size, etc.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">hpsa_find_board_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hpsa_get_max_perf_mode_cmds</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_commands</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* Allow room for some ioctls */</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">maxsgentries</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">MaxScatterGatherElements</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Limit in-command s/g elements to 32 save dma&#39;able memory.</span>
<span class="cm">	 * Howvever spec says if 0, use 31</span>
<span class="cm">	 */</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">max_cmd_sg_entries</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">maxsgentries</span> <span class="o">&gt;</span> <span class="mi">512</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">max_cmd_sg_entries</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">chainsize</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">maxsgentries</span> <span class="o">-</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_cmd_sg_entries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">maxsgentries</span><span class="o">--</span><span class="p">;</span> <span class="cm">/* save one for chain pointer */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">maxsgentries</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span> <span class="cm">/* default to traditional values */</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">chainsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Find out what task management functions are supported and cache */</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">TMFSupportFlags</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">TMFSupportFlags</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">hpsa_CISS_signature_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_signature</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">Signature</span><span class="p">,</span> <span class="s">&quot;CISS&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;not a valid CISS config table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Need to enable prefetch in the SCSI core for 6400 in x86 */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hpsa_enable_scsi_prefetch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86</span>
	<span class="n">u32</span> <span class="n">prefetch</span><span class="p">;</span>

	<span class="n">prefetch</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">SCSI_Prefetch</span><span class="p">));</span>
	<span class="n">prefetch</span> <span class="o">|=</span> <span class="mh">0x100</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">prefetch</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">SCSI_Prefetch</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Disable DMA prefetch for the P600.  Otherwise an ASIC bug may result</span>
<span class="cm"> * in a prefetch beyond physical memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hpsa_p600_dma_prefetch_quirk</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dma_prefetch</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">board_id</span> <span class="o">!=</span> <span class="mh">0x3225103C</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dma_prefetch</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">I2O_DMA1_CFG</span><span class="p">);</span>
	<span class="n">dma_prefetch</span> <span class="o">|=</span> <span class="mh">0x8000</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">dma_prefetch</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">I2O_DMA1_CFG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">hpsa_wait_for_mode_change_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">doorbell_value</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* under certain very rare conditions, this can take awhile.</span>
<span class="cm">	 * (e.g.: hot replace a failed 144GB drive in a RAID 5 set right</span>
<span class="cm">	 * as we enter this code.)</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_CONFIG_WAIT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">doorbell_value</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">SA5_DOORBELL</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">doorbell_value</span> <span class="o">&amp;</span> <span class="n">CFGTBL_ChangeReq</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* delay and try again */</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hpsa_enter_simple_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">trans_support</span><span class="p">;</span>

	<span class="n">trans_support</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">TransportSupport</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trans_support</span> <span class="o">&amp;</span> <span class="n">SIMPLE_MODE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="n">h</span><span class="o">-&gt;</span><span class="n">max_commands</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">CmdsOutMax</span><span class="p">));</span>
	<span class="cm">/* Update the field, and then ring the doorbell */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">CFGTBL_Trans_Simple</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">HostWrite</span><span class="p">.</span><span class="n">TransportRequest</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">CFGTBL_ChangeReq</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">SA5_DOORBELL</span><span class="p">);</span>
	<span class="n">hpsa_wait_for_mode_change_ack</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">print_cfg_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">TransportActive</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">CFGTBL_Trans_Simple</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;unable to get board into simple mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">transMethod</span> <span class="o">=</span> <span class="n">CFGTBL_Trans_Simple</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hpsa_pci_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">prod_index</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">prod_index</span> <span class="o">=</span> <span class="n">hpsa_lookup_board_id</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">board_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prod_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">product_name</span> <span class="o">=</span> <span class="n">products</span><span class="p">[</span><span class="n">prod_index</span><span class="p">].</span><span class="n">product_name</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">products</span><span class="p">[</span><span class="n">prod_index</span><span class="p">].</span><span class="n">access</span><span class="p">);</span>

	<span class="n">pci_disable_link_state</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCIE_LINK_STATE_L0S</span> <span class="o">|</span>
			       <span class="n">PCIE_LINK_STATE_L1</span> <span class="o">|</span> <span class="n">PCIE_LINK_STATE_CLKPM</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to enable PCI device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable bus mastering (pci_disable_device may disable this) */</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">HPSA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;cannot obtain PCI resources, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hpsa_interrupt_mode</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">hpsa_pci_find_memory_BAR</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_free_res</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">remap_pci_mem</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">,</span> <span class="mh">0x250</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_free_res</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">hpsa_wait_for_board_state</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">BOARD_READY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_free_res</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">hpsa_find_cfgtables</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_free_res</span><span class="p">;</span>
	<span class="n">hpsa_find_board_params</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpsa_CISS_signature_present</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_free_res</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hpsa_enable_scsi_prefetch</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">hpsa_p600_dma_prefetch_quirk</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">hpsa_enter_simple_mode</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_free_res</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_free_res:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">hpsa_hba_inquiry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

<span class="cp">#define HBA_INQUIRY_BYTE_COUNT 64</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">hba_inquiry_data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">HBA_INQUIRY_BYTE_COUNT</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hba_inquiry_data</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_scsi_do_inquiry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">RAID_CTLR_LUNID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">hba_inquiry_data</span><span class="p">,</span> <span class="n">HBA_INQUIRY_BYTE_COUNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hba_inquiry_data</span><span class="p">);</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">hba_inquiry_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__devinit</span> <span class="kt">int</span> <span class="nf">hpsa_init_reset_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reset_devices</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Reset the controller with a PCI power-cycle or via doorbell */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_kdump_hard_reset_controller</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* -ENOTSUPP here means we cannot reset the controller</span>
<span class="cm">	 * but it&#39;s already (and still) up and running in</span>
<span class="cm">	 * &quot;performant mode&quot;.  Or, it might be 640x, which can&#39;t reset</span>
<span class="cm">	 * due to concerns about shared bbwc between 6402/6404 pair.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span> <span class="cm">/* just try to do the kdump anyhow. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* Now try to get the controller to respond to a no-op */</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Waiting for controller to respond to no-op</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HPSA_POST_RESET_NOOP_RETRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_noop</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no-op failed%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">11</span> <span class="o">?</span> <span class="s">&quot;; re-trying&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__devinit</span> <span class="kt">int</span> <span class="nf">hpsa_allocate_cmd_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool_bits</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span>
		<span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span><span class="p">,</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span> <span class="o">*</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
		    <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">),</span>
		    <span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool_dhandle</span><span class="p">));</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">errinfo_pool</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
		    <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">errinfo_pool</span><span class="p">),</span>
		    <span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">errinfo_pool_dhandle</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool_bits</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">errinfo_pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;out of memory in %s&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_free_cmd_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool_bits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			    <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">CommandList</span><span class="p">),</span>
			    <span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool_dhandle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">errinfo_pool</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			    <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ErrorInfo</span><span class="p">),</span>
			    <span class="n">h</span><span class="o">-&gt;</span><span class="n">errinfo_pool</span><span class="p">,</span>
			    <span class="n">h</span><span class="o">-&gt;</span><span class="n">errinfo_pool_dhandle</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_request_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="n">irqreturn_t</span> <span class="p">(</span><span class="o">*</span><span class="n">msixhandler</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
	<span class="n">irqreturn_t</span> <span class="p">(</span><span class="o">*</span><span class="n">intxhandler</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize h-&gt;q[x] = x so that interrupt handlers know which</span>
<span class="cm">	 * queue to process.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_REPLY_QUEUES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">intr_mode</span> <span class="o">==</span> <span class="n">PERF_MODE_INT</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">msix_vector</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If performant mode and MSI-X, use multiple reply queues */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_REPLY_QUEUES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">msixhandler</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">devname</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Use single reply pool */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">msix_vector</span> <span class="o">||</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">msi_vector</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">],</span>
				<span class="n">msixhandler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">devname</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">],</span>
				<span class="n">intxhandler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">devname</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to get irq %d for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">h</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">],</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">devname</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hpsa_kdump_soft_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_send_host_reset</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">RAID_CTLR_LUNID</span><span class="p">,</span>
		<span class="n">HPSA_RESET_TYPE_CONTROLLER</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Resetting array controller failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Waiting for board to soft reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_wait_for_board_state</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">BOARD_NOT_READY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Soft reset had no effect.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Board reset, awaiting READY status.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_wait_for_board_state</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">BOARD_READY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Board failed to become ready &quot;</span>
			<span class="s">&quot;after soft reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">msix_vector</span> <span class="o">||</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">intr_mode</span> <span class="o">!=</span> <span class="n">PERF_MODE_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Single reply queue, only one irq to free */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">;</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_REPLY_QUEUES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_free_irqs_and_disable_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_irqs</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PCI_MSI</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">msix_vector</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">msix_enabled</span><span class="p">)</span>
			<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">msi_vector</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">msi_enabled</span><span class="p">)</span>
			<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI_MSI */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_undo_allocations_after_kdump_soft_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hpsa_free_irqs_and_disable_msix</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">hpsa_free_sg_chain_blocks</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">hpsa_free_cmd_pool</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">blockFetchTable</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool_size</span><span class="p">,</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool_dhandle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_ctlr_from_lockup_detector_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockup_detector_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpsa_lockup_detector</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lockup_detected</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* already stopped the lockup detector */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lockup_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Called when controller lockup detected. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fail_all_cmds_on_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* Mark all outstanding commands as failed and complete them. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">CommandList</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">CommandStatus</span> <span class="o">=</span> <span class="n">CMD_HARDWARE_ERR</span><span class="p">;</span>
		<span class="n">finish_cmd</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">controller_lockup_detected</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockup_detector_lock</span><span class="p">);</span>
	<span class="n">remove_ctlr_from_lockup_detector_list</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">.</span><span class="n">set_intr_mask</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">HPSA_INTR_OFF</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">lockup_detected</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">SA5_SCRATCHPAD_OFFSET</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Controller lockup detected: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">lockup_detected</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">fail_all_cmds_on_list</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmpQ</span><span class="p">);</span>
	<span class="n">fail_all_cmds_on_list</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">reqQ</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">detect_controller_lockup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">now</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">heartbeat</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockup_detector_lock</span><span class="p">);</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">get_jiffies_64</span><span class="p">();</span>
	<span class="cm">/* If we&#39;ve received an interrupt recently, we&#39;re ok. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after64</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">last_intr_timestamp</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">heartbeat_sample_interval</span><span class="p">),</span> <span class="n">now</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;ve already checked the heartbeat recently, we&#39;re ok.</span>
<span class="cm">	 * This could happen if someone sends us a signal. We</span>
<span class="cm">	 * otherwise don&#39;t care about signals in this thread.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after64</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">last_heartbeat_timestamp</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">heartbeat_sample_interval</span><span class="p">),</span> <span class="n">now</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* If heartbeat has not changed since we last looked, we&#39;re not ok. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">heartbeat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">HeartBeat</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">last_heartbeat</span> <span class="o">==</span> <span class="n">heartbeat</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">controller_lockup_detected</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We&#39;re ok. */</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">last_heartbeat</span> <span class="o">=</span> <span class="n">heartbeat</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">last_heartbeat_timestamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">detect_controller_lockup_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">notused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">HEARTBEAT_SAMPLE_INTERVAL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockup_detector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hpsa_ctlr_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">h</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ctlr_info</span><span class="p">,</span> <span class="n">lockup_list</span><span class="p">);</span>
			<span class="n">detect_controller_lockup</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockup_detector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_ctlr_to_lockup_detector_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">h</span><span class="o">-&gt;</span><span class="n">heartbeat_sample_interval</span> <span class="o">=</span> <span class="n">HEARTBEAT_SAMPLE_INTERVAL</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockup_detector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lockup_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hpsa_ctlr_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockup_detector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_controller_lockup_detector</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Start the lockup detector thread if not already started */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpsa_lockup_detector</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockup_detector_lock</span><span class="p">);</span>
		<span class="n">hpsa_lockup_detector</span> <span class="o">=</span>
			<span class="n">kthread_run</span><span class="p">(</span><span class="n">detect_controller_lockup_thread</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">,</span> <span class="n">HPSA</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpsa_lockup_detector</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Could not start lockup detector thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">add_ctlr_to_lockup_detector_list</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">stop_controller_lockup_detector</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockup_detector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">remove_ctlr_from_lockup_detector_list</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="cm">/* If the list of ctlr&#39;s to monitor is empty, stop the thread */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpsa_ctlr_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockup_detector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">hpsa_lockup_detector</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockup_detector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">hpsa_lockup_detector</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockup_detector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hpsa_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dac</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">try_soft_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">number_of_controllers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">DRIVER_NAME</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_init_reset_devices</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="cm">/* If the reset fails in a particular way (it has no way to do</span>
<span class="cm">		 * a proper hard reset, so returns -ENOTSUPP) we can try to do</span>
<span class="cm">		 * a soft reset once we get the controller configured up to the</span>
<span class="cm">		 * point that it can accept a command.</span>
<span class="cm">		 */</span>
		<span class="n">try_soft_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">reinit_after_soft_reset:</span>

	<span class="cm">/* Command structures must be aligned on a 32-byte boundary because</span>
<span class="cm">	 * the 5 lower bits of the address are used by the hardware. and by</span>
<span class="cm">	 * the driver.  See comments in hpsa.h for more info.</span>
<span class="cm">	 */</span>
<span class="cp">#define COMMANDLIST_ALIGNMENT 32</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">CommandList</span><span class="p">)</span> <span class="o">%</span> <span class="n">COMMANDLIST_ALIGNMENT</span><span class="p">);</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">intr_mode</span> <span class="o">=</span> <span class="n">hpsa_simple_mode</span> <span class="o">?</span> <span class="n">SIMPLE_MODE_INT</span> <span class="o">:</span> <span class="n">PERF_MODE_INT</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmpQ</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">reqQ</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_pci_init</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">clean1</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">devname</span><span class="p">,</span> <span class="n">HPSA</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">number_of_controllers</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">ctlr</span> <span class="o">=</span> <span class="n">number_of_controllers</span><span class="p">;</span>
	<span class="n">number_of_controllers</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* configure PCI DMA stuff */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dac</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no suitable DMA available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">clean1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* make sure the board interrupts are off */</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">.</span><span class="n">set_intr_mask</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">HPSA_INTR_OFF</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_request_irq</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">do_hpsa_intr_msi</span><span class="p">,</span> <span class="n">do_hpsa_intr_intx</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">clean2</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: &lt;0x%x&gt; at IRQ %d%s using DAC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">h</span><span class="o">-&gt;</span><span class="n">devname</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
	       <span class="n">h</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">],</span> <span class="n">dac</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot; not&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_allocate_cmd_pool</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">clean4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_allocate_sg_chain_blocks</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">clean4</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_wait_queue</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">scan_finished</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* no scan currently in progress */</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">ndevices</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_host</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">);</span>
	<span class="n">hpsa_put_ctlr_into_performant_mode</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>

	<span class="cm">/* At this point, the controller is ready to take commands.</span>
<span class="cm">	 * Now, if reset_devices and the hard reset didn&#39;t work, try</span>
<span class="cm">	 * the soft reset and see if that works.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">try_soft_reset</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* This is kind of gross.  We may or may not get a completion</span>
<span class="cm">		 * from the soft reset command, and if we do, then the value</span>
<span class="cm">		 * from the fifo may or may not be valid.  So, we wait 10 secs</span>
<span class="cm">		 * after the reset throwing away any completions we get during</span>
<span class="cm">		 * that time.  Unregister the interrupt handler and register</span>
<span class="cm">		 * fake ones to scoop up any residual completions.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">.</span><span class="n">set_intr_mask</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">HPSA_INTR_OFF</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">free_irqs</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_request_irq</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">hpsa_msix_discard_completions</span><span class="p">,</span>
					<span class="n">hpsa_intx_discard_completions</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to request_irq after &quot;</span>
				<span class="s">&quot;soft reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">clean4</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">hpsa_kdump_soft_reset</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="cm">/* Neither hard nor soft reset worked, we&#39;re hosed. */</span>
			<span class="k">goto</span> <span class="n">clean4</span><span class="p">;</span>

		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Board READY.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Waiting for stale completions to drain.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">.</span><span class="n">set_intr_mask</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">HPSA_INTR_ON</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">.</span><span class="n">set_intr_mask</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">HPSA_INTR_OFF</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">controller_reset_failed</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Soft reset appears to have failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* since the controller&#39;s reset, we have to go back and re-init</span>
<span class="cm">		 * everything.  Easiest to just forget what we&#39;ve done and do it</span>
<span class="cm">		 * all over again.</span>
<span class="cm">		 */</span>
		<span class="n">hpsa_undo_allocations_after_kdump_soft_reset</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
		<span class="n">try_soft_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="cm">/* don&#39;t go to clean4, we already unallocated */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">reinit_after_soft_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Turn the interrupts on so we can service requests */</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">.</span><span class="n">set_intr_mask</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">HPSA_INTR_ON</span><span class="p">);</span>

	<span class="n">hpsa_hba_inquiry</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">hpsa_register_scsi</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>	<span class="cm">/* hook ourselves into SCSI subsystem */</span>
	<span class="n">start_controller_lockup_detector</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">clean4:</span>
	<span class="n">hpsa_free_sg_chain_blocks</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">hpsa_free_cmd_pool</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">free_irqs</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
<span class="nl">clean2:</span>
<span class="nl">clean1:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_flush_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">flush_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">CommandList</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">flush_buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flush_buf</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">cmd_special_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cmd_special_alloc returned NULL!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_of_memory</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fill_cmd</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">HPSA_CACHE_FLUSH</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">flush_buf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">RAID_CTLR_LUNID</span><span class="p">,</span> <span class="n">TYPE_CMD</span><span class="p">);</span>
	<span class="n">hpsa_scsi_do_simple_cmd_with_retry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">err_info</span><span class="o">-&gt;</span><span class="n">CommandStatus</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;error flushing cache on controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">cmd_special_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="nl">out_of_memory:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">flush_buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpsa_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>

	<span class="n">h</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="cm">/* Turn board interrupts off  and send the flush cache command</span>
<span class="cm">	 * sendcmd will turn off interrupt, and send the flush...</span>
<span class="cm">	 * To write all data in the battery backed cache to disks</span>
<span class="cm">	 */</span>
	<span class="n">hpsa_flush_cache</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">.</span><span class="n">set_intr_mask</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">HPSA_INTR_OFF</span><span class="p">);</span>
	<span class="n">hpsa_free_irqs_and_disable_msix</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">hpsa_free_device_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">ndevices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">hpsa_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to remove device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">stop_controller_lockup_detector</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">hpsa_unregister_scsi</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>	<span class="cm">/* unhook from SCSI subsystem */</span>
	<span class="n">hpsa_shutdown</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="p">);</span>
	<span class="n">hpsa_free_device_info</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">hpsa_free_sg_chain_blocks</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">CommandList</span><span class="p">),</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool_dhandle</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_cmds</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ErrorInfo</span><span class="p">),</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">errinfo_pool</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">errinfo_pool_dhandle</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool_size</span><span class="p">,</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool_dhandle</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_pool_bits</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">blockFetchTable</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hba_inquiry_data</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_suspend</span><span class="p">(</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">))</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">))</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpsa_resume</span><span class="p">(</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">))</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">hpsa_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">HPSA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">hpsa_init_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">hpsa_remove_one</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">hpsa_pci_device_id</span><span class="p">,</span>	<span class="cm">/* id_table */</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">hpsa_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">hpsa_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">hpsa_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Fill in bucket_map[], given nsgs (the max number of</span>
<span class="cm"> * scatter gather elements supported) and bucket[],</span>
<span class="cm"> * which is an array of 8 integers.  The bucket[] array</span>
<span class="cm"> * contains 8 different DMA transfer sizes (in 16</span>
<span class="cm"> * byte increments) which the controller uses to fetch</span>
<span class="cm"> * commands.  This function fills in bucket_map[], which</span>
<span class="cm"> * maps a given number of scatter gather elements to one of</span>
<span class="cm"> * the 8 DMA transfer sizes.  The point of it is to allow the</span>
<span class="cm"> * controller to only do as much DMA as needed to fetch the</span>
<span class="cm"> * command, with the DMA transfer size encoded in the lower</span>
<span class="cm"> * bits of the command address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>  <span class="nf">calc_bucket_map</span><span class="p">(</span><span class="kt">int</span> <span class="n">bucket</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">num_buckets</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">nsgs</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bucket_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* even a command with 0 SGs requires 4 blocks */</span>
<span class="cp">#define MINIMUM_TRANSFER_BLOCKS 4</span>
<span class="cp">#define NUM_BUCKETS 8</span>
	<span class="cm">/* Note, bucket_map must have nsgs+1 entries. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nsgs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Compute size of a command with i SG entries */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">MINIMUM_TRANSFER_BLOCKS</span><span class="p">;</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">num_buckets</span><span class="p">;</span> <span class="cm">/* Assume the biggest bucket */</span>
		<span class="cm">/* Find the bucket that is just big enough */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bucket</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">b</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* for a command with i SG entries, use bucket b. */</span>
		<span class="n">bucket_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__devinit</span> <span class="kt">void</span> <span class="nf">hpsa_enter_performant_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">use_short_tags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">register_value</span><span class="p">;</span>

	<span class="cm">/* This is a bit complicated.  There are 8 registers on</span>
<span class="cm">	 * the controller which we write to to tell it 8 different</span>
<span class="cm">	 * sizes of commands which there may be.  It&#39;s a way of</span>
<span class="cm">	 * reducing the DMA done to fetch each command.  Encoded into</span>
<span class="cm">	 * each command&#39;s tag are 3 bits which communicate to the controller</span>
<span class="cm">	 * which of the eight sizes that command fits within.  The size of</span>
<span class="cm">	 * each command depends on how many scatter gather entries there are.</span>
<span class="cm">	 * Each SG entry requires 16 bytes.  The eight registers are programmed</span>
<span class="cm">	 * with the number of 16-byte blocks a command of that size requires.</span>
<span class="cm">	 * The smallest command possible requires 5 such 16 byte blocks.</span>
<span class="cm">	 * the largest command possible requires SG_ENTRIES_IN_CMD + 4 16-byte</span>
<span class="cm">	 * blocks.  Note, this only extends to the SG entries contained</span>
<span class="cm">	 * within the command block, and does not extend to chained blocks</span>
<span class="cm">	 * of SG elements.   bft[] contains the eight values we write to</span>
<span class="cm">	 * the registers.  They are not evenly distributed, but have more</span>
<span class="cm">	 * sizes for small commands, and fewer sizes for larger commands.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">bft</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="n">SG_ENTRIES_IN_CMD</span> <span class="o">+</span> <span class="mi">4</span><span class="p">};</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="mi">28</span> <span class="o">&gt;</span> <span class="n">SG_ENTRIES_IN_CMD</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="cm">/*  5 = 1 s/g entry or 4k</span>
<span class="cm">	 *  6 = 2 s/g entry or 8k</span>
<span class="cm">	 *  8 = 4 s/g entry or 16k</span>
<span class="cm">	 * 10 = 6 s/g entry or 24k</span>
<span class="cm">	 */</span>

	<span class="cm">/* Controller spec: zero out this buffer. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool_size</span><span class="p">);</span>

	<span class="n">bft</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">SG_ENTRIES_IN_CMD</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">calc_bucket_map</span><span class="p">(</span><span class="n">bft</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">bft</span><span class="p">),</span>
				<span class="n">SG_ENTRIES_IN_CMD</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">blockFetchTable</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">bft</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span><span class="o">-&gt;</span><span class="n">BlockFetch</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* size of controller ring buffer */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">max_commands</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span><span class="o">-&gt;</span><span class="n">RepQSize</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">nreply_queues</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span><span class="o">-&gt;</span><span class="n">RepQCount</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span><span class="o">-&gt;</span><span class="n">RepQCtrAddrLow32</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span><span class="o">-&gt;</span><span class="n">RepQCtrAddrHigh32</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nreply_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span><span class="o">-&gt;</span><span class="n">RepQAddr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">upper</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool_dhandle</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">max_commands</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">transtable</span><span class="o">-&gt;</span><span class="n">RepQAddr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lower</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">CFGTBL_Trans_Performant</span> <span class="o">|</span> <span class="n">use_short_tags</span> <span class="o">|</span>
		<span class="n">CFGTBL_Trans_enable_directed_msix</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">HostWrite</span><span class="p">.</span><span class="n">TransportRequest</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">CFGTBL_ChangeReq</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">SA5_DOORBELL</span><span class="p">);</span>
	<span class="n">hpsa_wait_for_mode_change_ack</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">register_value</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">TransportActive</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">register_value</span> <span class="o">&amp;</span> <span class="n">CFGTBL_Trans_Performant</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to get board into&quot;</span>
					<span class="s">&quot; performant mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Change the access methods to the performant access methods */</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">access</span> <span class="o">=</span> <span class="n">SA5_performant_access</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">transMethod</span> <span class="o">=</span> <span class="n">CFGTBL_Trans_Performant</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__devinit</span> <span class="kt">void</span> <span class="nf">hpsa_put_ctlr_into_performant_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctlr_info</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">trans_support</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hpsa_simple_mode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">trans_support</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfgtable</span><span class="o">-&gt;</span><span class="n">TransportSupport</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trans_support</span> <span class="o">&amp;</span> <span class="n">PERFORMANT_MODE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">h</span><span class="o">-&gt;</span><span class="n">nreply_queues</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">msix_vector</span> <span class="o">?</span> <span class="n">MAX_REPLY_QUEUES</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hpsa_get_max_perf_mode_cmds</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="cm">/* Performant mode ring buffer and supporting data structures */</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool_size</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_commands</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nreply_queues</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool_size</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool_dhandle</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nreply_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">max_commands</span> <span class="o">*</span> <span class="n">i</span><span class="p">];</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_commands</span><span class="p">;</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wraparound</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* spec: init to 1 */</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">current_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Need a block fetch table for performant mode */</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">blockFetchTable</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(((</span><span class="n">SG_ENTRIES_IN_CMD</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">blockFetchTable</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>

	<span class="n">hpsa_enter_performant_mode</span><span class="p">(</span><span class="n">h</span><span class="p">,</span>
		<span class="n">trans_support</span> <span class="o">&amp;</span> <span class="n">CFGTBL_Trans_use_short_tags</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">clean_up:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool_size</span><span class="p">,</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">reply_pool_dhandle</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">blockFetchTable</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  This is it.  Register the PCI driver information for the cards we control</span>
<span class="cm"> *  the OS will call our registered routines when it finds one of our cards.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hpsa_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpsa_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">hpsa_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpsa_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">hpsa_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">hpsa_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
