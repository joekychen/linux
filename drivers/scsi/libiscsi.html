<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › libiscsi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>libiscsi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * iSCSI lib functions</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.</span>
<span class="cm"> * Copyright (C) 2004 - 2006 Mike Christie</span>
<span class="cm"> * Copyright (C) 2004 - 2005 Dmitry Yusupov</span>
<span class="cm"> * Copyright (C) 2004 - 2005 Alex Aizman</span>
<span class="cm"> * maintained by open-iscsi@googlegroups.com</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kfifo.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/iscsi_proto.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_iscsi.h&gt;</span>
<span class="cp">#include &lt;scsi/libiscsi.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">iscsi_dbg_lib_conn</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">debug_libiscsi_conn</span><span class="p">,</span> <span class="n">iscsi_dbg_lib_conn</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
		   <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug_libiscsi_conn</span><span class="p">,</span>
		 <span class="s">&quot;Turn on debugging for connections in libiscsi module. &quot;</span>
		 <span class="s">&quot;Set to 1 to turn on, and zero to turn off. Default is off.&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">iscsi_dbg_lib_session</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">debug_libiscsi_session</span><span class="p">,</span> <span class="n">iscsi_dbg_lib_session</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
		   <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug_libiscsi_session</span><span class="p">,</span>
		 <span class="s">&quot;Turn on debugging for sessions in libiscsi module. &quot;</span>
		 <span class="s">&quot;Set to 1 to turn on, and zero to turn off. Default is off.&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">iscsi_dbg_lib_eh</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">debug_libiscsi_eh</span><span class="p">,</span> <span class="n">iscsi_dbg_lib_eh</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
		   <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug_libiscsi_eh</span><span class="p">,</span>
		 <span class="s">&quot;Turn on debugging for error handling in libiscsi module. &quot;</span>
		 <span class="s">&quot;Set to 1 to turn on, and zero to turn off. Default is off.&quot;</span><span class="p">);</span>

<span class="cp">#define ISCSI_DBG_CONN(_conn, dbg_fmt, arg...)			\</span>
<span class="cp">	do {							\</span>
<span class="cp">		if (iscsi_dbg_lib_conn)				\</span>
<span class="cp">			iscsi_conn_printk(KERN_INFO, _conn,	\</span>
<span class="cp">					     &quot;%s &quot; dbg_fmt,	\</span>
<span class="cp">					     __func__, ##arg);	\</span>
<span class="cp">	} while (0);</span>

<span class="cp">#define ISCSI_DBG_SESSION(_session, dbg_fmt, arg...)			\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (iscsi_dbg_lib_session)				\</span>
<span class="cp">			iscsi_session_printk(KERN_INFO, _session,	\</span>
<span class="cp">					     &quot;%s &quot; dbg_fmt,		\</span>
<span class="cp">					     __func__, ##arg);		\</span>
<span class="cp">	} while (0);</span>

<span class="cp">#define ISCSI_DBG_EH(_session, dbg_fmt, arg...)				\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (iscsi_dbg_lib_eh)					\</span>
<span class="cp">			iscsi_session_printk(KERN_INFO, _session,	\</span>
<span class="cp">					     &quot;%s &quot; dbg_fmt,		\</span>
<span class="cp">					     __func__, ##arg);		\</span>
<span class="cp">	} while (0);</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iscsi_conn_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">)</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">xmitwork</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_conn_queue_work</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__iscsi_update_cmdsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
				 <span class="kt">uint32_t</span> <span class="n">exp_cmdsn</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">max_cmdsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * standard specifies this check for when to update expected and</span>
<span class="cm">	 * max sequence numbers</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_sna_lt</span><span class="p">(</span><span class="n">max_cmdsn</span><span class="p">,</span> <span class="n">exp_cmdsn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">exp_cmdsn</span> <span class="o">!=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">exp_cmdsn</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">iscsi_sna_lt</span><span class="p">(</span><span class="n">exp_cmdsn</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">exp_cmdsn</span><span class="p">))</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">exp_cmdsn</span> <span class="o">=</span> <span class="n">exp_cmdsn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_cmdsn</span> <span class="o">!=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">max_cmdsn</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">iscsi_sna_lt</span><span class="p">(</span><span class="n">max_cmdsn</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">max_cmdsn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">max_cmdsn</span> <span class="o">=</span> <span class="n">max_cmdsn</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * if the window closed with IO queued, then kick the</span>
<span class="cm">		 * xmit thread</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span><span class="o">-&gt;</span><span class="n">cmdqueue</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span><span class="o">-&gt;</span><span class="n">mgmtqueue</span><span class="p">))</span>
			<span class="n">iscsi_conn_queue_work</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">iscsi_update_cmdsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_nopin</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__iscsi_update_cmdsn</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">exp_cmdsn</span><span class="p">),</span>
			     <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">max_cmdsn</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_update_cmdsn</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_prep_data_out_pdu - initialize Data-Out</span>
<span class="cm"> * @task: scsi command task</span>
<span class="cm"> * @r2t: R2T info</span>
<span class="cm"> * @hdr: iscsi data in pdu</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	Initialize Data-Out within this R2T sequence and finds</span>
<span class="cm"> *	proper data_offset within this SCSI command.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called with connection lock taken.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">iscsi_prep_data_out_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_r2t_info</span> <span class="o">*</span><span class="n">r2t</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">iscsi_data</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">r2t</span><span class="o">-&gt;</span><span class="n">data_length</span> <span class="o">-</span> <span class="n">r2t</span><span class="o">-&gt;</span><span class="n">sent</span><span class="p">;</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_data</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_data</span><span class="p">));</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">ttt</span> <span class="o">=</span> <span class="n">r2t</span><span class="o">-&gt;</span><span class="n">ttt</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">datasn</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">r2t</span><span class="o">-&gt;</span><span class="n">datasn</span><span class="p">);</span>
	<span class="n">r2t</span><span class="o">-&gt;</span><span class="n">datasn</span><span class="o">++</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">ISCSI_OP_SCSI_DATA_OUT</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_itt</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">exp_statsn</span> <span class="o">=</span> <span class="n">r2t</span><span class="o">-&gt;</span><span class="n">exp_statsn</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">r2t</span><span class="o">-&gt;</span><span class="n">data_offset</span> <span class="o">+</span> <span class="n">r2t</span><span class="o">-&gt;</span><span class="n">sent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">max_xmit_dlength</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hton24</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">dlength</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">max_xmit_dlength</span><span class="p">);</span>
		<span class="n">r2t</span><span class="o">-&gt;</span><span class="n">data_count</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">max_xmit_dlength</span><span class="p">;</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hton24</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">dlength</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
		<span class="n">r2t</span><span class="o">-&gt;</span><span class="n">data_count</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ISCSI_FLAG_CMD_FINAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">dataout_pdus_cnt</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_prep_data_out_pdu</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iscsi_add_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">exp_len</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_len</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">exp_len</span> <span class="o">&gt;</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ISCSI_PAD_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span> <span class="cm">/* caller must pad the AHS */</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_len</span> <span class="o">=</span> <span class="n">exp_len</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * make an extended cdb AHS</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iscsi_prep_ecdb_ahs</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rlen</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ahslength</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_ecdb_ahdr</span> <span class="o">*</span><span class="n">ecdb_ahdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ecdb_ahdr</span> <span class="o">=</span> <span class="n">iscsi_next_hdr</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">rlen</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">-</span> <span class="n">ISCSI_CDB_SIZE</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rlen</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ecdb_ahdr</span><span class="o">-&gt;</span><span class="n">ecdb</span><span class="p">));</span>
	<span class="n">ahslength</span> <span class="o">=</span> <span class="n">rlen</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ecdb_ahdr</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">);</span>

	<span class="n">pad_len</span> <span class="o">=</span> <span class="n">iscsi_padding</span><span class="p">(</span><span class="n">rlen</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_add_hdr</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ecdb_ahdr</span><span class="o">-&gt;</span><span class="n">ahslength</span><span class="p">)</span> <span class="o">+</span>
	                   <span class="k">sizeof</span><span class="p">(</span><span class="n">ecdb_ahdr</span><span class="o">-&gt;</span><span class="n">ahstype</span><span class="p">)</span> <span class="o">+</span> <span class="n">ahslength</span> <span class="o">+</span> <span class="n">pad_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pad_len</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ecdb_ahdr</span><span class="o">-&gt;</span><span class="n">ecdb</span><span class="p">[</span><span class="n">rlen</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">);</span>

	<span class="n">ecdb_ahdr</span><span class="o">-&gt;</span><span class="n">ahslength</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ahslength</span><span class="p">);</span>
	<span class="n">ecdb_ahdr</span><span class="o">-&gt;</span><span class="n">ahstype</span> <span class="o">=</span> <span class="n">ISCSI_AHSTYPE_CDB</span><span class="p">;</span>
	<span class="n">ecdb_ahdr</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ecdb_ahdr</span><span class="o">-&gt;</span><span class="n">ecdb</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span> <span class="o">+</span> <span class="n">ISCSI_CDB_SIZE</span><span class="p">,</span> <span class="n">rlen</span><span class="p">);</span>

	<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span>
			  <span class="s">&quot;iscsi_prep_ecdb_ahs: varlen_cdb_len %d &quot;</span>
		          <span class="s">&quot;rlen %d pad_len %d ahs_length %d iscsi_headers_size &quot;</span>
		          <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">,</span> <span class="n">rlen</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">,</span> <span class="n">ahslength</span><span class="p">,</span>
		          <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_len</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iscsi_prep_bidi_ahs</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_rlength_ahdr</span> <span class="o">*</span><span class="n">rlen_ahdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rlen_ahdr</span> <span class="o">=</span> <span class="n">iscsi_next_hdr</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_add_hdr</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rlen_ahdr</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rlen_ahdr</span><span class="o">-&gt;</span><span class="n">ahslength</span> <span class="o">=</span>
		<span class="n">cpu_to_be16</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">rlen_ahdr</span><span class="o">-&gt;</span><span class="n">read_length</span><span class="p">)</span> <span class="o">+</span>
						  <span class="k">sizeof</span><span class="p">(</span><span class="n">rlen_ahdr</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">));</span>
	<span class="n">rlen_ahdr</span><span class="o">-&gt;</span><span class="n">ahstype</span> <span class="o">=</span> <span class="n">ISCSI_AHSTYPE_RLENGTH</span><span class="p">;</span>
	<span class="n">rlen_ahdr</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rlen_ahdr</span><span class="o">-&gt;</span><span class="n">read_length</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">scsi_in</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span>
			  <span class="s">&quot;bidi-in rlen_ahdr-&gt;read_length(%d) &quot;</span>
		          <span class="s">&quot;rlen_ahdr-&gt;ahslength(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		          <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rlen_ahdr</span><span class="o">-&gt;</span><span class="n">read_length</span><span class="p">),</span>
		          <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">rlen_ahdr</span><span class="o">-&gt;</span><span class="n">ahslength</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_check_tmf_restrictions - check if a task is affected by TMF</span>
<span class="cm"> * @task: iscsi task</span>
<span class="cm"> * @opcode: opcode to check for</span>
<span class="cm"> *</span>
<span class="cm"> * During TMF a task has to be checked if it&#39;s affected.</span>
<span class="cm"> * All unrelated I/O can be passed through, but I/O to the</span>
<span class="cm"> * affected LUN should be restricted.</span>
<span class="cm"> * If &#39;fast_abort&#39; is set we won&#39;t be sending any I/O to the</span>
<span class="cm"> * affected LUN.</span>
<span class="cm"> * Otherwise the target is waiting for all TTTs to be completed,</span>
<span class="cm"> * so we have to send all outstanding Data-Out PDUs to the target.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iscsi_check_tmf_restrictions</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_tm</span> <span class="o">*</span><span class="n">tmf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmhdr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hdr_lun</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">==</span> <span class="n">TMF_INITIAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tmf</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">ISCSI_OPCODE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ISCSI_OP_SCSI_TMFUNC</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ISCSI_TM_FUNC_VALUE</span><span class="p">(</span><span class="n">tmf</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ISCSI_TM_FUNC_LOGICAL_UNIT_RESET</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Allow PDUs for unrelated LUNs</span>
<span class="cm">		 */</span>
		<span class="n">hdr_lun</span> <span class="o">=</span> <span class="n">scsilun_to_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmf</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdr_lun</span> <span class="o">!=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">ISCSI_TM_FUNC_TARGET_WARM_RESET</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Fail all SCSI cmd PDUs</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">!=</span> <span class="n">ISCSI_OP_SCSI_DATA_OUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span>
					  <span class="s">&quot;task [op %x/%x itt &quot;</span>
					  <span class="s">&quot;0x%x/0x%x] &quot;</span>
					  <span class="s">&quot;rejected.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span>
					  <span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_itt</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * And also all data-out PDUs in response to R2T</span>
<span class="cm">		 * if fast_abort is set.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">fast_abort</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span>
					  <span class="s">&quot;task [op %x/%x itt &quot;</span>
					  <span class="s">&quot;0x%x/0x%x] fast abort.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span>
					  <span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_itt</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_TM_FUNC_ABORT_TASK</span>:
		<span class="cm">/*</span>
<span class="cm">		 * the caller has already checked if the task</span>
<span class="cm">		 * they want to abort was in the pending queue so if</span>
<span class="cm">		 * we are here the cmd pdu has gone out already, and</span>
<span class="cm">		 * we will only hit this for data-outs</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">ISCSI_OP_SCSI_DATA_OUT</span> <span class="o">&amp;&amp;</span>
		    <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_itt</span> <span class="o">==</span> <span class="n">tmf</span><span class="o">-&gt;</span><span class="n">rtt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span>
					  <span class="s">&quot;Preventing task %x/%x from sending &quot;</span>
					  <span class="s">&quot;data-out due to abort task in &quot;</span>
					  <span class="s">&quot;progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">,</span>
					  <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_itt</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_prep_scsi_cmd_pdu - prep iscsi scsi cmd pdu</span>
<span class="cm"> * @task: iscsi task</span>
<span class="cm"> *</span>
<span class="cm"> * Prep basic iSCSI PDU fields for a scsi cmd pdu. The LLD should set</span>
<span class="cm"> * fields like dlength or final based on how much data it sends</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iscsi_prep_scsi_cmd_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_scsi_req</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">hdrlength</span><span class="p">,</span> <span class="n">cmd_len</span><span class="p">;</span>
	<span class="n">itt_t</span> <span class="n">itt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_check_tmf_restrictions</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ISCSI_OP_SCSI_CMD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">alloc_pdu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">alloc_pdu</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ISCSI_OP_SCSI_CMD</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_scsi_req</span> <span class="o">*</span><span class="p">)</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">itt</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">parse_pdu_itt</span><span class="p">)</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_itt</span> <span class="o">=</span> <span class="n">itt</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_itt</span> <span class="o">=</span> <span class="n">build_itt</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">,</span>
						     <span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">);</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_add_hdr</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">ISCSI_OP_SCSI_CMD</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ISCSI_ATTR_SIMPLE</span><span class="p">;</span>
	<span class="n">int_to_scsilun</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">exp_statsn</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">exp_statsn</span><span class="p">);</span>
	<span class="n">cmd_len</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_len</span> <span class="o">&lt;</span> <span class="n">ISCSI_CDB_SIZE</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="n">cmd_len</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ISCSI_CDB_SIZE</span> <span class="o">-</span> <span class="n">cmd_len</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd_len</span> <span class="o">&gt;</span> <span class="n">ISCSI_CDB_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_prep_ecdb_ahs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">cmd_len</span> <span class="o">=</span> <span class="n">ISCSI_CDB_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">cmd_len</span><span class="p">);</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">imm_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_bidi_cmnd</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ISCSI_FLAG_CMD_READ</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_prep_bidi_ahs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">out_len</span> <span class="o">=</span> <span class="n">scsi_out</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">iscsi_r2t_info</span> <span class="o">*</span><span class="n">r2t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">unsol_r2t</span><span class="p">;</span>

		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_length</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">out_len</span><span class="p">);</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ISCSI_FLAG_CMD_WRITE</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Write counters:</span>
<span class="cm">		 *</span>
<span class="cm">		 *	imm_count	bytes to be sent right after</span>
<span class="cm">		 *			SCSI PDU Header</span>
<span class="cm">		 *</span>
<span class="cm">		 *	unsol_count	bytes(as Data-Out) to be sent</span>
<span class="cm">		 *			without	R2T ack right after</span>
<span class="cm">		 *			immediate data</span>
<span class="cm">		 *</span>
<span class="cm">		 *	r2t data_length bytes to be sent via R2T ack&#39;s</span>
<span class="cm">		 *</span>
<span class="cm">		 *      pad_count       bytes to be sent as zero-padding</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">r2t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">r2t</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">imm_data_en</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">out_len</span> <span class="o">&gt;=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">first_burst</span><span class="p">)</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">imm_count</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">first_burst</span><span class="p">,</span>
							<span class="n">conn</span><span class="o">-&gt;</span><span class="n">max_xmit_dlength</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">imm_count</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">out_len</span><span class="p">,</span>
							<span class="n">conn</span><span class="o">-&gt;</span><span class="n">max_xmit_dlength</span><span class="p">);</span>
			<span class="n">hton24</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">dlength</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">imm_count</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">zero_data</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">dlength</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">initial_r2t_en</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r2t</span><span class="o">-&gt;</span><span class="n">data_length</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">first_burst</span><span class="p">,</span> <span class="n">out_len</span><span class="p">)</span> <span class="o">-</span>
					       <span class="n">task</span><span class="o">-&gt;</span><span class="n">imm_count</span><span class="p">;</span>
			<span class="n">r2t</span><span class="o">-&gt;</span><span class="n">data_offset</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">imm_count</span><span class="p">;</span>
			<span class="n">r2t</span><span class="o">-&gt;</span><span class="n">ttt</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">ISCSI_RESERVED_TAG</span><span class="p">);</span>
			<span class="n">r2t</span><span class="o">-&gt;</span><span class="n">exp_statsn</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">exp_statsn</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">unsol_r2t</span><span class="p">.</span><span class="n">data_length</span><span class="p">)</span>
			<span class="cm">/* No unsolicit Data-Out&#39;s */</span>
			<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ISCSI_FLAG_CMD_FINAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ISCSI_FLAG_CMD_FINAL</span><span class="p">;</span>
		<span class="n">zero_data</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">dlength</span><span class="p">);</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_length</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">scsi_in</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span>
			<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ISCSI_FLAG_CMD_READ</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* calculate size of additional header segments (AHSs) */</span>
	<span class="n">hdrlength</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">hdrlength</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ISCSI_PAD_LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">hdrlength</span> <span class="o">/=</span> <span class="n">ISCSI_PAD_LEN</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">hdrlength</span> <span class="o">&gt;=</span> <span class="mi">256</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">hlength</span> <span class="o">=</span> <span class="n">hdrlength</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">cmdsn</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">cmdsn</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdsn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">init_task</span> <span class="o">&amp;&amp;</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">init_task</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_TASK_RUNNING</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdsn</span><span class="o">++</span><span class="p">;</span>

	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">scsicmd_pdus_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;iscsi prep [%s cid %d sc %p cdb 0x%x &quot;</span>
			  <span class="s">&quot;itt 0x%x len %d bidi_len %d cmdsn %d win %d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">scsi_bidi_cmnd</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;bidirectional&quot;</span> <span class="o">:</span>
			  <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span> <span class="o">?</span>
			  <span class="s">&quot;write&quot;</span> <span class="o">:</span> <span class="s">&quot;read&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			  <span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">,</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">sc</span><span class="p">),</span>
			  <span class="n">scsi_bidi_cmnd</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">?</span> <span class="n">scsi_in</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			  <span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdsn</span><span class="p">,</span>
			  <span class="n">session</span><span class="o">-&gt;</span><span class="n">max_cmdsn</span> <span class="o">-</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">exp_cmdsn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_free_task - free a task</span>
<span class="cm"> * @task: iscsi cmd task</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with session lock.</span>
<span class="cm"> * This function returns the scsi command to scsi-ml or cleans</span>
<span class="cm"> * up mgmt tasks then returns the task to the pool.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_free_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oldstate</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;freeing task itt 0x%x state %d sc %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="p">);</span>

	<span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">cleanup_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_TASK_FREE</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * login task is preallocated so do not free</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">login_task</span> <span class="o">==</span> <span class="n">task</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">kfifo_in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdpool</span><span class="p">.</span><span class="n">queue</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">task</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* SCSI eh reuses commands to verify us */</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * queue command may call this to free the task, so</span>
<span class="cm">		 * it will decide how to return sc to scsi-ml.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldstate</span> <span class="o">!=</span> <span class="n">ISCSI_TASK_REQUEUE_SCSIQ</span><span class="p">)</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__iscsi_get_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__iscsi_get_task</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__iscsi_put_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
		<span class="n">iscsi_free_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__iscsi_put_task</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">iscsi_put_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">__iscsi_put_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_put_task</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_complete_task - finish a task</span>
<span class="cm"> * @task: iscsi cmd task</span>
<span class="cm"> * @state: state to complete task with</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with session lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_complete_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">;</span>

	<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span>
			  <span class="s">&quot;complete task itt 0x%x state %d sc %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_TASK_COMPLETED</span> <span class="o">||</span>
	    <span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_TASK_ABRT_TMF</span> <span class="o">||</span>
	    <span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_TASK_ABRT_SESS_RECOV</span> <span class="o">||</span>
	    <span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_TASK_REQUEUE_SCSIQ</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_TASK_FREE</span><span class="p">);</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">==</span> <span class="n">task</span><span class="p">)</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_task</span> <span class="o">==</span> <span class="n">task</span><span class="p">)</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* release get from queueing */</span>
	<span class="n">__iscsi_put_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_complete_scsi_task - finish scsi task normally</span>
<span class="cm"> * @task: iscsi task for scsi cmd</span>
<span class="cm"> * @exp_cmdsn: expected cmd sn in cpu format</span>
<span class="cm"> * @max_cmdsn: max cmd sn in cpu format</span>
<span class="cm"> *</span>
<span class="cm"> * This is used when drivers do not need or cannot perform</span>
<span class="cm"> * lower level pdu processing.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with session lock</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iscsi_complete_scsi_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
			      <span class="kt">uint32_t</span> <span class="n">exp_cmdsn</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">max_cmdsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">;</span>

	<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;[itt 0x%x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">);</span>

	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">last_recv</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">__iscsi_update_cmdsn</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="n">exp_cmdsn</span><span class="p">,</span> <span class="n">max_cmdsn</span><span class="p">);</span>
	<span class="n">iscsi_complete_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ISCSI_TASK_COMPLETED</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_complete_scsi_task</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * session lock must be held and if not called for a task that is</span>
<span class="cm"> * still pending or from the xmit thread, then xmit thread must</span>
<span class="cm"> * be suspended.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fail_scsi_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if a command completes and we get a successful tmf response</span>
<span class="cm">	 * we will hit this because the scsi eh abort code does not take</span>
<span class="cm">	 * a ref to the task.</span>
<span class="cm">	 */</span>
	<span class="n">sc</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_TASK_PENDING</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * cmd never made it to the xmit thread, so we should not count</span>
<span class="cm">		 * the cmd in the sequencing</span>
<span class="cm">		 */</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">queued_cmdsn</span><span class="o">--</span><span class="p">;</span>
		<span class="cm">/* it was never sent so just complete like normal */</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_TASK_COMPLETED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">DID_TRANSPORT_DISRUPTED</span><span class="p">)</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_TASK_ABRT_SESS_RECOV</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_TASK_ABRT_TMF</span><span class="p">;</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_bidi_cmnd</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span>
		<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">sc</span><span class="p">));</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">scsi_out</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">resid</span> <span class="o">=</span> <span class="n">scsi_out</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">scsi_in</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">resid</span> <span class="o">=</span> <span class="n">scsi_in</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iscsi_complete_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iscsi_prep_mgmt_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_hdr</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_nopout</span> <span class="o">*</span><span class="n">nop</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_nopout</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">opcode</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">ISCSI_OPCODE_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_STATE_LOGGING_OUT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">!=</span> <span class="n">ISCSI_OP_LOGIN</span> <span class="o">&amp;&amp;</span> <span class="n">opcode</span> <span class="o">!=</span> <span class="n">ISCSI_OP_TEXT</span><span class="p">)</span>
		<span class="n">nop</span><span class="o">-&gt;</span><span class="n">exp_statsn</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">exp_statsn</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * pre-format CmdSN for outgoing PDU.</span>
<span class="cm">	 */</span>
	<span class="n">nop</span><span class="o">-&gt;</span><span class="n">cmdsn</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdsn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span> <span class="o">!=</span> <span class="n">RESERVED_ITT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * TODO: We always use immediate for normal session pdus.</span>
<span class="cm">		 * If we start to send tmfs or nops as non-immediate then</span>
<span class="cm">		 * we should start checking the cmdsn numbers for mgmt tasks.</span>
<span class="cm">		 *</span>
<span class="cm">		 * During discovery sessions iscsid sends TEXT as non immediate,</span>
<span class="cm">		 * but we always only send one PDU at a time.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">c_stage</span> <span class="o">==</span> <span class="n">ISCSI_CONN_STARTED</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">ISCSI_OP_IMMEDIATE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">session</span><span class="o">-&gt;</span><span class="n">queued_cmdsn</span><span class="o">++</span><span class="p">;</span>
			<span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdsn</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">init_task</span> <span class="o">&amp;&amp;</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">init_task</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">ISCSI_OPCODE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">ISCSI_OP_LOGOUT</span><span class="p">)</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_STATE_LOGGING_OUT</span><span class="p">;</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_TASK_RUNNING</span><span class="p">;</span>
	<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;mgmtpdu [op 0x%x hdr-&gt;itt 0x%x &quot;</span>
			  <span class="s">&quot;datalen %d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">ISCSI_OPCODE_MASK</span><span class="p">,</span>
			  <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">data_count</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span>
<span class="nf">__iscsi_conn_send_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
		      <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">data_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">uint8_t</span> <span class="n">opcode</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">ISCSI_OPCODE_MASK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="n">itt_t</span> <span class="n">itt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_STATE_TERMINATE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">ISCSI_OP_LOGIN</span> <span class="o">||</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">ISCSI_OP_TEXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Login and Text are sent serially, in</span>
<span class="cm">		 * request-followed-by-response sequence.</span>
<span class="cm">		 * Same task can be used. Same ITT must be used.</span>
<span class="cm">		 * Note that login_task is preallocated at conn_create().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">login_task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">ISCSI_TASK_FREE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="s">&quot;Login/Text in &quot;</span>
					  <span class="s">&quot;progress. Cannot start new task.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">task</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">login_task</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">ISCSI_STATE_LOGGED_IN</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">c_stage</span> <span class="o">==</span> <span class="n">ISCSI_CONN_INITIAL_STAGE</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">c_stage</span> <span class="o">==</span> <span class="n">ISCSI_CONN_STOPPED</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kfifo_out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdpool</span><span class="p">.</span><span class="n">queue</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">task</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * released in complete pdu for task we expect a response for, and</span>
<span class="cm">	 * released by the lld when it has transmitted the task for</span>
<span class="cm">	 * pdus we do not expect a response for.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span> <span class="o">=</span> <span class="n">conn</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">);</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_TASK_PENDING</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">data_count</span> <span class="o">=</span> <span class="n">data_size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">data_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">alloc_pdu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">alloc_pdu</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="s">&quot;Could not allocate &quot;</span>
					 <span class="s">&quot;pdu for mgmt task.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">free_task</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">itt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_hdr</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_hdr</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span> <span class="o">!=</span> <span class="n">RESERVED_ITT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">parse_pdu_itt</span><span class="p">)</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span> <span class="o">=</span> <span class="n">itt</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span> <span class="o">=</span> <span class="n">build_itt</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">,</span>
						   <span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_prep_mgmt_task</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">task</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">free_task</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">xmit_task</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">free_task</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">mgmtqueue</span><span class="p">);</span>
		<span class="n">iscsi_conn_queue_work</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">task</span><span class="p">;</span>

<span class="nl">free_task:</span>
	<span class="n">__iscsi_put_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iscsi_conn_send_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_cls_conn</span> <span class="o">*</span><span class="n">cls_conn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">data_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">cls_conn</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__iscsi_conn_send_pdu</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_size</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_conn_send_pdu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_cmd_rsp - SCSI Command Response processing</span>
<span class="cm"> * @conn: iscsi connection</span>
<span class="cm"> * @hdr: iscsi header</span>
<span class="cm"> * @task: scsi command task</span>
<span class="cm"> * @data: cmd data buffer</span>
<span class="cm"> * @datalen: len of buffer</span>
<span class="cm"> *</span>
<span class="cm"> * iscsi_cmd_rsp sets up the scsi_cmnd fields based on the PDU and</span>
<span class="cm"> * then completes the command and task.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_scsi_cmd_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">datalen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_scsi_rsp</span> <span class="o">*</span><span class="n">rhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_scsi_rsp</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="p">;</span>

	<span class="n">iscsi_update_cmdsn</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_nopin</span><span class="o">*</span><span class="p">)</span><span class="n">rhdr</span><span class="p">);</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">exp_statsn</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">statsn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">cmd_status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">response</span> <span class="o">!=</span> <span class="n">ISCSI_STATUS_CMD_COMPLETED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">==</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint16_t</span> <span class="n">senselen</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">datalen</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">invalid_datalen:</span>
			<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span>  <span class="n">conn</span><span class="p">,</span>
					 <span class="s">&quot;Got CHECK_CONDITION but invalid data &quot;</span>
					 <span class="s">&quot;buffer size of %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">senselen</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">datalen</span> <span class="o">&lt;</span> <span class="n">senselen</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">invalid_datalen</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
		       <span class="n">min_t</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">,</span> <span class="n">senselen</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">));</span>
		<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;copied %d bytes of sense</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">min_t</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">,</span> <span class="n">senselen</span><span class="p">,</span>
				  <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ISCSI_FLAG_CMD_BIDI_UNDERFLOW</span> <span class="o">|</span>
			   <span class="n">ISCSI_FLAG_CMD_BIDI_OVERFLOW</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">res_count</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">bi_residual_count</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_bidi_cmnd</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">res_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ISCSI_FLAG_CMD_BIDI_OVERFLOW</span> <span class="o">||</span>
				 <span class="n">res_count</span> <span class="o">&lt;=</span> <span class="n">scsi_in</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">))</span>
			<span class="n">scsi_in</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">resid</span> <span class="o">=</span> <span class="n">res_count</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">cmd_status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ISCSI_FLAG_CMD_UNDERFLOW</span> <span class="o">|</span>
	                   <span class="n">ISCSI_FLAG_CMD_OVERFLOW</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">res_count</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">residual_count</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">res_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ISCSI_FLAG_CMD_OVERFLOW</span> <span class="o">||</span>
		     <span class="n">res_count</span> <span class="o">&lt;=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">sc</span><span class="p">)))</span>
			<span class="cm">/* write side for bidi or uni-io set_resid */</span>
			<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">res_count</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">cmd_status</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;cmd rsp done [sc %p res %d itt 0x%x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">sc</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">);</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">scsirsp_pdus_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">iscsi_complete_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ISCSI_TASK_COMPLETED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_data_in_rsp - SCSI Data-In Response processing</span>
<span class="cm"> * @conn: iscsi connection</span>
<span class="cm"> * @hdr:  iscsi pdu</span>
<span class="cm"> * @task: scsi command task</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">iscsi_data_in_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_data_rsp</span> <span class="o">*</span><span class="n">rhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_data_rsp</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ISCSI_FLAG_DATA_STATUS</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">iscsi_update_cmdsn</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_nopin</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">cmd_status</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">exp_statsn</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">statsn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ISCSI_FLAG_DATA_UNDERFLOW</span> <span class="o">|</span>
	                   <span class="n">ISCSI_FLAG_DATA_OVERFLOW</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">res_count</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">residual_count</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">res_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ISCSI_FLAG_CMD_OVERFLOW</span> <span class="o">||</span>
		     <span class="n">res_count</span> <span class="o">&lt;=</span> <span class="n">scsi_in</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">))</span>
			<span class="n">scsi_in</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">resid</span> <span class="o">=</span> <span class="n">res_count</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">cmd_status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;data in with status done &quot;</span>
			  <span class="s">&quot;[sc %p res %d itt 0x%x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">sc</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">);</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">scsirsp_pdus_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">iscsi_complete_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ISCSI_TASK_COMPLETED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_tmf_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_tm_rsp</span> <span class="o">*</span><span class="n">tmf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_tm_rsp</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">;</span>

	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">exp_statsn</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">statsn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmfrsp_pdus_cnt</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">!=</span> <span class="n">TMF_QUEUED</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmf</span><span class="o">-&gt;</span><span class="n">response</span> <span class="o">==</span> <span class="n">ISCSI_TMF_RSP_COMPLETE</span><span class="p">)</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_SUCCESS</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tmf</span><span class="o">-&gt;</span><span class="n">response</span> <span class="o">==</span> <span class="n">ISCSI_TMF_RSP_NO_TASK</span><span class="p">)</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_NOT_FOUND</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_FAILED</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ehwait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_send_nopout</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_nopin</span> <span class="o">*</span><span class="n">rhdr</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">iscsi_nopout</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rhdr</span> <span class="o">&amp;&amp;</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_task</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_nopout</span><span class="p">));</span>
	<span class="n">hdr</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">ISCSI_OP_NOOP_OUT</span> <span class="o">|</span> <span class="n">ISCSI_OP_IMMEDIATE</span><span class="p">;</span>
	<span class="n">hdr</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ISCSI_FLAG_CMD_FINAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rhdr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">lun</span> <span class="o">=</span> <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">ttt</span> <span class="o">=</span> <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">ttt</span><span class="p">;</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">itt</span> <span class="o">=</span> <span class="n">RESERVED_ITT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">ttt</span> <span class="o">=</span> <span class="n">RESERVED_ITT</span><span class="p">;</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">__iscsi_conn_send_pdu</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_hdr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">hdr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="s">&quot;Could not send nopout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rhdr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* only track our nops */</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_task</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">last_ping</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iscsi_nop_out_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">iscsi_nopin</span> <span class="o">*</span><span class="n">nop</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_task</span> <span class="o">!=</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this is not in response to one of our</span>
<span class="cm">		 * nops then it must be from userspace.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_recv_pdu</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">cls_conn</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">nop</span><span class="p">,</span>
				   <span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">))</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ISCSI_ERR_CONN_FAILED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">transport_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">recv_timeout</span><span class="p">);</span>
	<span class="n">iscsi_complete_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ISCSI_TASK_COMPLETED</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iscsi_handle_reject</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_reject</span> <span class="o">*</span><span class="n">reject</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_reject</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_hdr</span> <span class="n">rejected_pdu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">exp_statsn</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">reject</span><span class="o">-&gt;</span><span class="n">statsn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ntoh24</span><span class="p">(</span><span class="n">reject</span><span class="o">-&gt;</span><span class="n">dlength</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">datalen</span> <span class="o">||</span>
	    <span class="n">ntoh24</span><span class="p">(</span><span class="n">reject</span><span class="o">-&gt;</span><span class="n">dlength</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="s">&quot;Cannot handle rejected &quot;</span>
				  <span class="s">&quot;pdu. Invalid data length (pdu dlength &quot;</span>
				  <span class="s">&quot;%u, datalen %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">reject</span><span class="o">-&gt;</span><span class="n">dlength</span><span class="p">),</span>
				  <span class="n">datalen</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ISCSI_ERR_PROTO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rejected_pdu</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_hdr</span><span class="p">));</span>
	<span class="n">opcode</span> <span class="o">=</span> <span class="n">rejected_pdu</span><span class="p">.</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">ISCSI_OPCODE_MASK</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reject</span><span class="o">-&gt;</span><span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ISCSI_REASON_DATA_DIGEST_ERROR</span>:
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span>
				  <span class="s">&quot;pdu (op 0x%x itt 0x%x) rejected &quot;</span>
				  <span class="s">&quot;due to DataDigest error.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">rejected_pdu</span><span class="p">.</span><span class="n">itt</span><span class="p">,</span> <span class="n">opcode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_REASON_IMM_CMD_REJECT</span>:
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span>
				  <span class="s">&quot;pdu (op 0x%x itt 0x%x) rejected. Too many &quot;</span>
				  <span class="s">&quot;immediate commands.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">rejected_pdu</span><span class="p">.</span><span class="n">itt</span><span class="p">,</span> <span class="n">opcode</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We only send one TMF at a time so if the target could not</span>
<span class="cm">		 * handle it, then it should get fixed (RFC mandates that</span>
<span class="cm">		 * a target can handle one immediate TMF per conn).</span>
<span class="cm">		 *</span>
<span class="cm">		 * For nops-outs, we could have sent more than one if</span>
<span class="cm">		 * the target is sending us lots of nop-ins</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">!=</span> <span class="n">ISCSI_OP_NOOP_OUT</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		 <span class="k">if</span> <span class="p">(</span><span class="n">rejected_pdu</span><span class="p">.</span><span class="n">itt</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">ISCSI_RESERVED_TAG</span><span class="p">))</span>
			<span class="cm">/*</span>
<span class="cm">			 * nop-out in response to target&#39;s nop-out rejected.</span>
<span class="cm">			 * Just resend.</span>
<span class="cm">			 */</span>
			<span class="n">iscsi_send_nopout</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span>
					  <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_nopin</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rejected_pdu</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Our nop as ping got dropped. We know the target</span>
<span class="cm">			 * and transport are ok so just clean up</span>
<span class="cm">			 */</span>
			<span class="n">task</span> <span class="o">=</span> <span class="n">iscsi_itt_to_task</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">rejected_pdu</span><span class="p">.</span><span class="n">itt</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span>
						 <span class="s">&quot;Invalid pdu reject. Could &quot;</span>
						 <span class="s">&quot;not lookup rejected task.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">ISCSI_ERR_BAD_ITT</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_nop_out_rsp</span><span class="p">(</span><span class="n">task</span><span class="p">,</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_nopin</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rejected_pdu</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span>
				  <span class="s">&quot;pdu (op 0x%x itt 0x%x) rejected. Reason &quot;</span>
				  <span class="s">&quot;code 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rejected_pdu</span><span class="p">.</span><span class="n">itt</span><span class="p">,</span>
				  <span class="n">rejected_pdu</span><span class="p">.</span><span class="n">opcode</span><span class="p">,</span> <span class="n">reject</span><span class="o">-&gt;</span><span class="n">reason</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_itt_to_task - look up task by itt</span>
<span class="cm"> * @conn: iscsi connection</span>
<span class="cm"> * @itt: itt</span>
<span class="cm"> *</span>
<span class="cm"> * This should be used for mgmt tasks like login and nops, or if</span>
<span class="cm"> * the LDD&#39;s itt space does not include the session age.</span>
<span class="cm"> *</span>
<span class="cm"> * The session lock must be held.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="nf">iscsi_itt_to_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="n">itt_t</span> <span class="n">itt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">itt</span> <span class="o">==</span> <span class="n">RESERVED_ITT</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">parse_pdu_itt</span><span class="p">)</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">parse_pdu_itt</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">itt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">get_itt</span><span class="p">(</span><span class="n">itt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds_max</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_itt_to_task</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __iscsi_complete_pdu - complete pdu</span>
<span class="cm"> * @conn: iscsi conn</span>
<span class="cm"> * @hdr: iscsi header</span>
<span class="cm"> * @data: data buffer</span>
<span class="cm"> * @datalen: len of data buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Completes pdu processing by freeing any resources allocated at</span>
<span class="cm"> * queuecommand or send generic. session lock must be held and verify</span>
<span class="cm"> * itt must have been called.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__iscsi_complete_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">opcode</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">ISCSI_OPCODE_MASK</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">itt</span><span class="p">;</span>

	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">last_recv</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_verify_itt</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span> <span class="o">!=</span> <span class="n">RESERVED_ITT</span><span class="p">)</span>
		<span class="n">itt</span> <span class="o">=</span> <span class="n">get_itt</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">itt</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">;</span>

	<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;[op 0x%x cid %d itt 0x%x len %d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">opcode</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">itt</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">itt</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0U</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iscsi_update_cmdsn</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_nopin</span><span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>

		<span class="k">switch</span><span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ISCSI_OP_NOOP_IN</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">datalen</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">ISCSI_ERR_PROTO</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">ttt</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">ISCSI_RESERVED_TAG</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">iscsi_send_nopout</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_nopin</span><span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISCSI_OP_REJECT</span>:
			<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_handle_reject</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISCSI_OP_ASYNC_EVENT</span>:
			<span class="n">conn</span><span class="o">-&gt;</span><span class="n">exp_statsn</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">statsn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_recv_pdu</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">cls_conn</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">))</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">ISCSI_ERR_CONN_FAILED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ISCSI_ERR_BAD_OPCODE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ISCSI_OP_SCSI_CMD_RSP</span>:
	<span class="k">case</span> <span class="n">ISCSI_OP_SCSI_DATA_IN</span>:
		<span class="n">task</span> <span class="o">=</span> <span class="n">iscsi_itt_to_ctask</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ISCSI_ERR_BAD_ITT</span><span class="p">;</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">last_xfer</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_OP_R2T</span>:
		<span class="cm">/*</span>
<span class="cm">		 * LLD handles R2Ts if they need to.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_OP_LOGOUT_RSP</span>:
	<span class="k">case</span> <span class="n">ISCSI_OP_LOGIN_RSP</span>:
	<span class="k">case</span> <span class="n">ISCSI_OP_TEXT_RSP</span>:
	<span class="k">case</span> <span class="n">ISCSI_OP_SCSI_TMFUNC_RSP</span>:
	<span class="k">case</span> <span class="n">ISCSI_OP_NOOP_IN</span>:
		<span class="n">task</span> <span class="o">=</span> <span class="n">iscsi_itt_to_task</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ISCSI_ERR_BAD_ITT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">ISCSI_ERR_BAD_OPCODE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ISCSI_OP_SCSI_CMD_RSP</span>:
		<span class="n">iscsi_scsi_cmd_rsp</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_OP_SCSI_DATA_IN</span>:
		<span class="n">iscsi_data_in_rsp</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_OP_LOGOUT_RSP</span>:
		<span class="n">iscsi_update_cmdsn</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_nopin</span><span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">datalen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ISCSI_ERR_PROTO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">exp_statsn</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">statsn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">recv_pdu</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_OP_LOGIN_RSP</span>:
	<span class="k">case</span> <span class="n">ISCSI_OP_TEXT_RSP</span>:
		<span class="n">iscsi_update_cmdsn</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_nopin</span><span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * login related PDU&#39;s exp_statsn is handled in</span>
<span class="cm">		 * userspace</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">recv_pdu</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_OP_SCSI_TMFUNC_RSP</span>:
		<span class="n">iscsi_update_cmdsn</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_nopin</span><span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">datalen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ISCSI_ERR_PROTO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">iscsi_tmf_rsp</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
		<span class="n">iscsi_complete_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ISCSI_TASK_COMPLETED</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_OP_NOOP_IN</span>:
		<span class="n">iscsi_update_cmdsn</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_nopin</span><span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">ttt</span> <span class="o">!=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">ISCSI_RESERVED_TAG</span><span class="p">)</span> <span class="o">||</span> <span class="n">datalen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ISCSI_ERR_PROTO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">exp_statsn</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">statsn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_nop_out_rsp</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_nopin</span><span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">,</span>
				       <span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ISCSI_ERR_BAD_OPCODE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="nl">recv_pdu:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_recv_pdu</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">cls_conn</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ISCSI_ERR_CONN_FAILED</span><span class="p">;</span>
	<span class="n">iscsi_complete_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ISCSI_TASK_COMPLETED</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__iscsi_complete_pdu</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">iscsi_complete_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
		       <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">__iscsi_complete_pdu</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_complete_pdu</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">iscsi_verify_itt</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="n">itt_t</span> <span class="n">itt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">itt</span> <span class="o">==</span> <span class="n">RESERVED_ITT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">parse_pdu_itt</span><span class="p">)</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">parse_pdu_itt</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">itt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">age</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">get_itt</span><span class="p">(</span><span class="n">itt</span><span class="p">);</span>
		<span class="n">age</span> <span class="o">=</span> <span class="p">((</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">itt</span> <span class="o">&gt;&gt;</span> <span class="n">ISCSI_AGE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ISCSI_AGE_MASK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">age</span> <span class="o">!=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span>
				  <span class="s">&quot;received itt %x expected session age (%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">itt</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ISCSI_ERR_BAD_ITT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds_max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span>
				  <span class="s">&quot;received invalid itt index %u (max cmds &quot;</span>
				   <span class="s">&quot;%u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds_max</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ISCSI_ERR_BAD_ITT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_verify_itt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_itt_to_ctask - look up ctask by itt</span>
<span class="cm"> * @conn: iscsi connection</span>
<span class="cm"> * @itt: itt</span>
<span class="cm"> *</span>
<span class="cm"> * This should be used for cmd tasks.</span>
<span class="cm"> *</span>
<span class="cm"> * The session lock must be held.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="nf">iscsi_itt_to_ctask</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="n">itt_t</span> <span class="n">itt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_verify_itt</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">itt</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">iscsi_itt_to_task</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">itt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span> <span class="o">||</span> <span class="o">!</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">!=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iscsi_session_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span>
				  <span class="s">&quot;task&#39;s session age %d, expected %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">task</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_itt_to_ctask</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">iscsi_session_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">iscsi_err</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">conn</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_STATE_TERMINATE</span> <span class="o">||</span> <span class="o">!</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">cls_conn</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
	        <span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * if the host is being removed bypass the connection</span>
<span class="cm">	 * recovery initialization because we are going to kill</span>
<span class="cm">	 * the session.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">ISCSI_ERR_INVALID_HOST</span><span class="p">)</span>
		<span class="n">iscsi_conn_error_event</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">cls_conn</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">iscsi_conn_failure</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_session_failure</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">iscsi_conn_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="k">enum</span> <span class="n">iscsi_err</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_STATE_FAILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">stop_stage</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_STATE_FAILED</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">ISCSI_SUSPEND_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">suspend_tx</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">ISCSI_SUSPEND_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">suspend_rx</span><span class="p">);</span>
	<span class="n">iscsi_conn_error_event</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">cls_conn</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_conn_failure</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iscsi_check_cmdsn_window_closed</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for iSCSI window and take care of CmdSN wrap-around</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iscsi_sna_lte</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">queued_cmdsn</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">max_cmdsn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;iSCSI CmdSN closed. ExpCmdSn &quot;</span>
				  <span class="s">&quot;%u MaxCmdSN %u CmdSN %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">session</span><span class="o">-&gt;</span><span class="n">exp_cmdsn</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">max_cmdsn</span><span class="p">,</span>
				  <span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdsn</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">queued_cmdsn</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iscsi_xmit_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ISCSI_SUSPEND_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">suspend_tx</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>

	<span class="n">__iscsi_get_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">xmit_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* done with this task */</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">last_xfer</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__iscsi_put_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_requeue_task - requeue task to run from session workqueue</span>
<span class="cm"> * @task: task to requeue</span>
<span class="cm"> *</span>
<span class="cm"> * LLDs that need to run a task from the session workqueue should call</span>
<span class="cm"> * this. The session lock must be held. This should only be called</span>
<span class="cm"> * by software drivers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iscsi_requeue_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * this may be on the requeue list already if the xmit_task callout</span>
<span class="cm">	 * is handling the r2ts while we are adding new ones</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">))</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">requeue</span><span class="p">);</span>
	<span class="n">iscsi_conn_queue_work</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_requeue_task</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_data_xmit - xmit any command into the scheduled connection</span>
<span class="cm"> * @conn: iscsi connection</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	The function can return -EAGAIN in which case the caller must</span>
<span class="cm"> *	re-schedule it again later or recover. &#39;0&#39; return code means</span>
<span class="cm"> *	successful xmit.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iscsi_data_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ISCSI_SUSPEND_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">suspend_tx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;Tx suspended!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_xmit_task</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
	        <span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		        <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * process mgmt pdus like nops before commands since we should</span>
<span class="cm">	 * only have one nop-out as a ping from us and targets should not</span>
<span class="cm">	 * overflow us with nop-ins</span>
<span class="cm">	 */</span>
<span class="nl">check_mgmt:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">mgmtqueue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">mgmtqueue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">iscsi_task</span><span class="p">,</span> <span class="n">running</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_prep_mgmt_task</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__iscsi_put_task</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
			<span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_xmit_task</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* process pending command queue */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">cmdqueue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">cmdqueue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_task</span><span class="p">,</span>
					<span class="n">running</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_STATE_LOGGING_OUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fail_scsi_task</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">DID_IMM_RETRY</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_prep_scsi_cmd_pdu</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="o">||</span> <span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">cmdqueue</span><span class="p">);</span>
				<span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">fail_scsi_task</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">DID_ABORT</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_xmit_task</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * we could continuously get new task requests so</span>
<span class="cm">		 * we need to check the mgmt queue for nops that need to</span>
<span class="cm">		 * be sent to aviod starvation</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">mgmtqueue</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">check_mgmt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">requeue</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * we always do fastlogout - conn stop code will clean up.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_STATE_LOGGING_OUT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">task</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">requeue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_task</span><span class="p">,</span>
				  <span class="n">running</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_check_tmf_restrictions</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ISCSI_OP_SCSI_DATA_OUT</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">);</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_TASK_RUNNING</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_xmit_task</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">mgmtqueue</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">check_mgmt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_xmitworker</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_conn</span><span class="p">,</span> <span class="n">xmitwork</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * serialize Xmit worker on a per-connection basis.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_data_xmit</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="nf">iscsi_alloc_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kfifo_out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdpool</span><span class="p">.</span><span class="n">queue</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">task</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">task</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_TASK_PENDING</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">conn</span> <span class="o">=</span> <span class="n">conn</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span> <span class="o">=</span> <span class="n">sc</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">have_checked_conn</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">last_timeout</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">last_xfer</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">task</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">FAILURE_BAD_HOST</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">FAILURE_SESSION_FAILED</span><span class="p">,</span>
	<span class="n">FAILURE_SESSION_FREED</span><span class="p">,</span>
	<span class="n">FAILURE_WINDOW_CLOSED</span><span class="p">,</span>
	<span class="n">FAILURE_OOM</span><span class="p">,</span>
	<span class="n">FAILURE_SESSION_TERMINATE</span><span class="p">,</span>
	<span class="n">FAILURE_SESSION_IN_RECOVERY</span><span class="p">,</span>
	<span class="n">FAILURE_SESSION_RECOVERY_TIMEOUT</span><span class="p">,</span>
	<span class="n">FAILURE_SESSION_LOGGING_OUT</span><span class="p">,</span>
	<span class="n">FAILURE_SESSION_NOT_READY</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">iscsi_queuecommand</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span><span class="n">cls_session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reason</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ihost</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">cls_session</span> <span class="o">=</span> <span class="n">starget_to_session</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
	<span class="n">session</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">reason</span> <span class="o">=</span> <span class="n">iscsi_session_chkready</span><span class="p">(</span><span class="n">cls_session</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">reason</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fault</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">ISCSI_STATE_LOGGED_IN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * to handle the race between when we set the recovery state</span>
<span class="cm">		 * and block the session we requeue here (commands could</span>
<span class="cm">		 * be entering our queuecommand while a block is starting</span>
<span class="cm">		 * up because the block code is not locked)</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ISCSI_STATE_FAILED</span>:
		<span class="k">case</span> <span class="n">ISCSI_STATE_IN_RECOVERY</span>:
			<span class="n">reason</span> <span class="o">=</span> <span class="n">FAILURE_SESSION_IN_RECOVERY</span><span class="p">;</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_IMM_RETRY</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISCSI_STATE_LOGGING_OUT</span>:
			<span class="n">reason</span> <span class="o">=</span> <span class="n">FAILURE_SESSION_LOGGING_OUT</span><span class="p">;</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_IMM_RETRY</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISCSI_STATE_RECOVERY_FAILED</span>:
			<span class="n">reason</span> <span class="o">=</span> <span class="n">FAILURE_SESSION_RECOVERY_TIMEOUT</span><span class="p">;</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_TRANSPORT_FAILFAST</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISCSI_STATE_TERMINATE</span>:
			<span class="n">reason</span> <span class="o">=</span> <span class="n">FAILURE_SESSION_TERMINATE</span><span class="p">;</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">reason</span> <span class="o">=</span> <span class="n">FAILURE_SESSION_FREED</span><span class="p">;</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">fault</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">conn</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="n">FAILURE_SESSION_FREED</span><span class="p">;</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fault</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ISCSI_SUSPEND_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">suspend_tx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="n">FAILURE_SESSION_IN_RECOVERY</span><span class="p">;</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_REQUEUE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fault</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_check_cmdsn_window_closed</span><span class="p">(</span><span class="n">conn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="n">FAILURE_WINDOW_CLOSED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">reject</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">iscsi_alloc_task</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="n">FAILURE_OOM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">reject</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="n">iscsi_prep_scsi_cmd_pdu</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="o">||</span>  <span class="n">reason</span> <span class="o">==</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reason</span> <span class="o">=</span> <span class="n">FAILURE_OOM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">prepd_reject</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">prepd_fault</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">xmit_task</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdsn</span><span class="o">--</span><span class="p">;</span>
			<span class="n">reason</span> <span class="o">=</span> <span class="n">FAILURE_SESSION_NOT_READY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">prepd_reject</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">cmdqueue</span><span class="p">);</span>
		<span class="n">iscsi_conn_queue_work</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">session</span><span class="o">-&gt;</span><span class="n">queued_cmdsn</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">prepd_reject:</span>
	<span class="n">iscsi_complete_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ISCSI_TASK_REQUEUE_SCSIQ</span><span class="p">);</span>
<span class="nl">reject:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;cmd 0x%x rejected (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">sc</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reason</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SCSI_MLQUEUE_TARGET_BUSY</span><span class="p">;</span>

<span class="nl">prepd_fault:</span>
	<span class="n">iscsi_complete_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ISCSI_TASK_REQUEUE_SCSIQ</span><span class="p">);</span>
<span class="nl">fault:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;iscsi: cmd 0x%x is not queued (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">sc</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reason</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_bidi_cmnd</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span>
		<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">sc</span><span class="p">));</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">scsi_out</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">resid</span> <span class="o">=</span> <span class="n">scsi_out</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">scsi_in</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">resid</span> <span class="o">=</span> <span class="n">scsi_in</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_queuecommand</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">iscsi_change_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCSI_QDEPTH_DEFAULT</span>:
		<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">scsi_get_tag_type</span><span class="p">(</span><span class="n">sdev</span><span class="p">),</span> <span class="n">depth</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCSI_QDEPTH_QFULL</span>:
		<span class="n">scsi_track_queue_full</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCSI_QDEPTH_RAMP_UP</span>:
		<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">scsi_get_tag_type</span><span class="p">(</span><span class="n">sdev</span><span class="p">),</span> <span class="n">depth</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_change_queue_depth</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">iscsi_target_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span><span class="n">cls_session</span> <span class="o">=</span> <span class="n">starget_to_session</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="n">starget</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">scsi_cmds_max</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_target_alloc</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_tmf_timedout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">==</span> <span class="n">TMF_QUEUED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_TIMEDOUT</span><span class="p">;</span>
		<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;tmf timedout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* unblock eh_abort() */</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ehwait</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iscsi_exec_task_mgmt_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">iscsi_tm</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">__iscsi_conn_send_pdu</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">,</span>
				      <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="s">&quot;Could not send TMF.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">iscsi_conn_failure</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">ISCSI_ERR_CONN_FAILED</span><span class="p">);</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmfcmd_pdus_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">iscsi_tmf_timedout</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">conn</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_timer</span><span class="p">);</span>
	<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;tmf set timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * block eh thread until:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) tmf response</span>
<span class="cm">	 * 2) tmf timeout</span>
<span class="cm">	 * 3) session is terminated or restarted or userspace has</span>
<span class="cm">	 * given up on recovery</span>
<span class="cm">	 */</span>
	<span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ehwait</span><span class="p">,</span> <span class="n">age</span> <span class="o">!=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span> <span class="o">||</span>
				 <span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">ISCSI_STATE_LOGGED_IN</span> <span class="o">||</span>
				 <span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">!=</span> <span class="n">TMF_QUEUED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="n">flush_signals</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_timer</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* if the session drops it will clean up the task */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">age</span> <span class="o">!=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span> <span class="o">||</span>
	    <span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">ISCSI_STATE_LOGGED_IN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fail commands. session lock held and recv side suspended and xmit</span>
<span class="cm"> * thread flushed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fail_scsi_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">lun</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds_max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span> <span class="o">||</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_TASK_FREE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lun</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">lun</span> <span class="o">!=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span>
				  <span class="s">&quot;failing sc %p itt 0x%x state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">fail_scsi_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_suspend_queue - suspend iscsi_queuecommand</span>
<span class="cm"> * @conn: iscsi conn to stop queueing IO on</span>
<span class="cm"> *</span>
<span class="cm"> * This grabs the session lock to make sure no one is in</span>
<span class="cm"> * xmit_task/queuecommand, and then sets suspend to prevent</span>
<span class="cm"> * new commands from being queued. This only needs to be called</span>
<span class="cm"> * by offload drivers that need to sync a path like ep disconnect</span>
<span class="cm"> * with the iscsi_queuecommand/xmit_task. To start IO again libiscsi</span>
<span class="cm"> * will call iscsi_start_tx and iscsi_unblock_session when in FFP.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iscsi_suspend_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">ISCSI_SUSPEND_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">suspend_tx</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_suspend_queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_suspend_tx - suspend iscsi_data_xmit</span>
<span class="cm"> * @conn: iscsi conn tp stop processing IO on.</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets the suspend bit to prevent iscsi_data_xmit</span>
<span class="cm"> * from sending new IO, and if work is queued on the xmit thread</span>
<span class="cm"> * it will wait for it to be completed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iscsi_suspend_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">ISCSI_SUSPEND_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">suspend_tx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">)</span>
		<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_suspend_tx</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_start_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">ISCSI_SUSPEND_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">suspend_tx</span><span class="p">);</span>
	<span class="n">iscsi_conn_queue_work</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We want to make sure a ping is in flight. It has timed out.</span>
<span class="cm"> * And we are not busy processing a pdu that is making</span>
<span class="cm"> * progress but got started before the ping and is taking a while</span>
<span class="cm"> * to complete so the ping is just stuck behind it in a queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iscsi_has_ping_timed_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_task</span> <span class="o">&amp;&amp;</span>
	    <span class="n">time_before_eq</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">last_recv</span> <span class="o">+</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">recv_timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">+</span>
			   <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">),</span> <span class="n">jiffies</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">blk_eh_timer_return</span> <span class="nf">iscsi_eh_cmd_timed_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">blk_eh_timer_return</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">BLK_EH_NOT_HANDLED</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">running_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span><span class="n">cls_session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cls_session</span> <span class="o">=</span> <span class="n">starget_to_session</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
	<span class="n">session</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;scsi cmd %p timedout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">task</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="p">)</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Raced with completion. Blk layer has taken ownership</span>
<span class="cm">		 * so let timeout code complete it now.</span>
<span class="cm">		 */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">BLK_EH_HANDLED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">ISCSI_STATE_LOGGED_IN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are probably in the middle of iscsi recovery so let</span>
<span class="cm">		 * that complete and handle the error.</span>
<span class="cm">		 */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">BLK_EH_RESET_TIMER</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">conn</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* In the middle of shuting down */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">BLK_EH_RESET_TIMER</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have sent (at least queued to the network layer) a pdu or</span>
<span class="cm">	 * recvd one for the task since the last timeout ask for</span>
<span class="cm">	 * more time. If on the next timeout we have not made progress</span>
<span class="cm">	 * we can check if it is the task or connection when we send the</span>
<span class="cm">	 * nop as a ping.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">last_xfer</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">last_timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;Command making progress. Asking &quot;</span>
			     <span class="s">&quot;scsi-ml for more time to complete. &quot;</span>
			     <span class="s">&quot;Last data xfer at %lu. Last timeout was at &quot;</span>
			     <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">.&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">last_xfer</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">last_timeout</span><span class="p">);</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">have_checked_conn</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">BLK_EH_RESET_TIMER</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">recv_timeout</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_timeout</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * if the ping timedout then we are in the middle of cleaning up</span>
<span class="cm">	 * and can let the iscsi eh handle it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_has_ping_timed_out</span><span class="p">(</span><span class="n">conn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">BLK_EH_RESET_TIMER</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds_max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">running_task</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">running_task</span><span class="o">-&gt;</span><span class="n">sc</span> <span class="o">||</span> <span class="n">running_task</span> <span class="o">==</span> <span class="n">task</span> <span class="o">||</span>
		     <span class="n">running_task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">ISCSI_TASK_RUNNING</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Only check if cmds started before this one have made</span>
<span class="cm">		 * progress, or this could never fail</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">running_task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">jiffies_at_alloc</span><span class="p">,</span>
			       <span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">jiffies_at_alloc</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">running_task</span><span class="o">-&gt;</span><span class="n">last_xfer</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">last_timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This task has not made progress, but a task</span>
<span class="cm">			 * started before us has transferred data since</span>
<span class="cm">			 * we started/last-checked. We could be queueing</span>
<span class="cm">			 * too many tasks or the LU is bad.</span>
<span class="cm">			 *</span>
<span class="cm">			 * If the device is bad the cmds ahead of us on</span>
<span class="cm">			 * other devs will complete, and this loop will</span>
<span class="cm">			 * eventually fail starting the scsi eh.</span>
<span class="cm">			 */</span>
			<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;Command has not made progress &quot;</span>
				     <span class="s">&quot;but commands ahead of it have. &quot;</span>
				     <span class="s">&quot;Asking scsi-ml for more time to &quot;</span>
				     <span class="s">&quot;complete. Our last xfer vs running task &quot;</span>
				     <span class="s">&quot;last xfer %lu/%lu. Last check %lu.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">task</span><span class="o">-&gt;</span><span class="n">last_xfer</span><span class="p">,</span> <span class="n">running_task</span><span class="o">-&gt;</span><span class="n">last_xfer</span><span class="p">,</span>
				     <span class="n">task</span><span class="o">-&gt;</span><span class="n">last_timeout</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">BLK_EH_RESET_TIMER</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Assumes nop timeout is shorter than scsi cmd timeout */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">have_checked_conn</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Checking the transport already or nop from a cmd timeout still</span>
<span class="cm">	 * running</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">have_checked_conn</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">BLK_EH_RESET_TIMER</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure there is a transport check done */</span>
	<span class="n">iscsi_send_nopout</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">have_checked_conn</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">BLK_EH_RESET_TIMER</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">last_timeout</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;return %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">BLK_EH_RESET_TIMER</span> <span class="o">?</span>
		     <span class="s">&quot;timer reset&quot;</span> <span class="o">:</span> <span class="s">&quot;nh&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_check_transport_timeouts</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">recv_timeout</span><span class="p">,</span> <span class="n">next_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">last_recv</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">ISCSI_STATE_LOGGED_IN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">recv_timeout</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">recv_timeout</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">recv_timeout</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">recv_timeout</span> <span class="o">*=</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">last_recv</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">last_recv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_has_ping_timed_out</span><span class="p">(</span><span class="n">conn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="s">&quot;ping timeout of %d secs &quot;</span>
				  <span class="s">&quot;expired, recv timeout %d, last rx %lu, &quot;</span>
				  <span class="s">&quot;last ping %lu, now %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_timeout</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">recv_timeout</span><span class="p">,</span>
				  <span class="n">last_recv</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">last_ping</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">iscsi_conn_failure</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">ISCSI_ERR_CONN_FAILED</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_before_eq</span><span class="p">(</span><span class="n">last_recv</span> <span class="o">+</span> <span class="n">recv_timeout</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* send a ping to try to provoke some traffic */</span>
		<span class="n">ISCSI_DBG_CONN</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="s">&quot;Sending nopout as ping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">iscsi_send_nopout</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">next_timeout</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">last_ping</span> <span class="o">+</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">next_timeout</span> <span class="o">=</span> <span class="n">last_recv</span> <span class="o">+</span> <span class="n">recv_timeout</span><span class="p">;</span>

	<span class="n">ISCSI_DBG_CONN</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="s">&quot;Setting next tmo %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">next_timeout</span><span class="p">);</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">transport_timer</span><span class="p">,</span> <span class="n">next_timeout</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_prep_abort_task_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">iscsi_tm</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">ISCSI_OP_SCSI_TMFUNC</span> <span class="o">|</span> <span class="n">ISCSI_OP_IMMEDIATE</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ISCSI_TM_FUNC_ABORT_TASK</span> <span class="o">&amp;</span> <span class="n">ISCSI_FLAG_TM_FUNC_MASK</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ISCSI_FLAG_CMD_FINAL</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">rtt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">hdr_itt</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">refcmdsn</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">cmdsn</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iscsi_eh_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span><span class="n">cls_session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_tm</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">age</span><span class="p">;</span>

	<span class="n">cls_session</span> <span class="o">=</span> <span class="n">starget_to_session</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
	<span class="n">session</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;aborting sc %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * if session was ISCSI_STATE_IN_RECOVERY then we may not have</span>
<span class="cm">	 * got the command.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;sc never reached iscsi layer or &quot;</span>
				      <span class="s">&quot;it completed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are not logged in or we have started a new session</span>
<span class="cm">	 * then let the host reset code handle this</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span> <span class="o">||</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">ISCSI_STATE_LOGGED_IN</span> <span class="o">||</span>
	    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">!=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
		<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;failing abort due to dropped &quot;</span>
				  <span class="s">&quot;session.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">conn</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">eh_abort_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">age</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">;</span>

	<span class="n">task</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="p">)</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
	<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;aborting [sc %p itt 0x%x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">sc</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">);</span>

	<span class="cm">/* task completed before time out */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;sc completed while abort in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">success</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_TASK_PENDING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fail_scsi_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">DID_ABORT</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">success</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* only have one tmf outstanding at a time */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">!=</span> <span class="n">TMF_INITIAL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_QUEUED</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmhdr</span><span class="p">;</span>
	<span class="n">iscsi_prep_abort_task_pdu</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_exec_task_mgmt_fn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">abort_timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TMF_SUCCESS</span>:
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * stop tx side incase the target had sent a abort rsp but</span>
<span class="cm">		 * the initiator was still writing out data.</span>
<span class="cm">		 */</span>
		<span class="n">iscsi_suspend_tx</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * we do not stop the recv side because targets have been</span>
<span class="cm">		 * good and have never sent us a successful tmf response</span>
<span class="cm">		 * then sent more data for the cmd.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">fail_scsi_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">DID_ABORT</span><span class="p">);</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_INITIAL</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">iscsi_start_tx</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">success_unlocked</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TMF_TIMEDOUT</span>:
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">iscsi_conn_failure</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">ISCSI_ERR_SCSI_EH_SESSION_RST</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed_unlocked</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TMF_NOT_FOUND</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_INITIAL</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>
			<span class="cm">/* task completed before tmf abort response */</span>
			<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;sc completed while abort	in &quot;</span>
					      <span class="s">&quot;progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">success</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* fall through */</span>
	<span class="nl">default:</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_INITIAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">success:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">success_unlocked:</span>
	<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;abort success [sc %p itt 0x%x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">sc</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>

<span class="nl">failed:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">failed_unlocked:</span>
	<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;abort failed [sc %p itt 0x%x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span>
		     <span class="n">task</span> <span class="o">?</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_eh_abort</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_prep_lun_reset_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_tm</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">ISCSI_OP_SCSI_TMFUNC</span> <span class="o">|</span> <span class="n">ISCSI_OP_IMMEDIATE</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ISCSI_TM_FUNC_LOGICAL_UNIT_RESET</span> <span class="o">&amp;</span> <span class="n">ISCSI_FLAG_TM_FUNC_MASK</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ISCSI_FLAG_CMD_FINAL</span><span class="p">;</span>
	<span class="n">int_to_scsilun</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">rtt</span> <span class="o">=</span> <span class="n">RESERVED_ITT</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iscsi_eh_device_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span><span class="n">cls_session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_tm</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>

	<span class="n">cls_session</span> <span class="o">=</span> <span class="n">starget_to_session</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
	<span class="n">session</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;LU Reset [sc %p lun %u]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Just check if we are not logged in. We cannot check for</span>
<span class="cm">	 * the phase because the reset could come from a ioctl.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span> <span class="o">||</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">ISCSI_STATE_LOGGED_IN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="n">conn</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span><span class="p">;</span>

	<span class="cm">/* only have one tmf outstanding at a time */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">!=</span> <span class="n">TMF_INITIAL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_QUEUED</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmhdr</span><span class="p">;</span>
	<span class="n">iscsi_prep_lun_reset_pdu</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_exec_task_mgmt_fn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">,</span>
				    <span class="n">session</span><span class="o">-&gt;</span><span class="n">lu_reset_timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TMF_SUCCESS</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TMF_TIMEDOUT</span>:
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">iscsi_conn_failure</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">ISCSI_ERR_SCSI_EH_SESSION_RST</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_INITIAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">iscsi_suspend_tx</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>
	<span class="n">fail_scsi_tasks</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">DID_ERROR</span><span class="p">);</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_INITIAL</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">iscsi_start_tx</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

<span class="nl">unlock:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;dev reset result = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">rc</span> <span class="o">==</span> <span class="n">SUCCESS</span> <span class="o">?</span> <span class="s">&quot;SUCCESS&quot;</span> <span class="o">:</span> <span class="s">&quot;FAILED&quot;</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_eh_device_reset</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">iscsi_session_recovery_timedout</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span><span class="n">cls_session</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">ISCSI_STATE_LOGGED_IN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_STATE_RECOVERY_FAILED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span><span class="p">)</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span><span class="o">-&gt;</span><span class="n">ehwait</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_session_recovery_timedout</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_eh_session_reset - drop session and attempt relogin</span>
<span class="cm"> * @sc: scsi command</span>
<span class="cm"> *</span>
<span class="cm"> * This function will wait for a relogin, session termination from</span>
<span class="cm"> * userspace, or a recovery/replacement timeout.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iscsi_eh_session_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span><span class="n">cls_session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">;</span>

	<span class="n">cls_session</span> <span class="o">=</span> <span class="n">starget_to_session</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
	<span class="n">session</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="n">conn</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_STATE_TERMINATE</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">failed:</span>
		<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span>
			     <span class="s">&quot;failing session reset: Could not log back into &quot;</span>
			     <span class="s">&quot;%s, %s [age %d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">targetname</span><span class="p">,</span>
			     <span class="n">conn</span><span class="o">-&gt;</span><span class="n">persistent_address</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * we drop the lock here but the leadconn cannot be destoyed while</span>
<span class="cm">	 * we are in the scsi eh</span>
<span class="cm">	 */</span>
	<span class="n">iscsi_conn_failure</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">ISCSI_ERR_SCSI_EH_SESSION_RST</span><span class="p">);</span>

	<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;wait for relogin</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ehwait</span><span class="p">,</span>
				 <span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_STATE_TERMINATE</span> <span class="o">||</span>
				 <span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_STATE_LOGGED_IN</span> <span class="o">||</span>
				 <span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_STATE_RECOVERY_FAILED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="n">flush_signals</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_STATE_LOGGED_IN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span>
			     <span class="s">&quot;session reset succeeded for %s,%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">session</span><span class="o">-&gt;</span><span class="n">targetname</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">persistent_address</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_eh_session_reset</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_prep_tgt_reset_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_tm</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">ISCSI_OP_SCSI_TMFUNC</span> <span class="o">|</span> <span class="n">ISCSI_OP_IMMEDIATE</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ISCSI_TM_FUNC_TARGET_WARM_RESET</span> <span class="o">&amp;</span> <span class="n">ISCSI_FLAG_TM_FUNC_MASK</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ISCSI_FLAG_CMD_FINAL</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">rtt</span> <span class="o">=</span> <span class="n">RESERVED_ITT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_eh_target_reset - reset target</span>
<span class="cm"> * @sc: scsi command</span>
<span class="cm"> *</span>
<span class="cm"> * This will attempt to send a warm target reset.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iscsi_eh_target_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span><span class="n">cls_session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_tm</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>

	<span class="n">cls_session</span> <span class="o">=</span> <span class="n">starget_to_session</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
	<span class="n">session</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;tgt Reset [sc %p tgt %s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span>
		     <span class="n">session</span><span class="o">-&gt;</span><span class="n">targetname</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Just check if we are not logged in. We cannot check for</span>
<span class="cm">	 * the phase because the reset could come from a ioctl.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span> <span class="o">||</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">ISCSI_STATE_LOGGED_IN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="n">conn</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span><span class="p">;</span>

	<span class="cm">/* only have one tmf outstanding at a time */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">!=</span> <span class="n">TMF_INITIAL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_QUEUED</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmhdr</span><span class="p">;</span>
	<span class="n">iscsi_prep_tgt_reset_pdu</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_exec_task_mgmt_fn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">,</span>
				    <span class="n">session</span><span class="o">-&gt;</span><span class="n">tgt_reset_timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TMF_SUCCESS</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TMF_TIMEDOUT</span>:
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">iscsi_conn_failure</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">ISCSI_ERR_SCSI_EH_SESSION_RST</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_INITIAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">iscsi_suspend_tx</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>
	<span class="n">fail_scsi_tasks</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">DID_ERROR</span><span class="p">);</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_INITIAL</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">iscsi_start_tx</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

<span class="nl">unlock:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="n">ISCSI_DBG_EH</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;tgt %s reset result = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">targetname</span><span class="p">,</span>
		     <span class="n">rc</span> <span class="o">==</span> <span class="n">SUCCESS</span> <span class="o">?</span> <span class="s">&quot;SUCCESS&quot;</span> <span class="o">:</span> <span class="s">&quot;FAILED&quot;</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_eh_target_reset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_eh_recover_target - reset target and possibly the session</span>
<span class="cm"> * @sc: scsi command</span>
<span class="cm"> *</span>
<span class="cm"> * This will attempt to send a warm target reset. If that fails,</span>
<span class="cm"> * we will escalate to ERL0 session recovery.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iscsi_eh_recover_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_eh_target_reset</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">FAILED</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">iscsi_eh_session_reset</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_eh_recover_target</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Pre-allocate a pool of @max items of @item_size. By default, the pool</span>
<span class="cm"> * should be accessed via kfifo_{get,put} on q-&gt;queue.</span>
<span class="cm"> * Optionally, the caller can obtain the array of object pointers</span>
<span class="cm"> * by passing in a non-NULL @items pointer</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">iscsi_pool_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_pool</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="kt">void</span> <span class="o">***</span><span class="n">items</span><span class="p">,</span> <span class="kt">int</span> <span class="n">item_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_arrays</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">));</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>

	<span class="cm">/* If the user passed an items pointer, he wants a copy of</span>
<span class="cm">	 * the array. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">items</span><span class="p">)</span>
		<span class="n">num_arrays</span><span class="o">++</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">pool</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">num_arrays</span> <span class="o">*</span> <span class="n">max</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">kfifo_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">,</span> <span class="n">max</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">item_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">enomem</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfifo_in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">items</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pool</span> <span class="o">+</span> <span class="n">max</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">items</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">,</span> <span class="n">max</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">enomem:</span>
	<span class="n">iscsi_pool_free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_pool_init</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">iscsi_pool_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_pool</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_pool_free</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_host_add - add host to system</span>
<span class="cm"> * @shost: scsi host</span>
<span class="cm"> * @pdev: parent device</span>
<span class="cm"> *</span>
<span class="cm"> * This should be called by partial offload and software iscsi drivers</span>
<span class="cm"> * to add a host to the system.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iscsi_host_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">can_queue</span><span class="p">)</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">ISCSI_DEF_XMIT_CMDS_MAX</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span><span class="p">)</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span> <span class="o">=</span> <span class="n">ISCSI_DEF_CMD_PER_LUN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="o">-&gt;</span><span class="n">eh_timed_out</span><span class="p">)</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="o">-&gt;</span><span class="n">eh_timed_out</span> <span class="o">=</span> <span class="n">iscsi_eh_cmd_timed_out</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">scsi_add_host</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_host_add</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_host_alloc - allocate a host and driver data</span>
<span class="cm"> * @sht: scsi host template</span>
<span class="cm"> * @dd_data_size: driver host data size</span>
<span class="cm"> * @xmit_can_sleep: bool indicating if LLD will queue IO from a work queue</span>
<span class="cm"> *</span>
<span class="cm"> * This should be called by partial offload and software iscsi drivers.</span>
<span class="cm"> * To access the driver specific memory use the iscsi_host_priv() macro.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="nf">iscsi_host_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">dd_data_size</span><span class="p">,</span> <span class="n">bool</span> <span class="n">xmit_can_sleep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="n">sht</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_host</span><span class="p">)</span> <span class="o">+</span> <span class="n">dd_data_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ihost</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xmit_can_sleep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">workq_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">workq_name</span><span class="p">),</span>
			<span class="s">&quot;iscsi_q_%d&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">workq</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">workq_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_host</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_HOST_SETUP</span><span class="p">;</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">num_sessions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">session_removal_wq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">shost</span><span class="p">;</span>

<span class="nl">free_host:</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_host_alloc</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_notify_host_removed</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span><span class="n">cls_session</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iscsi_session_failure</span><span class="p">(</span><span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">,</span> <span class="n">ISCSI_ERR_INVALID_HOST</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_host_remove - remove host and sessions</span>
<span class="cm"> * @shost: scsi host</span>
<span class="cm"> *</span>
<span class="cm"> * If there are any sessions left, this will initiate the removal and wait</span>
<span class="cm"> * for the completion.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iscsi_host_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_HOST_REMOVED</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">iscsi_host_for_each_session</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">iscsi_notify_host_removed</span><span class="p">);</span>
	<span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">session_removal_wq</span><span class="p">,</span>
				 <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">num_sessions</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="n">flush_signals</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">)</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_host_remove</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">iscsi_host_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">hwaddress</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">initiatorname</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_host_free</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_host_dec_session_cnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_get</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Invalid state. Cannot notify host removal &quot;</span>
		      <span class="s">&quot;of session teardown event because host already &quot;</span>
		      <span class="s">&quot;removed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">num_sessions</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">num_sessions</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">session_removal_wq</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_session_setup - create iscsi cls session and host and session</span>
<span class="cm"> * @iscsit: iscsi transport template</span>
<span class="cm"> * @shost: scsi host</span>
<span class="cm"> * @cmds_max: session can queue</span>
<span class="cm"> * @cmd_task_size: LLD task private data size</span>
<span class="cm"> * @initial_cmdsn: initial CmdSN</span>
<span class="cm"> *</span>
<span class="cm"> * This can be used by software iscsi_transports that allocate</span>
<span class="cm"> * a session per scsi host.</span>
<span class="cm"> *</span>
<span class="cm"> * Callers should set cmds_max to the largest total numer (mgmt + scsi) of</span>
<span class="cm"> * tasks they support. The iscsi layer reserves ISCSI_MGMT_CMDS_MAX tasks</span>
<span class="cm"> * for nop handling and login/logout requests.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span>
<span class="nf">iscsi_session_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_transport</span> <span class="o">*</span><span class="n">iscsit</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span>
		    <span class="kt">uint16_t</span> <span class="n">cmds_max</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dd_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd_task_size</span><span class="p">,</span>
		    <span class="kt">uint32_t</span> <span class="n">initial_cmdsn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span><span class="n">cls_session</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmd_i</span><span class="p">,</span> <span class="n">scsi_cmds</span><span class="p">,</span> <span class="n">total_cmds</span> <span class="o">=</span> <span class="n">cmds_max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_HOST_REMOVED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">num_sessions</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">total_cmds</span><span class="p">)</span>
		<span class="n">total_cmds</span> <span class="o">=</span> <span class="n">ISCSI_DEF_XMIT_CMDS_MAX</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The iscsi layer needs some tasks for nop handling and tmfs,</span>
<span class="cm">	 * so the cmds_max must at least be greater than ISCSI_MGMT_CMDS_MAX</span>
<span class="cm">	 * + 1 command for scsi IO.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">total_cmds</span> <span class="o">&lt;</span> <span class="n">ISCSI_TOTAL_CMDS_MIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;iscsi: invalid can_queue of %d. can_queue &quot;</span>
		       <span class="s">&quot;must be a power of two that is at least %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">total_cmds</span><span class="p">,</span> <span class="n">ISCSI_TOTAL_CMDS_MIN</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">dec_session_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">total_cmds</span> <span class="o">&gt;</span> <span class="n">ISCSI_TOTAL_CMDS_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;iscsi: invalid can_queue of %d. can_queue &quot;</span>
		       <span class="s">&quot;must be a power of 2 less than or equal to %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">cmds_max</span><span class="p">,</span> <span class="n">ISCSI_TOTAL_CMDS_MAX</span><span class="p">);</span>
		<span class="n">total_cmds</span> <span class="o">=</span> <span class="n">ISCSI_TOTAL_CMDS_MAX</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">total_cmds</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;iscsi: invalid can_queue of %d. can_queue &quot;</span>
		       <span class="s">&quot;must be a power of 2.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total_cmds</span><span class="p">);</span>
		<span class="n">total_cmds</span> <span class="o">=</span> <span class="n">rounddown_pow_of_two</span><span class="p">(</span><span class="n">total_cmds</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_cmds</span> <span class="o">&lt;</span> <span class="n">ISCSI_TOTAL_CMDS_MIN</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;iscsi: Rounding can_queue to %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">total_cmds</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">scsi_cmds</span> <span class="o">=</span> <span class="n">total_cmds</span> <span class="o">-</span> <span class="n">ISCSI_MGMT_CMDS_MAX</span><span class="p">;</span>

	<span class="n">cls_session</span> <span class="o">=</span> <span class="n">iscsi_alloc_session</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">iscsit</span><span class="p">,</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_session</span><span class="p">)</span> <span class="o">+</span>
					  <span class="n">dd_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls_session</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">dec_session_count</span><span class="p">;</span>
	<span class="n">session</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">cls_session</span> <span class="o">=</span> <span class="n">cls_session</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">shost</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_STATE_FREE</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">fast_abort</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">tgt_reset_timeout</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">lu_reset_timeout</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">abort_timeout</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">scsi_cmds_max</span> <span class="o">=</span> <span class="n">scsi_cmds</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds_max</span> <span class="o">=</span> <span class="n">total_cmds</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">queued_cmdsn</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdsn</span> <span class="o">=</span> <span class="n">initial_cmdsn</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">exp_cmdsn</span> <span class="o">=</span> <span class="n">initial_cmdsn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">max_cmdsn</span> <span class="o">=</span> <span class="n">initial_cmdsn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">max_r2t</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">tt</span> <span class="o">=</span> <span class="n">iscsit</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">dd_data</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">session</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* initialize SCSI PDU commands pool */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_pool_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdpool</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds_max</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">void</span><span class="o">***</span><span class="p">)</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds</span><span class="p">,</span>
			    <span class="n">cmd_task_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">cmdpool_alloc_fail</span><span class="p">;</span>

	<span class="cm">/* pre-format cmds pool with ITT */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cmd_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cmd_i</span> <span class="o">&lt;</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds_max</span><span class="p">;</span> <span class="n">cmd_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds</span><span class="p">[</span><span class="n">cmd_i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd_task_size</span><span class="p">)</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">dd_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">task</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span> <span class="o">=</span> <span class="n">cmd_i</span><span class="p">;</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_TASK_FREE</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">iscsit</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">module_get_fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iscsi_add_session</span><span class="p">(</span><span class="n">cls_session</span><span class="p">,</span> <span class="n">id</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">cls_session_fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cls_session</span><span class="p">;</span>

<span class="nl">cls_session_fail:</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">iscsit</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
<span class="nl">module_get_fail:</span>
	<span class="n">iscsi_pool_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdpool</span><span class="p">);</span>
<span class="nl">cmdpool_alloc_fail:</span>
	<span class="n">iscsi_free_session</span><span class="p">(</span><span class="n">cls_session</span><span class="p">);</span>
<span class="nl">dec_session_count:</span>
	<span class="n">iscsi_host_dec_session_cnt</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_session_setup</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_session_teardown - destroy session, host, and cls_session</span>
<span class="cm"> * @cls_session: iscsi session</span>
<span class="cm"> *</span>
<span class="cm"> * The driver must have called iscsi_remove_session before</span>
<span class="cm"> * calling this.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iscsi_session_teardown</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span><span class="n">cls_session</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="n">iscsi_pool_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdpool</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">password_in</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">username</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">username_in</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">targetname</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">targetalias</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">initiatorname</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">ifacename</span><span class="p">);</span>

	<span class="n">iscsi_destroy_session</span><span class="p">(</span><span class="n">cls_session</span><span class="p">);</span>
	<span class="n">iscsi_host_dec_session_cnt</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_session_teardown</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_conn_setup - create iscsi_cls_conn and iscsi_conn</span>
<span class="cm"> * @cls_session: iscsi_cls_session</span>
<span class="cm"> * @dd_size: private driver data size</span>
<span class="cm"> * @conn_idx: cid</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iscsi_cls_conn</span> <span class="o">*</span>
<span class="nf">iscsi_conn_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span><span class="n">cls_session</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dd_size</span><span class="p">,</span>
		 <span class="kt">uint32_t</span> <span class="n">conn_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_cls_conn</span> <span class="o">*</span><span class="n">cls_conn</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="n">cls_conn</span> <span class="o">=</span> <span class="n">iscsi_create_conn</span><span class="p">(</span><span class="n">cls_session</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">conn</span><span class="p">)</span> <span class="o">+</span> <span class="n">dd_size</span><span class="p">,</span>
				     <span class="n">conn_idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls_conn</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">conn</span> <span class="o">=</span> <span class="n">cls_conn</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">conn</span><span class="p">)</span> <span class="o">+</span> <span class="n">dd_size</span><span class="p">);</span>

	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">dd_data</span> <span class="o">=</span> <span class="n">cls_conn</span><span class="o">-&gt;</span><span class="n">dd_data</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">conn</span><span class="p">);</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">cls_conn</span> <span class="o">=</span> <span class="n">cls_conn</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">c_stage</span> <span class="o">=</span> <span class="n">ISCSI_CONN_INITIAL_STAGE</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">conn_idx</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">exp_statsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_INITIAL</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">transport_timer</span><span class="p">);</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">transport_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">conn</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">transport_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">iscsi_check_transport_timeouts</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">mgmtqueue</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">cmdqueue</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">requeue</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">xmitwork</span><span class="p">,</span> <span class="n">iscsi_xmitworker</span><span class="p">);</span>

	<span class="cm">/* allocate login_task used for the login/text sequences */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kfifo_out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdpool</span><span class="p">.</span><span class="n">queue</span><span class="p">,</span>
                         <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">login_task</span><span class="p">,</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">login_task_alloc_fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span>
					 <span class="n">get_order</span><span class="p">(</span><span class="n">ISCSI_DEF_MAX_RECV_SEG_LEN</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">login_task_data_alloc_fail</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">login_task</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_timer</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ehwait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cls_conn</span><span class="p">;</span>

<span class="nl">login_task_data_alloc_fail:</span>
	<span class="n">kfifo_in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdpool</span><span class="p">.</span><span class="n">queue</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">login_task</span><span class="p">,</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">));</span>
<span class="nl">login_task_alloc_fail:</span>
	<span class="n">iscsi_destroy_conn</span><span class="p">(</span><span class="n">cls_conn</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_conn_setup</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iscsi_conn_teardown - teardown iscsi connection</span>
<span class="cm"> * cls_conn: iscsi class connection</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: we may need to make this into a two step process</span>
<span class="cm"> * like scsi-mls remove + put host</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iscsi_conn_teardown</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_cls_conn</span> <span class="o">*</span><span class="n">cls_conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">cls_conn</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">transport_timer</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">c_stage</span> <span class="o">=</span> <span class="n">ISCSI_CONN_CLEANUP_WAIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span> <span class="o">==</span> <span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * leading connection? then give up on recovery.</span>
<span class="cm">		 */</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_STATE_TERMINATE</span><span class="p">;</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ehwait</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Block until all in-progress commands for this connection</span>
<span class="cm">	 * time out or fail.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_busy</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* OK for ERL == 0 */</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="s">&quot;iscsi conn_destroy(): &quot;</span>
				  <span class="s">&quot;host_busy %d host_failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">session</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_busy</span><span class="p">,</span>
				  <span class="n">session</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_failed</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * force eh_abort() to unblock</span>
<span class="cm">		 */</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ehwait</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* flush queued up work because we free the connection below */</span>
	<span class="n">iscsi_suspend_tx</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
		   <span class="n">get_order</span><span class="p">(</span><span class="n">ISCSI_DEF_MAX_RECV_SEG_LEN</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">persistent_address</span><span class="p">);</span>
	<span class="n">kfifo_in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdpool</span><span class="p">.</span><span class="n">queue</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">login_task</span><span class="p">,</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span> <span class="o">==</span> <span class="n">conn</span><span class="p">)</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">iscsi_destroy_conn</span><span class="p">(</span><span class="n">cls_conn</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_conn_teardown</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">iscsi_conn_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_cls_conn</span> <span class="o">*</span><span class="n">cls_conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">cls_conn</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span>
				  <span class="s">&quot;can&#39;t start unbound connection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">imm_data_en</span> <span class="o">||</span> <span class="o">!</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">initial_r2t_en</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="n">session</span><span class="o">-&gt;</span><span class="n">first_burst</span> <span class="o">&gt;</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">max_burst</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="s">&quot;invalid burst lengths: &quot;</span>
				  <span class="s">&quot;first_burst %d max_burst %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">session</span><span class="o">-&gt;</span><span class="n">first_burst</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">max_burst</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_timeout</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">recv_timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="s">&quot;invalid recv timeout of &quot;</span>
				  <span class="s">&quot;zero. Using 5 seconds</span><span class="se">\n</span><span class="s">.&quot;</span><span class="p">);</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">recv_timeout</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">recv_timeout</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="s">&quot;invalid ping timeout of &quot;</span>
				  <span class="s">&quot;zero. Using 5 seconds.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_timeout</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">c_stage</span> <span class="o">=</span> <span class="n">ISCSI_CONN_STARTED</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_STATE_LOGGED_IN</span><span class="p">;</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">queued_cmdsn</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">cmdsn</span><span class="p">;</span>

	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">last_recv</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">last_ping</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">recv_timeout</span> <span class="o">&amp;&amp;</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_timeout</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">transport_timer</span><span class="p">,</span>
			  <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">recv_timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">));</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">stop_stage</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">STOP_CONN_RECOVER</span>:
		<span class="cm">/*</span>
<span class="cm">		 * unblock eh_abort() if it is blocked. re-try all</span>
<span class="cm">		 * commands after successful recovery</span>
<span class="cm">		 */</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">stop_stage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmf_state</span> <span class="o">=</span> <span class="n">TMF_INITIAL</span><span class="p">;</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span>
			<span class="n">session</span><span class="o">-&gt;</span><span class="n">age</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">STOP_CONN_TERM</span>:
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">stop_stage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">iscsi_unblock_session</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cls_session</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ehwait</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_conn_start</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fail_mgmt_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">state</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds_max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cmds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">sc</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_TASK_FREE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span>
				  <span class="s">&quot;failing mgmt itt 0x%x state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">task</span><span class="o">-&gt;</span><span class="n">itt</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_TASK_ABRT_SESS_RECOV</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_TASK_PENDING</span><span class="p">)</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_TASK_COMPLETED</span><span class="p">;</span>
		<span class="n">iscsi_complete_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>

	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iscsi_start_session_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">old_stop_stage</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">stop_stage</span> <span class="o">==</span> <span class="n">STOP_CONN_TERM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * When this is called for the in_login state, we only want to clean</span>
<span class="cm">	 * up the login task and connection. We do not need to block and set</span>
<span class="cm">	 * the recovery state again</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">STOP_CONN_TERM</span><span class="p">)</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_STATE_TERMINATE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">stop_stage</span> <span class="o">!=</span> <span class="n">STOP_CONN_RECOVER</span><span class="p">)</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ISCSI_STATE_IN_RECOVERY</span><span class="p">;</span>

	<span class="n">old_stop_stage</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">stop_stage</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">stop_stage</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">transport_timer</span><span class="p">);</span>
	<span class="n">iscsi_suspend_tx</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">c_stage</span> <span class="o">=</span> <span class="n">ISCSI_CONN_STOPPED</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * for connection level recovery we should not calculate</span>
<span class="cm">	 * header digest. conn-&gt;hdr_size used for optimization</span>
<span class="cm">	 * in hdr_extract() and will be re-negotiated at</span>
<span class="cm">	 * set_param() time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">STOP_CONN_RECOVER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">hdrdgst_en</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">conn</span><span class="o">-&gt;</span><span class="n">datadgst_en</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ISCSI_STATE_IN_RECOVERY</span> <span class="o">&amp;&amp;</span>
		    <span class="n">old_stop_stage</span> <span class="o">!=</span> <span class="n">STOP_CONN_RECOVER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ISCSI_DBG_SESSION</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&quot;blocking session</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">iscsi_block_session</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">cls_session</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * flush queues.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">fail_scsi_tasks</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">DID_TRANSPORT_DISRUPTED</span><span class="p">);</span>
	<span class="n">fail_mgmt_tasks</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">conn</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmhdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">tmhdr</span><span class="p">));</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">iscsi_conn_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_cls_conn</span> <span class="o">*</span><span class="n">cls_conn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">cls_conn</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">STOP_CONN_RECOVER</span>:
	<span class="k">case</span> <span class="n">STOP_CONN_TERM</span>:
		<span class="n">iscsi_start_session_recovery</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">iscsi_conn_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span>
				  <span class="s">&quot;invalid stop flag %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_conn_stop</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">iscsi_conn_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span><span class="n">cls_session</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">iscsi_cls_conn</span> <span class="o">*</span><span class="n">cls_conn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_leading</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">cls_conn</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_leading</span><span class="p">)</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">leadconn</span> <span class="o">=</span> <span class="n">conn</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unblock xmitworker(), Login Phase will pass through.</span>
<span class="cm">	 */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">ISCSI_SUSPEND_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">suspend_rx</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">ISCSI_SUSPEND_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">suspend_tx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_conn_bind</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iscsi_switch_str_param</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">new_val_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">new_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="n">new_val_buf</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new_val</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">new_val_buf</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">param</span><span class="p">);</span>
	<span class="o">*</span><span class="n">param</span> <span class="o">=</span> <span class="n">new_val</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iscsi_set_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_cls_conn</span> <span class="o">*</span><span class="n">cls_conn</span><span class="p">,</span>
		    <span class="k">enum</span> <span class="n">iscsi_param</span> <span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">cls_conn</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_FAST_ABORT</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">fast_abort</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_ABORT_TMO</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">abort_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_LU_RESET_TMO</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">lu_reset_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_TGT_RESET_TMO</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tgt_reset_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_PING_TMO</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_RECV_TMO</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">recv_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_MAX_RECV_DLENGTH</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">max_recv_dlength</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_MAX_XMIT_DLENGTH</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">max_xmit_dlength</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_HDRDGST_EN</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">hdrdgst_en</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_DATADGST_EN</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">datadgst_en</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_INITIAL_R2T_EN</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">initial_r2t_en</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_MAX_R2T</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%hu&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">max_r2t</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_IMM_DATA_EN</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">imm_data_en</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_FIRST_BURST</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">first_burst</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_MAX_BURST</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">max_burst</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_PDU_INORDER_EN</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">pdu_inorder_en</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_DATASEQ_INORDER_EN</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">dataseq_inorder_en</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_ERL</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">erl</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_EXP_STATSN</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">exp_statsn</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_USERNAME</span>:
		<span class="k">return</span> <span class="n">iscsi_switch_str_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">username</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_USERNAME_IN</span>:
		<span class="k">return</span> <span class="n">iscsi_switch_str_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">username_in</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_PASSWORD</span>:
		<span class="k">return</span> <span class="n">iscsi_switch_str_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_PASSWORD_IN</span>:
		<span class="k">return</span> <span class="n">iscsi_switch_str_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">password_in</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_TARGET_NAME</span>:
		<span class="k">return</span> <span class="n">iscsi_switch_str_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">targetname</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_TARGET_ALIAS</span>:
		<span class="k">return</span> <span class="n">iscsi_switch_str_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">targetalias</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_TPGT</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">tpgt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_PERSISTENT_PORT</span>:
		<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">persistent_port</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_PERSISTENT_ADDRESS</span>:
		<span class="k">return</span> <span class="n">iscsi_switch_str_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">persistent_address</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_IFACE_NAME</span>:
		<span class="k">return</span> <span class="n">iscsi_switch_str_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">ifacename</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_INITIATOR_NAME</span>:
		<span class="k">return</span> <span class="n">iscsi_switch_str_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">initiatorname</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_set_param</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">iscsi_session_get_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_cls_session</span> <span class="o">*</span><span class="n">cls_session</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">iscsi_param</span> <span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">cls_session</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_FAST_ABORT</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">fast_abort</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_ABORT_TMO</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">abort_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_LU_RESET_TMO</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">lu_reset_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_TGT_RESET_TMO</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">tgt_reset_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_INITIAL_R2T_EN</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">initial_r2t_en</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_MAX_R2T</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%hu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">max_r2t</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_IMM_DATA_EN</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">imm_data_en</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_FIRST_BURST</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">first_burst</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_MAX_BURST</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">max_burst</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_PDU_INORDER_EN</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">pdu_inorder_en</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_DATASEQ_INORDER_EN</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">dataseq_inorder_en</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_ERL</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">erl</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_TARGET_NAME</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">targetname</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_TARGET_ALIAS</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">targetalias</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_TPGT</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">tpgt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_USERNAME</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">username</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_USERNAME_IN</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">username_in</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_PASSWORD</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_PASSWORD_IN</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">password_in</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_IFACE_NAME</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">ifacename</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_INITIATOR_NAME</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">initiatorname</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_session_get_param</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">iscsi_conn_get_addr_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">iscsi_param</span> <span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="n">sin6</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">sin</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">ss_family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="n">sin</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="n">sin6</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_CONN_ADDRESS</span>:
	<span class="k">case</span> <span class="n">ISCSI_HOST_PARAM_IPADDRESS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sin</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%pI4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%pI6</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sin6</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_CONN_PORT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sin</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%hu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_port</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%hu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">sin6</span><span class="o">-&gt;</span><span class="n">sin6_port</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_conn_get_addr_param</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">iscsi_conn_get_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_cls_conn</span> <span class="o">*</span><span class="n">cls_conn</span><span class="p">,</span>
			 <span class="k">enum</span> <span class="n">iscsi_param</span> <span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">cls_conn</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_PING_TMO</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">ping_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_RECV_TMO</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">recv_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_MAX_RECV_DLENGTH</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">max_recv_dlength</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_MAX_XMIT_DLENGTH</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">max_xmit_dlength</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_HDRDGST_EN</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">hdrdgst_en</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_DATADGST_EN</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">datadgst_en</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_IFMARKER_EN</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">ifmarker_en</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_OFMARKER_EN</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">ofmarker_en</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_EXP_STATSN</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">exp_statsn</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_PERSISTENT_PORT</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">persistent_port</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_PARAM_PERSISTENT_ADDRESS</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">persistent_address</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_conn_get_param</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">iscsi_host_get_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">enum</span> <span class="n">iscsi_host_param</span> <span class="n">param</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ISCSI_HOST_PARAM_NETDEV_NAME</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_HOST_PARAM_HWADDRESS</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">hwaddress</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISCSI_HOST_PARAM_INITIATOR_NAME</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">initiatorname</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_host_get_param</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">iscsi_host_set_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">enum</span> <span class="n">iscsi_host_param</span> <span class="n">param</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ISCSI_HOST_PARAM_NETDEV_NAME</span>:
		<span class="k">return</span> <span class="n">iscsi_switch_str_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">ISCSI_HOST_PARAM_HWADDRESS</span>:
		<span class="k">return</span> <span class="n">iscsi_switch_str_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">hwaddress</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">ISCSI_HOST_PARAM_INITIATOR_NAME</span>:
		<span class="k">return</span> <span class="n">iscsi_switch_str_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">initiatorname</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">iscsi_host_set_param</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Mike Christie&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;iSCSI library functions&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
