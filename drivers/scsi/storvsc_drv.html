<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › storvsc_drv.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>storvsc_drv.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2009, Microsoft Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
<span class="cm"> * Place - Suite 330, Boston, MA 02111-1307 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *   Haiyang Zhang &lt;haiyangz@microsoft.com&gt;</span>
<span class="cm"> *   Hank Janssen  &lt;hjanssen@microsoft.com&gt;</span>
<span class="cm"> *   K. Y. Srinivasan &lt;kys@microsoft.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/hyperv.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_devinfo.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_dbg.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * All wire protocol details (storage protocol between the guest and the host)</span>
<span class="cm"> * are consolidated here.</span>
<span class="cm"> *</span>
<span class="cm"> * Begin protocol definitions.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Version history:</span>
<span class="cm"> * V1 Beta: 0.1</span>
<span class="cm"> * V1 RC &lt; 2008/1/31: 1.0</span>
<span class="cm"> * V1 RC &gt; 2008/1/31:  2.0</span>
<span class="cm"> * Win7: 4.2</span>
<span class="cm"> */</span>

<span class="cp">#define VMSTOR_CURRENT_MAJOR  4</span>
<span class="cp">#define VMSTOR_CURRENT_MINOR  2</span>


<span class="cm">/*  Packet structure describing virtual storage requests. */</span>
<span class="k">enum</span> <span class="n">vstor_packet_operation</span> <span class="p">{</span>
	<span class="n">VSTOR_OPERATION_COMPLETE_IO</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VSTOR_OPERATION_REMOVE_DEVICE</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">VSTOR_OPERATION_EXECUTE_SRB</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">VSTOR_OPERATION_RESET_LUN</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">VSTOR_OPERATION_RESET_ADAPTER</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">VSTOR_OPERATION_RESET_BUS</span>		<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">VSTOR_OPERATION_BEGIN_INITIALIZATION</span>	<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">VSTOR_OPERATION_END_INITIALIZATION</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">VSTOR_OPERATION_QUERY_PROTOCOL_VERSION</span>	<span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">VSTOR_OPERATION_QUERY_PROPERTIES</span>	<span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">VSTOR_OPERATION_ENUMERATE_BUS</span>		<span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">VSTOR_OPERATION_MAXIMUM</span>			<span class="o">=</span> <span class="mi">11</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Platform neutral description of a scsi request -</span>
<span class="cm"> * this remains the same across the write regardless of 32/64 bit</span>
<span class="cm"> * note: it&#39;s patterned off the SCSI_PASS_THROUGH structure</span>
<span class="cm"> */</span>
<span class="cp">#define STORVSC_MAX_CMD_LEN			0x10</span>
<span class="cp">#define STORVSC_SENSE_BUFFER_SIZE		0x12</span>
<span class="cp">#define STORVSC_MAX_BUF_LEN_WITH_PADDING	0x14</span>

<span class="k">struct</span> <span class="n">vmscsi_request</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">srb_status</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">scsi_status</span><span class="p">;</span>

	<span class="n">u8</span>  <span class="n">port_number</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">path_id</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">target_id</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">lun</span><span class="p">;</span>

	<span class="n">u8</span>  <span class="n">cdb_length</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">sense_info_length</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">data_in</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">reserved</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">data_transfer_length</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">cdb</span><span class="p">[</span><span class="n">STORVSC_MAX_CMD_LEN</span><span class="p">];</span>
		<span class="n">u8</span> <span class="n">sense_data</span><span class="p">[</span><span class="n">STORVSC_SENSE_BUFFER_SIZE</span><span class="p">];</span>
		<span class="n">u8</span> <span class="n">reserved_array</span><span class="p">[</span><span class="n">STORVSC_MAX_BUF_LEN_WITH_PADDING</span><span class="p">];</span>
	<span class="p">};</span>
<span class="p">}</span> <span class="n">__attribute</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>


<span class="cm">/*</span>
<span class="cm"> * This structure is sent during the intialization phase to get the different</span>
<span class="cm"> * properties of the channel.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vmstorage_channel_properties</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">protocol_version</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">path_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">target_id</span><span class="p">;</span>

	<span class="cm">/* Note: port number is only really known on the client side */</span>
	<span class="n">u32</span>  <span class="n">port_number</span><span class="p">;</span>
	<span class="n">u32</span>  <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span>   <span class="n">max_transfer_bytes</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This id is unique for each channel and will correspond with</span>
<span class="cm">	 * vendor specific data in the inquiry data.</span>
<span class="cm">	 */</span>

	<span class="n">u64</span>  <span class="n">unique_id</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*  This structure is sent during the storage protocol negotiations. */</span>
<span class="k">struct</span> <span class="n">vmstorage_protocol_version</span> <span class="p">{</span>
	<span class="cm">/* Major (MSW) and minor (LSW) version numbers. */</span>
	<span class="n">u16</span> <span class="n">major_minor</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Revision number is auto-incremented whenever this file is changed</span>
<span class="cm">	 * (See FILL_VMSTOR_REVISION macro above).  Mismatch does not</span>
<span class="cm">	 * definitely indicate incompatibility--but it does indicate mismatched</span>
<span class="cm">	 * builds.</span>
<span class="cm">	 * This is only used on the windows side. Just set it to 0.</span>
<span class="cm">	 */</span>
	<span class="n">u16</span> <span class="n">revision</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Channel Property Flags */</span>
<span class="cp">#define STORAGE_CHANNEL_REMOVABLE_FLAG		0x1</span>
<span class="cp">#define STORAGE_CHANNEL_EMULATED_IDE_FLAG	0x2</span>

<span class="k">struct</span> <span class="n">vstor_packet</span> <span class="p">{</span>
	<span class="cm">/* Requested operation type */</span>
	<span class="k">enum</span> <span class="n">vstor_packet_operation</span> <span class="n">operation</span><span class="p">;</span>

	<span class="cm">/*  Flags - see below for values */</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Status of the request returned from the server side. */</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Data payload area */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Structure used to forward SCSI commands from the</span>
<span class="cm">		 * client to the server.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">vmscsi_request</span> <span class="n">vm_srb</span><span class="p">;</span>

		<span class="cm">/* Structure used to query channel properties. */</span>
		<span class="k">struct</span> <span class="n">vmstorage_channel_properties</span> <span class="n">storage_channel_properties</span><span class="p">;</span>

		<span class="cm">/* Used during version negotiations. */</span>
		<span class="k">struct</span> <span class="n">vmstorage_protocol_version</span> <span class="n">version</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Packet Flags:</span>
<span class="cm"> *</span>
<span class="cm"> * This flag indicates that the server should send back a completion for this</span>
<span class="cm"> * packet.</span>
<span class="cm"> */</span>

<span class="cp">#define REQUEST_COMPLETION_FLAG	0x1</span>

<span class="cm">/* Matches Windows-end */</span>
<span class="k">enum</span> <span class="n">storvsc_request_type</span> <span class="p">{</span>
	<span class="n">WRITE_TYPE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">READ_TYPE</span><span class="p">,</span>
	<span class="n">UNKNOWN_TYPE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * SRB status codes and masks; a subset of the codes used here.</span>
<span class="cm"> */</span>

<span class="cp">#define SRB_STATUS_AUTOSENSE_VALID	0x80</span>
<span class="cp">#define SRB_STATUS_INVALID_LUN	0x20</span>
<span class="cp">#define SRB_STATUS_SUCCESS	0x01</span>
<span class="cp">#define SRB_STATUS_ERROR	0x04</span>

<span class="cm">/*</span>
<span class="cm"> * This is the end of Protocol specific defines.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * We setup a mempool to allocate request structures for this driver</span>
<span class="cm"> * on a per-lun basis. The following define specifies the number of</span>
<span class="cm"> * elements in the pool.</span>
<span class="cm"> */</span>

<span class="cp">#define STORVSC_MIN_BUF_NR				64</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">storvsc_ringbuffer_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">storvsc_ringbuffer_size</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">storvsc_ringbuffer_size</span><span class="p">,</span> <span class="s">&quot;Ring buffer size (bytes)&quot;</span><span class="p">);</span>

<span class="cp">#define STORVSC_MAX_IO_REQUESTS				128</span>

<span class="cm">/*</span>
<span class="cm"> * In Hyper-V, each port/path/target maps to 1 scsi host adapter.  In</span>
<span class="cm"> * reality, the path/target is not used (ie always set to 0) so our</span>
<span class="cm"> * scsi host adapter essentially has 1 bus with 1 target that contains</span>
<span class="cm"> * up to 256 luns.</span>
<span class="cm"> */</span>
<span class="cp">#define STORVSC_MAX_LUNS_PER_TARGET			64</span>
<span class="cp">#define STORVSC_MAX_TARGETS				1</span>
<span class="cp">#define STORVSC_MAX_CHANNELS				1</span>



<span class="k">struct</span> <span class="n">storvsc_cmd_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bounce_sgl_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">bounce_sgl</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

	<span class="cm">/* Synchronize the request/response if needed */</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">wait_event</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sense_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_multipage_buffer</span> <span class="n">data_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vstor_packet</span> <span class="n">vstor_packet</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* A storvsc device is a device object that contains a vmbus channel */</span>
<span class="k">struct</span> <span class="n">storvsc_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

	<span class="n">bool</span>	 <span class="n">destroy</span><span class="p">;</span>
	<span class="n">bool</span>	 <span class="n">drain_notify</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_outstanding_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span> <span class="n">waiting_to_drain</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Each unique Port/Path/Target represents 1 channel ie scsi</span>
<span class="cm">	 * controller. In reality, the pathid, targetid is always 0</span>
<span class="cm">	 * and the port is set by us</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port_number</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">path_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">target_id</span><span class="p">;</span>

	<span class="cm">/* Used for vsc/vsp channel reset process */</span>
	<span class="k">struct</span> <span class="n">storvsc_cmd_request</span> <span class="n">init_request</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">storvsc_cmd_request</span> <span class="n">reset_request</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">stor_mem_pools</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">request_pool</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">request_mempool</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hv_host_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">path</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">target</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">storvsc_scan_work</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">lun</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">storvsc_bus_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">storvsc_scan_work</span> <span class="o">*</span><span class="n">wrk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">order_id</span><span class="p">;</span>

	<span class="n">wrk</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">storvsc_scan_work</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">wrk</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span><span class="p">;</span> <span class="o">++</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wrk</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">reverse_ordering</span><span class="p">)</span>
			<span class="n">order_id</span> <span class="o">=</span> <span class="n">wrk</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">-</span> <span class="n">id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">order_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>

		<span class="n">scsi_scan_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wrk</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">order_id</span><span class="p">,</span> <span class="n">SCAN_WILD_CARD</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">wrk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">storvsc_remove_lun</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">storvsc_scan_work</span> <span class="o">*</span><span class="n">wrk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>

	<span class="n">wrk</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">storvsc_scan_work</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_host_get</span><span class="p">(</span><span class="n">wrk</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">scsi_device_lookup</span><span class="p">(</span><span class="n">wrk</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wrk</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
		<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">wrk</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">wrk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Major/minor macros.  Minor version is in LSB, meaning that earlier flat</span>
<span class="cm"> * version numbers will be interpreted as &quot;0.x&quot; (i.e., 1 becomes 0.1).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">storvsc_get_version</span><span class="p">(</span><span class="n">u8</span> <span class="n">major</span><span class="p">,</span> <span class="n">u8</span> <span class="n">minor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">version</span><span class="p">;</span>

	<span class="n">version</span> <span class="o">=</span> <span class="p">((</span><span class="n">major</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">minor</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">version</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We can get incoming messages from the host that are not in response to</span>
<span class="cm"> * messages that we have sent out. An example of this would be messages</span>
<span class="cm"> * received by the guest to notify dynamic addition/removal of LUNs. To</span>
<span class="cm"> * deal with potential race conditions where the driver may be in the</span>
<span class="cm"> * midst of being unloaded when we might receive an unsolicited message</span>
<span class="cm"> * from the host, we have implemented a mechanism to gurantee sequential</span>
<span class="cm"> * consistency:</span>
<span class="cm"> *</span>
<span class="cm"> * 1) Once the device is marked as being destroyed, we will fail all</span>
<span class="cm"> *    outgoing messages.</span>
<span class="cm"> * 2) We permit incoming messages when the device is being destroyed,</span>
<span class="cm"> *    only to properly account for messages already sent out.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="nf">get_out_stor_device</span><span class="p">(</span>
					<span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="n">stor_device</span><span class="p">;</span>

	<span class="n">stor_device</span> <span class="o">=</span> <span class="n">hv_get_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stor_device</span> <span class="o">&amp;&amp;</span> <span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">)</span>
		<span class="n">stor_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">stor_device</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">storvsc_wait_to_drain</span><span class="p">(</span><span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">drain_notify</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">waiting_to_drain</span><span class="p">,</span>
		   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_outstanding_req</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">drain_notify</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="nf">get_in_stor_device</span><span class="p">(</span>
					<span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="n">stor_device</span><span class="p">;</span>

	<span class="n">stor_device</span> <span class="o">=</span> <span class="n">hv_get_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stor_device</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">get_in_err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the device is being destroyed; allow incoming</span>
<span class="cm">	 * traffic only to cleanup outstanding requests.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">destroy</span>  <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">num_outstanding_req</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">stor_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">get_in_err:</span>
	<span class="k">return</span> <span class="n">stor_device</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_bounce_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page_buf</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sg_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_buf</span> <span class="o">=</span> <span class="n">sg_page</span><span class="p">((</span><span class="o">&amp;</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">__free_page</span><span class="p">(</span><span class="n">page_buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">sgl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_bounce_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* No need to check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sg_count</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* We have at least 2 sg entries */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sg_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* make sure 1st one does not have hole */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span> <span class="o">+</span> <span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">sg_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* make sure last one does not have hole */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* make sure no hole in the middle */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span> <span class="o">||</span> <span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="nf">create_bounce_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_count</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">bounce_sgl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page_buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buf_len</span> <span class="o">=</span> <span class="p">((</span><span class="n">write</span> <span class="o">==</span> <span class="n">WRITE_TYPE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">num_pages</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">bounce_sgl</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">num_pages</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bounce_sgl</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_buf</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_buf</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="n">sg_set_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bounce_sgl</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">page_buf</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bounce_sgl</span><span class="p">;</span>

<span class="nl">cleanup:</span>
	<span class="n">destroy_bounce_buffer</span><span class="p">(</span><span class="n">bounce_sgl</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Disgusting wrapper functions */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">sg_kmap_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sgl</span> <span class="o">+</span> <span class="n">idx</span><span class="p">));</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sg_kunmap_atomic</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kunmap_atomic</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Assume the original sgl has enough room */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">copy_from_bounce_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">orig_sgl</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">bounce_sgl</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">orig_sgl_count</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bounce_sgl_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">srclen</span><span class="p">,</span> <span class="n">destlen</span><span class="p">,</span> <span class="n">copylen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bounce_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dest_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">orig_sgl_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dest_addr</span> <span class="o">=</span> <span class="n">sg_kmap_atomic</span><span class="p">(</span><span class="n">orig_sgl</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">orig_sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">dest</span> <span class="o">=</span> <span class="n">dest_addr</span><span class="p">;</span>
		<span class="n">destlen</span> <span class="o">=</span> <span class="n">orig_sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bounce_addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">bounce_addr</span> <span class="o">=</span> <span class="n">sg_kmap_atomic</span><span class="p">(</span><span class="n">bounce_sgl</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">destlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">src</span> <span class="o">=</span> <span class="n">bounce_addr</span> <span class="o">+</span> <span class="n">bounce_sgl</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">srclen</span> <span class="o">=</span> <span class="n">bounce_sgl</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">length</span> <span class="o">-</span> <span class="n">bounce_sgl</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>

			<span class="n">copylen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">srclen</span><span class="p">,</span> <span class="n">destlen</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dest</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="p">,</span> <span class="n">copylen</span><span class="p">);</span>

			<span class="n">total_copied</span> <span class="o">+=</span> <span class="n">copylen</span><span class="p">;</span>
			<span class="n">bounce_sgl</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">copylen</span><span class="p">;</span>
			<span class="n">destlen</span> <span class="o">-=</span> <span class="n">copylen</span><span class="p">;</span>
			<span class="n">dest</span> <span class="o">+=</span> <span class="n">copylen</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bounce_sgl</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">offset</span> <span class="o">==</span> <span class="n">bounce_sgl</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* full */</span>
				<span class="n">sg_kunmap_atomic</span><span class="p">(</span><span class="n">bounce_addr</span><span class="p">);</span>
				<span class="n">j</span><span class="o">++</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * It is possible that the number of elements</span>
<span class="cm">				 * in the bounce buffer may not be equal to</span>
<span class="cm">				 * the number of elements in the original</span>
<span class="cm">				 * scatter list. Handle this correctly.</span>
<span class="cm">				 */</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">bounce_sgl_count</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * We are done; cleanup and return.</span>
<span class="cm">					 */</span>
					<span class="n">sg_kunmap_atomic</span><span class="p">(</span><span class="n">dest_addr</span> <span class="o">-</span> <span class="n">orig_sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">);</span>
					<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">total_copied</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* if we need to use another bounce buffer */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">destlen</span> <span class="o">||</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">orig_sgl_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
					<span class="n">bounce_addr</span> <span class="o">=</span> <span class="n">sg_kmap_atomic</span><span class="p">(</span><span class="n">bounce_sgl</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">destlen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">orig_sgl_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* unmap the last bounce that is &lt; PAGE_SIZE */</span>
				<span class="n">sg_kunmap_atomic</span><span class="p">(</span><span class="n">bounce_addr</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">sg_kunmap_atomic</span><span class="p">(</span><span class="n">dest_addr</span> <span class="o">-</span> <span class="n">orig_sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">total_copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Assume the bounce_sgl has enough room ie using the create_bounce_buffer() */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">copy_to_bounce_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">orig_sgl</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">bounce_sgl</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">orig_sgl_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">srclen</span><span class="p">,</span> <span class="n">destlen</span><span class="p">,</span> <span class="n">copylen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bounce_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">src_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">orig_sgl_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">src_addr</span> <span class="o">=</span> <span class="n">sg_kmap_atomic</span><span class="p">(</span><span class="n">orig_sgl</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">orig_sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">src</span> <span class="o">=</span> <span class="n">src_addr</span><span class="p">;</span>
		<span class="n">srclen</span> <span class="o">=</span> <span class="n">orig_sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bounce_addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">bounce_addr</span> <span class="o">=</span> <span class="n">sg_kmap_atomic</span><span class="p">(</span><span class="n">bounce_sgl</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">srclen</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* assume bounce offset always == 0 */</span>
			<span class="n">dest</span> <span class="o">=</span> <span class="n">bounce_addr</span> <span class="o">+</span> <span class="n">bounce_sgl</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
			<span class="n">destlen</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">bounce_sgl</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>

			<span class="n">copylen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">srclen</span><span class="p">,</span> <span class="n">destlen</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dest</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="p">,</span> <span class="n">copylen</span><span class="p">);</span>

			<span class="n">total_copied</span> <span class="o">+=</span> <span class="n">copylen</span><span class="p">;</span>
			<span class="n">bounce_sgl</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">length</span> <span class="o">+=</span> <span class="n">copylen</span><span class="p">;</span>
			<span class="n">srclen</span> <span class="o">-=</span> <span class="n">copylen</span><span class="p">;</span>
			<span class="n">src</span> <span class="o">+=</span> <span class="n">copylen</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bounce_sgl</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">length</span> <span class="o">==</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* full..move to next entry */</span>
				<span class="n">sg_kunmap_atomic</span><span class="p">(</span><span class="n">bounce_addr</span><span class="p">);</span>
				<span class="n">j</span><span class="o">++</span><span class="p">;</span>

				<span class="cm">/* if we need to use another bounce buffer */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">srclen</span> <span class="o">||</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">orig_sgl_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
					<span class="n">bounce_addr</span> <span class="o">=</span> <span class="n">sg_kmap_atomic</span><span class="p">(</span><span class="n">bounce_sgl</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>

			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">srclen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">orig_sgl_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* unmap the last bounce that is &lt; PAGE_SIZE */</span>
				<span class="n">sg_kunmap_atomic</span><span class="p">(</span><span class="n">bounce_addr</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">sg_kunmap_atomic</span><span class="p">(</span><span class="n">src_addr</span> <span class="o">-</span> <span class="n">orig_sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">total_copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">storvsc_channel_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="n">stor_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">storvsc_cmd_request</span> <span class="o">*</span><span class="n">request</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vstor_packet</span> <span class="o">*</span><span class="n">vstor_packet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">stor_device</span> <span class="o">=</span> <span class="n">get_out_stor_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stor_device</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">request</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">init_request</span><span class="p">;</span>
	<span class="n">vstor_packet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">vstor_packet</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now, initiate the vsc/vsp initialization protocol on the open</span>
<span class="cm">	 * channel</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">storvsc_cmd_request</span><span class="p">));</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">wait_event</span><span class="p">);</span>
	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">operation</span> <span class="o">=</span> <span class="n">VSTOR_OPERATION_BEGIN_INITIALIZATION</span><span class="p">;</span>
	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">REQUEST_COMPLETION_FLAG</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">vstor_packet</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">request</span><span class="p">,</span>
			       <span class="n">VM_PKT_DATA_INBAND</span><span class="p">,</span>
			       <span class="n">VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">wait_event</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">operation</span> <span class="o">!=</span> <span class="n">VSTOR_OPERATION_COMPLETE_IO</span> <span class="o">||</span>
	    <span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>


	<span class="cm">/* reuse the packet for version range supported */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vstor_packet</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span><span class="p">));</span>
	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">operation</span> <span class="o">=</span> <span class="n">VSTOR_OPERATION_QUERY_PROTOCOL_VERSION</span><span class="p">;</span>
	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">REQUEST_COMPLETION_FLAG</span><span class="p">;</span>

	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">.</span><span class="n">major_minor</span> <span class="o">=</span>
		<span class="n">storvsc_get_version</span><span class="p">(</span><span class="n">VMSTOR_CURRENT_MAJOR</span><span class="p">,</span> <span class="n">VMSTOR_CURRENT_MINOR</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The revision number is only used in Windows; set it to 0.</span>
<span class="cm">	 */</span>
	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">.</span><span class="n">revision</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">vstor_packet</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">request</span><span class="p">,</span>
			       <span class="n">VM_PKT_DATA_INBAND</span><span class="p">,</span>
			       <span class="n">VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">wait_event</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">operation</span> <span class="o">!=</span> <span class="n">VSTOR_OPERATION_COMPLETE_IO</span> <span class="o">||</span>
	    <span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>


	<span class="n">memset</span><span class="p">(</span><span class="n">vstor_packet</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span><span class="p">));</span>
	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">operation</span> <span class="o">=</span> <span class="n">VSTOR_OPERATION_QUERY_PROPERTIES</span><span class="p">;</span>
	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">REQUEST_COMPLETION_FLAG</span><span class="p">;</span>
	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">storage_channel_properties</span><span class="p">.</span><span class="n">port_number</span> <span class="o">=</span>
					<span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">port_number</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">vstor_packet</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">request</span><span class="p">,</span>
			       <span class="n">VM_PKT_DATA_INBAND</span><span class="p">,</span>
			       <span class="n">VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">wait_event</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">operation</span> <span class="o">!=</span> <span class="n">VSTOR_OPERATION_COMPLETE_IO</span> <span class="o">||</span>
	    <span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">path_id</span> <span class="o">=</span> <span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">storage_channel_properties</span><span class="p">.</span><span class="n">path_id</span><span class="p">;</span>
	<span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">target_id</span>
		<span class="o">=</span> <span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">storage_channel_properties</span><span class="p">.</span><span class="n">target_id</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">vstor_packet</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span><span class="p">));</span>
	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">operation</span> <span class="o">=</span> <span class="n">VSTOR_OPERATION_END_INITIALIZATION</span><span class="p">;</span>
	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">REQUEST_COMPLETION_FLAG</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">vstor_packet</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">request</span><span class="p">,</span>
			       <span class="n">VM_PKT_DATA_INBAND</span><span class="p">,</span>
			       <span class="n">VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">wait_event</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">operation</span> <span class="o">!=</span> <span class="n">VSTOR_OPERATION_COMPLETE_IO</span> <span class="o">||</span>
	    <span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>


<span class="nl">cleanup:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">storvsc_command_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">storvsc_cmd_request</span> <span class="o">*</span><span class="n">cmd_request</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmnd</span> <span class="o">=</span> <span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_host_device</span> <span class="o">*</span><span class="n">host_dev</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">scsi_done_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sense_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmscsi_request</span> <span class="o">*</span><span class="n">vm_srb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">storvsc_scan_work</span> <span class="o">*</span><span class="n">wrk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stor_mem_pools</span> <span class="o">*</span><span class="n">memp</span> <span class="o">=</span> <span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">vm_srb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">vstor_packet</span><span class="p">.</span><span class="n">vm_srb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">bounce_sgl_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">data_in</span> <span class="o">==</span> <span class="n">READ_TYPE</span><span class="p">)</span>
			<span class="n">copy_from_bounce_buffer</span><span class="p">(</span><span class="n">scsi_sglist</span><span class="p">(</span><span class="n">scmnd</span><span class="p">),</span>
					<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">bounce_sgl</span><span class="p">,</span>
					<span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scmnd</span><span class="p">),</span>
					<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">bounce_sgl_count</span><span class="p">);</span>
		<span class="n">destroy_bounce_buffer</span><span class="p">(</span><span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">bounce_sgl</span><span class="p">,</span>
					<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">bounce_sgl_count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is an error; offline the device since all</span>
<span class="cm">	 * error recovery strategies would have already been</span>
<span class="cm">	 * deployed on the host side. However, if the command</span>
<span class="cm">	 * were a pass-through command deal with it appropriately.</span>
<span class="cm">	 */</span>
	<span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">srb_status</span> <span class="o">==</span> <span class="n">SRB_STATUS_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ATA_16</span>:
		<span class="k">case</span> <span class="n">ATA_12</span>:
			<span class="n">set_host_byte</span><span class="p">(</span><span class="n">scmnd</span><span class="p">,</span> <span class="n">DID_PASSTHROUGH</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">set_host_byte</span><span class="p">(</span><span class="n">scmnd</span><span class="p">,</span> <span class="n">DID_TARGET_FAILURE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="cm">/*</span>
<span class="cm">	 * If the LUN is invalid; remove the device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">srb_status</span> <span class="o">==</span> <span class="n">SRB_STATUS_INVALID_LUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="n">stor_dev</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">host_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>

		<span class="n">stor_dev</span> <span class="o">=</span> <span class="n">get_in_stor_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">host</span> <span class="o">=</span> <span class="n">stor_dev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

		<span class="n">wrk</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">storvsc_scan_work</span><span class="p">),</span>
				<span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wrk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_TARGET_FAILURE</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">wrk</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">host</span><span class="p">;</span>
			<span class="n">wrk</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
			<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wrk</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">storvsc_remove_lun</span><span class="p">);</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wrk</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_normalize_sense</span><span class="p">(</span><span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
				<span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sense_hdr</span><span class="p">))</span>
			<span class="n">scsi_print_sense_hdr</span><span class="p">(</span><span class="s">&quot;storvsc&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sense_hdr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">scmnd</span><span class="p">,</span>
		<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">data_buffer</span><span class="p">.</span><span class="n">len</span> <span class="o">-</span>
		<span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">data_transfer_length</span><span class="p">);</span>

	<span class="n">scsi_done_fn</span> <span class="o">=</span> <span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">;</span>

	<span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">scsi_done_fn</span><span class="p">(</span><span class="n">scmnd</span><span class="p">);</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">cmd_request</span><span class="p">,</span> <span class="n">memp</span><span class="o">-&gt;</span><span class="n">request_mempool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">storvsc_on_io_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">vstor_packet</span> <span class="o">*</span><span class="n">vstor_packet</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">storvsc_cmd_request</span> <span class="o">*</span><span class="n">request</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="n">stor_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vstor_packet</span> <span class="o">*</span><span class="n">stor_pkt</span><span class="p">;</span>

	<span class="n">stor_device</span> <span class="o">=</span> <span class="n">hv_get_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">stor_pkt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">vstor_packet</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The current SCSI handling on the host side does</span>
<span class="cm">	 * not correctly handle:</span>
<span class="cm">	 * INQUIRY command with page code parameter set to 0x80</span>
<span class="cm">	 * MODE_SENSE command with cmd[2] == 0x1c</span>
<span class="cm">	 *</span>
<span class="cm">	 * Setup srb and scsi status so this won&#39;t be fatal.</span>
<span class="cm">	 * We do this so we can distinguish truly fatal failues</span>
<span class="cm">	 * (srb status == 0x4) and off-line the device in that case.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">stor_pkt</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INQUIRY</span><span class="p">)</span> <span class="o">||</span>
	   <span class="p">(</span><span class="n">stor_pkt</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MODE_SENSE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">scsi_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">srb_status</span> <span class="o">=</span> <span class="n">SRB_STATUS_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* Copy over the status...etc */</span>
	<span class="n">stor_pkt</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">scsi_status</span> <span class="o">=</span> <span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">scsi_status</span><span class="p">;</span>
	<span class="n">stor_pkt</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">srb_status</span> <span class="o">=</span> <span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">srb_status</span><span class="p">;</span>
	<span class="n">stor_pkt</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">sense_info_length</span> <span class="o">=</span>
	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">sense_info_length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">scsi_status</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
		<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">srb_status</span> <span class="o">!=</span> <span class="n">SRB_STATUS_SUCCESS</span><span class="p">){</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
			 <span class="s">&quot;cmd 0x%x scsi status 0x%x srb status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">stor_pkt</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			 <span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">scsi_status</span><span class="p">,</span>
			 <span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">srb_status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">scsi_status</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x02</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* CHECK_CONDITION */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">srb_status</span> <span class="o">&amp;</span>
			<span class="n">SRB_STATUS_AUTOSENSE_VALID</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* autosense data available */</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
				 <span class="s">&quot;stor pkt %p autosense data valid - len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">request</span><span class="p">,</span>
				 <span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">sense_info_length</span><span class="p">);</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
			       <span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">sense_data</span><span class="p">,</span>
			       <span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">sense_info_length</span><span class="p">);</span>

		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">stor_pkt</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">data_transfer_length</span> <span class="o">=</span>
	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">data_transfer_length</span><span class="p">;</span>

	<span class="n">storvsc_command_completion</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">num_outstanding_req</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">drain_notify</span><span class="p">)</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">waiting_to_drain</span><span class="p">);</span>


<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">storvsc_on_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">vstor_packet</span> <span class="o">*</span><span class="n">vstor_packet</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">storvsc_cmd_request</span> <span class="o">*</span><span class="n">request</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">storvsc_scan_work</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="n">stor_device</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">operation</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VSTOR_OPERATION_COMPLETE_IO</span>:
		<span class="n">storvsc_on_io_completion</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">vstor_packet</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">VSTOR_OPERATION_REMOVE_DEVICE</span>:
	<span class="k">case</span> <span class="n">VSTOR_OPERATION_ENUMERATE_BUS</span>:
		<span class="n">stor_device</span> <span class="o">=</span> <span class="n">get_in_stor_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="n">work</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">storvsc_scan_work</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">work</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">storvsc_bus_scan</span><span class="p">);</span>
		<span class="n">work</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">storvsc_on_channel_callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="p">)</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="n">stor_device</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bytes_recvd</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">request_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">packet</span><span class="p">[</span><span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span><span class="p">),</span> <span class="mi">8</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">storvsc_cmd_request</span> <span class="o">*</span><span class="n">request</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>


	<span class="n">stor_device</span> <span class="o">=</span> <span class="n">get_in_stor_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stor_device</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_recvpacket</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">packet</span><span class="p">,</span>
				       <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span><span class="p">),</span> <span class="mi">8</span><span class="p">),</span>
				       <span class="o">&amp;</span><span class="n">bytes_recvd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">request_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bytes_recvd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">request</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">storvsc_cmd_request</span> <span class="o">*</span><span class="p">)</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">request_id</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">request</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">init_request</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">reset_request</span><span class="p">))</span> <span class="p">{</span>

				<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">vstor_packet</span><span class="p">,</span> <span class="n">packet</span><span class="p">,</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span><span class="p">));</span>
				<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">wait_event</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">storvsc_on_receive</span><span class="p">(</span><span class="n">device</span><span class="p">,</span>
						<span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">packet</span><span class="p">,</span>
						<span class="n">request</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">storvsc_connect_to_vsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ring_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmstorage_channel_properties</span> <span class="n">props</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">props</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmstorage_channel_properties</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_open</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
			 <span class="n">ring_size</span><span class="p">,</span>
			 <span class="n">ring_size</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">props</span><span class="p">,</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmstorage_channel_properties</span><span class="p">),</span>
			 <span class="n">storvsc_on_channel_callback</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">storvsc_channel_init</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">storvsc_dev_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="n">stor_device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">stor_device</span> <span class="o">=</span> <span class="n">hv_get_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">inbound_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">inbound_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point, all outbound traffic should be disable. We</span>
<span class="cm">	 * only allow inbound traffic (responses) to proceed so that</span>
<span class="cm">	 * outstanding requests can be completed.</span>
<span class="cm">	 */</span>

	<span class="n">storvsc_wait_to_drain</span><span class="p">(</span><span class="n">stor_device</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we have already drained, we don&#39;t need to busy wait</span>
<span class="cm">	 * as was done in final_release_stor_device()</span>
<span class="cm">	 * Note that we cannot set the ext pointer to NULL until</span>
<span class="cm">	 * we have drained - to drain the outgoing packets, we need to</span>
<span class="cm">	 * allow incoming packets.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">inbound_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">hv_set_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">inbound_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Close the channel */</span>
	<span class="n">vmbus_close</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">stor_device</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">storvsc_do_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">storvsc_cmd_request</span> <span class="o">*</span><span class="n">request</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="n">stor_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vstor_packet</span> <span class="o">*</span><span class="n">vstor_packet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vstor_packet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">vstor_packet</span><span class="p">;</span>
	<span class="n">stor_device</span> <span class="o">=</span> <span class="n">get_out_stor_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stor_device</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>


	<span class="n">request</span><span class="o">-&gt;</span><span class="n">device</span>  <span class="o">=</span> <span class="n">device</span><span class="p">;</span>


	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REQUEST_COMPLETION_FLAG</span><span class="p">;</span>

	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmscsi_request</span><span class="p">);</span>


	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">sense_info_length</span> <span class="o">=</span> <span class="n">STORVSC_SENSE_BUFFER_SIZE</span><span class="p">;</span>


	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">data_transfer_length</span> <span class="o">=</span>
	<span class="n">request</span><span class="o">-&gt;</span><span class="n">data_buffer</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>

	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">operation</span> <span class="o">=</span> <span class="n">VSTOR_OPERATION_EXECUTE_SRB</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">data_buffer</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket_multipagebuffer</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">data_buffer</span><span class="p">,</span>
				<span class="n">vstor_packet</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">request</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">vstor_packet</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">request</span><span class="p">,</span>
			       <span class="n">VM_PKT_DATA_INBAND</span><span class="p">,</span>
			       <span class="n">VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">num_outstanding_req</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">storvsc_device_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdevice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stor_mem_pools</span> <span class="o">*</span><span class="n">memp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="n">STORVSC_MIN_BUF_NR</span><span class="p">;</span>

	<span class="n">memp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stor_mem_pools</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">memp</span><span class="o">-&gt;</span><span class="n">request_pool</span> <span class="o">=</span>
		<span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdevice</span><span class="o">-&gt;</span><span class="n">sdev_dev</span><span class="p">),</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">storvsc_cmd_request</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memp</span><span class="o">-&gt;</span><span class="n">request_pool</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err0</span><span class="p">;</span>

	<span class="n">memp</span><span class="o">-&gt;</span><span class="n">request_mempool</span> <span class="o">=</span> <span class="n">mempool_create</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">mempool_alloc_slab</span><span class="p">,</span>
						<span class="n">mempool_free_slab</span><span class="p">,</span>
						<span class="n">memp</span><span class="o">-&gt;</span><span class="n">request_pool</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memp</span><span class="o">-&gt;</span><span class="n">request_mempool</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err1</span><span class="p">;</span>

	<span class="n">sdevice</span><span class="o">-&gt;</span><span class="n">hostdata</span> <span class="o">=</span> <span class="n">memp</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err1:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">memp</span><span class="o">-&gt;</span><span class="n">request_pool</span><span class="p">);</span>

<span class="nl">err0:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">memp</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">storvsc_device_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdevice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stor_mem_pools</span> <span class="o">*</span><span class="n">memp</span> <span class="o">=</span> <span class="n">sdevice</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">memp</span><span class="o">-&gt;</span><span class="n">request_mempool</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">memp</span><span class="o">-&gt;</span><span class="n">request_pool</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">memp</span><span class="p">);</span>
	<span class="n">sdevice</span><span class="o">-&gt;</span><span class="n">hostdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">storvsc_device_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdevice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdevice</span><span class="p">,</span> <span class="n">MSG_SIMPLE_TAG</span><span class="p">,</span>
				<span class="n">STORVSC_MAX_IO_REQUESTS</span><span class="p">);</span>

	<span class="n">blk_queue_max_segment_size</span><span class="p">(</span><span class="n">sdevice</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">blk_queue_bounce_limit</span><span class="p">(</span><span class="n">sdevice</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">BLK_BOUNCE_ANY</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">storvsc_get_chs</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span> <span class="n">bdev</span><span class="p">,</span>
			   <span class="n">sector_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">nsect</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">cylinders</span> <span class="o">=</span> <span class="n">nsect</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">heads</span><span class="p">,</span> <span class="n">sectors_pt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are making up these values; let us keep it simple.</span>
<span class="cm">	 */</span>
	<span class="n">heads</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">sectors_pt</span> <span class="o">=</span> <span class="mh">0x3f</span><span class="p">;</span>      <span class="cm">/* Sectors per track */</span>
	<span class="n">sector_div</span><span class="p">(</span><span class="n">cylinders</span><span class="p">,</span> <span class="n">heads</span> <span class="o">*</span> <span class="n">sectors_pt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sector_t</span><span class="p">)(</span><span class="n">cylinders</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">heads</span> <span class="o">*</span> <span class="n">sectors_pt</span> <span class="o">&lt;</span> <span class="n">nsect</span><span class="p">)</span>
		<span class="n">cylinders</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">heads</span><span class="p">;</span>
	<span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sectors_pt</span><span class="p">;</span>
	<span class="n">info</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cylinders</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">storvsc_host_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hv_host_device</span> <span class="o">*</span><span class="n">host_dev</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="n">host_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="n">stor_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">storvsc_cmd_request</span> <span class="o">*</span><span class="n">request</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vstor_packet</span> <span class="o">*</span><span class="n">vstor_packet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>


	<span class="n">stor_device</span> <span class="o">=</span> <span class="n">get_out_stor_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stor_device</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>

	<span class="n">request</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">reset_request</span><span class="p">;</span>
	<span class="n">vstor_packet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">vstor_packet</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">wait_event</span><span class="p">);</span>

	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">operation</span> <span class="o">=</span> <span class="n">VSTOR_OPERATION_RESET_BUS</span><span class="p">;</span>
	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">REQUEST_COMPLETION_FLAG</span><span class="p">;</span>
	<span class="n">vstor_packet</span><span class="o">-&gt;</span><span class="n">vm_srb</span><span class="p">.</span><span class="n">path_id</span> <span class="o">=</span> <span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">path_id</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">vstor_packet</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">reset_request</span><span class="p">,</span>
			       <span class="n">VM_PKT_DATA_INBAND</span><span class="p">,</span>
			       <span class="n">VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">wait_event</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">TIMEOUT_ERROR</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * At this point, all outstanding requests in the adapter</span>
<span class="cm">	 * should have been flushed out and return to us</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">storvsc_scsi_cmd_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">allowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">scsi_op</span> <span class="o">=</span> <span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">scsi_op</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * smartd sends this command and the host does not handle</span>
<span class="cm">	 * this. So, don&#39;t send it.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SET_WINDOW</span>:
		<span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ILLEGAL_REQUEST</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">allowed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">allowed</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">storvsc_queuecommand</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_host_device</span> <span class="o">*</span><span class="n">host_dev</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">host_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">storvsc_cmd_request</span> <span class="o">*</span><span class="n">cmd_request</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">request_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmscsi_request</span> <span class="o">*</span><span class="n">vm_srb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stor_mem_pools</span> <span class="o">*</span><span class="n">memp</span> <span class="o">=</span> <span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">storvsc_scsi_cmd_ok</span><span class="p">(</span><span class="n">scmnd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">scmnd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">request_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">storvsc_cmd_request</span><span class="p">);</span>

	<span class="n">cmd_request</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">memp</span><span class="o">-&gt;</span><span class="n">request_mempool</span><span class="p">,</span>
				       <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We might be invoked in an interrupt context; hence</span>
<span class="cm">	 * mempool_alloc() can fail.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd_request</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_DEVICE_BUSY</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">cmd_request</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">storvsc_cmd_request</span><span class="p">));</span>

	<span class="cm">/* Setup the cmd request */</span>
	<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">scmnd</span><span class="p">;</span>

	<span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd_request</span><span class="p">;</span>

	<span class="n">vm_srb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">vstor_packet</span><span class="p">.</span><span class="n">vm_srb</span><span class="p">;</span>


	<span class="cm">/* Build the SRB */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DMA_TO_DEVICE</span>:
		<span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">data_in</span> <span class="o">=</span> <span class="n">WRITE_TYPE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_FROM_DEVICE</span>:
		<span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">data_in</span> <span class="o">=</span> <span class="n">READ_TYPE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">data_in</span> <span class="o">=</span> <span class="n">UNKNOWN_TYPE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">port_number</span> <span class="o">=</span> <span class="n">host_dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">path_id</span> <span class="o">=</span> <span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
	<span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">target_id</span> <span class="o">=</span> <span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>

	<span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">cdb_length</span> <span class="o">=</span> <span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">cdb_length</span><span class="p">);</span>

	<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">sense_buffer</span> <span class="o">=</span> <span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">;</span>


	<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">data_buffer</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scmnd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scmnd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sgl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">)</span><span class="n">scsi_sglist</span><span class="p">(</span><span class="n">scmnd</span><span class="p">);</span>
		<span class="n">sg_count</span> <span class="o">=</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scmnd</span><span class="p">);</span>

		<span class="cm">/* check if we need to bounce the sgl */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_bounce_buffer</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scmnd</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">bounce_sgl</span> <span class="o">=</span>
				<span class="n">create_bounce_buffer</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scmnd</span><span class="p">),</span>
						     <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scmnd</span><span class="p">),</span>
						     <span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">data_in</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">bounce_sgl</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">queue_error</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">bounce_sgl_count</span> <span class="o">=</span>
				<span class="n">ALIGN</span><span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scmnd</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
					<span class="n">PAGE_SHIFT</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">vm_srb</span><span class="o">-&gt;</span><span class="n">data_in</span> <span class="o">==</span> <span class="n">WRITE_TYPE</span><span class="p">)</span>
				<span class="n">copy_to_bounce_buffer</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span>
					<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">bounce_sgl</span><span class="p">,</span>
					<span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scmnd</span><span class="p">));</span>

			<span class="n">sgl</span> <span class="o">=</span> <span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">bounce_sgl</span><span class="p">;</span>
			<span class="n">sg_count</span> <span class="o">=</span> <span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">bounce_sgl_count</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">data_buffer</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">sgl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sg_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">data_buffer</span><span class="p">.</span><span class="n">pfn_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">page_to_pfn</span><span class="p">(</span><span class="n">sg_page</span><span class="p">((</span><span class="o">&amp;</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">])));</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scsi_sglist</span><span class="p">(</span><span class="n">scmnd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">data_buffer</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span>
			<span class="n">virt_to_phys</span><span class="p">(</span><span class="n">scsi_sglist</span><span class="p">(</span><span class="n">scmnd</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">data_buffer</span><span class="p">.</span><span class="n">pfn_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">virt_to_phys</span><span class="p">(</span><span class="n">scsi_sglist</span><span class="p">(</span><span class="n">scmnd</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Invokes the vsc to start an IO */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">storvsc_do_io</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd_request</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no more space */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">bounce_sgl_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">destroy_bounce_buffer</span><span class="p">(</span><span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">bounce_sgl</span><span class="p">,</span>
					<span class="n">cmd_request</span><span class="o">-&gt;</span><span class="n">bounce_sgl_count</span><span class="p">);</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">SCSI_MLQUEUE_DEVICE_BUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">queue_error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">queue_error:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">cmd_request</span><span class="p">,</span> <span class="n">memp</span><span class="o">-&gt;</span><span class="n">request_mempool</span><span class="p">);</span>
	<span class="n">scmnd</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">scsi_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span>	<span class="o">=</span>		<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>			<span class="s">&quot;storvsc_host_t&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bios_param</span> <span class="o">=</span>		<span class="n">storvsc_get_chs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span> <span class="o">=</span>		<span class="n">storvsc_queuecommand</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_host_reset_handler</span> <span class="o">=</span>	<span class="n">storvsc_host_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_alloc</span> <span class="o">=</span>		<span class="n">storvsc_device_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_destroy</span> <span class="o">=</span>	<span class="n">storvsc_device_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_configure</span> <span class="o">=</span>	<span class="n">storvsc_device_configure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmd_per_lun</span> <span class="o">=</span>		<span class="mi">1</span><span class="p">,</span>
	<span class="cm">/* 64 max_queue * 1 target */</span>
	<span class="p">.</span><span class="n">can_queue</span> <span class="o">=</span>		<span class="n">STORVSC_MAX_IO_REQUESTS</span><span class="o">*</span><span class="n">STORVSC_MAX_TARGETS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">this_id</span> <span class="o">=</span>		<span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="cm">/* no use setting to 0 since ll_blk_rw reset it to 1 */</span>
	<span class="cm">/* currently 32 */</span>
	<span class="p">.</span><span class="n">sg_tablesize</span> <span class="o">=</span>		<span class="n">MAX_MULTIPAGE_BUFFER_COUNT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span> <span class="o">=</span>	<span class="n">DISABLE_CLUSTERING</span><span class="p">,</span>
	<span class="cm">/* Make sure we dont get a sg segment crosses a page boundary */</span>
	<span class="p">.</span><span class="n">dma_boundary</span> <span class="o">=</span>		<span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SCSI_GUID</span><span class="p">,</span>
	<span class="n">IDE_GUID</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">hv_vmbus_device_id</span> <span class="n">id_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* SCSI guid */</span>
	<span class="p">{</span> <span class="n">VMBUS_DEVICE</span><span class="p">(</span><span class="mh">0xd9</span><span class="p">,</span> <span class="mh">0x63</span><span class="p">,</span> <span class="mh">0x61</span><span class="p">,</span> <span class="mh">0xba</span><span class="p">,</span> <span class="mh">0xa1</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x29</span><span class="p">,</span> <span class="mh">0x4d</span><span class="p">,</span>
		       <span class="mh">0xb6</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">,</span> <span class="mh">0x72</span><span class="p">,</span> <span class="mh">0xe2</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xb1</span><span class="p">,</span> <span class="mh">0xdc</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">)</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">SCSI_GUID</span> <span class="p">},</span>
	<span class="cm">/* IDE guid */</span>
	<span class="p">{</span> <span class="n">VMBUS_DEVICE</span><span class="p">(</span><span class="mh">0x32</span><span class="p">,</span> <span class="mh">0x26</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x32</span><span class="p">,</span> <span class="mh">0xcb</span><span class="p">,</span> <span class="mh">0x86</span><span class="p">,</span> <span class="mh">0xa2</span><span class="p">,</span> <span class="mh">0x44</span><span class="p">,</span>
		       <span class="mh">0x9b</span><span class="p">,</span> <span class="mh">0x5c</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="mh">0xd1</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x73</span><span class="p">,</span> <span class="mh">0x54</span><span class="p">,</span> <span class="mh">0xf5</span><span class="p">)</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">IDE_GUID</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">vmbus</span><span class="p">,</span> <span class="n">id_table</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">storvsc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">hv_vmbus_device_id</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_host_device</span> <span class="o">*</span><span class="n">host_dev</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">dev_is_ide</span> <span class="o">=</span> <span class="p">((</span><span class="n">dev_id</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">==</span> <span class="n">IDE_GUID</span><span class="p">)</span> <span class="o">?</span> <span class="nb">true</span> <span class="o">:</span> <span class="nb">false</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="n">stor_device</span><span class="p">;</span>

	<span class="n">host</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scsi_driver</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_host_device</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">host_dev</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">host_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_host_device</span><span class="p">));</span>

	<span class="n">host_dev</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">;</span>
	<span class="n">host_dev</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>


	<span class="n">stor_device</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">storvsc_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stor_device</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">waiting_to_drain</span><span class="p">);</span>
	<span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">host</span><span class="p">;</span>
	<span class="n">hv_set_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">stor_device</span><span class="p">);</span>

	<span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">port_number</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">storvsc_connect_to_vsp</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">storvsc_ringbuffer_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out1</span><span class="p">;</span>

	<span class="n">host_dev</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">path_id</span><span class="p">;</span>
	<span class="n">host_dev</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">target_id</span><span class="p">;</span>

	<span class="cm">/* max # of devices per target */</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="n">STORVSC_MAX_LUNS_PER_TARGET</span><span class="p">;</span>
	<span class="cm">/* max # of targets per channel */</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="n">STORVSC_MAX_TARGETS</span><span class="p">;</span>
	<span class="cm">/* max # of channels */</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">=</span> <span class="n">STORVSC_MAX_CHANNELS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* max cmd length */</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">=</span> <span class="n">STORVSC_MAX_CMD_LEN</span><span class="p">;</span>

	<span class="cm">/* Register the HBA and start the scsi bus scan */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_add_host</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_is_ide</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_scan_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">dev_instance</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span>
			 <span class="n">device</span><span class="o">-&gt;</span><span class="n">dev_instance</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_add_device</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out2:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Once we have connected with the host, we would need to</span>
<span class="cm">	 * to invoke storvsc_dev_remove() to rollback this state and</span>
<span class="cm">	 * this call also frees up the stor_device; hence the jump around</span>
<span class="cm">	 * err_out1 label.</span>
<span class="cm">	 */</span>
	<span class="n">storvsc_dev_remove</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">err_out0</span><span class="p">;</span>

<span class="nl">err_out1:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">stor_device</span><span class="p">);</span>

<span class="nl">err_out0:</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">storvsc_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">storvsc_device</span> <span class="o">*</span><span class="n">stor_device</span> <span class="o">=</span> <span class="n">hv_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">stor_device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">storvsc_dev_remove</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hv_driver</span> <span class="n">storvsc_drv</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">KBUILD_MODNAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">id_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">storvsc_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">storvsc_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">storvsc_drv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">max_outstanding_req_per_channel</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Divide the ring buffer data size (which is 1 page less</span>
<span class="cm">	 * than the ring buffer size since that page is reserved for</span>
<span class="cm">	 * the ring buffer indices) by the max request size (which is</span>
<span class="cm">	 * vmbus_channel_packet_multipage_buffer + struct vstor_packet + u64)</span>
<span class="cm">	 */</span>
	<span class="n">max_outstanding_req_per_channel</span> <span class="o">=</span>
		<span class="p">((</span><span class="n">storvsc_ringbuffer_size</span> <span class="o">-</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">/</span>
		<span class="n">ALIGN</span><span class="p">(</span><span class="n">MAX_MULTIPAGE_BUFFER_PACKET</span> <span class="o">+</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vstor_packet</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_outstanding_req_per_channel</span> <span class="o">&lt;</span>
	    <span class="n">STORVSC_MAX_IO_REQUESTS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">vmbus_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">storvsc_drv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">storvsc_drv_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmbus_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">storvsc_drv</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">HV_DRV_VERSION</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Microsoft Hyper-V virtual storage driver&quot;</span><span class="p">);</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">storvsc_drv_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">storvsc_drv_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
