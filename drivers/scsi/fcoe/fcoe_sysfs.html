<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › fcoe › fcoe_sysfs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fcoe_sysfs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright(c) 2011 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintained at www.Open-FCoE.org</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>

<span class="cp">#include &lt;scsi/fcoe_sysfs.h&gt;</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">ctlr_num</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">fcf_num</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * fcoe_fcf_dev_loss_tmo: the default number of seconds that fcoe sysfs</span>
<span class="cm"> * should insulate the loss of a fcf.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fcoe_fcf_dev_loss_tmo</span> <span class="o">=</span> <span class="mi">1800</span><span class="p">;</span>  <span class="cm">/* seconds */</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">fcf_dev_loss_tmo</span><span class="p">,</span> <span class="n">fcoe_fcf_dev_loss_tmo</span><span class="p">,</span>
		   <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">fcf_dev_loss_tmo</span><span class="p">,</span>
		 <span class="s">&quot;Maximum number of seconds that libfcoe should&quot;</span>
		 <span class="s">&quot; insulate the loss of a fcf. Once this value is&quot;</span>
		 <span class="s">&quot; exceeded, the fcf is removed.&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * These are used by the fcoe_*_show_function routines, they</span>
<span class="cm"> * are intentionally placed in the .c file as they&#39;re not intended</span>
<span class="cm"> * for use throughout the code.</span>
<span class="cm"> */</span>
<span class="cp">#define fcoe_ctlr_id(x)				\</span>
<span class="cp">	((x)-&gt;id)</span>
<span class="cp">#define fcoe_ctlr_work_q_name(x)		\</span>
<span class="cp">	((x)-&gt;work_q_name)</span>
<span class="cp">#define fcoe_ctlr_work_q(x)			\</span>
<span class="cp">	((x)-&gt;work_q)</span>
<span class="cp">#define fcoe_ctlr_devloss_work_q_name(x)	\</span>
<span class="cp">	((x)-&gt;devloss_work_q_name)</span>
<span class="cp">#define fcoe_ctlr_devloss_work_q(x)		\</span>
<span class="cp">	((x)-&gt;devloss_work_q)</span>
<span class="cp">#define fcoe_ctlr_mode(x)			\</span>
<span class="cp">	((x)-&gt;mode)</span>
<span class="cp">#define fcoe_ctlr_fcf_dev_loss_tmo(x)		\</span>
<span class="cp">	((x)-&gt;fcf_dev_loss_tmo)</span>
<span class="cp">#define fcoe_ctlr_link_fail(x)			\</span>
<span class="cp">	((x)-&gt;lesb.lesb_link_fail)</span>
<span class="cp">#define fcoe_ctlr_vlink_fail(x)			\</span>
<span class="cp">	((x)-&gt;lesb.lesb_vlink_fail)</span>
<span class="cp">#define fcoe_ctlr_miss_fka(x)			\</span>
<span class="cp">	((x)-&gt;lesb.lesb_miss_fka)</span>
<span class="cp">#define fcoe_ctlr_symb_err(x)			\</span>
<span class="cp">	((x)-&gt;lesb.lesb_symb_err)</span>
<span class="cp">#define fcoe_ctlr_err_block(x)			\</span>
<span class="cp">	((x)-&gt;lesb.lesb_err_block)</span>
<span class="cp">#define fcoe_ctlr_fcs_error(x)			\</span>
<span class="cp">	((x)-&gt;lesb.lesb_fcs_error)</span>
<span class="cp">#define fcoe_fcf_state(x)			\</span>
<span class="cp">	((x)-&gt;state)</span>
<span class="cp">#define fcoe_fcf_fabric_name(x)			\</span>
<span class="cp">	((x)-&gt;fabric_name)</span>
<span class="cp">#define fcoe_fcf_switch_name(x)			\</span>
<span class="cp">	((x)-&gt;switch_name)</span>
<span class="cp">#define fcoe_fcf_fc_map(x)			\</span>
<span class="cp">	((x)-&gt;fc_map)</span>
<span class="cp">#define fcoe_fcf_vfid(x)			\</span>
<span class="cp">	((x)-&gt;vfid)</span>
<span class="cp">#define fcoe_fcf_mac(x)				\</span>
<span class="cp">	((x)-&gt;mac)</span>
<span class="cp">#define fcoe_fcf_priority(x)			\</span>
<span class="cp">	((x)-&gt;priority)</span>
<span class="cp">#define fcoe_fcf_fka_period(x)			\</span>
<span class="cp">	((x)-&gt;fka_period)</span>
<span class="cp">#define fcoe_fcf_dev_loss_tmo(x)		\</span>
<span class="cp">	((x)-&gt;dev_loss_tmo)</span>
<span class="cp">#define fcoe_fcf_selected(x)			\</span>
<span class="cp">	((x)-&gt;selected)</span>
<span class="cp">#define fcoe_fcf_vlan_id(x)			\</span>
<span class="cp">	((x)-&gt;vlan_id)</span>

<span class="cm">/*</span>
<span class="cm"> * dev_loss_tmo attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_str_to_dev_loss</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kstrtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="o">*</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check for overflow; dev_loss_tmo is u32</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_fcf_set_dev_loss_tmo</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">fcf</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FCOE_FCF_STATE_UNKNOWN</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FCOE_FCF_STATE_DISCONNECTED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FCOE_FCF_STATE_DELETED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check for overflow; dev_loss_tmo is u32</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">fcoe_fcf_dev_loss_tmo</span><span class="p">(</span><span class="n">fcf</span><span class="p">)</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define FCOE_DEVICE_ATTR(_prefix, _name, _mode, _show, _store)	\</span>
<span class="cp">struct device_attribute device_attr_fcoe_##_prefix##_##_name =	\</span>
<span class="cp">	__ATTR(_name, _mode, _show, _store)</span>

<span class="cp">#define fcoe_ctlr_show_function(field, format_string, sz, cast)	\</span>
<span class="cp">static ssize_t show_fcoe_ctlr_device_##field(struct device *dev, \</span>
<span class="cp">					    struct device_attribute *attr, \</span>
<span class="cp">					    char *buf)			\</span>
<span class="cp">{									\</span>
<span class="cp">	struct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);		\</span>
<span class="cp">	if (ctlr-&gt;f-&gt;get_fcoe_ctlr_##field)				\</span>
<span class="cp">		ctlr-&gt;f-&gt;get_fcoe_ctlr_##field(ctlr);			\</span>
<span class="cp">	return snprintf(buf, sz, format_string,				\</span>
<span class="cp">			cast fcoe_ctlr_##field(ctlr));			\</span>
<span class="cp">}</span>

<span class="cp">#define fcoe_fcf_show_function(field, format_string, sz, cast)	\</span>
<span class="cp">static ssize_t show_fcoe_fcf_device_##field(struct device *dev,	\</span>
<span class="cp">					   struct device_attribute *attr, \</span>
<span class="cp">					   char *buf)			\</span>
<span class="cp">{									\</span>
<span class="cp">	struct fcoe_fcf_device *fcf = dev_to_fcf(dev);			\</span>
<span class="cp">	struct fcoe_ctlr_device *ctlr = fcoe_fcf_dev_to_ctlr_dev(fcf);	\</span>
<span class="cp">	if (ctlr-&gt;f-&gt;get_fcoe_fcf_##field)				\</span>
<span class="cp">		ctlr-&gt;f-&gt;get_fcoe_fcf_##field(fcf);			\</span>
<span class="cp">	return snprintf(buf, sz, format_string,				\</span>
<span class="cp">			cast fcoe_fcf_##field(fcf));			\</span>
<span class="cp">}</span>

<span class="cp">#define fcoe_ctlr_private_show_function(field, format_string, sz, cast)	\</span>
<span class="cp">static ssize_t show_fcoe_ctlr_device_##field(struct device *dev, \</span>
<span class="cp">					    struct device_attribute *attr, \</span>
<span class="cp">					    char *buf)			\</span>
<span class="cp">{									\</span>
<span class="cp">	struct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);		\</span>
<span class="cp">	return snprintf(buf, sz, format_string, cast fcoe_ctlr_##field(ctlr)); \</span>
<span class="cp">}</span>

<span class="cp">#define fcoe_fcf_private_show_function(field, format_string, sz, cast)	\</span>
<span class="cp">static ssize_t show_fcoe_fcf_device_##field(struct device *dev,	\</span>
<span class="cp">					   struct device_attribute *attr, \</span>
<span class="cp">					   char *buf)			\</span>
<span class="cp">{								\</span>
<span class="cp">	struct fcoe_fcf_device *fcf = dev_to_fcf(dev);			\</span>
<span class="cp">	return snprintf(buf, sz, format_string, cast fcoe_fcf_##field(fcf)); \</span>
<span class="cp">}</span>

<span class="cp">#define fcoe_ctlr_private_rd_attr(field, format_string, sz)		\</span>
<span class="cp">	fcoe_ctlr_private_show_function(field, format_string, sz, )	\</span>
<span class="cp">	static FCOE_DEVICE_ATTR(ctlr, field, S_IRUGO,			\</span>
<span class="cp">				show_fcoe_ctlr_device_##field, NULL)</span>

<span class="cp">#define fcoe_ctlr_rd_attr(field, format_string, sz)			\</span>
<span class="cp">	fcoe_ctlr_show_function(field, format_string, sz, )		\</span>
<span class="cp">	static FCOE_DEVICE_ATTR(ctlr, field, S_IRUGO,			\</span>
<span class="cp">				show_fcoe_ctlr_device_##field, NULL)</span>

<span class="cp">#define fcoe_fcf_rd_attr(field, format_string, sz)			\</span>
<span class="cp">	fcoe_fcf_show_function(field, format_string, sz, )		\</span>
<span class="cp">	static FCOE_DEVICE_ATTR(fcf, field, S_IRUGO,			\</span>
<span class="cp">				show_fcoe_fcf_device_##field, NULL)</span>

<span class="cp">#define fcoe_fcf_private_rd_attr(field, format_string, sz)		\</span>
<span class="cp">	fcoe_fcf_private_show_function(field, format_string, sz, )	\</span>
<span class="cp">	static FCOE_DEVICE_ATTR(fcf, field, S_IRUGO,			\</span>
<span class="cp">				show_fcoe_fcf_device_##field, NULL)</span>

<span class="cp">#define fcoe_ctlr_private_rd_attr_cast(field, format_string, sz, cast)	\</span>
<span class="cp">	fcoe_ctlr_private_show_function(field, format_string, sz, (cast)) \</span>
<span class="cp">	static FCOE_DEVICE_ATTR(ctlr, field, S_IRUGO,			\</span>
<span class="cp">				show_fcoe_ctlr_device_##field, NULL)</span>

<span class="cp">#define fcoe_fcf_private_rd_attr_cast(field, format_string, sz, cast)	\</span>
<span class="cp">	fcoe_fcf_private_show_function(field, format_string, sz, (cast)) \</span>
<span class="cp">	static FCOE_DEVICE_ATTR(fcf, field, S_IRUGO,			\</span>
<span class="cp">				show_fcoe_fcf_device_##field, NULL)</span>

<span class="cp">#define fcoe_enum_name_search(title, table_type, table)			\</span>
<span class="cp">static const char *get_fcoe_##title##_name(enum table_type table_key)	\</span>
<span class="cp">{									\</span>
<span class="cp">	int i;								\</span>
<span class="cp">	char *name = NULL;						\</span>
<span class="cp">									\</span>
<span class="cp">	for (i = 0; i &lt; ARRAY_SIZE(table); i++) {			\</span>
<span class="cp">		if (table[i].value == table_key) {			\</span>
<span class="cp">			name = table[i].name;				\</span>
<span class="cp">			break;						\</span>
<span class="cp">		}							\</span>
<span class="cp">	}								\</span>
<span class="cp">	return name;							\</span>
<span class="cp">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">fcf_state</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">char</span>           <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fcf_state_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">FCOE_FCF_STATE_UNKNOWN</span><span class="p">,</span>      <span class="s">&quot;Unknown&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FCOE_FCF_STATE_DISCONNECTED</span><span class="p">,</span> <span class="s">&quot;Disconnected&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FCOE_FCF_STATE_CONNECTED</span><span class="p">,</span>    <span class="s">&quot;Connected&quot;</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">fcoe_enum_name_search</span><span class="p">(</span><span class="n">fcf_state</span><span class="p">,</span> <span class="n">fcf_state</span><span class="p">,</span> <span class="n">fcf_state_names</span><span class="p">)</span>
<span class="cp">#define FCOE_FCF_STATE_MAX_NAMELEN 50</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">show_fcf_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">fcf</span> <span class="o">=</span> <span class="n">dev_to_fcf</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">name</span> <span class="o">=</span> <span class="n">get_fcoe_fcf_state_name</span><span class="p">(</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">FCOE_FCF_STATE_MAX_NAMELEN</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FCOE_DEVICE_ATTR</span><span class="p">(</span><span class="n">fcf</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">show_fcf_state</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">fip_conn_type</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">char</span>               <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fip_conn_type_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">FIP_CONN_TYPE_UNKNOWN</span><span class="p">,</span> <span class="s">&quot;Unknown&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FIP_CONN_TYPE_FABRIC</span><span class="p">,</span> <span class="s">&quot;Fabric&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FIP_CONN_TYPE_VN2VN</span><span class="p">,</span> <span class="s">&quot;VN2VN&quot;</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">fcoe_enum_name_search</span><span class="p">(</span><span class="n">ctlr_mode</span><span class="p">,</span> <span class="n">fip_conn_type</span><span class="p">,</span> <span class="n">fip_conn_type_names</span><span class="p">)</span>
<span class="cp">#define FCOE_CTLR_MODE_MAX_NAMELEN 50</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">show_ctlr_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr</span> <span class="o">=</span> <span class="n">dev_to_ctlr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_fcoe_ctlr_mode</span><span class="p">)</span>
		<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_fcoe_ctlr_mode</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">get_fcoe_ctlr_mode_name</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">FCOE_CTLR_MODE_MAX_NAMELEN</span><span class="p">,</span>
			<span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FCOE_DEVICE_ATTR</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
			<span class="n">show_ctlr_mode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_private_fcoe_ctlr_fcf_dev_loss_tmo</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr</span> <span class="o">=</span> <span class="n">dev_to_ctlr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">fcf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_str_to_dev_loss</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">fcoe_ctlr_fcf_dev_loss_tmo</span><span class="p">(</span><span class="n">ctlr</span><span class="p">)</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fcf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">fcfs</span><span class="p">,</span> <span class="n">peers</span><span class="p">)</span>
		<span class="n">fcoe_fcf_set_dev_loss_tmo</span><span class="p">(</span><span class="n">fcf</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">fcoe_ctlr_private_show_function</span><span class="p">(</span><span class="n">fcf_dev_loss_tmo</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="p">);</span>
<span class="k">static</span> <span class="n">FCOE_DEVICE_ATTR</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">fcf_dev_loss_tmo</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
			<span class="n">show_fcoe_ctlr_device_fcf_dev_loss_tmo</span><span class="p">,</span>
			<span class="n">store_private_fcoe_ctlr_fcf_dev_loss_tmo</span><span class="p">);</span>

<span class="cm">/* Link Error Status Block (LESB) */</span>
<span class="n">fcoe_ctlr_rd_attr</span><span class="p">(</span><span class="n">link_fail</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">fcoe_ctlr_rd_attr</span><span class="p">(</span><span class="n">vlink_fail</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">fcoe_ctlr_rd_attr</span><span class="p">(</span><span class="n">miss_fka</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">fcoe_ctlr_rd_attr</span><span class="p">(</span><span class="n">symb_err</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">fcoe_ctlr_rd_attr</span><span class="p">(</span><span class="n">err_block</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">fcoe_ctlr_rd_attr</span><span class="p">(</span><span class="n">fcs_error</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

<span class="n">fcoe_fcf_private_rd_attr_cast</span><span class="p">(</span><span class="n">fabric_name</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
<span class="n">fcoe_fcf_private_rd_attr_cast</span><span class="p">(</span><span class="n">switch_name</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
<span class="n">fcoe_fcf_private_rd_attr</span><span class="p">(</span><span class="n">priority</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">fcoe_fcf_private_rd_attr</span><span class="p">(</span><span class="n">fc_map</span><span class="p">,</span> <span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">fcoe_fcf_private_rd_attr</span><span class="p">(</span><span class="n">vfid</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">fcoe_fcf_private_rd_attr</span><span class="p">(</span><span class="n">mac</span><span class="p">,</span> <span class="s">&quot;%pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">fcoe_fcf_private_rd_attr</span><span class="p">(</span><span class="n">fka_period</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">fcoe_fcf_rd_attr</span><span class="p">(</span><span class="n">selected</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">fcoe_fcf_rd_attr</span><span class="p">(</span><span class="n">vlan_id</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

<span class="n">fcoe_fcf_private_show_function</span><span class="p">(</span><span class="n">dev_loss_tmo</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="p">)</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="n">store_fcoe_fcf_dev_loss_tmo</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">fcf</span> <span class="o">=</span> <span class="n">dev_to_fcf</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_str_to_dev_loss</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_fcf_set_dev_loss_tmo</span><span class="p">(</span><span class="n">fcf</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">FCOE_DEVICE_ATTR</span><span class="p">(</span><span class="n">fcf</span><span class="p">,</span> <span class="n">dev_loss_tmo</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
			<span class="n">show_fcoe_fcf_device_dev_loss_tmo</span><span class="p">,</span>
			<span class="n">store_fcoe_fcf_dev_loss_tmo</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">fcoe_ctlr_lesb_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_ctlr_link_fail</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_ctlr_vlink_fail</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_ctlr_miss_fka</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_ctlr_symb_err</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_ctlr_err_block</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_ctlr_fcs_error</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">fcoe_ctlr_lesb_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;lesb&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">fcoe_ctlr_lesb_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">fcoe_ctlr_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_ctlr_fcf_dev_loss_tmo</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_ctlr_mode</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">fcoe_ctlr_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">fcoe_ctlr_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">*</span><span class="n">fcoe_ctlr_attr_groups</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">fcoe_ctlr_attr_group</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">fcoe_ctlr_lesb_attr_group</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">fcoe_fcf_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_fcf_fabric_name</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_fcf_switch_name</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_fcf_dev_loss_tmo</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_fcf_fc_map</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_fcf_vfid</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_fcf_mac</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_fcf_priority</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_fcf_fka_period</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_fcf_state</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_fcf_selected</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_attr_fcoe_fcf_vlan_id</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">fcoe_fcf_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">fcoe_fcf_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">*</span><span class="n">fcoe_fcf_attr_groups</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">fcoe_fcf_attr_group</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bus_type</span> <span class="n">fcoe_bus_type</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_bus_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">fcoe_bus_type</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_ctlr_device_release() - Release the FIP ctlr memory</span>
<span class="cm"> * @dev: Pointer to the FIP ctlr&#39;s embedded device</span>
<span class="cm"> *</span>
<span class="cm"> * Called when the last FIP ctlr reference is released.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_ctlr_device_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr</span> <span class="o">=</span> <span class="n">dev_to_ctlr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_fcf_device_release() - Release the FIP fcf memory</span>
<span class="cm"> * @dev: Pointer to the fcf&#39;s embedded device</span>
<span class="cm"> *</span>
<span class="cm"> * Called when the last FIP fcf reference is released.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_fcf_device_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">fcf</span> <span class="o">=</span> <span class="n">dev_to_fcf</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fcf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">device_type</span> <span class="n">fcoe_ctlr_device_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;fcoe_ctlr&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">groups</span> <span class="o">=</span> <span class="n">fcoe_ctlr_attr_groups</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">fcoe_ctlr_device_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">device_type</span> <span class="n">fcoe_fcf_device_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;fcoe_fcf&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">groups</span> <span class="o">=</span> <span class="n">fcoe_fcf_attr_groups</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">fcoe_fcf_device_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bus_type</span> <span class="n">fcoe_bus_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;fcoe&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">match</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fcoe_bus_match</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_ctlr_device_flush_work() - Flush a FIP ctlr&#39;s workqueue</span>
<span class="cm"> * @ctlr: Pointer to the FIP ctlr whose workqueue is to be flushed</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fcoe_ctlr_device_flush_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcoe_ctlr_work_q</span><span class="p">(</span><span class="n">ctlr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;ERROR: FIP Ctlr &#39;%d&#39; attempted to flush work, &quot;</span>
		       <span class="s">&quot;when no workqueue created.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">fcoe_ctlr_work_q</span><span class="p">(</span><span class="n">ctlr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_ctlr_device_queue_work() - Schedule work for a FIP ctlr&#39;s workqueue</span>
<span class="cm"> * @ctlr: Pointer to the FIP ctlr who owns the devloss workqueue</span>
<span class="cm"> * @work:   Work to queue for execution</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	1 on success / 0 already queued / &lt; 0 for error</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcoe_ctlr_device_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fcoe_ctlr_work_q</span><span class="p">(</span><span class="n">ctlr</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;ERROR: FIP Ctlr &#39;%d&#39; attempted to queue work, &quot;</span>
		       <span class="s">&quot;when no workqueue created.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">queue_work</span><span class="p">(</span><span class="n">fcoe_ctlr_work_q</span><span class="p">(</span><span class="n">ctlr</span><span class="p">),</span> <span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_ctlr_device_flush_devloss() - Flush a FIP ctlr&#39;s devloss workqueue</span>
<span class="cm"> * @ctlr: Pointer to FIP ctlr whose workqueue is to be flushed</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fcoe_ctlr_device_flush_devloss</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcoe_ctlr_devloss_work_q</span><span class="p">(</span><span class="n">ctlr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;ERROR: FIP Ctlr &#39;%d&#39; attempted to flush work, &quot;</span>
		       <span class="s">&quot;when no workqueue created.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">fcoe_ctlr_devloss_work_q</span><span class="p">(</span><span class="n">ctlr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_ctlr_device_queue_devloss_work() - Schedule work for a FIP ctlr&#39;s devloss workqueue</span>
<span class="cm"> * @ctlr: Pointer to the FIP ctlr who owns the devloss workqueue</span>
<span class="cm"> * @work:   Work to queue for execution</span>
<span class="cm"> * @delay:  jiffies to delay the work queuing</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	1 on success / 0 already queued / &lt; 0 for error</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcoe_ctlr_device_queue_devloss_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fcoe_ctlr_devloss_work_q</span><span class="p">(</span><span class="n">ctlr</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;ERROR: FIP Ctlr &#39;%d&#39; attempted to queue work, &quot;</span>
		       <span class="s">&quot;when no workqueue created.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">fcoe_ctlr_devloss_work_q</span><span class="p">(</span><span class="n">ctlr</span><span class="p">),</span> <span class="n">work</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_fcf_device_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">switch_name</span> <span class="o">==</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">switch_name</span> <span class="o">&amp;&amp;</span>
	    <span class="n">new</span><span class="o">-&gt;</span><span class="n">fabric_name</span> <span class="o">==</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">fabric_name</span> <span class="o">&amp;&amp;</span>
	    <span class="n">new</span><span class="o">-&gt;</span><span class="n">fc_map</span> <span class="o">==</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">fc_map</span> <span class="o">&amp;&amp;</span>
	    <span class="n">compare_ether_addr</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_ctlr_device_add() - Add a FIP ctlr to sysfs</span>
<span class="cm"> * @parent:    The parent device to which the fcoe_ctlr instance</span>
<span class="cm"> *             should be attached</span>
<span class="cm"> * @f:         The LLD&#39;s FCoE sysfs function template pointer</span>
<span class="cm"> * @priv_size: Size to be allocated with the fcoe_ctlr_device for the LLD</span>
<span class="cm"> *</span>
<span class="cm"> * This routine allocates a FIP ctlr object with some additional memory</span>
<span class="cm"> * for the LLD. The FIP ctlr is initialized, added to sysfs and then</span>
<span class="cm"> * attributes are added to it.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="nf">fcoe_ctlr_device_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">fcoe_sysfs_function_template</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">priv_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr_device</span><span class="p">)</span> <span class="o">+</span> <span class="n">priv_size</span><span class="p">,</span>
		       <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctlr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlr_num</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">fcfs</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fcoe_bus_type</span><span class="p">;</span>
	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fcoe_ctlr_device_type</span><span class="p">;</span>

	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">fcf_dev_loss_tmo</span> <span class="o">=</span> <span class="n">fcoe_fcf_dev_loss_tmo</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">work_q_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">work_q_name</span><span class="p">),</span>
		 <span class="s">&quot;ctlr_wq_%d&quot;</span><span class="p">,</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">work_q</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span>
		<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">work_q_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">work_q</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_del</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">devloss_work_q_name</span><span class="p">,</span>
		 <span class="k">sizeof</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">devloss_work_q_name</span><span class="p">),</span>
		 <span class="s">&quot;ctlr_dl_wq_%d&quot;</span><span class="p">,</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">devloss_work_q</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span>
		<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">devloss_work_q_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">devloss_work_q</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_del_q</span><span class="p">;</span>

	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ctlr_%d&quot;</span><span class="p">,</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_del_q2</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ctlr</span><span class="p">;</span>

<span class="nl">out_del_q2:</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">devloss_work_q</span><span class="p">);</span>
	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">devloss_work_q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out_del_q:</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">work_q</span><span class="p">);</span>
	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">work_q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out_del:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fcoe_ctlr_device_add</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_ctlr_device_delete() - Delete a FIP ctlr and its subtree from sysfs</span>
<span class="cm"> * @ctlr: A pointer to the ctlr to be deleted</span>
<span class="cm"> *</span>
<span class="cm"> * Deletes a FIP ctlr and any fcfs attached</span>
<span class="cm"> * to it. Deleting fcfs will cause their childen</span>
<span class="cm"> * to be deleted as well.</span>
<span class="cm"> *</span>
<span class="cm"> * The ctlr is detached from sysfs and it&#39;s resources</span>
<span class="cm"> * are freed (work q), but the memory is not freed</span>
<span class="cm"> * until its last reference is released.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine expects no locks to be held before</span>
<span class="cm"> * calling.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: Currently there are no callbacks to clean up LLD data</span>
<span class="cm"> * for a fcoe_fcf_device. LLDs must keep this in mind as they need</span>
<span class="cm"> * to clean up each of their LLD data for all fcoe_fcf_device before</span>
<span class="cm"> * calling fcoe_ctlr_device_delete.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fcoe_ctlr_device_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">fcf</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="cm">/* Remove any attached fcfs */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">fcf</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">fcfs</span><span class="p">,</span> <span class="n">peers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">);</span>
		<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FCOE_FCF_STATE_DELETED</span><span class="p">;</span>
		<span class="n">fcoe_ctlr_device_queue_work</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">delete_work</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">fcoe_ctlr_device_flush_work</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>

	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">devloss_work_q</span><span class="p">);</span>
	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">devloss_work_q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">work_q</span><span class="p">);</span>
	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">work_q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fcoe_ctlr_device_delete</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_fcf_device_final_delete() - Final delete routine</span>
<span class="cm"> * @work: The FIP fcf&#39;s embedded work struct</span>
<span class="cm"> *</span>
<span class="cm"> * It is expected that the fcf has been removed from</span>
<span class="cm"> * the FIP ctlr&#39;s list before calling this routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_fcf_device_final_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">fcf</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fcoe_fcf_device</span><span class="p">,</span> <span class="n">delete_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_fcf_dev_to_ctlr_dev</span><span class="p">(</span><span class="n">fcf</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cancel any outstanding timers. These should really exist</span>
<span class="cm">	 * only when rmmod&#39;ing the LLDD and we&#39;re asking for</span>
<span class="cm">	 * immediate termination of the rports</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">dev_loss_work</span><span class="p">))</span>
		<span class="n">fcoe_ctlr_device_flush_devloss</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>

	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fip_timeout_deleted_fcf() - Delete a fcf when the devloss timer fires</span>
<span class="cm"> * @work: The FIP fcf&#39;s embedded work struct</span>
<span class="cm"> *</span>
<span class="cm"> * Removes the fcf from the FIP ctlr&#39;s list of fcfs and</span>
<span class="cm"> * queues the final deletion.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fip_timeout_deleted_fcf</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">fcf</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fcoe_fcf_device</span><span class="p">,</span> <span class="n">dev_loss_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_fcf_dev_to_ctlr_dev</span><span class="p">(</span><span class="n">fcf</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the fcf is deleted or reconnected before the timer</span>
<span class="cm">	 * fires the devloss queue will be flushed, but the state will</span>
<span class="cm">	 * either be CONNECTED or DELETED. If that is the case we</span>
<span class="cm">	 * cancel deleting the fcf.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FCOE_FCF_STATE_DISCONNECTED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		   <span class="s">&quot;FIP fcf connection time out: removing fcf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">);</span>
	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FCOE_FCF_STATE_DELETED</span><span class="p">;</span>
	<span class="n">fcoe_ctlr_device_queue_work</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">delete_work</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_fcf_device_delete() - Delete a FIP fcf</span>
<span class="cm"> * @fcf: Pointer to the fcf which is to be deleted</span>
<span class="cm"> *</span>
<span class="cm"> * Queues the FIP fcf on the devloss workqueue</span>
<span class="cm"> *</span>
<span class="cm"> * Expects the ctlr_attrs mutex to be held for fcf</span>
<span class="cm"> * state change.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fcoe_fcf_device_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">fcf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_fcf_dev_to_ctlr_dev</span><span class="p">(</span><span class="n">fcf</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">fcf</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FCOE_FCF_STATE_CONNECTED</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FCOE_FCF_STATE_DISCONNECTED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FCF will only be re-connected by the LLD calling</span>
<span class="cm">	 * fcoe_fcf_device_add, and it should be setting up</span>
<span class="cm">	 * priv then.</span>
<span class="cm">	 */</span>
	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">fcoe_ctlr_device_queue_devloss_work</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">dev_loss_work</span><span class="p">,</span>
					   <span class="n">timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fcoe_fcf_device_delete</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_fcf_device_add() - Add a FCoE sysfs fcoe_fcf_device to the system</span>
<span class="cm"> * @ctlr:    The fcoe_ctlr_device that will be the fcoe_fcf_device parent</span>
<span class="cm"> * @new_fcf: A temporary FCF used for lookups on the current list of fcfs</span>
<span class="cm"> *</span>
<span class="cm"> * Expects to be called with the ctlr-&gt;lock held</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="nf">fcoe_fcf_device_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">new_fcf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">fcf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fcf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">fcfs</span><span class="p">,</span> <span class="n">peers</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcoe_fcf_device_match</span><span class="p">(</span><span class="n">new_fcf</span><span class="p">,</span> <span class="n">fcf</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FCOE_FCF_STATE_CONNECTED</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">fcf</span><span class="p">;</span>

			<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FCOE_FCF_STATE_CONNECTED</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">dev_loss_work</span><span class="p">))</span>
				<span class="n">fcoe_ctlr_device_flush_devloss</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">fcf</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">fcf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_fcf_device</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fcf</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">delete_work</span><span class="p">,</span> <span class="n">fcoe_fcf_device_final_delete</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">dev_loss_work</span><span class="p">,</span> <span class="n">fip_timeout_deleted_fcf</span><span class="p">);</span>

	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fcoe_bus_type</span><span class="p">;</span>
	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fcoe_fcf_device_type</span><span class="p">;</span>
	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcf_num</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FCOE_FCF_STATE_UNKNOWN</span><span class="p">;</span>

	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo</span> <span class="o">=</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">fcf_dev_loss_tmo</span><span class="p">;</span>

	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fcf_%d&quot;</span><span class="p">,</span> <span class="n">fcf</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">fabric_name</span> <span class="o">=</span> <span class="n">new_fcf</span><span class="o">-&gt;</span><span class="n">fabric_name</span><span class="p">;</span>
	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">switch_name</span> <span class="o">=</span> <span class="n">new_fcf</span><span class="o">-&gt;</span><span class="n">switch_name</span><span class="p">;</span>
	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">fc_map</span> <span class="o">=</span> <span class="n">new_fcf</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">;</span>
	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">vfid</span> <span class="o">=</span> <span class="n">new_fcf</span><span class="o">-&gt;</span><span class="n">vfid</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">,</span> <span class="n">new_fcf</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">new_fcf</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">;</span>
	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">fka_period</span> <span class="o">=</span> <span class="n">new_fcf</span><span class="o">-&gt;</span><span class="n">fka_period</span><span class="p">;</span>
	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">selected</span> <span class="o">=</span> <span class="n">new_fcf</span><span class="o">-&gt;</span><span class="n">selected</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_del</span><span class="p">;</span>

	<span class="n">fcf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FCOE_FCF_STATE_CONNECTED</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcf</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">fcfs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fcf</span><span class="p">;</span>

<span class="nl">out_del:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fcf</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fcoe_fcf_device_add</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">fcoe_sysfs_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlr_num</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcf_num</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_bus_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__exit</span> <span class="nf">fcoe_sysfs_teardown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bus_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_bus_type</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
