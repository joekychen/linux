<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › fcoe › fcoe.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fcoe.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright(c) 2007 - 2009 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintained at www.Open-FCoE.org</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;net/dcbnl.h&gt;</span>
<span class="cp">#include &lt;net/dcbevent.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &lt;scsi/scsicam.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_fc.h&gt;</span>
<span class="cp">#include &lt;net/rtnetlink.h&gt;</span>

<span class="cp">#include &lt;scsi/fc/fc_encaps.h&gt;</span>
<span class="cp">#include &lt;scsi/fc/fc_fip.h&gt;</span>
<span class="cp">#include &lt;scsi/fc/fc_fcoe.h&gt;</span>

<span class="cp">#include &lt;scsi/libfc.h&gt;</span>
<span class="cp">#include &lt;scsi/fc_frame.h&gt;</span>
<span class="cp">#include &lt;scsi/libfcoe.h&gt;</span>

<span class="cp">#include &quot;fcoe.h&quot;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Open-FCoE.org&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;FCoE&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>

<span class="cm">/* Performance tuning parameters for fcoe */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fcoe_ddp_min</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">ddp_min</span><span class="p">,</span> <span class="n">fcoe_ddp_min</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ddp_min</span><span class="p">,</span> <span class="s">&quot;Minimum I/O size in bytes for &quot;</span>	\
		 <span class="s">&quot;Direct Data Placement (DDP).&quot;</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fcoe_debug_logging</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">debug_logging</span><span class="p">,</span> <span class="n">fcoe_debug_logging</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug_logging</span><span class="p">,</span> <span class="s">&quot;a bit mask of logging levels&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">fcoe_wq</span><span class="p">;</span>

<span class="cm">/* fcoe_percpu_clean completion.  Waiter protected by fcoe_create_mutex */</span>
<span class="k">static</span> <span class="n">DECLARE_COMPLETION</span><span class="p">(</span><span class="n">fcoe_flush_completion</span><span class="p">);</span>

<span class="cm">/* fcoe host list */</span>
<span class="cm">/* must only by accessed under the RTNL mutex */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">fcoe_hostlist</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_percpu_s</span><span class="p">,</span> <span class="n">fcoe_percpu</span><span class="p">);</span>

<span class="cm">/* Function Prototypes */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_percpu_receive_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fcoe_percpu_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_link_speed_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_link_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">fcoe_hostlist_lookup</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_hostlist_add</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_device_notification</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="p">,</span> <span class="n">ulong</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fcoe_dev_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fcoe_dev_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fcoe_interface</span>
<span class="o">*</span><span class="n">fcoe_hostlist_lookup_port</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_fip_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">fcoe_fip_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fcoe_update_src_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u8</span> <span class="o">*</span><span class="n">fcoe_get_src_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fcoe_destroy_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_ddp_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_ddp_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_ddp_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_cpu_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_dcb_app_notification</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">notifier</span><span class="p">,</span>
				     <span class="n">ulong</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">fcoe_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fip_state</span> <span class="n">fip_mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">fcoe_elsct_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">did</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span>
						   <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fcoe_recv_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">fcoe_get_lesb</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_els_lesb</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* notification function for packets from net device */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">fcoe_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">fcoe_device_notification</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* notification function for CPU hotplug events */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">fcoe_cpu_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">fcoe_cpu_callback</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* notification function for DCB events */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">dcb_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">fcoe_dcb_app_notification</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span><span class="n">fcoe_nport_scsi_transport</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span><span class="n">fcoe_vport_scsi_transport</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_vport_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_vport_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span> <span class="n">disabled</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_vport_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span> <span class="n">disable</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fcoe_set_vport_symbolic_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fcoe_set_port_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fcoe_ctlr_get_lesb</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fcoe_fcf_get_vlan_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fcoe_sysfs_function_template</span> <span class="n">fcoe_sysfs_templ</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_fcoe_ctlr_mode</span> <span class="o">=</span> <span class="n">fcoe_ctlr_get_fip_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_fcoe_ctlr_link_fail</span> <span class="o">=</span> <span class="n">fcoe_ctlr_get_lesb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_fcoe_ctlr_vlink_fail</span> <span class="o">=</span> <span class="n">fcoe_ctlr_get_lesb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_fcoe_ctlr_miss_fka</span> <span class="o">=</span> <span class="n">fcoe_ctlr_get_lesb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_fcoe_ctlr_symb_err</span> <span class="o">=</span> <span class="n">fcoe_ctlr_get_lesb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_fcoe_ctlr_err_block</span> <span class="o">=</span> <span class="n">fcoe_ctlr_get_lesb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_fcoe_ctlr_fcs_error</span> <span class="o">=</span> <span class="n">fcoe_ctlr_get_lesb</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_fcoe_fcf_selected</span> <span class="o">=</span> <span class="n">fcoe_fcf_get_selected</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_fcoe_fcf_vlan_id</span> <span class="o">=</span> <span class="n">fcoe_fcf_get_vlan_id</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">libfc_function_template</span> <span class="n">fcoe_libfc_fcn_templ</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">frame_send</span> <span class="o">=</span> <span class="n">fcoe_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ddp_setup</span> <span class="o">=</span> <span class="n">fcoe_ddp_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ddp_done</span> <span class="o">=</span> <span class="n">fcoe_ddp_done</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ddp_target</span> <span class="o">=</span> <span class="n">fcoe_ddp_target</span><span class="p">,</span>
	<span class="p">.</span><span class="n">elsct_send</span> <span class="o">=</span> <span class="n">fcoe_elsct_send</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_lesb</span> <span class="o">=</span> <span class="n">fcoe_get_lesb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lport_set_port_id</span> <span class="o">=</span> <span class="n">fcoe_set_port_id</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_function_template</span> <span class="n">fcoe_nport_fc_functions</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show_host_node_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_port_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_supported_classes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_supported_fc4s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_active_fc4s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_maxframe_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_serial_number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_manufacturer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_model</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_model_description</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_hardware_version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_driver_version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_firmware_version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_optionrom_version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">show_host_port_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_supported_speeds</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_host_speed</span> <span class="o">=</span> <span class="n">fc_get_host_speed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_speed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_port_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_host_port_state</span> <span class="o">=</span> <span class="n">fc_get_host_port_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_port_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_symbolic_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">dd_fcrport_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport_libfc_priv</span><span class="p">),</span>
	<span class="p">.</span><span class="n">show_rport_maxframe_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_rport_supported_classes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">show_host_fabric_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_starget_node_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_starget_port_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_starget_port_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_rport_dev_loss_tmo</span> <span class="o">=</span> <span class="n">fc_set_rport_loss_tmo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_rport_dev_loss_tmo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_fc_host_stats</span> <span class="o">=</span> <span class="n">fc_get_host_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">issue_fc_host_lip</span> <span class="o">=</span> <span class="n">fcoe_reset</span><span class="p">,</span>

	<span class="p">.</span><span class="n">terminate_rport_io</span> <span class="o">=</span> <span class="n">fc_rport_terminate_io</span><span class="p">,</span>

	<span class="p">.</span><span class="n">vport_create</span> <span class="o">=</span> <span class="n">fcoe_vport_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vport_delete</span> <span class="o">=</span> <span class="n">fcoe_vport_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vport_disable</span> <span class="o">=</span> <span class="n">fcoe_vport_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_vport_symbolic_name</span> <span class="o">=</span> <span class="n">fcoe_set_vport_symbolic_name</span><span class="p">,</span>

	<span class="p">.</span><span class="n">bsg_request</span> <span class="o">=</span> <span class="n">fc_lport_bsg_request</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_function_template</span> <span class="n">fcoe_vport_fc_functions</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show_host_node_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_port_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_supported_classes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_supported_fc4s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_active_fc4s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_maxframe_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_serial_number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_manufacturer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_model</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_model_description</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_hardware_version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_driver_version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_firmware_version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_optionrom_version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">show_host_port_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_supported_speeds</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_host_speed</span> <span class="o">=</span> <span class="n">fc_get_host_speed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_speed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_port_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_host_port_state</span> <span class="o">=</span> <span class="n">fc_get_host_port_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_port_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_symbolic_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">dd_fcrport_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport_libfc_priv</span><span class="p">),</span>
	<span class="p">.</span><span class="n">show_rport_maxframe_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_rport_supported_classes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">show_host_fabric_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_starget_node_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_starget_port_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_starget_port_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_rport_dev_loss_tmo</span> <span class="o">=</span> <span class="n">fc_set_rport_loss_tmo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_rport_dev_loss_tmo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_fc_host_stats</span> <span class="o">=</span> <span class="n">fc_get_host_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">issue_fc_host_lip</span> <span class="o">=</span> <span class="n">fcoe_reset</span><span class="p">,</span>

	<span class="p">.</span><span class="n">terminate_rport_io</span> <span class="o">=</span> <span class="n">fc_rport_terminate_io</span><span class="p">,</span>

	<span class="p">.</span><span class="n">bsg_request</span> <span class="o">=</span> <span class="n">fc_lport_bsg_request</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">fcoe_shost_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;FCoE Driver&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_name</span> <span class="o">=</span> <span class="n">FCOE_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span> <span class="o">=</span> <span class="n">fc_queuecommand</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_abort_handler</span> <span class="o">=</span> <span class="n">fc_eh_abort</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_device_reset_handler</span> <span class="o">=</span> <span class="n">fc_eh_device_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_host_reset_handler</span> <span class="o">=</span> <span class="n">fc_eh_host_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_alloc</span> <span class="o">=</span> <span class="n">fc_slave_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change_queue_depth</span> <span class="o">=</span> <span class="n">fc_change_queue_depth</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change_queue_type</span> <span class="o">=</span> <span class="n">fc_change_queue_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">this_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmd_per_lun</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">FCOE_MAX_OUTSTANDING_COMMANDS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span> <span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">SG_ALL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_interface_setup() - Setup a FCoE interface</span>
<span class="cm"> * @fcoe:   The new FCoE interface</span>
<span class="cm"> * @netdev: The net device that the fcoe interface is on</span>
<span class="cm"> *</span>
<span class="cm"> * Returns : 0 for success</span>
<span class="cm"> * Locking: must be called with the RTNL mutex held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_interface_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">fip</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">real_dev</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flogi_maddr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>

	<span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>

	<span class="cm">/* Let LLD initialize for FCoE */</span>
	<span class="n">ops</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_fcoe_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_fcoe_enable</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
			<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Failed to enable FCoE&quot;</span>
					<span class="s">&quot; specific feature for LLD.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Do not support for bonding device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_BONDING</span> <span class="o">&amp;&amp;</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_MASTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Bonded interfaces not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* look for SAN MAC address, if multiple SAN MACs exist, only</span>
<span class="cm">	 * use the first one for SPMA */</span>
	<span class="n">real_dev</span> <span class="o">=</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_802_1Q_VLAN</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">vlan_dev_real_dev</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">:</span> <span class="n">netdev</span><span class="p">;</span>
	<span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">realdev</span> <span class="o">=</span> <span class="n">real_dev</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_dev_addr</span><span class="p">(</span><span class="n">real_dev</span><span class="p">,</span> <span class="n">ha</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NETDEV_HW_ADDR_T_SAN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">fip</span><span class="o">-&gt;</span><span class="n">ctl_src_addr</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="n">fip</span><span class="o">-&gt;</span><span class="n">spma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="cm">/* setup Source Mac Address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fip</span><span class="o">-&gt;</span><span class="n">spma</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">fip</span><span class="o">-&gt;</span><span class="n">ctl_src_addr</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add FCoE MAC address as second unicast MAC address</span>
<span class="cm">	 * or enter promiscuous mode if not capable of listening</span>
<span class="cm">	 * for multiple unicast MACs.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">flogi_maddr</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="n">FC_FCOE_FLOGI_MAC</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">dev_uc_add</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">flogi_maddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fip</span><span class="o">-&gt;</span><span class="n">spma</span><span class="p">)</span>
		<span class="n">dev_uc_add</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">fip</span><span class="o">-&gt;</span><span class="n">ctl_src_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fip</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">FIP_MODE_VN2VN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_mc_add</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">FIP_ALL_VN2VN_MACS</span><span class="p">);</span>
		<span class="n">dev_mc_add</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">FIP_ALL_P2P_MACS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dev_mc_add</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">FIP_ALL_ENODE_MACS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * setup the receive function from ethernet driver</span>
<span class="cm">	 * on the ethertype for the given device</span>
<span class="cm">	 */</span>
	<span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">fcoe_packet_type</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">fcoe_rcv</span><span class="p">;</span>
	<span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">fcoe_packet_type</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">__constant_htons</span><span class="p">(</span><span class="n">ETH_P_FCOE</span><span class="p">);</span>
	<span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">fcoe_packet_type</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>
	<span class="n">dev_add_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">fcoe_packet_type</span><span class="p">);</span>

	<span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">fip_packet_type</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">fcoe_fip_recv</span><span class="p">;</span>
	<span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">fip_packet_type</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_FIP</span><span class="p">);</span>
	<span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">fip_packet_type</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>
	<span class="n">dev_add_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">fip_packet_type</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_interface_create() - Create a FCoE interface on a net device</span>
<span class="cm"> * @netdev: The net device to create the FCoE interface on</span>
<span class="cm"> * @fip_mode: The mode to use for FIP</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: pointer to a struct fcoe_interface or NULL on error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="nf">fcoe_interface_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
						    <span class="k">enum</span> <span class="n">fip_state</span> <span class="n">fip_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span>
				<span class="s">&quot;Could not get a reference to the module</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">fcoe</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EBUSY</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_interface</span><span class="p">);</span>
	<span class="n">ctlr_dev</span> <span class="o">=</span> <span class="n">fcoe_ctlr_device_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_sysfs_templ</span><span class="p">,</span>
					<span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctlr_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FCOE_DBG</span><span class="p">(</span><span class="s">&quot;Failed to add fcoe_ctlr_device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">fcoe</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_putmod</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_ctlr_device_priv</span><span class="p">(</span><span class="n">ctlr_dev</span><span class="p">);</span>
	<span class="n">fcoe</span> <span class="o">=</span> <span class="n">fcoe_ctlr_priv</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>

	<span class="n">dev_hold</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize FIP.</span>
<span class="cm">	 */</span>
	<span class="n">fcoe_ctlr_init</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">fip_mode</span><span class="p">);</span>
	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">send</span> <span class="o">=</span> <span class="n">fcoe_fip_send</span><span class="p">;</span>
	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">update_mac</span> <span class="o">=</span> <span class="n">fcoe_update_src_mac</span><span class="p">;</span>
	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">get_src_addr</span> <span class="o">=</span> <span class="n">fcoe_get_src_mac</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fcoe_interface_setup</span><span class="p">(</span><span class="n">fcoe</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fcoe_ctlr_destroy</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>
		<span class="n">fcoe_ctlr_device_delete</span><span class="p">(</span><span class="n">ctlr_dev</span><span class="p">);</span>
		<span class="n">dev_put</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">fcoe</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_putmod</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">out_putmod:</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">fcoe</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_interface_remove() - remove FCoE interface from netdev</span>
<span class="cm"> * @fcoe: The FCoE interface to be cleaned up</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must be holding the RTNL mutex</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_interface_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">fip</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">flogi_maddr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t listen for Ethernet packets anymore.</span>
<span class="cm">	 * synchronize_net() ensures that the packet handlers are not running</span>
<span class="cm">	 * on another CPU. dev_remove_pack() would do that, this calls the</span>
<span class="cm">	 * unsyncronized version __dev_remove_pack() to avoid multiple delays.</span>
<span class="cm">	 */</span>
	<span class="n">__dev_remove_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">fcoe_packet_type</span><span class="p">);</span>
	<span class="n">__dev_remove_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">fip_packet_type</span><span class="p">);</span>
	<span class="n">synchronize_net</span><span class="p">();</span>

	<span class="cm">/* Delete secondary MAC addresses */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">flogi_maddr</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="n">FC_FCOE_FLOGI_MAC</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">dev_uc_del</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">flogi_maddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fip</span><span class="o">-&gt;</span><span class="n">spma</span><span class="p">)</span>
		<span class="n">dev_uc_del</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">fip</span><span class="o">-&gt;</span><span class="n">ctl_src_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fip</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">FIP_MODE_VN2VN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_mc_del</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">FIP_ALL_VN2VN_MACS</span><span class="p">);</span>
		<span class="n">dev_mc_del</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">FIP_ALL_P2P_MACS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dev_mc_del</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">FIP_ALL_ENODE_MACS</span><span class="p">);</span>

	<span class="cm">/* Tell the LLD we are done w/ FCoE */</span>
	<span class="n">ops</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_fcoe_disable</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_fcoe_disable</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
			<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Failed to disable FCoE&quot;</span>
					<span class="s">&quot; specific feature for LLD.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">removed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fcoe_interface_cleanup() - Clean up a FCoE interface</span>
<span class="cm"> * @fcoe: The FCoE interface to be cleaned up</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_interface_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">fip</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr_dev</span> <span class="o">=</span> <span class="n">fcoe_ctlr_to_ctlr_dev</span><span class="p">(</span><span class="n">fip</span><span class="p">);</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">)</span>
		<span class="n">fcoe_interface_remove</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="cm">/* Release the self-reference taken during fcoe_interface_create() */</span>
	<span class="cm">/* tear-down the FCoE controller */</span>
	<span class="n">fcoe_ctlr_destroy</span><span class="p">(</span><span class="n">fip</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">fip</span><span class="o">-&gt;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="n">fcoe_ctlr_device_delete</span><span class="p">(</span><span class="n">ctlr_dev</span><span class="p">);</span>
	<span class="n">dev_put</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_fip_recv() - Handler for received FIP frames</span>
<span class="cm"> * @skb:      The receive skb</span>
<span class="cm"> * @netdev:   The associated net device</span>
<span class="cm"> * @ptype:    The packet_type structure which was used to register this handler</span>
<span class="cm"> * @orig_dev: The original net_device the the skb was received on.</span>
<span class="cm"> *	      (in case dev is a bond)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_fip_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">ptype</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">orig_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">;</span>

	<span class="n">fcoe</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fcoe_interface</span><span class="p">,</span> <span class="n">fip_packet_type</span><span class="p">);</span>
	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="n">fcoe_ctlr_recv</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_port_send() - Send an Ethernet-encapsulated FIP/FCoE frame</span>
<span class="cm"> * @port: The FCoE port</span>
<span class="cm"> * @skb: The FIP/FCoE packet to be sent</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_port_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">qlen</span><span class="p">)</span>
		<span class="n">fcoe_check_wait_queue</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lport</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fcoe_start_io</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">fcoe_check_wait_queue</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lport</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_fip_send() - Send an Ethernet-encapsulated FIP frame</span>
<span class="cm"> * @fip: The FCoE controller</span>
<span class="cm"> * @skb: The FIP packet to be sent</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_fip_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">fip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">fcoe_from_ctlr</span><span class="p">(</span><span class="n">fip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">fcoe_port_send</span><span class="p">(</span><span class="n">lport_priv</span><span class="p">(</span><span class="n">fip</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">),</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_update_src_mac() - Update the Ethernet MAC filters</span>
<span class="cm"> * @lport: The local port to update the source MAC on</span>
<span class="cm"> * @addr:  Unicast MAC address to add</span>
<span class="cm"> *</span>
<span class="cm"> * Remove any previously-set unicast MAC filter.</span>
<span class="cm"> * Add secondary FCoE MAC address filter for our OUI.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_update_src_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">data_src_addr</span><span class="p">))</span>
		<span class="n">dev_uc_del</span><span class="p">(</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">data_src_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
		<span class="n">dev_uc_add</span><span class="p">(</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">data_src_addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_get_src_mac() - return the Ethernet source address for an lport</span>
<span class="cm"> * @lport: libfc lport</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="o">*</span><span class="nf">fcoe_get_src_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">data_src_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_lport_config() - Set up a local port</span>
<span class="cm"> * @lport: The local port to be setup</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_lport_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">link_up</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">qfull</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">max_retry_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">max_rport_retry_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">e_d_tov</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>	<span class="cm">/* FC-FS default */</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">r_a_tov</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">service_params</span> <span class="o">=</span> <span class="p">(</span><span class="n">FCP_SPPF_INIT_FCN</span> <span class="o">|</span> <span class="n">FCP_SPPF_RD_XRDY_DIS</span> <span class="o">|</span>
				 <span class="n">FCP_SPPF_RETRY</span> <span class="o">|</span> <span class="n">FCP_SPPF_CONF_COMPL</span><span class="p">);</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">does_npiv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">fc_lport_init_stats</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="cm">/* lport fc_lport related configuration */</span>
	<span class="n">fc_lport_config</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="cm">/* offload related configuration */</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">crc_offload</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">seq_offload</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_xid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">lso_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_netdev_features_change - Updates the lport&#39;s offload flags based</span>
<span class="cm"> * on the LLD netdev&#39;s FCoE feature flags</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_netdev_features_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_SG</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">sg_supp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">sg_supp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_FCOE_CRC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">crc_offload</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Supports FCCRC offload</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">crc_offload</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_FSO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">seq_offload</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">lso_max</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">gso_max_size</span><span class="p">;</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Supports LSO for max len 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">lport</span><span class="o">-&gt;</span><span class="n">lso_max</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">seq_offload</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">lso_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">fcoe_ddp_xid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_xid</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">fcoe_ddp_xid</span><span class="p">;</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Supports LRO for max xid 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_xid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_xid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_netdev_config() - Set up net devive for SW FCoE</span>
<span class="cm"> * @lport:  The local port that is associated with the net device</span>
<span class="cm"> * @netdev: The associated net device</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called after fcoe_lport_config() as it will use local port mutex</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_netdev_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mfs</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">wwnn</span><span class="p">,</span> <span class="n">wwpn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>

	<span class="cm">/* Setup lport private data to point to fcoe softc */</span>
	<span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="n">fcoe</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine max frame size based on underlying device and optional</span>
<span class="cm">	 * user-configured limit.  If the MFS is too low, fcoe_link_ok()</span>
<span class="cm">	 * will return 0, so do this first.</span>
<span class="cm">	 */</span>
	<span class="n">mfs</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_FCOE_MTU</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mfs</span> <span class="o">=</span> <span class="n">FCOE_MTU</span><span class="p">;</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Supports FCOE_MTU of %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mfs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mfs</span> <span class="o">-=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_hdr</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_crc_eof</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fc_set_mfs</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">mfs</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* offload features support */</span>
	<span class="n">fcoe_netdev_features_change</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>

	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">fcoe_queue_timer</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lport</span><span class="p">);</span>

	<span class="n">fcoe_link_speed_update</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcoe_get_wwn</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wwnn</span><span class="p">,</span> <span class="n">NETDEV_FCOE_WWNN</span><span class="p">))</span>
			<span class="n">wwnn</span> <span class="o">=</span> <span class="n">fcoe_wwn_from_mac</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">ctl_src_addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">fc_set_wwnn</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">wwnn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcoe_get_wwn</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wwpn</span><span class="p">,</span> <span class="n">NETDEV_FCOE_WWPN</span><span class="p">))</span>
			<span class="n">wwpn</span> <span class="o">=</span> <span class="n">fcoe_wwn_from_mac</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">ctl_src_addr</span><span class="p">,</span>
						 <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">fc_set_wwpn</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">wwpn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_shost_config() - Set up the SCSI host associated with a local port</span>
<span class="cm"> * @lport: The local port</span>
<span class="cm"> * @dev:   The device associated with the SCSI host</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called after fcoe_lport_config() and fcoe_netdev_config()</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_shost_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* lport scsi host config */</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="n">FCOE_MAX_LUN</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="n">FCOE_MAX_FCP_TARGET</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">=</span> <span class="n">FCOE_MAX_CMD_LEN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">transportt</span> <span class="o">=</span> <span class="n">fcoe_vport_scsi_transport</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">transportt</span> <span class="o">=</span> <span class="n">fcoe_nport_scsi_transport</span><span class="p">;</span>

	<span class="cm">/* add the new host to the SCSI-ml */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">scsi_add_host</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">fcoe_netdev</span><span class="p">(</span><span class="n">lport</span><span class="p">),</span> <span class="s">&quot;fcoe_shost_config: &quot;</span>
				<span class="s">&quot;error on scsi_add_host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">)</span>
		<span class="n">fc_host_max_npiv_vports</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span> <span class="o">=</span> <span class="n">USHRT_MAX</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">fc_host_symbolic_name</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span> <span class="n">FC_SYMBOLIC_NAME_SIZE</span><span class="p">,</span>
		 <span class="s">&quot;%s v%s over %s&quot;</span><span class="p">,</span> <span class="n">FCOE_NAME</span><span class="p">,</span> <span class="n">FCOE_VERSION</span><span class="p">,</span>
		 <span class="n">fcoe_netdev</span><span class="p">(</span><span class="n">lport</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fcoe_fdmi_info() - Get FDMI related info from net devive for SW FCoE</span>
<span class="cm"> * @lport:  The local port that is associated with the net device</span>
<span class="cm"> * @netdev: The associated net device</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called after fcoe_shost_config() as it will use local port mutex</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_fdmi_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">realdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_fcoe_hbainfo</span> <span class="n">fdmi</span><span class="p">;</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="n">fcoe</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">realdev</span> <span class="o">=</span> <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">realdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">realdev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* No FDMI state m/c for NPIV ports */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">realdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_fcoe_get_hbainfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdmi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fdmi</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">realdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_fcoe_get_hbainfo</span><span class="p">(</span><span class="n">realdev</span><span class="p">,</span>
							       <span class="o">&amp;</span><span class="n">fdmi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;fcoe: Failed to retrieve FDMI &quot;</span>
					<span class="s">&quot;information from netdev.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">snprintf</span><span class="p">(</span><span class="n">fc_host_serial_number</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span>
			 <span class="n">FC_SERIAL_NUMBER_SIZE</span><span class="p">,</span>
			 <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			 <span class="n">fdmi</span><span class="p">.</span><span class="n">serial_number</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">fc_host_manufacturer</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span>
			 <span class="n">FC_SERIAL_NUMBER_SIZE</span><span class="p">,</span>
			 <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			 <span class="n">fdmi</span><span class="p">.</span><span class="n">manufacturer</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">fc_host_model</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span>
			 <span class="n">FC_SYMBOLIC_NAME_SIZE</span><span class="p">,</span>
			 <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			 <span class="n">fdmi</span><span class="p">.</span><span class="n">model</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">fc_host_model_description</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span>
			 <span class="n">FC_SYMBOLIC_NAME_SIZE</span><span class="p">,</span>
			 <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			 <span class="n">fdmi</span><span class="p">.</span><span class="n">model_description</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">fc_host_hardware_version</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span>
			 <span class="n">FC_VERSION_STRING_SIZE</span><span class="p">,</span>
			 <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			 <span class="n">fdmi</span><span class="p">.</span><span class="n">hardware_version</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">fc_host_driver_version</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span>
			 <span class="n">FC_VERSION_STRING_SIZE</span><span class="p">,</span>
			 <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			 <span class="n">fdmi</span><span class="p">.</span><span class="n">driver_version</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">fc_host_optionrom_version</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span>
			 <span class="n">FC_VERSION_STRING_SIZE</span><span class="p">,</span>
			 <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			 <span class="n">fdmi</span><span class="p">.</span><span class="n">optionrom_version</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">fc_host_firmware_version</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span>
			 <span class="n">FC_VERSION_STRING_SIZE</span><span class="p">,</span>
			 <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			 <span class="n">fdmi</span><span class="p">.</span><span class="n">firmware_version</span><span class="p">);</span>

		<span class="cm">/* Enable FDMI lport states */</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">fdmi_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">fdmi_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;fcoe: No FDMI support.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_oem_match() - The match routine for the offloaded exchange manager</span>
<span class="cm"> * @fp: The I/O frame</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will be associated with an exchange manager (EM). When</span>
<span class="cm"> * the libfc exchange handling code is looking for an EM to use it will</span>
<span class="cm"> * call this routine and pass it the frame that it wishes to send. This</span>
<span class="cm"> * routine will return True if the associated EM is to be used and False</span>
<span class="cm"> * if the echange code should continue looking for an EM.</span>
<span class="cm"> *</span>
<span class="cm"> * The offload EM that this routine is associated with will handle any</span>
<span class="cm"> * packets that are for SCSI read requests.</span>
<span class="cm"> *</span>
<span class="cm"> * This has been enhanced to work when FCoE stack is operating in target</span>
<span class="cm"> * mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: True for read types I/O, otherwise returns false.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">fcoe_oem_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcp_cmnd</span> <span class="o">*</span><span class="n">fcp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_fcp_is_read</span><span class="p">(</span><span class="n">fr_fsp</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">fr_fsp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">&gt;</span> <span class="n">fcoe_ddp_min</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">fr_fsp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span> <span class="o">==</span> <span class="n">FC_RCTL_DD_UNSOL_CMD</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span><span class="p">)</span> <span class="o">==</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fcp</span> <span class="o">=</span> <span class="n">fc_frame_payload_get</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fcp</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fcp</span><span class="o">-&gt;</span><span class="n">fc_flags</span> <span class="o">&amp;</span> <span class="n">FCP_CFL_WRDATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">fcp</span><span class="o">-&gt;</span><span class="n">fc_dl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">fcoe_ddp_min</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_em_config() - Allocate and configure an exchange manager</span>
<span class="cm"> * @lport: The local port that the new EM will be associated with</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 on success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fcoe_em_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">oldfcoe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">old_real_dev</span><span class="p">,</span> <span class="o">*</span><span class="n">cur_real_dev</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">min_xid</span> <span class="o">=</span> <span class="n">FCOE_MIN_XID</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">max_xid</span> <span class="o">=</span> <span class="n">FCOE_MAX_XID</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if need to allocate an em instance for</span>
<span class="cm">	 * offload exchange ids to be shared across all VN_PORTs/lport.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_enabled</span> <span class="o">||</span> <span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_xid</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_xid</span> <span class="o">&gt;=</span> <span class="n">max_xid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_xid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">skip_oem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reuse existing offload em instance in case</span>
<span class="cm">	 * it is already allocated on real eth device</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_802_1Q_VLAN</span><span class="p">)</span>
		<span class="n">cur_real_dev</span> <span class="o">=</span> <span class="n">vlan_dev_real_dev</span><span class="p">(</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cur_real_dev</span> <span class="o">=</span> <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">oldfcoe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_hostlist</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldfcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_802_1Q_VLAN</span><span class="p">)</span>
			<span class="n">old_real_dev</span> <span class="o">=</span> <span class="n">vlan_dev_real_dev</span><span class="p">(</span><span class="n">oldfcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">old_real_dev</span> <span class="o">=</span> <span class="n">oldfcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cur_real_dev</span> <span class="o">==</span> <span class="n">old_real_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">oem</span> <span class="o">=</span> <span class="n">oldfcoe</span><span class="o">-&gt;</span><span class="n">oem</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">oem</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fc_exch_mgr_add</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">oem</span><span class="p">,</span> <span class="n">fcoe_oem_match</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fcoe_em_config: failed to add &quot;</span>
			       <span class="s">&quot;offload em:%p on interface:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">oem</span><span class="p">,</span> <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">oem</span> <span class="o">=</span> <span class="n">fc_exch_mgr_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">FC_CLASS_3</span><span class="p">,</span>
					      <span class="n">FCOE_MIN_XID</span><span class="p">,</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_xid</span><span class="p">,</span>
					      <span class="n">fcoe_oem_match</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">oem</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fcoe_em_config: failed to allocate &quot;</span>
			       <span class="s">&quot;em for offload exches on interface:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Exclude offload EM xid range from next EM xid range.</span>
<span class="cm">	 */</span>
	<span class="n">min_xid</span> <span class="o">+=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">lro_xid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">skip_oem:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fc_exch_mgr_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">FC_CLASS_3</span><span class="p">,</span> <span class="n">min_xid</span><span class="p">,</span> <span class="n">max_xid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fcoe_em_config: failed to &quot;</span>
		       <span class="s">&quot;allocate em on interface %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_if_destroy() - Tear down a SW FCoE instance</span>
<span class="cm"> * @lport: The local port to be destroyed</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_if_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Destroying interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Logout of the fabric */</span>
	<span class="n">fc_fabric_logoff</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="cm">/* Cleanup the fc_lport */</span>
	<span class="n">fc_lport_destroy</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="cm">/* Stop the transmit retry timer */</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="cm">/* Free existing transmit skbs */</span>
	<span class="n">fcoe_clean_pending_queue</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">data_src_addr</span><span class="p">))</span>
		<span class="n">dev_uc_del</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">data_src_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">)</span>
		<span class="n">synchronize_net</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">fcoe_interface_remove</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="cm">/* Free queued packets for the per-CPU receive threads */</span>
	<span class="n">fcoe_percpu_clean</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="cm">/* Detach from the scsi-ml */</span>
	<span class="n">fc_remove_host</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="cm">/* Destroy lport scsi_priv */</span>
	<span class="n">fc_fcp_destroy</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="cm">/* There are no more rports or I/O, free the EM */</span>
	<span class="n">fc_exch_mgr_free</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="cm">/* Free memory used by statistical counters */</span>
	<span class="n">fc_lport_free_stats</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release the Scsi_Host for vport but hold on to</span>
<span class="cm">	 * master lport until it fcoe interface fully cleaned-up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">)</span>
		<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_ddp_setup() - Call a LLD&#39;s ddp_setup through the net device</span>
<span class="cm"> * @lport: The local port to setup DDP for</span>
<span class="cm"> * @xid:   The exchange ID for this DDP transfer</span>
<span class="cm"> * @sgl:   The scatterlist describing this transfer</span>
<span class="cm"> * @sgc:   The number of sg items</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if the DDP context was not configured</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_ddp_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="n">u16</span> <span class="n">xid</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sgc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe_netdev</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_fcoe_ddp_setup</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_fcoe_ddp_setup</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span>
							      <span class="n">xid</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span>
							      <span class="n">sgc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_ddp_target() - Call a LLD&#39;s ddp_target through the net device</span>
<span class="cm"> * @lport: The local port to setup DDP for</span>
<span class="cm"> * @xid:   The exchange ID for this DDP transfer</span>
<span class="cm"> * @sgl:   The scatterlist describing this transfer</span>
<span class="cm"> * @sgc:   The number of sg items</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if the DDP context was not configured</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_ddp_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="n">u16</span> <span class="n">xid</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sgc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe_netdev</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_fcoe_ddp_target</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_fcoe_ddp_target</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span>
							       <span class="n">sgl</span><span class="p">,</span> <span class="n">sgc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fcoe_ddp_done() - Call a LLD&#39;s ddp_done through the net device</span>
<span class="cm"> * @lport: The local port to complete DDP on</span>
<span class="cm"> * @xid:   The exchange ID for this DDP transfer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: the length of data that have been completed by DDP</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_ddp_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="n">u16</span> <span class="n">xid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe_netdev</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_fcoe_ddp_done</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_fcoe_ddp_done</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_if_create() - Create a FCoE instance on an interface</span>
<span class="cm"> * @fcoe:   The FCoE interface to create a local port on</span>
<span class="cm"> * @parent: The device pointer to be the parent in sysfs for the SCSI host</span>
<span class="cm"> * @npiv:   Indicates if the port is a vport or not</span>
<span class="cm"> *</span>
<span class="cm"> * Creates a fc_lport instance and a Scsi_Host instance and configure them.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: The allocated fc_lport or an error pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="nf">fcoe_if_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">npiv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="o">*</span><span class="n">n_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * parent is only a vport if npiv is 1,</span>
<span class="cm">	 * but we&#39;ll only use vport in that case so go ahead and set it</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">dev_to_vport</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Create Interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">npiv</span><span class="p">)</span>
		<span class="n">lport</span> <span class="o">=</span> <span class="n">libfc_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_shost_template</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">port</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">lport</span> <span class="o">=</span> <span class="n">libfc_vport_create</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">port</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Could not allocate host structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">lport</span> <span class="o">=</span> <span class="n">lport</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fcoe</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">max_queue_depth</span> <span class="o">=</span> <span class="n">FCOE_MAX_QUEUE_DEPTH</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">min_queue_depth</span> <span class="o">=</span> <span class="n">FCOE_MIN_QUEUE_DEPTH</span><span class="p">;</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">destroy_work</span><span class="p">,</span> <span class="n">fcoe_destroy_work</span><span class="p">);</span>

	<span class="cm">/* configure a fc_lport including the exchange manager */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_lport_config</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Could not configure lport for the &quot;</span>
				<span class="s">&quot;interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_host_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">npiv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Setting vport names, &quot;</span>
				<span class="s">&quot;%16.16llx %16.16llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">vport</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">);</span>
		<span class="n">fc_set_wwnn</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">);</span>
		<span class="n">fc_set_wwpn</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* configure lport network properties */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_netdev_config</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Could not configure netdev for the &quot;</span>
				<span class="s">&quot;interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_lp_destroy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* configure lport scsi host properties */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_shost_config</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Could not configure shost for the &quot;</span>
				<span class="s">&quot;interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_lp_destroy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the library */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_libfc_config</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">ctlr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_libfc_fcn_templ</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Could not configure libfc for the &quot;</span>
				<span class="s">&quot;interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_lp_destroy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialized FDMI information */</span>
	<span class="n">fcoe_fdmi_info</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * fcoe_em_alloc() and fcoe_hostlist_add() both</span>
<span class="cm">	 * need to be atomic with respect to other changes to the</span>
<span class="cm">	 * hostlist since fcoe_em_alloc() looks for an existing EM</span>
<span class="cm">	 * instance on host list updated by fcoe_hostlist_add().</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is currently handled through the fcoe_config_mutex</span>
<span class="cm">	 * begin held.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">npiv</span><span class="p">)</span>
		<span class="cm">/* lport exch manager allocation */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_em_config</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">shost</span> <span class="o">=</span> <span class="n">vport_to_shost</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="n">n_port</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">fc_exch_mgr_list_clone</span><span class="p">(</span><span class="n">n_port</span><span class="p">,</span> <span class="n">lport</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Could not configure the EM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_lp_destroy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">lport</span><span class="p">;</span>

<span class="nl">out_lp_destroy:</span>
	<span class="n">fc_exch_mgr_free</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
<span class="nl">out_host_put:</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_if_init() - Initialization routine for fcoe.ko</span>
<span class="cm"> *</span>
<span class="cm"> * Attaches the SW FCoE transport to the FC transport</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 on success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">fcoe_if_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* attach to scsi transport */</span>
	<span class="n">fcoe_nport_scsi_transport</span> <span class="o">=</span>
		<span class="n">fc_attach_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_nport_fc_functions</span><span class="p">);</span>
	<span class="n">fcoe_vport_scsi_transport</span> <span class="o">=</span>
		<span class="n">fc_attach_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_vport_fc_functions</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcoe_nport_scsi_transport</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fcoe: Failed to attach to the FC transport</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_if_exit() - Tear down fcoe.ko</span>
<span class="cm"> *</span>
<span class="cm"> * Detaches the SW FCoE transport from the FC transport</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 on success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="nf">fcoe_if_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fc_release_transport</span><span class="p">(</span><span class="n">fcoe_nport_scsi_transport</span><span class="p">);</span>
	<span class="n">fc_release_transport</span><span class="p">(</span><span class="n">fcoe_vport_scsi_transport</span><span class="p">);</span>
	<span class="n">fcoe_nport_scsi_transport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">fcoe_vport_scsi_transport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_percpu_thread_create() - Create a receive thread for an online CPU</span>
<span class="cm"> * @cpu: The CPU index of the CPU to create a receive thread for</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_percpu_thread_create</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_percpu_s</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">fcoe_percpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="kr">thread</span> <span class="o">=</span> <span class="n">kthread_create_on_node</span><span class="p">(</span><span class="n">fcoe_percpu_receive_thread</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span>
					<span class="s">&quot;fcoethread/%d&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="kr">thread</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">kthread_bind</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>

		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">;</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_percpu_thread_destroy() - Remove the receive thread of a CPU</span>
<span class="cm"> * @cpu: The CPU index of the CPU whose receive thread is to be destroyed</span>
<span class="cm"> *</span>
<span class="cm"> * Destroys a per-CPU Rx thread. Any pending skbs are moved to the</span>
<span class="cm"> * current CPU&#39;s Rx thread. If the thread being destroyed is bound to</span>
<span class="cm"> * the CPU processing this context the skbs will be freed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_percpu_thread_destroy</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_percpu_s</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">crc_eof</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">struct</span> <span class="n">fcoe_percpu_s</span> <span class="o">*</span><span class="n">p0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">targ_cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

	<span class="n">FCOE_DBG</span><span class="p">(</span><span class="s">&quot;Destroying receive thread for CPU %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/* Prevent any new skbs from being queued for this CPU. */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">fcoe_percpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="kr">thread</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">crc_eof</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">crc_eof_page</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crc_eof_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crc_eof_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t bother moving the skb&#39;s if this context is running</span>
<span class="cm">	 * on the same CPU that is having its thread destroyed. This</span>
<span class="cm">	 * can easily happen when the module is removed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">targ_cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">fcoe_percpu</span><span class="p">,</span> <span class="n">targ_cpu</span><span class="p">);</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p0</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p0</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">FCOE_DBG</span><span class="p">(</span><span class="s">&quot;Moving frames from CPU %d to CPU %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">cpu</span><span class="p">,</span> <span class="n">targ_cpu</span><span class="p">);</span>

			<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p0</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p0</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The targeted CPU is not initialized and cannot accept</span>
<span class="cm">			 * new	skbs. Unlock the targeted CPU and drop the skbs</span>
<span class="cm">			 * on the CPU that is going offline.</span>
<span class="cm">			 */</span>
			<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p0</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This scenario occurs when the module is being removed</span>
<span class="cm">		 * and all threads are being destroyed. skbs will continue</span>
<span class="cm">		 * to be shifted from the CPU thread that is being removed</span>
<span class="cm">		 * to the CPU thread associated with the CPU that is processing</span>
<span class="cm">		 * the module removal. Once there is only one CPU Rx thread it</span>
<span class="cm">		 * will reach this case and we will drop all skbs and later</span>
<span class="cm">		 * stop the thread.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_cpu</span><span class="p">();</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * This a non-SMP scenario where the singular Rx thread is</span>
<span class="cm">	 * being removed. Free all skbs and stop the thread.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="kr">thread</span><span class="p">)</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">crc_eof</span><span class="p">)</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">crc_eof</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_cpu_callback() - Handler for CPU hotplug events</span>
<span class="cm"> * @nfb:    The callback data block</span>
<span class="cm"> * @action: The event triggering the callback</span>
<span class="cm"> * @hcpu:   The index of the CPU that the event is for</span>
<span class="cm"> *</span>
<span class="cm"> * This creates or destroys per-CPU data for fcoe</span>
<span class="cm"> *</span>
<span class="cm"> * Returns NOTIFY_OK always.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_cpu_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
	<span class="k">case</span> <span class="n">CPU_ONLINE_FROZEN</span>:
		<span class="n">FCOE_DBG</span><span class="p">(</span><span class="s">&quot;CPU %x online: Create Rx thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">fcoe_percpu_thread_create</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD_FROZEN</span>:
		<span class="n">FCOE_DBG</span><span class="p">(</span><span class="s">&quot;CPU %x offline: Remove Rx thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">fcoe_percpu_thread_destroy</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_select_cpu() - Selects CPU to handle post-processing of incoming</span>
<span class="cm"> *			command.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine selects next CPU based on cpumask to distribute</span>
<span class="cm"> * incoming requests in round robin.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: int CPU number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fcoe_select_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">selected_cpu</span><span class="p">;</span>

	<span class="n">selected_cpu</span> <span class="o">=</span> <span class="n">cpumask_next</span><span class="p">(</span><span class="n">selected_cpu</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">selected_cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
		<span class="n">selected_cpu</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">selected_cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_rcv() - Receive packets from a net device</span>
<span class="cm"> * @skb:    The received packet</span>
<span class="cm"> * @netdev: The net device that the packet was received on</span>
<span class="cm"> * @ptype:  The packet type context</span>
<span class="cm"> * @olddev: The last device net device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called by NET_RX_SOFTIRQ. It receives a packet, builds a</span>
<span class="cm"> * FC frame and passes the frame to libfc.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">ptype</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">olddev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_rcv_info</span> <span class="o">*</span><span class="n">fr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_percpu_s</span> <span class="o">*</span><span class="n">fps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">fcoe</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fcoe_interface</span><span class="p">,</span> <span class="n">fcoe_packet_type</span><span class="p">);</span>
	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="n">lport</span> <span class="o">=</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Cannot find hba structure&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">link_up</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err2</span><span class="p">;</span>

	<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;skb_info: len:%d data_len:%d head:%p &quot;</span>
			<span class="s">&quot;data:%p tail:%p end:%p sum:%d dev:%s&quot;</span><span class="p">,</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			<span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">skb_end_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">?</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;&lt;NULL&gt;&quot;</span><span class="p">);</span>

	<span class="n">eh</span> <span class="o">=</span> <span class="n">eth_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_fip_mode</span><span class="p">(</span><span class="n">ctlr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">compare_ether_addr</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">,</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">dest_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;wrong source mac address:%pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">eh</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for minimum frame length, and make sure required FCoE</span>
<span class="cm">	 * and FC headers are pulled into the linear data area.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">FCOE_MIN_FRAME</span><span class="p">)</span> <span class="o">||</span>
		     <span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">FCOE_HEADER_LEN</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">skb_set_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_hdr</span><span class="p">));</span>
	<span class="n">fh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ntoh24</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">!=</span> <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_d_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;FC frame d_id mismatch with MAC:%pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">eh</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fr</span> <span class="o">=</span> <span class="n">fcoe_dev_from_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">fr</span><span class="o">-&gt;</span><span class="n">fr_dev</span> <span class="o">=</span> <span class="n">lport</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case the incoming frame&#39;s exchange is originated from</span>
<span class="cm">	 * the initiator, then received frame&#39;s exchange id is ANDed</span>
<span class="cm">	 * with fc_cpu_mask bits to get the same cpu on which exchange</span>
<span class="cm">	 * was originated, otherwise select cpu using rx exchange id</span>
<span class="cm">	 * or fcoe_select_cpu().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FC_FC_EX_CTX</span><span class="p">)</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">fc_cpu_mask</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span><span class="p">)</span> <span class="o">==</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">)</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="n">fcoe_select_cpu</span><span class="p">();</span>
		<span class="k">else</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">fc_cpu_mask</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">fps</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">fcoe_percpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fps</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fps</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The targeted CPU is not ready, let&#39;s target</span>
<span class="cm">		 * the first CPU now. For non-SMP systems this</span>
<span class="cm">		 * will check the same CPU twice.</span>
<span class="cm">		 */</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;CPU is online, but no receive thread &quot;</span>
				<span class="s">&quot;ready for incoming skb- using first online &quot;</span>
				<span class="s">&quot;CPU.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fps</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">);</span>
		<span class="n">fps</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">fcoe_percpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fps</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fps</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fps</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We now have a valid CPU that we&#39;re targeting for</span>
<span class="cm">	 * this skb. We also have this receive thread locked,</span>
<span class="cm">	 * so we&#39;re free to queue skbs into it&#39;s queue.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: We used to have a set of conditions under which we would</span>
<span class="cm">	 * call fcoe_recv_frame directly, rather than queuing to the rx list</span>
<span class="cm">	 * as it could save a few cycles, but doing so is prohibited, as</span>
<span class="cm">	 * fcoe_recv_frame has several paths that may sleep, which is forbidden</span>
<span class="cm">	 * in softirq context.</span>
<span class="cm">	 */</span>
	<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fps</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fps</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">)</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">fps</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fps</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">dev_stats</span><span class="p">,</span> <span class="n">get_cpu</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">ErrorFrames</span><span class="o">++</span><span class="p">;</span>
	<span class="n">put_cpu</span><span class="p">();</span>
<span class="nl">err2:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_alloc_paged_crc_eof() - Allocate a page to be used for the trailer CRC</span>
<span class="cm"> * @skb:  The packet to be transmitted</span>
<span class="cm"> * @tlen: The total length of the trailer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_alloc_paged_crc_eof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_percpu_s</span> <span class="o">*</span><span class="n">fps</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">fps</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">get_cpu_var</span><span class="p">(</span><span class="n">fcoe_percpu</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_get_paged_crc_eof</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tlen</span><span class="p">,</span> <span class="n">fps</span><span class="p">);</span>
	<span class="n">put_cpu_var</span><span class="p">(</span><span class="n">fcoe_percpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_xmit() - Transmit a FCoE frame</span>
<span class="cm"> * @lport: The local port that the frame is to be transmitted for</span>
<span class="cm"> * @fp:	   The frame to be transmitted</span>
<span class="cm"> *</span>
<span class="cm"> * Return: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">wlen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">crc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_crc_eof</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_dev_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hlen</span><span class="p">;</span>		<span class="cm">/* header length implies the version */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tlen</span><span class="p">;</span>		<span class="cm">/* trailer length */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">elen</span><span class="p">;</span>		<span class="cm">/* eth header, may include vlan */</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">sof</span><span class="p">,</span> <span class="n">eof</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_hdr</span> <span class="o">*</span><span class="n">hp</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">fr_len</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">fp_skb</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">wlen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">/</span> <span class="n">FCOE_WORD_TO_BYTE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">link_up</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_type</span> <span class="o">==</span> <span class="n">FC_TYPE_ELS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">fcoe_ctlr_els_send</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">lport</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sof</span> <span class="o">=</span> <span class="n">fr_sof</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">eof</span> <span class="o">=</span> <span class="n">fr_eof</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

	<span class="n">elen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span><span class="p">);</span>
	<span class="n">hlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_hdr</span><span class="p">);</span>
	<span class="n">tlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_crc_eof</span><span class="p">);</span>
	<span class="n">wlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">tlen</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">crc</span><span class="p">))</span> <span class="o">/</span> <span class="n">FCOE_WORD_TO_BYTE</span><span class="p">;</span>

	<span class="cm">/* crc offload */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">crc_offload</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_start</span> <span class="o">=</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">crc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>
		<span class="n">crc</span> <span class="o">=</span> <span class="n">fcoe_fc_crc</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* copy port crc and eof to the skb buff */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_is_nonlinear</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcoe_alloc_paged_crc_eof</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tlen</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">))</span>
			<span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_crc_eof</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tlen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="p">));</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">fcoe_eof</span> <span class="o">=</span> <span class="n">eof</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">fcoe_crc32</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">crc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_is_nonlinear</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* adjust skb network/transport offsets to match mac/fcoe/port */</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">elen</span> <span class="o">+</span> <span class="n">hlen</span><span class="p">);</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_len</span> <span class="o">=</span> <span class="n">elen</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_FCOE</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_802_1Q_VLAN</span> <span class="o">&amp;&amp;</span>
	    <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">realdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">vlan_tci</span> <span class="o">=</span> <span class="n">VLAN_TAG_PRESENT</span> <span class="o">|</span>
				<span class="n">vlan_dev_vlan_id</span><span class="p">(</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">realdev</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="cm">/* fill up mac and fcoe headers */</span>
	<span class="n">eh</span> <span class="o">=</span> <span class="n">eth_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">eh</span><span class="o">-&gt;</span><span class="n">h_proto</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_FCOE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">,</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">dest_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">map_dest</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">h_dest</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_d_id</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">flogi_oxid</span> <span class="o">!=</span> <span class="n">FC_XID_UNKNOWN</span><span class="p">))</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">,</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">ctl_src_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">data_src_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">hp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_hdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">eh</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hp</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">FC_FCOE_VER</span><span class="p">)</span>
		<span class="n">FC_FCOE_ENCAPS_VER</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="n">FC_FCOE_VER</span><span class="p">);</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">fcoe_sof</span> <span class="o">=</span> <span class="n">sof</span><span class="p">;</span>

	<span class="cm">/* fcoe lso, mss is in max_payload which is non-zero for FCP data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">seq_offload</span> <span class="o">&amp;&amp;</span> <span class="n">fr_max_payload</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">=</span> <span class="n">SKB_GSO_FCOE</span><span class="p">;</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="n">fr_max_payload</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* update tx stats: regardless if LLD fails */</span>
	<span class="n">stats</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">dev_stats</span><span class="p">,</span> <span class="n">get_cpu</span><span class="p">());</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">TxFrames</span><span class="o">++</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">TxWords</span> <span class="o">+=</span> <span class="n">wlen</span><span class="p">;</span>
	<span class="n">put_cpu</span><span class="p">();</span>

	<span class="cm">/* send down to lld */</span>
	<span class="n">fr_dev</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">lport</span><span class="p">;</span>
	<span class="n">fcoe_port_send</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_percpu_flush_done() - Indicate per-CPU queue flush completion</span>
<span class="cm"> * @skb: The completed skb (argument required by destructor)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_percpu_flush_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_flush_completion</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_filter_frames() - filter out bad fcoe frames, i.e. bad CRC</span>
<span class="cm"> * @lport: The local port the frame was received on</span>
<span class="cm"> * @fp:	   The received frame</span>
<span class="cm"> *</span>
<span class="cm"> * Return: 0 on passing filtering checks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fcoe_filter_frames</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">fp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_dev_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We only check CRC if no offload is available and if it is</span>
<span class="cm">	 * it&#39;s solicited data, in which case, the FCP layer would</span>
<span class="cm">	 * check it during the copy.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">crc_offload</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">)</span>
		<span class="n">fr_flags</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCPHF_CRC_UNCHECKED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">fr_flags</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">|=</span> <span class="n">FCPHF_CRC_UNCHECKED</span><span class="p">;</span>

	<span class="n">fh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span> <span class="o">==</span> <span class="n">FC_RCTL_DD_SOL_DATA</span> <span class="o">&amp;&amp;</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_type</span> <span class="o">==</span> <span class="n">FC_TYPE_FCP</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fcoe</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="p">)</span><span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_fip_mode</span><span class="p">(</span><span class="n">ctlr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fc_frame_payload_op</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">ELS_LOGO</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_s_id</span><span class="p">)</span> <span class="o">==</span> <span class="n">FC_FID_FLOGI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FCOE_DBG</span><span class="p">(</span><span class="s">&quot;fcoe: dropping FCoE lport LOGO in fip mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fr_flags</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FCPHF_CRC_UNCHECKED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">fr_crc</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="o">==</span> <span class="o">~</span><span class="n">crc32</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fr_flags</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCPHF_CRC_UNCHECKED</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">stats</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">dev_stats</span><span class="p">,</span> <span class="n">get_cpu</span><span class="p">());</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">InvalidCRCCount</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">InvalidCRCCount</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;fcoe: dropping frame with CRC error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">put_cpu</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_recv_frame() - process a single received frame</span>
<span class="cm"> * @skb: frame to process</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_recv_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">fr_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_rcv_info</span> <span class="o">*</span><span class="n">fr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_dev_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_crc_eof</span> <span class="n">crc_eof</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_hdr</span> <span class="o">*</span><span class="n">hp</span><span class="p">;</span>

	<span class="n">fr</span> <span class="o">=</span> <span class="n">fcoe_dev_from_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">lport</span> <span class="o">=</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">fr_dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">!=</span> <span class="n">fcoe_percpu_flush_done</span><span class="p">)</span>
			<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NULL lport in skb&quot;</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;skb_info: len:%d data_len:%d &quot;</span>
			<span class="s">&quot;head:%p data:%p tail:%p end:%p sum:%d dev:%s&quot;</span><span class="p">,</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">,</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
			<span class="n">skb_end_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">?</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;&lt;NULL&gt;&quot;</span><span class="p">);</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="n">skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span> <span class="cm">/* check for skb_is_nonlinear is within skb_linearize */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Frame length checks and setting up the header pointers</span>
<span class="cm">	 * was done in fcoe_rcv already.</span>
<span class="cm">	 */</span>
	<span class="n">hp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_hdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">stats</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">dev_stats</span><span class="p">,</span> <span class="n">get_cpu</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">FC_FCOE_DECAPS_VER</span><span class="p">(</span><span class="n">hp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">FC_FCOE_VER</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">ErrorFrames</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;fcoe: FCoE version &quot;</span>
			       <span class="s">&quot;mismatch: The frame has &quot;</span>
			       <span class="s">&quot;version %x, but the &quot;</span>
			       <span class="s">&quot;initiator supports version &quot;</span>
			       <span class="s">&quot;%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">FC_FCOE_DECAPS_VER</span><span class="p">(</span><span class="n">hp</span><span class="p">),</span>
			       <span class="n">FC_FCOE_VER</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_hdr</span><span class="p">));</span>
	<span class="n">fr_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_crc_eof</span><span class="p">);</span>

	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">RxFrames</span><span class="o">++</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">RxWords</span> <span class="o">+=</span> <span class="n">fr_len</span> <span class="o">/</span> <span class="n">FCOE_WORD_TO_BYTE</span><span class="p">;</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">fc_frame_init</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">fr_dev</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">lport</span><span class="p">;</span>
	<span class="n">fr_sof</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">fcoe_sof</span><span class="p">;</span>

	<span class="cm">/* Copy out the CRC and EOF trailer for access */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_copy_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fr_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">crc_eof</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">crc_eof</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="n">fr_eof</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">crc_eof</span><span class="p">.</span><span class="n">fcoe_eof</span><span class="p">;</span>
	<span class="n">fr_crc</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">=</span> <span class="n">crc_eof</span><span class="p">.</span><span class="n">fcoe_crc32</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pskb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fr_len</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcoe_filter_frames</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">put_cpu</span><span class="p">();</span>
		<span class="n">fc_exch_recv</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">drop:</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">ErrorFrames</span><span class="o">++</span><span class="p">;</span>
	<span class="n">put_cpu</span><span class="p">();</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_percpu_receive_thread() - The per-CPU packet receive thread</span>
<span class="cm"> * @arg: The per-CPU context</span>
<span class="cm"> *</span>
<span class="cm"> * Return: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_percpu_receive_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_percpu_s</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>

	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>

		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">skb_queue_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">fcoe_recv_frame</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_dev_setup() - Setup the link change notification interface</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_dev_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">register_dcbevent_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcb_notifier</span><span class="p">);</span>
	<span class="n">register_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_notifier</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_dev_cleanup() - Cleanup the link change notification interface</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_dev_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_dcbevent_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcb_notifier</span><span class="p">);</span>
	<span class="n">unregister_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_notifier</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span>
<span class="nf">fcoe_hostlist_lookup_realdev_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">real_dev</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fcoe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_hostlist</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_802_1Q_VLAN</span><span class="p">)</span>
			<span class="n">real_dev</span> <span class="o">=</span> <span class="n">vlan_dev_real_dev</span><span class="p">(</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">real_dev</span> <span class="o">=</span> <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span> <span class="o">==</span> <span class="n">real_dev</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">fcoe</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_dcb_app_notification</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">notifier</span><span class="p">,</span>
				     <span class="n">ulong</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dcb_app_type</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">app</span><span class="p">.</span><span class="n">selector</span> <span class="o">!=</span> <span class="n">DCB_APP_IDTYPE_ETHTYPE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

	<span class="n">netdev</span> <span class="o">=</span> <span class="n">dev_get_by_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

	<span class="n">fcoe</span> <span class="o">=</span> <span class="n">fcoe_hostlist_lookup_realdev_port</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">dev_put</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcoe</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">dcbx</span> <span class="o">&amp;</span> <span class="n">DCB_CAP_DCBX_VER_CEE</span><span class="p">)</span>
		<span class="n">prio</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">app</span><span class="p">.</span><span class="n">priority</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">prio</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">app</span><span class="p">.</span><span class="n">priority</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">app</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ETH_P_FIP</span> <span class="o">||</span>
	    <span class="n">entry</span><span class="o">-&gt;</span><span class="n">app</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ETH_P_FCOE</span><span class="p">)</span>
		<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">prio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">app</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ETH_P_FCOE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">);</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">prio</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_device_notification() - Handler for net device events</span>
<span class="cm"> * @notifier: The context of the notification</span>
<span class="cm"> * @event:    The type of event</span>
<span class="cm"> * @ptr:      The net device that the event was on</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the Ethernet driver in case of link change event.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_device_notification</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">notifier</span><span class="p">,</span>
				    <span class="n">ulong</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_dev_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">link_possible</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mfs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fcoe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_hostlist</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">==</span> <span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
			<span class="n">lport</span> <span class="o">=</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NETDEV_DOWN</span>:
	<span class="k">case</span> <span class="n">NETDEV_GOING_DOWN</span>:
		<span class="n">link_possible</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_UP</span>:
	<span class="k">case</span> <span class="n">NETDEV_CHANGE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_CHANGEMTU</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_FCOE_MTU</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">mfs</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">-</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_hdr</span><span class="p">)</span> <span class="o">+</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_crc_eof</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mfs</span> <span class="o">&gt;=</span> <span class="n">FC_MIN_MAX_FRAME</span><span class="p">)</span>
			<span class="n">fc_set_mfs</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">mfs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_REGISTER</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_UNREGISTER</span>:
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">fcoe_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">destroy_work</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_FEAT_CHANGE</span>:
		<span class="n">fcoe_netdev_features_change</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">FCOE_NETDEV_DBG</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Unknown event %ld &quot;</span>
				<span class="s">&quot;from netdev netlink</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fcoe_link_speed_update</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link_possible</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fcoe_link_ok</span><span class="p">(</span><span class="n">lport</span><span class="p">))</span>
		<span class="n">fcoe_ctlr_link_up</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fcoe_ctlr_link_down</span><span class="p">(</span><span class="n">ctlr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">stats</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">dev_stats</span><span class="p">,</span> <span class="n">get_cpu</span><span class="p">());</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">LinkFailureCount</span><span class="o">++</span><span class="p">;</span>
		<span class="n">put_cpu</span><span class="p">();</span>
		<span class="n">fcoe_clean_pending_queue</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_disable() - Disables a FCoE interface</span>
<span class="cm"> * @netdev  : The net_device object the Ethernet interface to create on</span>
<span class="cm"> *</span>
<span class="cm"> * Called from fcoe transport.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">fcoe</span> <span class="o">=</span> <span class="n">fcoe_hostlist_lookup_port</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fcoe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
		<span class="n">fcoe_ctlr_link_down</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>
		<span class="n">fcoe_clean_pending_queue</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_enable() - Enables a FCoE interface</span>
<span class="cm"> * @netdev  : The net_device object the Ethernet interface to create on</span>
<span class="cm"> *</span>
<span class="cm"> * Called from fcoe transport.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">fcoe</span> <span class="o">=</span> <span class="n">fcoe_hostlist_lookup_port</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcoe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcoe_link_ok</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">))</span>
		<span class="n">fcoe_ctlr_link_up</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_destroy() - Destroy a FCoE interface</span>
<span class="cm"> * @netdev  : The net_device object the Ethernet interface to create on</span>
<span class="cm"> *</span>
<span class="cm"> * Called from fcoe transport</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">fcoe</span> <span class="o">=</span> <span class="n">fcoe_hostlist_lookup_port</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcoe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_nodev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="n">lport</span> <span class="o">=</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
	<span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">fcoe_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">destroy_work</span><span class="p">);</span>
<span class="nl">out_nodev:</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_destroy_work() - Destroy a FCoE port in a deferred work context</span>
<span class="cm"> * @work: Handle to the FCoE port to be destroyed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_destroy_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fcoe_port</span><span class="p">,</span> <span class="n">destroy_work</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>

	<span class="n">fcoe</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">fcoe_if_destroy</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lport</span><span class="p">);</span>
	<span class="n">fcoe_interface_cleanup</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_match() - Check if the FCoE is supported on the given netdevice</span>
<span class="cm"> * @netdev  : The net_device object the Ethernet interface to create on</span>
<span class="cm"> *</span>
<span class="cm"> * Called from fcoe transport.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: always returns true as this is the default FCoE transport,</span>
<span class="cm"> * i.e., support all netdevs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">fcoe_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_dcb_create() - Initialize DCB attributes and hooks</span>
<span class="cm"> * @netdev: The net_device object of the L2 link that should be queried</span>
<span class="cm"> * @port: The fcoe_port to bind FCoE APP priority with</span>
<span class="cm"> * @</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_dcb_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_DCB</span>
	<span class="kt">int</span> <span class="n">dcbx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">fup</span><span class="p">,</span> <span class="n">up</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">realdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dcb_app</span> <span class="n">app</span> <span class="o">=</span> <span class="p">{</span>
				<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
				<span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ETH_P_FCOE</span>
			     <span class="p">};</span>

	<span class="cm">/* setup DCB priority attributes. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span> <span class="o">&amp;&amp;</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dcbnl_ops</span> <span class="o">&amp;&amp;</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dcbnl_ops</span><span class="o">-&gt;</span><span class="n">getdcbx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dcbx</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dcbnl_ops</span><span class="o">-&gt;</span><span class="n">getdcbx</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dcbx</span> <span class="o">&amp;</span> <span class="n">DCB_CAP_DCBX_VER_IEEE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">app</span><span class="p">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">IEEE_8021QAZ_APP_SEL_ETHERTYPE</span><span class="p">;</span>
			<span class="n">up</span> <span class="o">=</span> <span class="n">dcb_ieee_getapp_mask</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">app</span><span class="p">);</span>
			<span class="n">app</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ETH_P_FIP</span><span class="p">;</span>
			<span class="n">fup</span> <span class="o">=</span> <span class="n">dcb_ieee_getapp_mask</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">app</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">app</span><span class="p">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">DCB_APP_IDTYPE_ETHTYPE</span><span class="p">;</span>
			<span class="n">up</span> <span class="o">=</span> <span class="n">dcb_getapp</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">app</span><span class="p">);</span>
			<span class="n">app</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ETH_P_FIP</span><span class="p">;</span>
			<span class="n">fup</span> <span class="o">=</span> <span class="n">dcb_getapp</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">app</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">port</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">up</span><span class="p">)</span> <span class="o">?</span> <span class="n">ffs</span><span class="p">(</span><span class="n">up</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">fup</span><span class="p">)</span> <span class="o">?</span> <span class="n">ffs</span><span class="p">(</span><span class="n">fup</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_create() - Create a fcoe interface</span>
<span class="cm"> * @netdev  : The net_device object the Ethernet interface to create on</span>
<span class="cm"> * @fip_mode: The FIP mode for this creation</span>
<span class="cm"> *</span>
<span class="cm"> * Called from fcoe transport</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fip_state</span> <span class="n">fip_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>

	<span class="cm">/* look for existing lport */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fcoe_hostlist_lookup</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_nodev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fcoe</span> <span class="o">=</span> <span class="n">fcoe_interface_create</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">fip_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fcoe</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_nodev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="n">ctlr_dev</span> <span class="o">=</span> <span class="n">fcoe_ctlr_to_ctlr_dev</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>
	<span class="n">lport</span> <span class="o">=</span> <span class="n">fcoe_if_create</span><span class="p">(</span><span class="n">fcoe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctlr_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lport</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fcoe: Failed to create interface (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
		<span class="n">fcoe_interface_cleanup</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_nortnl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make this the &quot;master&quot; N_Port */</span>
	<span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lp</span> <span class="o">=</span> <span class="n">lport</span><span class="p">;</span>

	<span class="cm">/* setup DCB priority attributes. */</span>
	<span class="n">fcoe_dcb_create</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>

	<span class="cm">/* add to lports list */</span>
	<span class="n">fcoe_hostlist_add</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="cm">/* start FIP Discovery and FLOGI */</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">boot_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">fc_fabric_login</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcoe_link_ok</span><span class="p">(</span><span class="n">lport</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
		<span class="n">fcoe_ctlr_link_up</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_nodev:</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
<span class="nl">out_nortnl:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_link_speed_update() - Update the supported and actual link speeds</span>
<span class="cm"> * @lport: The local port to update speeds for</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if the ethtool query was successful</span>
<span class="cm"> *          -1 if the ethtool query failed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_link_speed_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe_netdev</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="n">ecmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__ethtool_get_settings</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">link_supported_speeds</span> <span class="o">&amp;=</span>
			<span class="o">~</span><span class="p">(</span><span class="n">FC_PORTSPEED_1GBIT</span> <span class="o">|</span> <span class="n">FC_PORTSPEED_10GBIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecmd</span><span class="p">.</span><span class="n">supported</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SUPPORTED_1000baseT_Half</span> <span class="o">|</span>
				      <span class="n">SUPPORTED_1000baseT_Full</span><span class="p">))</span>
			<span class="n">lport</span><span class="o">-&gt;</span><span class="n">link_supported_speeds</span> <span class="o">|=</span> <span class="n">FC_PORTSPEED_1GBIT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecmd</span><span class="p">.</span><span class="n">supported</span> <span class="o">&amp;</span> <span class="n">SUPPORTED_10000baseT_Full</span><span class="p">)</span>
			<span class="n">lport</span><span class="o">-&gt;</span><span class="n">link_supported_speeds</span> <span class="o">|=</span>
				<span class="n">FC_PORTSPEED_10GBIT</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ethtool_cmd_speed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ecmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SPEED_1000</span>:
			<span class="n">lport</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">=</span> <span class="n">FC_PORTSPEED_1GBIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SPEED_10000</span>:
			<span class="n">lport</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">=</span> <span class="n">FC_PORTSPEED_10GBIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_link_ok() - Check if the link is OK for a local port</span>
<span class="cm"> * @lport: The local port to check link on</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if link is UP and OK, -1 if not</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_link_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe_netdev</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_oper_up</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_percpu_clean() - Clear all pending skbs for an local port</span>
<span class="cm"> * @lport: The local port whose skbs are to be cleared</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with fcoe_create_mutex held to single-thread completion.</span>
<span class="cm"> *</span>
<span class="cm"> * This flushes the pending skbs by adding a new skb to each queue and</span>
<span class="cm"> * waiting until they are all freed.  This assures us that not only are</span>
<span class="cm"> * there no packets that will be handled by the lport, but also that any</span>
<span class="cm"> * threads already handling packet have returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_percpu_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_percpu_s</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">fcoe_percpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">||</span> <span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">fcoe_percpu_flush_done</span><span class="p">;</span>

		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">qlen</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">wake_up_process</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_flush_completion</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_reset() - Reset a local port</span>
<span class="cm"> * @shost: The SCSI host associated with the local port to be reset</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: Always 0 (return value required by FC transport template)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>

	<span class="n">fcoe_ctlr_link_down</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>
	<span class="n">fcoe_clean_pending_queue</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcoe_link_ok</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">))</span>
		<span class="n">fcoe_ctlr_link_up</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_hostlist_lookup_port() - Find the FCoE interface associated with a net device</span>
<span class="cm"> * @netdev: The net device used as a key</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: Must be called with the RNL mutex held.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: NULL or the FCoE interface</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span>
<span class="nf">fcoe_hostlist_lookup_port</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fcoe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_hostlist</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">==</span> <span class="n">netdev</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">fcoe</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_hostlist_lookup() - Find the local port associated with a</span>
<span class="cm"> *			    given net device</span>
<span class="cm"> * @netdev: The netdevice used as a key</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: Must be called with the RTNL mutex held</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: NULL or the local port</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="nf">fcoe_hostlist_lookup</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>

	<span class="n">fcoe</span> <span class="o">=</span> <span class="n">fcoe_hostlist_lookup_port</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">fcoe</span><span class="p">)</span> <span class="o">?</span> <span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lp</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_hostlist_add() - Add the FCoE interface identified by a local</span>
<span class="cm"> *			 port to the hostlist</span>
<span class="cm"> * @lport: The local port that identifies the FCoE interface to be added</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: must be called with the RTNL mutex held</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_hostlist_add</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>

	<span class="n">fcoe</span> <span class="o">=</span> <span class="n">fcoe_hostlist_lookup_port</span><span class="p">(</span><span class="n">fcoe_netdev</span><span class="p">(</span><span class="n">lport</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcoe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
		<span class="n">fcoe</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_hostlist</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="n">fcoe_sw_transport</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">{</span><span class="n">FCOE_TRANSPORT_DEFAULT</span><span class="p">},</span>
	<span class="p">.</span><span class="n">attached</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
	<span class="p">.</span><span class="n">list</span> <span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">fcoe_sw_transport</span><span class="p">.</span><span class="n">list</span><span class="p">),</span>
	<span class="p">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">fcoe_match</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">fcoe_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">fcoe_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable</span> <span class="o">=</span> <span class="n">fcoe_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable</span> <span class="o">=</span> <span class="n">fcoe_disable</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_init() - Initialize fcoe.ko</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 on success, or a negative value on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">fcoe_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_percpu_s</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fcoe_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;fcoe&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcoe_wq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* register as a fcoe transport */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_transport_attach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_sw_transport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;failed to register an fcoe transport, check &quot;</span>
			<span class="s">&quot;if libfcoe is loaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">fcoe_percpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fcoe_rx_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">fcoe_percpu_thread_create</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/* Initialize per CPU interrupt thread */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">register_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_cpu_notifier</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="cm">/* Setup link change notification */</span>
	<span class="n">fcoe_dev_setup</span><span class="p">();</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_if_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fcoe_percpu_thread_destroy</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">fcoe_wq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">fcoe_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_exit() - Clean up fcoe.ko</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 on success or a  negative value on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">fcoe_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>

	<span class="n">fcoe_dev_cleanup</span><span class="p">();</span>

	<span class="cm">/* releases the associated fcoe hosts */</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">fcoe</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_hostlist</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">ctlr</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">fcoe_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">destroy_work</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="n">unregister_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_cpu_notifier</span><span class="p">);</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">fcoe_percpu_thread_destroy</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * destroy_work&#39;s may be chained but destroy_workqueue()</span>
<span class="cm">	 * can take care of them. Just kill the fcoe_wq.</span>
<span class="cm">	 */</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">fcoe_wq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Detaching from the scsi transport must happen after all</span>
<span class="cm">	 * destroys are done on the fcoe_wq. destroy_workqueue will</span>
<span class="cm">	 * enusre the fcoe_wq is flushed.</span>
<span class="cm">	 */</span>
	<span class="n">fcoe_if_exit</span><span class="p">();</span>

	<span class="cm">/* detach from fcoe transport */</span>
	<span class="n">fcoe_transport_detach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_sw_transport</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">fcoe_exit</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_flogi_resp() - FCoE specific FLOGI and FDISC response handler</span>
<span class="cm"> * @seq: active sequence in the FLOGI or FDISC exchange</span>
<span class="cm"> * @fp: response frame, or error encoded in a pointer (timeout)</span>
<span class="cm"> * @arg: pointer the the fcoe_ctlr structure</span>
<span class="cm"> *</span>
<span class="cm"> * This handles MAC address management for FCoE, then passes control on to</span>
<span class="cm"> * the libfc FLOGI response handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_flogi_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">fip</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch</span> <span class="o">*</span><span class="n">exch</span> <span class="o">=</span> <span class="n">fc_seq_exch</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">exch</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">mac</span> <span class="o">=</span> <span class="n">fr_cb</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">granted_mac</span><span class="p">;</span>
	<span class="cm">/* pre-FIP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">mac</span><span class="p">))</span>
		<span class="n">fcoe_ctlr_recv_flogi</span><span class="p">(</span><span class="n">fip</span><span class="p">,</span> <span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">mac</span><span class="p">))</span>
		<span class="n">fcoe_update_src_mac</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">mac</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="n">fc_lport_flogi_resp</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">lport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_logo_resp() - FCoE specific LOGO response handler</span>
<span class="cm"> * @seq: active sequence in the LOGO exchange</span>
<span class="cm"> * @fp: response frame, or error encoded in a pointer (timeout)</span>
<span class="cm"> * @arg: pointer the the fcoe_ctlr structure</span>
<span class="cm"> *</span>
<span class="cm"> * This handles MAC address management for FCoE, then passes control on to</span>
<span class="cm"> * the libfc LOGO response handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_logo_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">u8</span> <span class="n">zero_mac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>
		<span class="n">fcoe_update_src_mac</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">zero_mac</span><span class="p">);</span>
	<span class="n">fc_lport_logo_resp</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">lport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_elsct_send - FCoE specific ELS handler</span>
<span class="cm"> *</span>
<span class="cm"> * This does special case handling of FIP encapsualted ELS exchanges for FCoE,</span>
<span class="cm"> * using FCoE specific response handlers and passing the FIP controller as</span>
<span class="cm"> * the argument (the lport is still available from the exchange).</span>
<span class="cm"> *</span>
<span class="cm"> * Most of the work here is just handed off to the libfc routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="nf">fcoe_elsct_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="n">u32</span> <span class="n">did</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span>
						   <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">fip</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">fc_frame_header_get</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ELS_FLOGI</span>:
	<span class="k">case</span> <span class="n">ELS_FDISC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">point_to_multipoint</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">fc_elsct_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">fcoe_flogi_resp</span><span class="p">,</span>
				     <span class="n">fip</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">ELS_LOGO</span>:
		<span class="cm">/* only hook onto fabric logouts, not port logouts */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ntoh24</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_d_id</span><span class="p">)</span> <span class="o">!=</span> <span class="n">FC_FID_FLOGI</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">fc_elsct_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">fcoe_logo_resp</span><span class="p">,</span>
				     <span class="n">lport</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">fc_elsct_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">resp</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_vport_create() - create an fc_host/scsi_host for a vport</span>
<span class="cm"> * @vport: fc_vport object to create a new fc_host for</span>
<span class="cm"> * @disabled: start the new fc_host in a disabled state by default?</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_vport_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="n">bool</span> <span class="n">disabled</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">vport_to_shost</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">n_port</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">n_port</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">vn_port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_validate_vport_create</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fcoe_wwn_to_str</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fcoe: Failed to create vport, &quot;</span>
			<span class="s">&quot;WWPN (0x%s) already exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">buf</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">vn_port</span> <span class="o">=</span> <span class="n">fcoe_if_create</span><span class="p">(</span><span class="n">fcoe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vn_port</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fcoe: fcoe_vport_create(%s) failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_DISABLED</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vn_port</span><span class="o">-&gt;</span><span class="n">boot_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">fc_fabric_login</span><span class="p">(</span><span class="n">vn_port</span><span class="p">);</span>
		<span class="n">fc_vport_setlink</span><span class="p">(</span><span class="n">vn_port</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_vport_destroy() - destroy the fc_host/scsi_host for a vport</span>
<span class="cm"> * @vport: fc_vport object that is being destroyed</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_vport_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">vport_to_shost</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">n_port</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">vn_port</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_port</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn_port</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_port</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>
	<span class="n">fcoe_if_destroy</span><span class="p">(</span><span class="n">vn_port</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcoe_config_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_vport_disable() - change vport state</span>
<span class="cm"> * @vport: vport to bring online/offline</span>
<span class="cm"> * @disable: should the vport be disabled?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_vport_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="n">bool</span> <span class="n">disable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_DISABLED</span><span class="p">);</span>
		<span class="n">fc_fabric_logoff</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">boot_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">fc_fabric_login</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
		<span class="n">fc_vport_setlink</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_vport_set_symbolic_name() - append vport string to symbolic name</span>
<span class="cm"> * @vport: fc_vport with a new symbolic name string</span>
<span class="cm"> *</span>
<span class="cm"> * After generating a new symbolic name string, a new RSPN_ID request is</span>
<span class="cm"> * sent to the name server.  There is no response handler, so if it fails</span>
<span class="cm"> * for some reason it will not be retried.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_set_vport_symbolic_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">fc_host_symbolic_name</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span> <span class="n">FC_SYMBOLIC_NAME_SIZE</span><span class="p">,</span>
		 <span class="s">&quot;%s v%s over %s : %s&quot;</span><span class="p">,</span> <span class="n">FCOE_NAME</span><span class="p">,</span> <span class="n">FCOE_VERSION</span><span class="p">,</span>
		 <span class="n">fcoe_netdev</span><span class="p">(</span><span class="n">lport</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">symbolic_name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">LPORT_ST_READY</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">strnlen</span><span class="p">(</span><span class="n">fc_host_symbolic_name</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span> <span class="mi">255</span><span class="p">);</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="n">fc_frame_alloc</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_ct_hdr</span><span class="p">)</span> <span class="o">+</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_ns_rspn</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">elsct_send</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">FC_FID_DIR_SERV</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">FC_NS_RSPN_ID</span><span class="p">,</span>
			     <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">r_a_tov</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_get_lesb() - Fill the FCoE Link Error Status Block</span>
<span class="cm"> * @lport: the local port</span>
<span class="cm"> * @fc_lesb: the link error status block</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_get_lesb</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">fc_els_lesb</span> <span class="o">*</span><span class="n">fc_lesb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe_netdev</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>

	<span class="n">__fcoe_get_lesb</span><span class="p">(</span><span class="n">lport</span><span class="p">,</span> <span class="n">fc_lesb</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_ctlr_get_lesb</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">fip</span> <span class="o">=</span> <span class="n">fcoe_ctlr_device_priv</span><span class="p">(</span><span class="n">ctlr_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe_netdev</span><span class="p">(</span><span class="n">fip</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_fc_els_lesb</span> <span class="o">*</span><span class="n">fcoe_lesb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_els_lesb</span> <span class="n">fc_lesb</span><span class="p">;</span>

	<span class="n">__fcoe_get_lesb</span><span class="p">(</span><span class="n">fip</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_lesb</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="n">fcoe_lesb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_fc_els_lesb</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">fc_lesb</span><span class="p">);</span>

	<span class="n">ctlr_dev</span><span class="o">-&gt;</span><span class="n">lesb</span><span class="p">.</span><span class="n">lesb_link_fail</span> <span class="o">=</span>
		<span class="n">ntohl</span><span class="p">(</span><span class="n">fcoe_lesb</span><span class="o">-&gt;</span><span class="n">lesb_link_fail</span><span class="p">);</span>
	<span class="n">ctlr_dev</span><span class="o">-&gt;</span><span class="n">lesb</span><span class="p">.</span><span class="n">lesb_vlink_fail</span> <span class="o">=</span>
		<span class="n">ntohl</span><span class="p">(</span><span class="n">fcoe_lesb</span><span class="o">-&gt;</span><span class="n">lesb_vlink_fail</span><span class="p">);</span>
	<span class="n">ctlr_dev</span><span class="o">-&gt;</span><span class="n">lesb</span><span class="p">.</span><span class="n">lesb_miss_fka</span> <span class="o">=</span>
		<span class="n">ntohl</span><span class="p">(</span><span class="n">fcoe_lesb</span><span class="o">-&gt;</span><span class="n">lesb_miss_fka</span><span class="p">);</span>
	<span class="n">ctlr_dev</span><span class="o">-&gt;</span><span class="n">lesb</span><span class="p">.</span><span class="n">lesb_symb_err</span> <span class="o">=</span>
		<span class="n">ntohl</span><span class="p">(</span><span class="n">fcoe_lesb</span><span class="o">-&gt;</span><span class="n">lesb_symb_err</span><span class="p">);</span>
	<span class="n">ctlr_dev</span><span class="o">-&gt;</span><span class="n">lesb</span><span class="p">.</span><span class="n">lesb_err_block</span> <span class="o">=</span>
		<span class="n">ntohl</span><span class="p">(</span><span class="n">fcoe_lesb</span><span class="o">-&gt;</span><span class="n">lesb_err_block</span><span class="p">);</span>
	<span class="n">ctlr_dev</span><span class="o">-&gt;</span><span class="n">lesb</span><span class="p">.</span><span class="n">lesb_fcs_error</span> <span class="o">=</span>
		<span class="n">ntohl</span><span class="p">(</span><span class="n">fcoe_lesb</span><span class="o">-&gt;</span><span class="n">lesb_fcs_error</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_fcf_get_vlan_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">fcf_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="n">ctlr_dev</span> <span class="o">=</span>
		<span class="n">fcoe_fcf_dev_to_ctlr_dev</span><span class="p">(</span><span class="n">fcf_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_ctlr_device_priv</span><span class="p">(</span><span class="n">ctlr_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span> <span class="o">=</span> <span class="n">fcoe_ctlr_priv</span><span class="p">(</span><span class="n">ctlr</span><span class="p">);</span>

	<span class="n">fcf_dev</span><span class="o">-&gt;</span><span class="n">vlan_id</span> <span class="o">=</span> <span class="n">vlan_dev_vlan_id</span><span class="p">(</span><span class="n">fcoe</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_set_port_id() - Callback from libfc when Port_ID is set.</span>
<span class="cm"> * @lport: the local port</span>
<span class="cm"> * @port_id: the port ID</span>
<span class="cm"> * @fp: the received frame, if any, that caused the port_id to be set.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine handles the case where we received a FLOGI and are</span>
<span class="cm"> * entering point-to-point mode.  We need to call fcoe_ctlr_recv_flogi()</span>
<span class="cm"> * so it can set the non-mapped mode and gateway address.</span>
<span class="cm"> *</span>
<span class="cm"> * The FLOGI LS_ACC is handled by fcoe_flogi_resp().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_set_port_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">port_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fcoe_interface</span> <span class="o">*</span><span class="n">fcoe</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span> <span class="o">=</span> <span class="n">fcoe_to_ctlr</span><span class="p">(</span><span class="n">fcoe</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">&amp;&amp;</span> <span class="n">fc_frame_payload_op</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">ELS_FLOGI</span><span class="p">)</span>
		<span class="n">fcoe_ctlr_recv_flogi</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">lport</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
