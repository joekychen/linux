<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › fcoe › fcoe_transport.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fcoe_transport.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintained at www.Open-FCoE.org</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;scsi/libfcoe.h&gt;</span>

<span class="cp">#include &quot;libfcoe.h&quot;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Open-FCoE.org&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;FIP discovery protocol and FCoE transport for FCoE HBAs&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_transport_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_transport_destroy</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_transport_show</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">fcoe_transport_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">fcoe_netdev_map_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_transport_enable</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fcoe_transport_disable</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">libfcoe_device_notification</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">notifier</span><span class="p">,</span>
				    <span class="n">ulong</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">fcoe_transports</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ft_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">fcoe_netdevs</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">fn_mutex</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">libfcoe_debug_logging</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">debug_logging</span><span class="p">,</span> <span class="n">libfcoe_debug_logging</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug_logging</span><span class="p">,</span> <span class="s">&quot;a bit mask of logging levels&quot;</span><span class="p">);</span>

<span class="n">module_param_call</span><span class="p">(</span><span class="n">show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">fcoe_transport_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="p">);</span>
<span class="n">__MODULE_PARM_TYPE</span><span class="p">(</span><span class="n">show</span><span class="p">,</span> <span class="s">&quot;string&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">show</span><span class="p">,</span> <span class="s">&quot; Show attached FCoE transports&quot;</span><span class="p">);</span>

<span class="n">module_param_call</span><span class="p">(</span><span class="n">create</span><span class="p">,</span> <span class="n">fcoe_transport_create</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">FIP_MODE_FABRIC</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">__MODULE_PARM_TYPE</span><span class="p">(</span><span class="n">create</span><span class="p">,</span> <span class="s">&quot;string&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">create</span><span class="p">,</span> <span class="s">&quot; Creates fcoe instance on a ethernet interface&quot;</span><span class="p">);</span>

<span class="n">module_param_call</span><span class="p">(</span><span class="n">create_vn2vn</span><span class="p">,</span> <span class="n">fcoe_transport_create</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">FIP_MODE_VN2VN</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">__MODULE_PARM_TYPE</span><span class="p">(</span><span class="n">create_vn2vn</span><span class="p">,</span> <span class="s">&quot;string&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">create_vn2vn</span><span class="p">,</span> <span class="s">&quot; Creates a VN_node to VN_node FCoE instance &quot;</span>
		 <span class="s">&quot;on an Ethernet interface&quot;</span><span class="p">);</span>

<span class="n">module_param_call</span><span class="p">(</span><span class="n">destroy</span><span class="p">,</span> <span class="n">fcoe_transport_destroy</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">__MODULE_PARM_TYPE</span><span class="p">(</span><span class="n">destroy</span><span class="p">,</span> <span class="s">&quot;string&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">destroy</span><span class="p">,</span> <span class="s">&quot; Destroys fcoe instance on a ethernet interface&quot;</span><span class="p">);</span>

<span class="n">module_param_call</span><span class="p">(</span><span class="n">enable</span><span class="p">,</span> <span class="n">fcoe_transport_enable</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">__MODULE_PARM_TYPE</span><span class="p">(</span><span class="n">enable</span><span class="p">,</span> <span class="s">&quot;string&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">enable</span><span class="p">,</span> <span class="s">&quot; Enables fcoe on a ethernet interface.&quot;</span><span class="p">);</span>

<span class="n">module_param_call</span><span class="p">(</span><span class="n">disable</span><span class="p">,</span> <span class="n">fcoe_transport_disable</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">__MODULE_PARM_TYPE</span><span class="p">(</span><span class="n">disable</span><span class="p">,</span> <span class="s">&quot;string&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">disable</span><span class="p">,</span> <span class="s">&quot; Disables fcoe on a ethernet interface.&quot;</span><span class="p">);</span>

<span class="cm">/* notification function for packets from net device */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">libfcoe_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">libfcoe_device_notification</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">__fcoe_get_lesb</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">fc_els_lesb</span> <span class="o">*</span><span class="n">fc_lesb</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">lfc</span><span class="p">,</span> <span class="n">vlfc</span><span class="p">,</span> <span class="n">mdac</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_dev_stats</span> <span class="o">*</span><span class="n">devst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_fc_els_lesb</span> <span class="o">*</span><span class="n">lesb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">lfc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vlfc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mdac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lesb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_fc_els_lesb</span> <span class="o">*</span><span class="p">)</span><span class="n">fc_lesb</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">lesb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lesb</span><span class="p">));</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">devst</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">dev_stats</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">lfc</span> <span class="o">+=</span> <span class="n">devst</span><span class="o">-&gt;</span><span class="n">LinkFailureCount</span><span class="p">;</span>
		<span class="n">vlfc</span> <span class="o">+=</span> <span class="n">devst</span><span class="o">-&gt;</span><span class="n">VLinkFailureCount</span><span class="p">;</span>
		<span class="n">mdac</span> <span class="o">+=</span> <span class="n">devst</span><span class="o">-&gt;</span><span class="n">MissDiscAdvCount</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lesb</span><span class="o">-&gt;</span><span class="n">lesb_link_fail</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">lfc</span><span class="p">);</span>
	<span class="n">lesb</span><span class="o">-&gt;</span><span class="n">lesb_vlink_fail</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">vlfc</span><span class="p">);</span>
	<span class="n">lesb</span><span class="o">-&gt;</span><span class="n">lesb_miss_fka</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">mdac</span><span class="p">);</span>
	<span class="n">lesb</span><span class="o">-&gt;</span><span class="n">lesb_fcs_error</span> <span class="o">=</span>
			<span class="n">htonl</span><span class="p">(</span><span class="n">dev_get_stats</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rx_crc_errors</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__fcoe_get_lesb</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">fcoe_wwn_to_str</span><span class="p">(</span><span class="n">u64</span> <span class="n">wwn</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">wwpn</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="n">u64_to_wwn</span><span class="p">(</span><span class="n">wwn</span><span class="p">,</span> <span class="n">wwpn</span><span class="p">);</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%02x%02x%02x%02x%02x%02x%02x%02x&quot;</span><span class="p">,</span>
		 <span class="n">wwpn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wwpn</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">wwpn</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">wwpn</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
		 <span class="n">wwpn</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">wwpn</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">wwpn</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">wwpn</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fcoe_wwn_to_str</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_validate_vport_create() - Validate a vport before creating it</span>
<span class="cm"> * @vport: NPIV port to be created</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is meant to add validation for a vport before creating it</span>
<span class="cm"> * via fcoe_vport_create().</span>
<span class="cm"> * Current validations are:</span>
<span class="cm"> *      - WWPN supplied is unique for given lport</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcoe_validate_vport_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">vport_to_shost</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">n_port</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">vn_port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_port</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>

	<span class="n">fcoe_wwn_to_str</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
	<span class="cm">/* Check if the wwpn is not same as that of the lport */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_port</span><span class="o">-&gt;</span><span class="n">wwpn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;vport WWPN 0x%s is same as that of the &quot;</span>
				      <span class="s">&quot;base port WWPN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if there is any existing vport with same wwpn */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vn_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n_port</span><span class="o">-&gt;</span><span class="n">vports</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn_port</span><span class="o">-&gt;</span><span class="n">wwpn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;vport with given WWPN 0x%s &quot;</span>
					      <span class="s">&quot;already exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_port</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fcoe_validate_vport_create</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_get_wwn() - Get the world wide name from LLD if it supports it</span>
<span class="cm"> * @netdev: the associated net device</span>
<span class="cm"> * @wwn: the output WWN</span>
<span class="cm"> * @type: the type of WWN (WWPN or WWNN)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcoe_get_wwn</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">wwn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_fcoe_get_wwn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_fcoe_get_wwn</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">wwn</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fcoe_get_wwn</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_fc_crc() - Calculates the CRC for a given frame</span>
<span class="cm"> * @fp: The frame to be checksumed</span>
<span class="cm"> *</span>
<span class="cm"> * This uses crc32() routine to calculate the CRC for a frame</span>
<span class="cm"> *</span>
<span class="cm"> * Return: The 32 bit CRC value</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">fcoe_fc_crc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">fp_skb</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">clen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">crc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">off</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">off</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">));</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span>
				<span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
			<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">crc</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="p">(</span><span class="n">off</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">),</span> <span class="n">clen</span><span class="p">);</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
			<span class="n">off</span> <span class="o">+=</span> <span class="n">clen</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">clen</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">crc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fcoe_fc_crc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_start_io() - Start FCoE I/O</span>
<span class="cm"> * @skb: The packet to be transmitted</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called from the net device to start transmitting</span>
<span class="cm"> * FCoE packets.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcoe_start_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">nskb</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nskb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dev_queue_xmit</span><span class="p">(</span><span class="n">nskb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fcoe_start_io</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * fcoe_clean_pending_queue() - Dequeue a skb and free it</span>
<span class="cm"> * @lport: The local port to dequeue a skb on</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fcoe_clean_pending_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span>  <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fcoe_clean_pending_queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_check_wait_queue() - Attempt to clear the transmit backlog</span>
<span class="cm"> * @lport: The local port whose backlog is to be cleared</span>
<span class="cm"> *</span>
<span class="cm"> * This empties the wait_queue, dequeues the head of the wait_queue queue</span>
<span class="cm"> * and calls fcoe_start_io() for each packet. If all skb have been</span>
<span class="cm"> * transmitted it returns the qlen. If an error occurs it restores</span>
<span class="cm"> * wait_queue (to try again later) and returns -1.</span>
<span class="cm"> *</span>
<span class="cm"> * The wait_queue is used when the skb transmit fails. The failed skb</span>
<span class="cm"> * will go in the wait_queue which will be emptied by the timer function or</span>
<span class="cm"> * by the next skb transmit.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fcoe_check_wait_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue_active</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">qlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* keep qlen &gt; 0 until fcoe_start_io succeeds */</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">qlen</span><span class="o">++</span><span class="p">;</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">);</span>

		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_start_io</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="cm">/* undo temporary increment above */</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">qlen</span><span class="o">--</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* undo temporary increment above */</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">qlen</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">qlen</span> <span class="o">&lt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">min_queue_depth</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">qfull</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">qlen</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">))</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">qlen</span> <span class="o">&gt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">max_queue_depth</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">qfull</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">fcoe_pending_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fcoe_check_wait_queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_queue_timer() - The fcoe queue timer</span>
<span class="cm"> * @lport: The local port</span>
<span class="cm"> *</span>
<span class="cm"> * Calls fcoe_check_wait_queue on timeout</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fcoe_queue_timer</span><span class="p">(</span><span class="n">ulong</span> <span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fcoe_check_wait_queue</span><span class="p">((</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">)</span><span class="n">lport</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fcoe_queue_timer</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_get_paged_crc_eof() - Allocate a page to be used for the trailer CRC</span>
<span class="cm"> * @skb:  The packet to be transmitted</span>
<span class="cm"> * @tlen: The total length of the trailer</span>
<span class="cm"> * @fps:  The fcoe context</span>
<span class="cm"> *</span>
<span class="cm"> * This routine allocates a page for frame trailers. The page is re-used if</span>
<span class="cm"> * there is enough room left on it for the current trailer. If there isn&#39;t</span>
<span class="cm"> * enough buffer left a new page is allocated for the trailer. Reference to</span>
<span class="cm"> * the page from this function as well as the skbs using the page fragments</span>
<span class="cm"> * ensure that the page is freed at the appropriate time.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcoe_get_paged_crc_eof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tlen</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">fcoe_percpu_s</span> <span class="o">*</span><span class="n">fps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">fps</span><span class="o">-&gt;</span><span class="n">crc_eof_page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">fps</span><span class="o">-&gt;</span><span class="n">crc_eof_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">fps</span><span class="o">-&gt;</span><span class="n">crc_eof_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
			   <span class="n">fps</span><span class="o">-&gt;</span><span class="n">crc_eof_offset</span><span class="p">,</span> <span class="n">tlen</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">tlen</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">tlen</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">tlen</span><span class="p">;</span>
	<span class="n">fps</span><span class="o">-&gt;</span><span class="n">crc_eof_offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_crc_eof</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fps</span><span class="o">-&gt;</span><span class="n">crc_eof_offset</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fps</span><span class="o">-&gt;</span><span class="n">crc_eof_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">fps</span><span class="o">-&gt;</span><span class="n">crc_eof_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fcoe_get_paged_crc_eof</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_transport_lookup - find an fcoe transport that matches a netdev</span>
<span class="cm"> * @netdev: The netdev to look for from all attached transports</span>
<span class="cm"> *</span>
<span class="cm"> * Returns : ptr to the fcoe transport that supports this netdev or NULL</span>
<span class="cm"> * if not found.</span>
<span class="cm"> *</span>
<span class="cm"> * The ft_mutex should be held when this is called</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="nf">fcoe_transport_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">ft</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ft</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_transports</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ft</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">&amp;&amp;</span> <span class="n">ft</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ft</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_transport_attach - Attaches an FCoE transport</span>
<span class="cm"> * @ft: The fcoe transport to be attached</span>
<span class="cm"> *</span>
<span class="cm"> * Returns : 0 for success</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcoe_transport_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">ft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ft</span><span class="o">-&gt;</span><span class="n">attached</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;transport %s already attached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">ft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_attach</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Add default transport to the tail */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">ft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">FCOE_TRANSPORT_DEFAULT</span><span class="p">))</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_transports</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_transports</span><span class="p">);</span>

	<span class="n">ft</span><span class="o">-&gt;</span><span class="n">attached</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;attaching transport %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

<span class="nl">out_attach:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fcoe_transport_attach</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_transport_detach - Detaches an FCoE transport</span>
<span class="cm"> * @ft: The fcoe transport to be attached</span>
<span class="cm"> *</span>
<span class="cm"> * Returns : 0 for success</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcoe_transport_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">ft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_netdev_mapping</span> <span class="o">*</span><span class="n">nm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ft</span><span class="o">-&gt;</span><span class="n">attached</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;transport %s already detached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_attach</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* remove netdev mapping for this transport as it is going away */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fn_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_netdevs</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nm</span><span class="o">-&gt;</span><span class="n">ft</span> <span class="o">==</span> <span class="n">ft</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;transport %s going away, &quot;</span>
				<span class="s">&quot;remove its netdev mapping for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nm</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">nm</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fn_mutex</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">ft</span><span class="o">-&gt;</span><span class="n">attached</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;detaching transport %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

<span class="nl">out_attach:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fcoe_transport_detach</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_transport_show</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">ft</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;Attached FCoE transports:&quot;</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ft</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_transports</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">IFNAMSIZ</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">IFNAMSIZ</span><span class="p">,</span> <span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">ft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">IFNAMSIZ</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">fcoe_transport_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">register_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">libfcoe_notifier</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="nf">fcoe_transport_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">ft</span><span class="p">;</span>

	<span class="n">unregister_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">libfcoe_notifier</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ft</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_transports</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;FCoE transport %s is still attached!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">ft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_add_netdev_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">ft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_netdev_mapping</span> <span class="o">*</span><span class="n">nm</span><span class="p">;</span>

	<span class="n">nm</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nm</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to allocate netdev_mapping&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nm</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>
	<span class="n">nm</span><span class="o">-&gt;</span><span class="n">ft</span> <span class="o">=</span> <span class="n">ft</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fn_mutex</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nm</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_netdevs</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fn_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcoe_del_netdev_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_netdev_mapping</span> <span class="o">*</span><span class="n">nm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fn_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_netdevs</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nm</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">==</span> <span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nm</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">nm</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fn_mutex</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fn_mutex</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fcoe_netdev_map_lookup - find the fcoe transport that matches the netdev on which</span>
<span class="cm"> * it was created</span>
<span class="cm"> *</span>
<span class="cm"> * Returns : ptr to the fcoe transport that supports this netdev or NULL</span>
<span class="cm"> * if not found.</span>
<span class="cm"> *</span>
<span class="cm"> * The ft_mutex should be held when this is called</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="nf">fcoe_netdev_map_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">ft</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_netdev_mapping</span> <span class="o">*</span><span class="n">nm</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fn_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_netdevs</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span> <span class="o">==</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ft</span> <span class="o">=</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">ft</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fn_mutex</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ft</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fn_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_if_to_netdev() - Parse a name buffer to get a net device</span>
<span class="cm"> * @buffer: The name of the net device</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: NULL or a ptr to net_device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">fcoe_if_to_netdev</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">ifname</span><span class="p">[</span><span class="n">IFNAMSIZ</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">ifname</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">ifname</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">ifname</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">cp</span> <span class="o">&gt;=</span> <span class="n">ifname</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">cp</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
			<span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">dev_get_by_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">ifname</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * libfcoe_device_notification() - Handler for net device events</span>
<span class="cm"> * @notifier: The context of the notification</span>
<span class="cm"> * @event:    The type of event</span>
<span class="cm"> * @ptr:      The net device that the event was on</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the Ethernet driver in case of link change event.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">libfcoe_device_notification</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">notifier</span><span class="p">,</span>
				    <span class="n">ulong</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NETDEV_UNREGISTER</span>:
		<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;NETDEV_UNREGISTER %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">fcoe_del_netdev_mapping</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fcoe_transport_create() - Create a fcoe interface</span>
<span class="cm"> * @buffer: The name of the Ethernet interface to create on</span>
<span class="cm"> * @kp:	    The associated kernel param</span>
<span class="cm"> *</span>
<span class="cm"> * Called from sysfs. This holds the ft_mutex while calling the</span>
<span class="cm"> * registered fcoe transport&#39;s create function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_transport_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">ft</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fip_state</span> <span class="n">fip_mode</span> <span class="o">=</span> <span class="p">(</span><span class="k">enum</span> <span class="n">fip_state</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>

	<span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe_if_to_netdev</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;Invalid device %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_nodev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ft</span> <span class="o">=</span> <span class="n">fcoe_netdev_map_lookup</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ft</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;transport %s already has existing &quot;</span>
				      <span class="s">&quot;FCoE instance on %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">ft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_putdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ft</span> <span class="o">=</span> <span class="n">fcoe_transport_lookup</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ft</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;no FCoE transport found for %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_putdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_add_netdev_mapping</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">ft</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;failed to add new netdev mapping &quot;</span>
				      <span class="s">&quot;for FCoE transport %s for %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">ft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_putdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* pass to transport create */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ft</span><span class="o">-&gt;</span><span class="n">create</span> <span class="o">?</span> <span class="n">ft</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">fip_mode</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">fcoe_del_netdev_mapping</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;transport %s %s to create fcoe on %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">ft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;failed&quot;</span> <span class="o">:</span> <span class="s">&quot;succeeded&quot;</span><span class="p">,</span>
			      <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

<span class="nl">out_putdev:</span>
	<span class="n">dev_put</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="nl">out_nodev:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_transport_destroy() - Destroy a FCoE interface</span>
<span class="cm"> * @buffer: The name of the Ethernet interface to be destroyed</span>
<span class="cm"> * @kp:	    The associated kernel parameter</span>
<span class="cm"> *</span>
<span class="cm"> * Called from sysfs. This holds the ft_mutex while calling the</span>
<span class="cm"> * registered fcoe transport&#39;s destroy function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_transport_destroy</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">ft</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>

	<span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe_if_to_netdev</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;invalid device %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_nodev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ft</span> <span class="o">=</span> <span class="n">fcoe_netdev_map_lookup</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ft</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;no FCoE transport found for %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_putdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* pass to transport destroy */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ft</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">?</span> <span class="n">ft</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">fcoe_del_netdev_mapping</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">LIBFCOE_TRANSPORT_DBG</span><span class="p">(</span><span class="s">&quot;transport %s %s to destroy fcoe on %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">ft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;failed&quot;</span> <span class="o">:</span> <span class="s">&quot;succeeded&quot;</span><span class="p">,</span>
			      <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

<span class="nl">out_putdev:</span>
	<span class="n">dev_put</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="nl">out_nodev:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_transport_disable() - Disables a FCoE interface</span>
<span class="cm"> * @buffer: The name of the Ethernet interface to be disabled</span>
<span class="cm"> * @kp:	    The associated kernel parameter</span>
<span class="cm"> *</span>
<span class="cm"> * Called from sysfs.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_transport_disable</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">ft</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>

	<span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe_if_to_netdev</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nodev</span><span class="p">;</span>

	<span class="n">ft</span> <span class="o">=</span> <span class="n">fcoe_netdev_map_lookup</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ft</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_putdev</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ft</span><span class="o">-&gt;</span><span class="n">disable</span> <span class="o">?</span> <span class="n">ft</span><span class="o">-&gt;</span><span class="n">disable</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

<span class="nl">out_putdev:</span>
	<span class="n">dev_put</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="nl">out_nodev:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">restart_syscall</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_transport_enable() - Enables a FCoE interface</span>
<span class="cm"> * @buffer: The name of the Ethernet interface to be enabled</span>
<span class="cm"> * @kp:     The associated kernel parameter</span>
<span class="cm"> *</span>
<span class="cm"> * Called from sysfs.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 for success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fcoe_transport_enable</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">ft</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>

	<span class="n">netdev</span> <span class="o">=</span> <span class="n">fcoe_if_to_netdev</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nodev</span><span class="p">;</span>

	<span class="n">ft</span> <span class="o">=</span> <span class="n">fcoe_netdev_map_lookup</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ft</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_putdev</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ft</span><span class="o">-&gt;</span><span class="n">enable</span> <span class="o">?</span> <span class="n">ft</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

<span class="nl">out_putdev:</span>
	<span class="n">dev_put</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="nl">out_nodev:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * libfcoe_init() - Initialization routine for libfcoe.ko</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">libfcoe_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_transport_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fcoe_sysfs_setup</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">fcoe_transport_exit</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">libfcoe_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * libfcoe_exit() - Tear down libfcoe.ko</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">libfcoe_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fcoe_sysfs_teardown</span><span class="p">();</span>
	<span class="n">fcoe_transport_exit</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">libfcoe_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
