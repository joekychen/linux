<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › scsi_proc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>scsi_proc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/drivers/scsi/scsi_proc.c</span>
<span class="cm"> *</span>
<span class="cm"> * The functions in this file provide an interface between</span>
<span class="cm"> * the PROC file system and the SCSI device drivers</span>
<span class="cm"> * It is mainly used for debugging, statistics and to pass </span>
<span class="cm"> * information directly to the lowlevel driver.</span>
<span class="cm"> *</span>
<span class="cm"> * (c) 1995 Michael Neuffer neuffer@goofy.zdv.uni-mainz.de </span>
<span class="cm"> * Version: 0.99.8   last change: 95/09/13</span>
<span class="cm"> * </span>
<span class="cm"> * generic command parser provided by: </span>
<span class="cm"> * Andreas Heilwagen &lt;crashcar@informatik.uni-koblenz.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * generic_proc_info() support of xxxx_info() by:</span>
<span class="cm"> * Michael A. Griffith &lt;grif@acm.org&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport.h&gt;</span>

<span class="cp">#include &quot;scsi_priv.h&quot;</span>
<span class="cp">#include &quot;scsi_logging.h&quot;</span>


<span class="cm">/* 4K page size, but our output routines, use some slack for overruns */</span>
<span class="cp">#define PROC_BLOCK_SIZE (3*1024)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_scsi</span><span class="p">;</span>

<span class="cm">/* Protect sht-&gt;present and sht-&gt;proc_dir */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">global_host_template_mutex</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * proc_scsi_read - handle read from /proc by calling host&#39;s proc_info() command</span>
<span class="cm"> * @buffer: passed to proc_info</span>
<span class="cm"> * @start: passed to proc_info</span>
<span class="cm"> * @offset: passed to proc_info</span>
<span class="cm"> * @length: passed to proc_info</span>
<span class="cm"> * @eof: returns whether length read was less than requested</span>
<span class="cm"> * @data: pointer to a &amp;struct Scsi_Host</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_scsi_read</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">proc_info</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * proc_scsi_write_proc - Handle write to /proc by calling host&#39;s proc_info()</span>
<span class="cm"> * @file: not used</span>
<span class="cm"> * @buf: source of data to write.</span>
<span class="cm"> * @count: number of bytes (at most PROC_BLOCK_SIZE) to write.</span>
<span class="cm"> * @data: pointer to &amp;struct Scsi_Host</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_scsi_write_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
                           <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
    
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">PROC_BLOCK_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">proc_info</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_proc_hostdir_add - Create directory in /proc for a scsi host</span>
<span class="cm"> * @sht: owner of this directory</span>
<span class="cm"> *</span>
<span class="cm"> * Sets sht-&gt;proc_dir to the new directory.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">scsi_proc_hostdir_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sht</span><span class="o">-&gt;</span><span class="n">proc_info</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_host_template_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sht</span><span class="o">-&gt;</span><span class="n">present</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sht</span><span class="o">-&gt;</span><span class="n">proc_dir</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="n">sht</span><span class="o">-&gt;</span><span class="n">proc_name</span><span class="p">,</span> <span class="n">proc_scsi</span><span class="p">);</span>
        	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sht</span><span class="o">-&gt;</span><span class="n">proc_dir</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: proc_mkdir failed for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">sht</span><span class="o">-&gt;</span><span class="n">proc_name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_host_template_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_proc_hostdir_rm - remove directory in /proc for a scsi host</span>
<span class="cm"> * @sht: owner of directory</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_proc_hostdir_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sht</span><span class="o">-&gt;</span><span class="n">proc_info</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_host_template_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">sht</span><span class="o">-&gt;</span><span class="n">present</span> <span class="o">&amp;&amp;</span> <span class="n">sht</span><span class="o">-&gt;</span><span class="n">proc_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="n">sht</span><span class="o">-&gt;</span><span class="n">proc_name</span><span class="p">,</span> <span class="n">proc_scsi</span><span class="p">);</span>
		<span class="n">sht</span><span class="o">-&gt;</span><span class="n">proc_dir</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_host_template_mutex</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * scsi_proc_host_add - Add entry for this host to appropriate /proc dir</span>
<span class="cm"> * @shost: host to add</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_proc_host_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sht</span><span class="o">-&gt;</span><span class="n">proc_dir</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">create_proc_read_entry</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
			<span class="n">sht</span><span class="o">-&gt;</span><span class="n">proc_dir</span><span class="p">,</span> <span class="n">proc_scsi_read</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Failed to register host %d in&quot;</span>
		       <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span>
		       <span class="n">sht</span><span class="o">-&gt;</span><span class="n">proc_name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> 

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">write_proc</span> <span class="o">=</span> <span class="n">proc_scsi_write_proc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_proc_host_rm - remove this host&#39;s entry from /proc</span>
<span class="cm"> * @shost: which host</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_proc_host_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">proc_dir</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">proc_dir</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * proc_print_scsidevice - return data about this host</span>
<span class="cm"> * @dev: A scsi device</span>
<span class="cm"> * @data: &amp;struct seq_file to output to.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: prints Host, Channel, Id, Lun, Vendor, Model, Rev, Type,</span>
<span class="cm"> * and revision.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_print_scsidevice</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_is_sdev_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
		<span class="s">&quot;Host: scsi%d Channel: %02d Id: %02d Lun: %02d</span><span class="se">\n</span><span class="s">  Vendor: &quot;</span><span class="p">,</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; Model: &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; Rev: &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;  Type:   %s &quot;</span><span class="p">,</span> <span class="n">scsi_device_type</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;               ANSI  SCSI revision: %02x&quot;</span><span class="p">,</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">-</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; CCS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_add_single_device - Respond to user request to probe for/add device</span>
<span class="cm"> * @host: user-supplied decimal integer</span>
<span class="cm"> * @channel: user-supplied decimal integer</span>
<span class="cm"> * @id: user-supplied decimal integer</span>
<span class="cm"> * @lun: user-supplied decimal integer</span>
<span class="cm"> *</span>
<span class="cm"> * Description: called by writing &quot;scsi add-single-device&quot; to /proc/scsi/scsi.</span>
<span class="cm"> *</span>
<span class="cm"> * does scsi_host_lookup() and either user_scan() if that transport</span>
<span class="cm"> * type supports it, or else scsi_scan_host_selected()</span>
<span class="cm"> *</span>
<span class="cm"> * Note: this seems to be aimed exclusively at SCSI parallel busses.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scsi_add_single_device</span><span class="p">(</span><span class="n">uint</span> <span class="n">host</span><span class="p">,</span> <span class="n">uint</span> <span class="n">channel</span><span class="p">,</span> <span class="n">uint</span> <span class="n">id</span><span class="p">,</span> <span class="n">uint</span> <span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_lookup</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="o">-&gt;</span><span class="n">user_scan</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="o">-&gt;</span><span class="n">user_scan</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_scan_host_selected</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_remove_single_device - Respond to user request to remove a device</span>
<span class="cm"> * @host: user-supplied decimal integer</span>
<span class="cm"> * @channel: user-supplied decimal integer</span>
<span class="cm"> * @id: user-supplied decimal integer</span>
<span class="cm"> * @lun: user-supplied decimal integer</span>
<span class="cm"> *</span>
<span class="cm"> * Description: called by writing &quot;scsi remove-single-device&quot; to</span>
<span class="cm"> * /proc/scsi/scsi.  Does a scsi_device_lookup() and scsi_remove_device()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scsi_remove_single_device</span><span class="p">(</span><span class="n">uint</span> <span class="n">host</span><span class="p">,</span> <span class="n">uint</span> <span class="n">channel</span><span class="p">,</span> <span class="n">uint</span> <span class="n">id</span><span class="p">,</span> <span class="n">uint</span> <span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_lookup</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">sdev</span> <span class="o">=</span> <span class="n">scsi_device_lookup</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
		<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * proc_scsi_write - handle writes to /proc/scsi/scsi</span>
<span class="cm"> * @file: not used</span>
<span class="cm"> * @buf: buffer to write</span>
<span class="cm"> * @length: length of buf, at most PAGE_SIZE</span>
<span class="cm"> * @ppos: not used</span>
<span class="cm"> *</span>
<span class="cm"> * Description: this provides a legacy mechanism to add or remove devices by</span>
<span class="cm"> * Host, Channel, ID, and Lun.  To use,</span>
<span class="cm"> * &quot;echo &#39;scsi add-single-device 0 1 2 3&#39; &gt; /proc/scsi/scsi&quot; or</span>
<span class="cm"> * &quot;echo &#39;scsi remove-single-device 0 1 2 3&#39; &gt; /proc/scsi/scsi&quot; with</span>
<span class="cm"> * &quot;0 1 2 3&quot; replaced by the Host, Channel, Id, and Lun.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: this seems to be aimed at parallel SCSI. Most modern busses (USB,</span>
<span class="cm"> * SATA, Firewire, Fibre Channel, etc) dynamically assign these values to</span>
<span class="cm"> * provide a unique identifier and nothing more.</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">proc_scsi_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">host</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Usage: echo &quot;scsi add-single-device 0 1 2 3&quot; &gt;/proc/scsi/scsi</span>
<span class="cm">	 * with  &quot;0 1 2 3&quot; replaced by your &quot;Host Channel Id Lun&quot;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="s">&quot;scsi add-single-device&quot;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">22</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="mi">23</span><span class="p">;</span>

		<span class="n">host</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">lun</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">scsi_add_single_device</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Usage: echo &quot;scsi remove-single-device 0 1 2 3&quot; &gt;/proc/scsi/scsi</span>
<span class="cm">	 * with  &quot;0 1 2 3&quot; replaced by your &quot;Host Channel Id Lun&quot;.</span>
<span class="cm">	 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="s">&quot;scsi remove-single-device&quot;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">25</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="mi">26</span><span class="p">;</span>

		<span class="n">host</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">lun</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">scsi_remove_single_device</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * convert success returns so that we return the </span>
<span class="cm">	 * number of bytes consumed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>

 <span class="nl">out:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">always_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">next_scsi_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">bus_find_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scsi_bus_type</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					      <span class="n">always_match</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">scsi_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sfile</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">dev</span> <span class="o">=</span> <span class="n">next_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="o">--</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">sfile</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">scsi_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sfile</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="n">sfile</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">next_scsi_device</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sfile</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scsi_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sfile</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sfile</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">sfile</span><span class="p">,</span> <span class="s">&quot;Attached devices:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">proc_print_scsidevice</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sfile</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">scsi_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">scsi_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>	<span class="o">=</span> <span class="n">scsi_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>	<span class="o">=</span> <span class="n">scsi_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">scsi_seq_show</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * proc_scsi_open - glue function</span>
<span class="cm"> * @inode: not used</span>
<span class="cm"> * @file: passed to single_open()</span>
<span class="cm"> *</span>
<span class="cm"> * Associates proc_scsi_show with this file</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_scsi_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t really need this for the write case but it doesn&#39;t</span>
<span class="cm">	 * harm either.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scsi_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_scsi_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">proc_scsi_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">proc_scsi_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_init_procfs - create scsi and scsi/scsi in procfs</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">scsi_init_procfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">pde</span><span class="p">;</span>

	<span class="n">proc_scsi</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="s">&quot;scsi&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_scsi</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err1</span><span class="p">;</span>

	<span class="n">pde</span> <span class="o">=</span> <span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;scsi/scsi&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_scsi_operations</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pde</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err2</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err2:</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;scsi&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">err1:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_exit_procfs - Remove scsi/scsi and scsi from procfs</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_exit_procfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;scsi/scsi&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;scsi&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
