<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › scsi_lib.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>scsi_lib.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  scsi_lib.c Copyright (C) 1999 Eric Youngdale</span>
<span class="cm"> *</span>
<span class="cm"> *  SCSI queueing library.</span>
<span class="cm"> *      Initial versions: Eric Youngdale (eric@andante.org).</span>
<span class="cm"> *                        Based upon conversations with large numbers</span>
<span class="cm"> *                        of people at Linux Expo.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_dbg.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_driver.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>

<span class="cp">#include &quot;scsi_priv.h&quot;</span>
<span class="cp">#include &quot;scsi_logging.h&quot;</span>


<span class="cp">#define SG_MEMPOOL_NR		ARRAY_SIZE(scsi_sg_pools)</span>
<span class="cp">#define SG_MEMPOOL_SIZE		2</span>

<span class="k">struct</span> <span class="n">scsi_host_sg_pool</span> <span class="p">{</span>
	<span class="kt">size_t</span>		<span class="n">size</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span>	<span class="o">*</span><span class="n">slab</span><span class="p">;</span>
	<span class="n">mempool_t</span>	<span class="o">*</span><span class="n">pool</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define SP(x) { x, &quot;sgpool-&quot; __stringify(x) }</span>
<span class="cp">#if (SCSI_MAX_SG_SEGMENTS &lt; 32)</span>
<span class="cp">#error SCSI_MAX_SG_SEGMENTS is too small (must be 32 or greater)</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_sg_pool</span> <span class="n">scsi_sg_pools</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SP</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
	<span class="n">SP</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span>
<span class="cp">#if (SCSI_MAX_SG_SEGMENTS &gt; 32)</span>
	<span class="n">SP</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
<span class="cp">#if (SCSI_MAX_SG_SEGMENTS &gt; 64)</span>
	<span class="n">SP</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
<span class="cp">#if (SCSI_MAX_SG_SEGMENTS &gt; 128)</span>
	<span class="n">SP</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span>
<span class="cp">#if (SCSI_MAX_SG_SEGMENTS &gt; 256)</span>
<span class="cp">#error SCSI_MAX_SG_SEGMENTS is too large (256 MAX)</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
	<span class="n">SP</span><span class="p">(</span><span class="n">SCSI_MAX_SG_SEGMENTS</span><span class="p">)</span>
<span class="p">};</span>
<span class="cp">#undef SP</span>

<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">scsi_sdb_cache</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * When to reinvoke queueing after a resource shortage. It&#39;s 3 msecs to</span>
<span class="cm"> * not change behaviour from the previous unplug mechanism, experimentation</span>
<span class="cm"> * may prove this needs changing.</span>
<span class="cm"> */</span>
<span class="cp">#define SCSI_QUEUE_DELAY	3</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	scsi_unprep_request()</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose:	Remove all preparation done for a request, including its</span>
<span class="cm"> *		associated scsi_cmnd, so that it can be requeued.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:	req	- request to unprepare</span>
<span class="cm"> *</span>
<span class="cm"> * Lock status:	Assumed that no locks are held upon entry.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:	Nothing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_unprep_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">;</span>

	<span class="n">blk_unprep_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">special</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">scsi_put_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __scsi_queue_insert - private queue insertion</span>
<span class="cm"> * @cmd: The SCSI command being requeued</span>
<span class="cm"> * @reason:  The reason for the requeue</span>
<span class="cm"> * @unbusy: Whether the queue should be unbusied</span>
<span class="cm"> *</span>
<span class="cm"> * This is a private queue insertion.  The public interface</span>
<span class="cm"> * scsi_queue_insert() always assumes the queue should be unbusied</span>
<span class="cm"> * because it&#39;s always called before the completion.  This function is</span>
<span class="cm"> * for a requeue after completion, which should only occur in this</span>
<span class="cm"> * file.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__scsi_queue_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unbusy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">scsi_target</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">SCSI_LOG_MLQUEUE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
		 <span class="n">printk</span><span class="p">(</span><span class="s">&quot;Inserting command %p into mlqueue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the appropriate busy bit for the device/host.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the host/device isn&#39;t busy, assume that something actually</span>
<span class="cm">	 * completed, and that we should be able to queue a command now.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that the prior mid-layer assumption that any host could</span>
<span class="cm">	 * always queue at least one command is now broken.  The mid-layer</span>
<span class="cm">	 * will implement a user specifiable stall (see</span>
<span class="cm">	 * scsi_host.max_host_blocked and scsi_device.max_device_blocked)</span>
<span class="cm">	 * if a command is requeued with no other commands outstanding</span>
<span class="cm">	 * either for the device or for the host.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span>:
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">host_blocked</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">max_host_blocked</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCSI_MLQUEUE_DEVICE_BUSY</span>:
	<span class="k">case</span> <span class="n">SCSI_MLQUEUE_EH_RETRY</span>:
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">device_blocked</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">max_device_blocked</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCSI_MLQUEUE_TARGET_BUSY</span>:
		<span class="n">starget</span><span class="o">-&gt;</span><span class="n">target_blocked</span> <span class="o">=</span> <span class="n">starget</span><span class="o">-&gt;</span><span class="n">max_target_blocked</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Decrement the counters, since these commands are no longer</span>
<span class="cm">	 * active on the host/device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unbusy</span><span class="p">)</span>
		<span class="n">scsi_device_unbusy</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Requeue this command.  It will go before all other commands</span>
<span class="cm">	 * that are already in the queue.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">blk_requeue_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">kblockd_schedule_work</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">requeue_work</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:    scsi_queue_insert()</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose:     Insert a command in the midlevel queue.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:   cmd    - command that we are adding to queue.</span>
<span class="cm"> *              reason - why we are inserting command to queue.</span>
<span class="cm"> *</span>
<span class="cm"> * Lock status: Assumed that lock is not held upon entry.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:     Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:       We do this for one of two cases.  Either the host is busy</span>
<span class="cm"> *              and it cannot accept any more commands for the time being,</span>
<span class="cm"> *              or the device returned QUEUE_FULL and can accept no more</span>
<span class="cm"> *              commands.</span>
<span class="cm"> * Notes:       This could be called either from an interrupt context or a</span>
<span class="cm"> *              normal process context.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">scsi_queue_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__scsi_queue_insert</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * scsi_execute - insert request and wait for the result</span>
<span class="cm"> * @sdev:	scsi device</span>
<span class="cm"> * @cmd:	scsi command</span>
<span class="cm"> * @data_direction: data direction</span>
<span class="cm"> * @buffer:	data buffer</span>
<span class="cm"> * @bufflen:	len of buffer</span>
<span class="cm"> * @sense:	optional sense buffer</span>
<span class="cm"> * @timeout:	request timeout in seconds</span>
<span class="cm"> * @retries:	number of times to retry request</span>
<span class="cm"> * @flags:	or into request flags;</span>
<span class="cm"> * @resid:	optional residual length</span>
<span class="cm"> *</span>
<span class="cm"> * returns the req-&gt;errors value which is the scsi_cmnd result</span>
<span class="cm"> * field.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">scsi_execute</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">data_direction</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">bufflen</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sense</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">retries</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="o">*</span><span class="n">resid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">DRIVER_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">blk_get_request</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">__GFP_WAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bufflen</span> <span class="o">&amp;&amp;</span>	<span class="n">blk_rq_map_kern</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span>
					<span class="n">buffer</span><span class="p">,</span> <span class="n">bufflen</span><span class="p">,</span> <span class="n">__GFP_WAIT</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="n">COMMAND_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">sense</span> <span class="o">=</span> <span class="n">sense</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">sense_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">=</span> <span class="n">retries</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_BLOCK_PC</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">|=</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">REQ_QUIET</span> <span class="o">|</span> <span class="n">REQ_PREEMPT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * head injection *required* here otherwise quiesce won&#39;t work</span>
<span class="cm">	 */</span>
	<span class="n">blk_execute_rq</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some devices (USB mass-storage in particular) may transfer</span>
<span class="cm">	 * garbage data together with a residue indicating that the data</span>
<span class="cm">	 * is invalid.  Prevent the garbage from being misinterpreted</span>
<span class="cm">	 * and prevent security leaks by zeroing out the excess data.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">resid_len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">resid_len</span> <span class="o">&lt;=</span> <span class="n">bufflen</span><span class="p">))</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="p">(</span><span class="n">bufflen</span> <span class="o">-</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">resid_len</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">resid_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">resid</span><span class="p">)</span>
		<span class="o">*</span><span class="n">resid</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">resid_len</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">errors</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">blk_put_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_execute</span><span class="p">);</span>


<span class="kt">int</span> <span class="nf">scsi_execute_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">data_direction</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">bufflen</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="n">sshdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">retries</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="o">*</span><span class="n">resid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sense</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sense</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sense</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">DRIVER_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">scsi_execute</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">data_direction</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">bufflen</span><span class="p">,</span>
			      <span class="n">sense</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">retries</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">resid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">)</span>
		<span class="n">scsi_normalize_sense</span><span class="p">(</span><span class="n">sense</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="n">sshdr</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">sense</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_execute_req</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function:    scsi_init_cmd_errh()</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose:     Initialize cmd fields related to error handling.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:   cmd	- command that is ready to be queued.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:       This function has the job of initializing a number of</span>
<span class="cm"> *              fields related to error handling.   Typically this will</span>
<span class="cm"> *              be called once for each command, as required.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_init_cmd_errh</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">serial_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="n">scsi_command_size</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">scsi_device_unbusy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">scsi_target</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_busy</span><span class="o">--</span><span class="p">;</span>
	<span class="n">starget</span><span class="o">-&gt;</span><span class="n">target_busy</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scsi_host_in_recovery</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_failed</span> <span class="o">||</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_eh_scheduled</span><span class="p">)))</span>
		<span class="n">scsi_eh_wakeup</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">device_busy</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called for single_lun devices on IO completion. Clear starget_sdev_user,</span>
<span class="cm"> * and call blk_run_queue for all the scsi_devices on the target -</span>
<span class="cm"> * including current_sdev first.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with *no* scsi locks held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_single_lun_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">current_sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">current_sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">scsi_target</span><span class="p">(</span><span class="n">current_sdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">starget</span><span class="o">-&gt;</span><span class="n">starget_sdev_user</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call blk_run_queue for all LUNs on the target, starting with</span>
<span class="cm">	 * current_sdev. We race with others (to set starget_sdev_user),</span>
<span class="cm">	 * but in most cases, we will be first. Ideally, each LU on the</span>
<span class="cm">	 * target would get some limited time or requests on the target.</span>
<span class="cm">	 */</span>
	<span class="n">blk_run_queue</span><span class="p">(</span><span class="n">current_sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">starget_sdev_user</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span>
			<span class="n">same_target_siblings</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span> <span class="o">==</span> <span class="n">current_sdev</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_device_get</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">blk_run_queue</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	
		<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_device_is_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">device_busy</span> <span class="o">&gt;=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span> <span class="o">||</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">device_blocked</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_target_is_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		 <span class="n">starget</span><span class="o">-&gt;</span><span class="n">target_busy</span> <span class="o">&gt;=</span> <span class="n">starget</span><span class="o">-&gt;</span><span class="n">can_queue</span><span class="p">)</span> <span class="o">||</span>
		 <span class="n">starget</span><span class="o">-&gt;</span><span class="n">target_blocked</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_host_is_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_busy</span> <span class="o">&gt;=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">can_queue</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_blocked</span> <span class="o">||</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_self_blocked</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	scsi_run_queue()</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose:	Select a proper request queue to serve next</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:	q	- last request&#39;s queue</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:     Nothing</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:	The previous command was completely finished, start</span>
<span class="cm"> *		a new one if possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_run_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">starved_list</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* if the device is dead, sdev will be NULL, so no queue to run */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sdev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">single_lun</span><span class="p">)</span>
		<span class="n">scsi_single_lun_run</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">starved_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">starved_list</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starved_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * As long as shost is accepting commands and we have</span>
<span class="cm">		 * starved queues, call blk_run_queue. scsi_request_fn</span>
<span class="cm">		 * drops the queue_lock and can add us back to the</span>
<span class="cm">		 * starved_list.</span>
<span class="cm">		 *</span>
<span class="cm">		 * host_lock protects the starved_list and starved_entry.</span>
<span class="cm">		 * scsi_request_fn must get the host_lock before checking</span>
<span class="cm">		 * or modifying starved_list or starved_entry.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_host_is_busy</span><span class="p">(</span><span class="n">shost</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">sdev</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">starved_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">scsi_device</span><span class="p">,</span> <span class="n">starved_entry</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">starved_entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_target_is_busy</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sdev</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">starved_entry</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">starved_list</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">__blk_run_queue</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* put any unprocessed entries back */</span>
	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starved_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">starved_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">blk_run_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">scsi_requeue_run_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span><span class="p">,</span> <span class="n">requeue_work</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span>
	<span class="n">scsi_run_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:	scsi_requeue_command()</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose:	Handle post-processing of completed commands.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:	q	- queue to operate on</span>
<span class="cm"> *		cmd	- command that may need to be requeued.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:	Nothing</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:	After command completion, there may be blocks left</span>
<span class="cm"> *		over which weren&#39;t finished by the previous command</span>
<span class="cm"> *		this can be for a number of reasons - the main one is</span>
<span class="cm"> *		I/O errors in the middle of the request, in which case</span>
<span class="cm"> *		we need to request the blocks that come after the bad</span>
<span class="cm"> *		sector.</span>
<span class="cm"> * Notes:	Upon return, cmd is a stale pointer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_requeue_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">scsi_unprep_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">blk_requeue_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">scsi_run_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">scsi_next_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span>

	<span class="cm">/* need to hold a reference on the device before we let go of the cmd */</span>
	<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">);</span>

	<span class="n">scsi_put_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">scsi_run_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="cm">/* ok to remove device now */</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">scsi_run_host_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>

	<span class="n">shost_for_each_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">shost</span><span class="p">)</span>
		<span class="n">scsi_run_queue</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__scsi_release_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function:    scsi_end_request()</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose:     Post-processing of completed commands (usually invoked at end</span>
<span class="cm"> *		of upper level post-processing and scsi_io_completion).</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:   cmd	 - command that is complete.</span>
<span class="cm"> *              error    - 0 if I/O indicates success, &lt; 0 for I/O error.</span>
<span class="cm"> *              bytes    - number of bytes of completed I/O</span>
<span class="cm"> *		requeue  - indicates whether we should requeue leftovers.</span>
<span class="cm"> *</span>
<span class="cm"> * Lock status: Assumed that lock is not held upon entry.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:     cmd if requeue required, NULL otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:       This is called for block device requests in order to</span>
<span class="cm"> *              mark some number of sectors as complete.</span>
<span class="cm"> * </span>
<span class="cm"> *		We are guaranteeing that the request queue will be goosed</span>
<span class="cm"> *		at some point during this call.</span>
<span class="cm"> * Notes:	If cmd was requeued, upon return it will be a stale pointer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="nf">scsi_end_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">requeue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are blocks left over at the end, set up the command</span>
<span class="cm">	 * to queue the remainder of them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_end_request</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">bytes</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* kill remainder if no retrys */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">scsi_noretry_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span>
			<span class="n">blk_end_request_all</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">requeue</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Bleah.  Leftovers again.  Stick the</span>
<span class="cm">				 * leftovers in the front of the</span>
<span class="cm">				 * queue, and goose the queue again.</span>
<span class="cm">				 */</span>
				<span class="n">scsi_release_buffers</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
				<span class="n">scsi_requeue_command</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
				<span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This will goose the queue request function at the end, so we don&#39;t</span>
<span class="cm">	 * need to worry about launching another command.</span>
<span class="cm">	 */</span>
	<span class="n">__scsi_release_buffers</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">scsi_next_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">scsi_sgtable_index</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nents</span> <span class="o">&gt;</span> <span class="n">SCSI_MAX_SG_SEGMENTS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nents</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">get_count_order</span><span class="p">(</span><span class="n">nents</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_sg_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_host_sg_pool</span> <span class="o">*</span><span class="n">sgp</span><span class="p">;</span>

	<span class="n">sgp</span> <span class="o">=</span> <span class="n">scsi_sg_pools</span> <span class="o">+</span> <span class="n">scsi_sgtable_index</span><span class="p">(</span><span class="n">nents</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">sgp</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="nf">scsi_sg_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_host_sg_pool</span> <span class="o">*</span><span class="n">sgp</span><span class="p">;</span>

	<span class="n">sgp</span> <span class="o">=</span> <span class="n">scsi_sg_pools</span> <span class="o">+</span> <span class="n">scsi_sgtable_index</span><span class="p">(</span><span class="n">nents</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scsi_alloc_sgtable</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_data_buffer</span> <span class="o">*</span><span class="n">sdb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
			      <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">nents</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__sg_alloc_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdb</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">SCSI_MAX_SG_SEGMENTS</span><span class="p">,</span>
			       <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">scsi_sg_alloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="n">__sg_free_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdb</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">,</span> <span class="n">SCSI_MAX_SG_SEGMENTS</span><span class="p">,</span>
				<span class="n">scsi_sg_free</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_free_sgtable</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_data_buffer</span> <span class="o">*</span><span class="n">sdb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__sg_free_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdb</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">,</span> <span class="n">SCSI_MAX_SG_SEGMENTS</span><span class="p">,</span> <span class="n">scsi_sg_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__scsi_release_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">do_bidi_check</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sdb</span><span class="p">.</span><span class="n">table</span><span class="p">.</span><span class="n">nents</span><span class="p">)</span>
		<span class="n">scsi_free_sgtable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sdb</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sdb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sdb</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">do_bidi_check</span> <span class="o">&amp;&amp;</span> <span class="n">scsi_bidi_cmnd</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_data_buffer</span> <span class="o">*</span><span class="n">bidi_sdb</span> <span class="o">=</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">;</span>
		<span class="n">scsi_free_sgtable</span><span class="p">(</span><span class="n">bidi_sdb</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">scsi_sdb_cache</span><span class="p">,</span> <span class="n">bidi_sdb</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="o">-&gt;</span><span class="n">special</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_prot_sg_count</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span>
		<span class="n">scsi_free_sgtable</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">prot_sdb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:    scsi_release_buffers()</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose:     Completion processing for block device I/O requests.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:   cmd	- command that we are bailing.</span>
<span class="cm"> *</span>
<span class="cm"> * Lock status: Assumed that no lock is held upon entry.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:     Nothing</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:       In the event that an upper level driver rejects a</span>
<span class="cm"> *		command, we must release resources allocated during</span>
<span class="cm"> *		the __init_io() function.  Primarily this would involve</span>
<span class="cm"> *		the scatter-gather table, and potentially any bounce</span>
<span class="cm"> *		buffers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_release_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__scsi_release_buffers</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_release_buffers</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__scsi_error_from_host_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">host_byte</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DID_TRANSPORT_FAILFAST</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOLINK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DID_TARGET_FAILURE</span>:
		<span class="n">set_host_byte</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">DID_OK</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DID_NEXUS_FAILURE</span>:
		<span class="n">set_host_byte</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">DID_OK</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:    scsi_io_completion()</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose:     Completion processing for block device I/O requests.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:   cmd   - command that is finished.</span>
<span class="cm"> *</span>
<span class="cm"> * Lock status: Assumed that no lock is held upon entry.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:     Nothing</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:       This function is matched in terms of capabilities to</span>
<span class="cm"> *              the function that created the scatter-gather list.</span>
<span class="cm"> *              In other words, if there are no bounce buffers</span>
<span class="cm"> *              (the normal case for most drivers), we don&#39;t need</span>
<span class="cm"> *              the logic to deal with cleaning up afterwards.</span>
<span class="cm"> *</span>
<span class="cm"> *		We must call scsi_end_request().  This will finish off</span>
<span class="cm"> *		the specified number of sectors.  If we are done, the</span>
<span class="cm"> *		command block will be released and the queue function</span>
<span class="cm"> *		will be goosed.  If we are not done then we have to</span>
<span class="cm"> *		figure out what to do next:</span>
<span class="cm"> *</span>
<span class="cm"> *		a) We can call scsi_requeue_command().  The request</span>
<span class="cm"> *		   will be unprepared and put back on the queue.  Then</span>
<span class="cm"> *		   a new command will be created for it.  This should</span>
<span class="cm"> *		   be used if we made forward progress, or if we want</span>
<span class="cm"> *		   to switch from READ(10) to READ(6) for example.</span>
<span class="cm"> *</span>
<span class="cm"> *		b) We can call scsi_queue_insert().  The request will</span>
<span class="cm"> *		   be put back on the queue and retried using the same</span>
<span class="cm"> *		   command as before, possibly after a delay.</span>
<span class="cm"> *</span>
<span class="cm"> *		c) We can call blk_end_request() with -EIO to fail</span>
<span class="cm"> *		   the remainder of the request.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_io_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">good_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sense_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sense_deferred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span><span class="n">ACTION_FAIL</span><span class="p">,</span> <span class="n">ACTION_REPREP</span><span class="p">,</span> <span class="n">ACTION_RETRY</span><span class="p">,</span>
	      <span class="n">ACTION_DELAYED_RETRY</span><span class="p">}</span> <span class="n">action</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">description</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sense_valid</span> <span class="o">=</span> <span class="n">scsi_command_normalize_sense</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sense_valid</span><span class="p">)</span>
			<span class="n">sense_deferred</span> <span class="o">=</span> <span class="n">scsi_sense_is_deferred</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_BLOCK_PC</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* SG_IO ioctl from block level */</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sense_valid</span> <span class="o">&amp;&amp;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">sense</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * SG_IO wants current and deferred errors</span>
<span class="cm">				 */</span>
				<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">)</span>
					<span class="n">len</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">sense</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>  <span class="n">len</span><span class="p">);</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">sense_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sense_deferred</span><span class="p">)</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">__scsi_error_from_host_byte</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">req</span><span class="o">-&gt;</span><span class="n">resid_len</span> <span class="o">=</span> <span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_bidi_cmnd</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Bidi commands Must be complete as a whole,</span>
<span class="cm">			 * both sides at once.</span>
<span class="cm">			 */</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="o">-&gt;</span><span class="n">resid_len</span> <span class="o">=</span> <span class="n">scsi_in</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">resid</span><span class="p">;</span>

			<span class="n">scsi_release_buffers</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="n">blk_end_request_all</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">scsi_next_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* no bidi support for !REQ_TYPE_BLOCK_PC yet */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">blk_bidi_rq</span><span class="p">(</span><span class="n">req</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Next deal with any sectors which we were able to correctly</span>
<span class="cm">	 * handle.</span>
<span class="cm">	 */</span>
	<span class="n">SCSI_LOG_HLCOMPLETE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%u sectors total, &quot;</span>
				      <span class="s">&quot;%d bytes done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">req</span><span class="p">),</span> <span class="n">good_bytes</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Recovered errors need reporting, but they&#39;re always treated</span>
<span class="cm">	 * as success, so fiddle the result code here.  For BLOCK_PC</span>
<span class="cm">	 * we already took a copy of the original into rq-&gt;errors which</span>
<span class="cm">	 * is what gets returned to the user</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sense_valid</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">RECOVERED_ERROR</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* if ATA PASS-THROUGH INFORMATION AVAILABLE skip</span>
<span class="cm">		 * print since caller wants ATA registers. Only occurs on</span>
<span class="cm">		 * SCSI ATA PASS_THROUGH commands when CK_COND=1</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span> <span class="o">==</span> <span class="mh">0x1d</span><span class="p">))</span>
			<span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_QUIET</span><span class="p">))</span>
			<span class="n">scsi_print_sense</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* BLOCK_PC may have set error */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * A number of bytes were successfully read.  If there</span>
<span class="cm">	 * are leftovers and there is some kind of error</span>
<span class="cm">	 * (result != 0), retry the rest.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_end_request</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">good_bytes</span><span class="p">,</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">__scsi_error_from_host_byte</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host_byte</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="n">DID_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Third party bus reset or reset for error recovery</span>
<span class="cm">		 * reasons.  Just retry the command and see what</span>
<span class="cm">		 * happens.</span>
<span class="cm">		 */</span>
		<span class="n">action</span> <span class="o">=</span> <span class="n">ACTION_RETRY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sense_valid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sense_deferred</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">UNIT_ATTENTION</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">removable</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Detected disc change.  Set a bit</span>
<span class="cm">				 * and quietly refuse further access.</span>
<span class="cm">				 */</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">description</span> <span class="o">=</span> <span class="s">&quot;Media Changed&quot;</span><span class="p">;</span>
				<span class="n">action</span> <span class="o">=</span> <span class="n">ACTION_FAIL</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Must have been a power glitch, or a</span>
<span class="cm">				 * bus reset.  Could not have been a</span>
<span class="cm">				 * media change, so we just retry the</span>
<span class="cm">				 * command and see what happens.</span>
<span class="cm">				 */</span>
				<span class="n">action</span> <span class="o">=</span> <span class="n">ACTION_RETRY</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ILLEGAL_REQUEST</span>:
			<span class="cm">/* If we had an ILLEGAL REQUEST returned, then</span>
<span class="cm">			 * we may have performed an unsupported</span>
<span class="cm">			 * command.  The only thing this should be</span>
<span class="cm">			 * would be a ten byte read where only a six</span>
<span class="cm">			 * byte read was supported.  Also, on a system</span>
<span class="cm">			 * where READ CAPACITY failed, we may have</span>
<span class="cm">			 * read past the end of the disk.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">use_10_for_rw</span> <span class="o">&amp;&amp;</span>
			    <span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x20</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_10</span> <span class="o">||</span>
			     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_10</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* This will issue a new 6-byte command. */</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">use_10_for_rw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">action</span> <span class="o">=</span> <span class="n">ACTION_REPREP</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x10</span><span class="p">)</span> <span class="cm">/* DIX */</span> <span class="p">{</span>
				<span class="n">description</span> <span class="o">=</span> <span class="s">&quot;Host Data Integrity Failure&quot;</span><span class="p">;</span>
				<span class="n">action</span> <span class="o">=</span> <span class="n">ACTION_FAIL</span><span class="p">;</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
			<span class="cm">/* INVALID COMMAND OPCODE or INVALID FIELD IN CDB */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x20</span> <span class="o">||</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x24</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				   <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">UNMAP</span> <span class="o">||</span>
				    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_SAME_16</span> <span class="o">||</span>
				    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_SAME</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">description</span> <span class="o">=</span> <span class="s">&quot;Discard failure&quot;</span><span class="p">;</span>
				<span class="n">action</span> <span class="o">=</span> <span class="n">ACTION_FAIL</span><span class="p">;</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">action</span> <span class="o">=</span> <span class="n">ACTION_FAIL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ABORTED_COMMAND</span>:
			<span class="n">action</span> <span class="o">=</span> <span class="n">ACTION_FAIL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* DIF */</span>
				<span class="n">description</span> <span class="o">=</span> <span class="s">&quot;Target Data Integrity Failure&quot;</span><span class="p">;</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NOT_READY</span>:
			<span class="cm">/* If the device is in the process of becoming</span>
<span class="cm">			 * ready, or has a temporary blockage, retry.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x04</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="mh">0x01</span>: <span class="cm">/* becoming ready */</span>
				<span class="k">case</span> <span class="mh">0x04</span>: <span class="cm">/* format in progress */</span>
				<span class="k">case</span> <span class="mh">0x05</span>: <span class="cm">/* rebuild in progress */</span>
				<span class="k">case</span> <span class="mh">0x06</span>: <span class="cm">/* recalculation in progress */</span>
				<span class="k">case</span> <span class="mh">0x07</span>: <span class="cm">/* operation in progress */</span>
				<span class="k">case</span> <span class="mh">0x08</span>: <span class="cm">/* Long write in progress */</span>
				<span class="k">case</span> <span class="mh">0x09</span>: <span class="cm">/* self test in progress */</span>
				<span class="k">case</span> <span class="mh">0x14</span>: <span class="cm">/* space allocation in progress */</span>
					<span class="n">action</span> <span class="o">=</span> <span class="n">ACTION_DELAYED_RETRY</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="nl">default:</span>
					<span class="n">description</span> <span class="o">=</span> <span class="s">&quot;Device not ready&quot;</span><span class="p">;</span>
					<span class="n">action</span> <span class="o">=</span> <span class="n">ACTION_FAIL</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">description</span> <span class="o">=</span> <span class="s">&quot;Device not ready&quot;</span><span class="p">;</span>
				<span class="n">action</span> <span class="o">=</span> <span class="n">ACTION_FAIL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VOLUME_OVERFLOW</span>:
			<span class="cm">/* See SSC3rXX or current. */</span>
			<span class="n">action</span> <span class="o">=</span> <span class="n">ACTION_FAIL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">description</span> <span class="o">=</span> <span class="s">&quot;Unhandled sense code&quot;</span><span class="p">;</span>
			<span class="n">action</span> <span class="o">=</span> <span class="n">ACTION_FAIL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">description</span> <span class="o">=</span> <span class="s">&quot;Unhandled error code&quot;</span><span class="p">;</span>
		<span class="n">action</span> <span class="o">=</span> <span class="n">ACTION_FAIL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ACTION_FAIL</span>:
		<span class="cm">/* Give up and fail the remainder of the request */</span>
		<span class="n">scsi_release_buffers</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_QUIET</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">description</span><span class="p">)</span>
				<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					    <span class="n">description</span><span class="p">);</span>
			<span class="n">scsi_print_result</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">driver_byte</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DRIVER_SENSE</span><span class="p">)</span>
				<span class="n">scsi_print_sense</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="n">scsi_print_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk_end_request_err</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">error</span><span class="p">))</span>
			<span class="n">scsi_requeue_command</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">scsi_next_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ACTION_REPREP</span>:
		<span class="cm">/* Unprep the request and put it back at the head of the queue.</span>
<span class="cm">		 * A new command will be prepared and issued.</span>
<span class="cm">		 */</span>
		<span class="n">scsi_release_buffers</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">scsi_requeue_command</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ACTION_RETRY</span>:
		<span class="cm">/* Retry the same command immediately */</span>
		<span class="n">__scsi_queue_insert</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">SCSI_MLQUEUE_EH_RETRY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ACTION_DELAYED_RETRY</span>:
		<span class="cm">/* Retry the same command after a delay */</span>
		<span class="n">__scsi_queue_insert</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">SCSI_MLQUEUE_DEVICE_BUSY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scsi_init_sgtable</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_data_buffer</span> <span class="o">*</span><span class="n">sdb</span><span class="p">,</span>
			     <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If sg table allocation fails, requeue request later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scsi_alloc_sgtable</span><span class="p">(</span><span class="n">sdb</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nr_phys_segments</span><span class="p">,</span>
					<span class="n">gfp_mask</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">BLKPREP_DEFER</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* </span>
<span class="cm">	 * Next, walk the list, and fill in the addresses and sizes of</span>
<span class="cm">	 * each segment.</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">blk_rq_map_sg</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">sdb</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">sgl</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">sdb</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">nents</span><span class="p">);</span>
	<span class="n">sdb</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">nents</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">sdb</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">BLKPREP_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:    scsi_init_io()</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose:     SCSI I/O initialize function.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:   cmd   - Command descriptor we wish to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:     0 on success</span>
<span class="cm"> *		BLKPREP_DEFER if the failure is retryable</span>
<span class="cm"> *		BLKPREP_KILL if the failure is fatal</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">scsi_init_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">scsi_init_sgtable</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sdb</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_bidi_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_data_buffer</span> <span class="o">*</span><span class="n">bidi_sdb</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span>
			<span class="n">scsi_sdb_cache</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bidi_sdb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">BLKPREP_DEFER</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="o">-&gt;</span><span class="n">special</span> <span class="o">=</span> <span class="n">bidi_sdb</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_init_sgtable</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">,</span> <span class="n">bidi_sdb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_integrity_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_data_buffer</span> <span class="o">*</span><span class="n">prot_sdb</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">prot_sdb</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ivecs</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">prot_sdb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">ivecs</span> <span class="o">=</span> <span class="n">blk_rq_count_integrity_sg</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_alloc_sgtable</span><span class="p">(</span><span class="n">prot_sdb</span><span class="p">,</span> <span class="n">ivecs</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">BLKPREP_DEFER</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">count</span> <span class="o">=</span> <span class="n">blk_rq_map_integrity_sg</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">,</span>
						<span class="n">prot_sdb</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">sgl</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">ivecs</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">queue_max_integrity_segments</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">)));</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">prot_sdb</span> <span class="o">=</span> <span class="n">prot_sdb</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">prot_sdb</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">nents</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">BLKPREP_OK</span> <span class="p">;</span>

<span class="nl">err_exit:</span>
	<span class="n">scsi_release_buffers</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">special</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">scsi_put_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_init_io</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="nf">scsi_get_cmd_from_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">scsi_get_command</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">special</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* pull a tag out of the request if we have one */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">prot_op</span> <span class="o">=</span> <span class="n">SCSI_PROT_NORMAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">scsi_setup_blk_pc_cmnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_prep_state_check</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">BLKPREP_OK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">scsi_get_cmd_from_req</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">BLKPREP_DEFER</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * BLOCK_PC requests may transfer data, in which case they must</span>
<span class="cm">	 * a bio attached to them.  Or they might contain a SCSI command</span>
<span class="cm">	 * that does not transfer data, in which case they may optionally</span>
<span class="cm">	 * submit a request without an attached bio.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">nr_phys_segments</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_init_io</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">req</span><span class="p">));</span>

		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sdb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sdb</span><span class="p">));</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">req</span><span class="p">))</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">=</span> <span class="n">DMA_NONE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rq_data_dir</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>
	
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transfersize</span> <span class="o">=</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">allowed</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">retries</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">BLKPREP_OK</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_setup_blk_pc_cmnd</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Setup a REQ_TYPE_FS command.  These are simple read/write request</span>
<span class="cm"> * from filesystems that still need to be translated to SCSI CDBs from</span>
<span class="cm"> * the ULD.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">scsi_setup_fs_cmnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_prep_state_check</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">BLKPREP_OK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_dh_data</span> <span class="o">&amp;&amp;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_dh_data</span><span class="o">-&gt;</span><span class="n">scsi_dh</span>
			 <span class="o">&amp;&amp;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_dh_data</span><span class="o">-&gt;</span><span class="n">scsi_dh</span><span class="o">-&gt;</span><span class="n">prep_fn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_dh_data</span><span class="o">-&gt;</span><span class="n">scsi_dh</span><span class="o">-&gt;</span><span class="n">prep_fn</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">BLKPREP_OK</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Filesystem requests must transfer data.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">nr_phys_segments</span><span class="p">);</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">scsi_get_cmd_from_req</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">BLKPREP_DEFER</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BLK_MAX_CDB</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">scsi_init_io</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_setup_fs_cmnd</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">scsi_prep_state_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">BLKPREP_OK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the device is not in running state we will reject some</span>
<span class="cm">	 * or all commands.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">!=</span> <span class="n">SDEV_RUNNING</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SDEV_OFFLINE</span>:
			<span class="cm">/*</span>
<span class="cm">			 * If the device is offline we refuse to process any</span>
<span class="cm">			 * commands.  The device must be brought online</span>
<span class="cm">			 * before trying any recovery commands.</span>
<span class="cm">			 */</span>
			<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span>
				    <span class="s">&quot;rejecting I/O to offline device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">BLKPREP_KILL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SDEV_DEL</span>:
			<span class="cm">/*</span>
<span class="cm">			 * If the device is fully deleted, we refuse to</span>
<span class="cm">			 * process any commands as well.</span>
<span class="cm">			 */</span>
			<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span>
				    <span class="s">&quot;rejecting I/O to dead device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">BLKPREP_KILL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SDEV_QUIESCE</span>:
		<span class="k">case</span> <span class="n">SDEV_BLOCK</span>:
		<span class="k">case</span> <span class="n">SDEV_CREATED_BLOCK</span>:
			<span class="cm">/*</span>
<span class="cm">			 * If the devices is blocked we defer normal commands.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_PREEMPT</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">BLKPREP_DEFER</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="cm">/*</span>
<span class="cm">			 * For any other not fully online state we only allow</span>
<span class="cm">			 * special commands.  In particular any user initiated</span>
<span class="cm">			 * command is not allowed.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_PREEMPT</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">BLKPREP_KILL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_prep_state_check</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">scsi_prep_return</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BLKPREP_KILL</span>:
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="cm">/* release the command and kill it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">;</span>
			<span class="n">scsi_release_buffers</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="n">scsi_put_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">special</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BLKPREP_DEFER</span>:
		<span class="cm">/*</span>
<span class="cm">		 * If we defer, the blk_peek_request() returns NULL, but the</span>
<span class="cm">		 * queue must be restarted, so we schedule a callback to happen</span>
<span class="cm">		 * shortly.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">device_busy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">blk_delay_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">SCSI_QUEUE_DELAY</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">|=</span> <span class="n">REQ_DONTPREP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_prep_return</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">scsi_prep_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">BLKPREP_KILL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_BLOCK_PC</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_setup_blk_pc_cmnd</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">scsi_prep_return</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_prep_fn</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * scsi_dev_queue_ready: if we can send requests to sdev, return 1 else</span>
<span class="cm"> * return 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with the queue_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_dev_queue_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">device_busy</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">device_blocked</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * unblock after device_blocked iterates to zero</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">device_blocked</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SCSI_LOG_MLQUEUE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span>
				   <span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span>
				   <span class="s">&quot;unblocking device at zero depth</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">blk_delay_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">SCSI_QUEUE_DELAY</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_device_is_busy</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * scsi_target_queue_ready: checks if there we can send commands to target</span>
<span class="cm"> * @sdev: scsi device on starget to check.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with the host lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_target_queue_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">scsi_target</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">single_lun</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">starget_sdev_user</span> <span class="o">&amp;&amp;</span>
		    <span class="n">starget</span><span class="o">-&gt;</span><span class="n">starget_sdev_user</span> <span class="o">!=</span> <span class="n">sdev</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">starget</span><span class="o">-&gt;</span><span class="n">starget_sdev_user</span> <span class="o">=</span> <span class="n">sdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">target_busy</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">starget</span><span class="o">-&gt;</span><span class="n">target_blocked</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * unblock after target_blocked iterates to zero</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">target_blocked</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SCSI_LOG_MLQUEUE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">starget</span><span class="p">,</span>
					 <span class="s">&quot;unblocking target at zero depth</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_target_is_busy</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">starved_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">starved_list</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * scsi_host_queue_ready: if we can send requests to shost, return 1 else</span>
<span class="cm"> * return 0. We must end up running the queue again whenever 0 is</span>
<span class="cm"> * returned, else IO can hang.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with host_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_host_queue_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_host_in_recovery</span><span class="p">(</span><span class="n">shost</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_busy</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_blocked</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * unblock after host_blocked iterates to zero</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_blocked</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SCSI_LOG_MLQUEUE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scsi%d unblocking host at zero depth</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_host_is_busy</span><span class="p">(</span><span class="n">shost</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">starved_entry</span><span class="p">))</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">starved_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">starved_list</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We&#39;re OK to process the command, so we can&#39;t be starved */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">starved_entry</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">starved_entry</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Busy state exporting function for request stacking drivers.</span>
<span class="cm"> *</span>
<span class="cm"> * For efficiency, no lock is taken to check the busy state of</span>
<span class="cm"> * shost/starget/sdev, since the returned value is not guaranteed and</span>
<span class="cm"> * may be changed after request stacking drivers call the function,</span>
<span class="cm"> * regardless of taking lock or not.</span>
<span class="cm"> *</span>
<span class="cm"> * When scsi can&#39;t dispatch I/Os anymore and needs to kill I/Os</span>
<span class="cm"> * (e.g. !sdev), scsi needs to return &#39;not busy&#39;.</span>
<span class="cm"> * Otherwise, request stacking drivers may hold requests forever.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scsi_lld_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ignore host/starget busy state.</span>
<span class="cm">	 * Since block layer does not have a concept of fairness across</span>
<span class="cm">	 * multiple queues, congestion of host/starget needs to be handled</span>
<span class="cm">	 * in SCSI layer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_host_in_recovery</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">||</span> <span class="n">scsi_device_is_busy</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Kill a request for a dead device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_kill_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>

	<span class="n">blk_start_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;killing request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">starget</span> <span class="o">=</span> <span class="n">scsi_target</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">shost</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">scsi_init_cmd_errh</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iorequest_cnt</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * SCSI request completion path will do scsi_device_unbusy(),</span>
<span class="cm">	 * bump busy counts.  To bump the counters, we need to dance</span>
<span class="cm">	 * with the locks as normal issue path does.</span>
<span class="cm">	 */</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">device_busy</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_busy</span><span class="o">++</span><span class="p">;</span>
	<span class="n">starget</span><span class="o">-&gt;</span><span class="n">target_busy</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="n">blk_complete_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_softirq_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wait_for</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">allowed</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">disposition</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">eh_entry</span><span class="p">);</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iodone_cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ioerr_cnt</span><span class="p">);</span>

	<span class="n">disposition</span> <span class="o">=</span> <span class="n">scsi_decide_disposition</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disposition</span> <span class="o">!=</span> <span class="n">SUCCESS</span> <span class="o">&amp;&amp;</span>
	    <span class="n">time_before</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">jiffies_at_alloc</span> <span class="o">+</span> <span class="n">wait_for</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
			    <span class="s">&quot;timing out command, waited %lus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">wait_for</span><span class="o">/</span><span class="n">HZ</span><span class="p">);</span>
		<span class="n">disposition</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>
			
	<span class="n">scsi_log_completion</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">disposition</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">disposition</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SUCCESS</span>:
			<span class="n">scsi_finish_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NEEDS_RETRY</span>:
			<span class="n">scsi_queue_insert</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">SCSI_MLQUEUE_EH_RETRY</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ADD_TO_MLQUEUE</span>:
			<span class="n">scsi_queue_insert</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">SCSI_MLQUEUE_DEVICE_BUSY</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_eh_scmd_add</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">scsi_finish_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:    scsi_request_fn()</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose:     Main strategy routine for SCSI.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:   q       - Pointer to actual queue.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:     Nothing</span>
<span class="cm"> *</span>
<span class="cm"> * Lock status: IO request lock assumed to be held when called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_request_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">req</span> <span class="o">=</span> <span class="n">blk_peek_request</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">scsi_kill_request</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">))</span>
		<span class="cm">/* We must be tearing the block queue down already */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * To start with, we keep looping until the queue is empty, or until</span>
<span class="cm">	 * the host is no longer able to accept any more requests.</span>
<span class="cm">	 */</span>
	<span class="n">shost</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rtn</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * get next queueable request.  We do this early to make sure</span>
<span class="cm">		 * that the request is fully prepared even if we cannot </span>
<span class="cm">		 * accept it.</span>
<span class="cm">		 */</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">blk_peek_request</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span> <span class="o">||</span> <span class="o">!</span><span class="n">scsi_dev_queue_ready</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">sdev</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">scsi_device_online</span><span class="p">(</span><span class="n">sdev</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span>
				    <span class="s">&quot;rejecting I/O to offline device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">scsi_kill_request</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>


		<span class="cm">/*</span>
<span class="cm">		 * Remove the request from the request list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">blk_queue_tagged</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">blk_queue_start_tag</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">)))</span>
			<span class="n">blk_start_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">device_busy</span><span class="o">++</span><span class="p">;</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;impossible request in %s.</span><span class="se">\n</span><span class="s">&quot;</span>
					 <span class="s">&quot;please mail a stack trace to &quot;</span>
					 <span class="s">&quot;linux-scsi@vger.kernel.org</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">__func__</span><span class="p">);</span>
			<span class="n">blk_dump_rq_flags</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We hit this when the driver is using a host wide</span>
<span class="cm">		 * tag map. For device level tag maps the queue_depth check</span>
<span class="cm">		 * in the device ready fn would prevent us from trying</span>
<span class="cm">		 * to allocate a tag. Since the map is a shared host resource</span>
<span class="cm">		 * we add the dev to the starved list so it eventually gets</span>
<span class="cm">		 * a run when a tag is freed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk_queue_tagged</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">blk_rq_tagged</span><span class="p">(</span><span class="n">req</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">starved_entry</span><span class="p">))</span>
				<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">starved_entry</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">starved_list</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">not_ready</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_target_queue_ready</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">sdev</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">not_ready</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_host_queue_ready</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="n">sdev</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">not_ready</span><span class="p">;</span>

		<span class="n">scsi_target</span><span class="p">(</span><span class="n">sdev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">target_busy</span><span class="o">++</span><span class="p">;</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_busy</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * XXX(hch): This is rather suboptimal, scsi_dispatch_cmd will</span>
<span class="cm">		 *		take the lock again.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Finally, initialize any error handling parameters, and set up</span>
<span class="cm">		 * the timers for timeouts.</span>
<span class="cm">		 */</span>
		<span class="n">scsi_init_cmd_errh</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Dispatch the command to the low-level driver.</span>
<span class="cm">		 */</span>
		<span class="n">rtn</span> <span class="o">=</span> <span class="n">scsi_dispatch_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rtn</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_delay</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

 <span class="nl">not_ready:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * lock q, handle tag, requeue req, and decrement device_busy. We</span>
<span class="cm">	 * must return with queue_lock held.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Decrementing device_busy without checking it is OK, as all such</span>
<span class="cm">	 * cases (host limits or settings) should run the queue at some</span>
<span class="cm">	 * later time.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">blk_requeue_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">device_busy</span><span class="o">--</span><span class="p">;</span>
<span class="nl">out_delay:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">device_busy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">blk_delay_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">SCSI_QUEUE_DELAY</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="cm">/* must be careful here...if we trigger the -&gt;remove() function</span>
<span class="cm">	 * we cannot be holding the q lock */</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">scsi_calculate_bounce_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">host_dev</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bounce_limit</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">BLK_BOUNCE_ISA</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Platforms with virtual-DMA translation</span>
<span class="cm">	 * hardware have no practical limit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PCI_DMA_BUS_IS_PHYS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">BLK_BOUNCE_ANY</span><span class="p">;</span>

	<span class="n">host_dev</span> <span class="o">=</span> <span class="n">scsi_get_device</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_dev</span> <span class="o">&amp;&amp;</span> <span class="n">host_dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span>
		<span class="n">bounce_limit</span> <span class="o">=</span> <span class="o">*</span><span class="n">host_dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bounce_limit</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_calculate_bounce_limit</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="nf">__scsi_alloc_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span>
					 <span class="n">request_fn_proc</span> <span class="o">*</span><span class="n">request_fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">;</span>

	<span class="n">q</span> <span class="o">=</span> <span class="n">blk_init_queue</span><span class="p">(</span><span class="n">request_fn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * this limit is imposed by hardware restrictions</span>
<span class="cm">	 */</span>
	<span class="n">blk_queue_max_segments</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span><span class="p">,</span>
					<span class="n">SCSI_MAX_SG_CHAIN_SEGMENTS</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_host_prot_dma</span><span class="p">(</span><span class="n">shost</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">sg_prot_tablesize</span> <span class="o">=</span>
			<span class="n">min_not_zero</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">sg_prot_tablesize</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">SCSI_MAX_PROT_SG_SEGMENTS</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">sg_prot_tablesize</span> <span class="o">&lt;</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span><span class="p">);</span>
		<span class="n">blk_queue_max_integrity_segments</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">sg_prot_tablesize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">blk_queue_max_hw_sectors</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_sectors</span><span class="p">);</span>
	<span class="n">blk_queue_bounce_limit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">scsi_calculate_bounce_limit</span><span class="p">(</span><span class="n">shost</span><span class="p">));</span>
	<span class="n">blk_queue_segment_boundary</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_boundary</span><span class="p">);</span>
	<span class="n">dma_set_seg_boundary</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_boundary</span><span class="p">);</span>

	<span class="n">blk_queue_max_segment_size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dma_get_max_seg_size</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">use_clustering</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">cluster</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * set a reasonable default alignment on word boundaries: the</span>
<span class="cm">	 * host and device may alter it using</span>
<span class="cm">	 * blk_queue_update_dma_alignment() later.</span>
<span class="cm">	 */</span>
	<span class="n">blk_queue_dma_alignment</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">q</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__scsi_alloc_queue</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="nf">scsi_alloc_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="n">q</span> <span class="o">=</span> <span class="n">__scsi_alloc_queue</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">scsi_request_fn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">blk_queue_prep_rq</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">scsi_prep_fn</span><span class="p">);</span>
	<span class="n">blk_queue_softirq_done</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">scsi_softirq_done</span><span class="p">);</span>
	<span class="n">blk_queue_rq_timed_out</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">scsi_times_out</span><span class="p">);</span>
	<span class="n">blk_queue_lld_busy</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">scsi_lld_busy</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">q</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">scsi_free_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">);</span>

	<span class="cm">/* cause scsi_request_fn() to kill all non-finished requests */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">request_fn</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function:    scsi_block_requests()</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose:     Utility function used by low-level drivers to prevent further</span>
<span class="cm"> *		commands from being queued to the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:   shost       - Host in question</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:     Nothing</span>
<span class="cm"> *</span>
<span class="cm"> * Lock status: No locks are assumed held.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:       There is no timer nor any other means by which the requests</span>
<span class="cm"> *		get unblocked other than the low-level driver calling</span>
<span class="cm"> *		scsi_unblock_requests().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_block_requests</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_self_blocked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_block_requests</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function:    scsi_unblock_requests()</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose:     Utility function used by low-level drivers to allow further</span>
<span class="cm"> *		commands from being queued to the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:   shost       - Host in question</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:     Nothing</span>
<span class="cm"> *</span>
<span class="cm"> * Lock status: No locks are assumed held.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:       There is no timer nor any other means by which the requests</span>
<span class="cm"> *		get unblocked other than the low-level driver calling</span>
<span class="cm"> *		scsi_unblock_requests().</span>
<span class="cm"> *</span>
<span class="cm"> *		This is done as an API function so that changes to the</span>
<span class="cm"> *		internals of the scsi mid-layer won&#39;t require wholesale</span>
<span class="cm"> *		changes to drivers that use this feature.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_unblock_requests</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_self_blocked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">scsi_run_host_queues</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_unblock_requests</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">scsi_init_queue</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">scsi_sdb_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;scsi_data_buffer&quot;</span><span class="p">,</span>
					   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_data_buffer</span><span class="p">),</span>
					   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_sdb_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SCSI: can&#39;t init scsi sdb cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SG_MEMPOOL_NR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_host_sg_pool</span> <span class="o">*</span><span class="n">sgp</span> <span class="o">=</span> <span class="n">scsi_sg_pools</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">sgp</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span><span class="p">);</span>

		<span class="n">sgp</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SCSI: can&#39;t init sg slab %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">sgp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cleanup_sdb</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sgp</span><span class="o">-&gt;</span><span class="n">pool</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="n">SG_MEMPOOL_SIZE</span><span class="p">,</span>
						     <span class="n">sgp</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SCSI: can&#39;t init sg mempool %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">sgp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cleanup_sdb</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">cleanup_sdb:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SG_MEMPOOL_NR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_host_sg_pool</span> <span class="o">*</span><span class="n">sgp</span> <span class="o">=</span> <span class="n">scsi_sg_pools</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">)</span>
			<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">)</span>
			<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">scsi_sdb_cache</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">scsi_exit_queue</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">scsi_sdb_cache</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SG_MEMPOOL_NR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_host_sg_pool</span> <span class="o">*</span><span class="n">sgp</span> <span class="o">=</span> <span class="n">scsi_sg_pools</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">);</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	scsi_mode_select - issue a mode select</span>
<span class="cm"> *	@sdev:	SCSI device to be queried</span>
<span class="cm"> *	@pf:	Page format bit (1 == standard, 0 == vendor specific)</span>
<span class="cm"> *	@sp:	Save page bit (0 == don&#39;t save, 1 == save)</span>
<span class="cm"> *	@modepage: mode page being requested</span>
<span class="cm"> *	@buffer: request buffer (may not be smaller than eight bytes)</span>
<span class="cm"> *	@len:	length of request buffer.</span>
<span class="cm"> *	@timeout: command timeout</span>
<span class="cm"> *	@retries: number of retries before failing</span>
<span class="cm"> *	@data: returns a structure abstracting the mode header data</span>
<span class="cm"> *	@sshdr: place to put sense data (or NULL if no sense to be collected).</span>
<span class="cm"> *		must be SCSI_SENSE_BUFFERSIZE big.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns zero if successful; negative error number or scsi</span>
<span class="cm"> *	status on error</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">scsi_mode_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">modepage</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">retries</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">scsi_mode_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="n">sshdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">real_buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
	<span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pf</span> <span class="o">?</span> <span class="mh">0x10</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">sp</span> <span class="o">?</span> <span class="mh">0x01</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_10_for_ms</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">65535</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">real_buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">real_buffer</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">real_buffer</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">real_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">real_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">real_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">medium_type</span><span class="p">;</span>
		<span class="n">real_buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">device_specific</span><span class="p">;</span>
		<span class="n">real_buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">longlba</span> <span class="o">?</span> <span class="mh">0x01</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">real_buffer</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">real_buffer</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block_descriptor_length</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">real_buffer</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block_descriptor_length</span><span class="p">;</span>

		<span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MODE_SELECT_10</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">255</span> <span class="o">||</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block_descriptor_length</span> <span class="o">&gt;</span> <span class="mi">255</span> <span class="o">||</span>
		    <span class="n">data</span><span class="o">-&gt;</span><span class="n">longlba</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">real_buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">real_buffer</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">real_buffer</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">real_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">real_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">medium_type</span><span class="p">;</span>
		<span class="n">real_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">device_specific</span><span class="p">;</span>
		<span class="n">real_buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block_descriptor_length</span><span class="p">;</span>
		

		<span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MODE_SELECT</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_execute_req</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">,</span> <span class="n">real_buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
			       <span class="n">sshdr</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">retries</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">real_buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">scsi_mode_select</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	scsi_mode_sense - issue a mode sense, falling back from 10 to six bytes if necessary.</span>
<span class="cm"> *	@sdev:	SCSI device to be queried</span>
<span class="cm"> *	@dbd:	set if mode sense will allow block descriptors to be returned</span>
<span class="cm"> *	@modepage: mode page being requested</span>
<span class="cm"> *	@buffer: request buffer (may not be smaller than eight bytes)</span>
<span class="cm"> *	@len:	length of request buffer.</span>
<span class="cm"> *	@timeout: command timeout</span>
<span class="cm"> *	@retries: number of retries before failing</span>
<span class="cm"> *	@data: returns a structure abstracting the mode header data</span>
<span class="cm"> *	@sshdr: place to put sense data (or NULL if no sense to be collected).</span>
<span class="cm"> *		must be SCSI_SENSE_BUFFERSIZE big.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns zero if unsuccessful, or the header offset (either 4</span>
<span class="cm"> *	or 8 depending on whether a six or ten byte command was</span>
<span class="cm"> *	issued) if successful.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">scsi_mode_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dbd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">modepage</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">retries</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">scsi_mode_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="n">sshdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">use_10_for_ms</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">header_length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">my_sshdr</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dbd</span> <span class="o">&amp;</span> <span class="mh">0x18</span><span class="p">;</span>	<span class="cm">/* allows DBD and LLBA bits */</span>
	<span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">modepage</span><span class="p">;</span>

	<span class="cm">/* caller might not be interested in sense, but we need it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sshdr</span><span class="p">)</span>
		<span class="n">sshdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_sshdr</span><span class="p">;</span>

 <span class="nl">retry:</span>
	<span class="n">use_10_for_ms</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_10_for_ms</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_10_for_ms</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

		<span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MODE_SENSE_10</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">header_length</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MODE_SENSE</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">header_length</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">scsi_execute_req</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				  <span class="n">sshdr</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">retries</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* This code looks awful: what it&#39;s doing is making sure an</span>
<span class="cm">	 * ILLEGAL REQUEST sense return identifies the actual command</span>
<span class="cm">	 * byte as the problem.  MODE_SENSE commands can return</span>
<span class="cm">	 * ILLEGAL REQUEST if the code page isn&#39;t supported */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_10_for_ms</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">scsi_status_is_good</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">driver_byte</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DRIVER_SENSE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_sense_valid</span><span class="p">(</span><span class="n">sshdr</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">sshdr</span><span class="o">-&gt;</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">sshdr</span><span class="o">-&gt;</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sshdr</span><span class="o">-&gt;</span><span class="n">ascq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* </span>
<span class="cm">				 * Invalid command operation code</span>
<span class="cm">				 */</span>
				<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_10_for_ms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">scsi_status_is_good</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x86</span> <span class="o">&amp;&amp;</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x0b</span> <span class="o">&amp;&amp;</span>
			     <span class="p">(</span><span class="n">modepage</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">modepage</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* Initio breakage? */</span>
			<span class="n">header_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">medium_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">device_specific</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">longlba</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">block_descriptor_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">use_10_for_ms</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">256</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">medium_type</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">device_specific</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">longlba</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">block_descriptor_length</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">*</span><span class="mi">256</span>
				<span class="o">+</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">medium_type</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">device_specific</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">block_descriptor_length</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">=</span> <span class="n">header_length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_mode_sense</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	scsi_test_unit_ready - test if unit is ready</span>
<span class="cm"> *	@sdev:	scsi device to change the state of.</span>
<span class="cm"> *	@timeout: command timeout</span>
<span class="cm"> *	@retries: number of retries before failing</span>
<span class="cm"> *	@sshdr_external: Optional pointer to struct scsi_sense_hdr for</span>
<span class="cm"> *		returning sense. Make sure that this is cleared before passing</span>
<span class="cm"> *		in.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns zero if unsuccessful or an error if TUR failed.  For</span>
<span class="cm"> *	removable media, UNIT_ATTENTION sets -&gt;changed flag.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">scsi_test_unit_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">retries</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="n">sshdr_external</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">cmd</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">TEST_UNIT_READY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="n">sshdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sshdr_external</span><span class="p">)</span>
		<span class="n">sshdr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sshdr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sshdr</span> <span class="o">=</span> <span class="n">sshdr_external</span><span class="p">;</span>

	<span class="cm">/* try to eat the UNIT_ATTENTION if there are enough retries */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">scsi_execute_req</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">DMA_NONE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sshdr</span><span class="p">,</span>
					  <span class="n">timeout</span><span class="p">,</span> <span class="n">retries</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">&amp;&amp;</span> <span class="n">scsi_sense_valid</span><span class="p">(</span><span class="n">sshdr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sshdr</span><span class="o">-&gt;</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">UNIT_ATTENTION</span><span class="p">)</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">scsi_sense_valid</span><span class="p">(</span><span class="n">sshdr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="n">sshdr</span><span class="o">-&gt;</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">UNIT_ATTENTION</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">retries</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sshdr_external</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sshdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_test_unit_ready</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	scsi_device_set_state - Take the given device through the device state model.</span>
<span class="cm"> *	@sdev:	scsi device to change the state of.</span>
<span class="cm"> *	@state:	state to change to.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns zero if unsuccessful or an error if the requested </span>
<span class="cm"> *	transition is illegal.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">scsi_device_set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">scsi_device_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">scsi_device_state</span> <span class="n">oldstate</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">oldstate</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SDEV_CREATED</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">oldstate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SDEV_CREATED_BLOCK</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">illegal</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
			
	<span class="k">case</span> <span class="n">SDEV_RUNNING</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">oldstate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SDEV_CREATED</span>:
		<span class="k">case</span> <span class="n">SDEV_OFFLINE</span>:
		<span class="k">case</span> <span class="n">SDEV_QUIESCE</span>:
		<span class="k">case</span> <span class="n">SDEV_BLOCK</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">illegal</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SDEV_QUIESCE</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">oldstate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SDEV_RUNNING</span>:
		<span class="k">case</span> <span class="n">SDEV_OFFLINE</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">illegal</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SDEV_OFFLINE</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">oldstate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SDEV_CREATED</span>:
		<span class="k">case</span> <span class="n">SDEV_RUNNING</span>:
		<span class="k">case</span> <span class="n">SDEV_QUIESCE</span>:
		<span class="k">case</span> <span class="n">SDEV_BLOCK</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">illegal</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SDEV_BLOCK</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">oldstate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SDEV_RUNNING</span>:
		<span class="k">case</span> <span class="n">SDEV_CREATED_BLOCK</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">illegal</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SDEV_CREATED_BLOCK</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">oldstate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SDEV_CREATED</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">illegal</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SDEV_CANCEL</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">oldstate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SDEV_CREATED</span>:
		<span class="k">case</span> <span class="n">SDEV_RUNNING</span>:
		<span class="k">case</span> <span class="n">SDEV_QUIESCE</span>:
		<span class="k">case</span> <span class="n">SDEV_OFFLINE</span>:
		<span class="k">case</span> <span class="n">SDEV_BLOCK</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">illegal</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SDEV_DEL</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">oldstate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SDEV_CREATED</span>:
		<span class="k">case</span> <span class="n">SDEV_RUNNING</span>:
		<span class="k">case</span> <span class="n">SDEV_OFFLINE</span>:
		<span class="k">case</span> <span class="n">SDEV_CANCEL</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">illegal</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">illegal:</span>
	<span class="n">SCSI_LOG_ERROR_RECOVERY</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> 
				<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span>
					    <span class="s">&quot;Illegal state transition %s-&gt;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					    <span class="n">scsi_device_state_name</span><span class="p">(</span><span class="n">oldstate</span><span class="p">),</span>
					    <span class="n">scsi_device_state_name</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
				<span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_device_set_state</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * 	sdev_evt_emit - emit a single SCSI device uevent</span>
<span class="cm"> *	@sdev: associated SCSI device</span>
<span class="cm"> *	@evt: event to emit</span>
<span class="cm"> *</span>
<span class="cm"> *	Send a single uevent (scsi_event) to the associated scsi_device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_evt_emit</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_event</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">envp</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">evt_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SDEV_EVT_MEDIA_CHANGE</span>:
		<span class="n">envp</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;SDEV_MEDIA_CHANGE=1&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* do nothing */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">envp</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kobject_uevent_env</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_CHANGE</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * 	sdev_evt_thread - send a uevent for each scsi event</span>
<span class="cm"> *	@work: work struct for scsi_device</span>
<span class="cm"> *</span>
<span class="cm"> *	Dispatch queued events to their associated scsi_device kobjects</span>
<span class="cm"> *	as uevents.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_evt_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">event_list</span><span class="p">);</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span><span class="p">,</span> <span class="n">event_work</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_event</span> <span class="o">*</span><span class="n">evt</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_list</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">evt</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_event</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="n">scsi_evt_emit</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">evt</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">evt</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * 	sdev_evt_send - send asserted event to uevent thread</span>
<span class="cm"> *	@sdev: scsi_device event occurred on</span>
<span class="cm"> *	@evt: event to send</span>
<span class="cm"> *</span>
<span class="cm"> *	Assert scsi device event asynchronously.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sdev_evt_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_event</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* FIXME: currently this check eliminates all media change events</span>
<span class="c">	 * for polled devices.  Need to update to discriminate between AN</span>
<span class="c">	 * and polled events */</span>
<span class="c">	if (!test_bit(evt-&gt;evt_type, sdev-&gt;supported_events)) {</span>
<span class="c">		kfree(evt);</span>
<span class="c">		return;</span>
<span class="c">	}</span>
<span class="cp">#endif</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">event_work</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sdev_evt_send</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * 	sdev_evt_alloc - allocate a new scsi event</span>
<span class="cm"> *	@evt_type: type of event to allocate</span>
<span class="cm"> *	@gfpflags: GFP flags for allocation</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocates and returns a new scsi_event.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">scsi_event</span> <span class="o">*</span><span class="nf">sdev_evt_alloc</span><span class="p">(</span><span class="k">enum</span> <span class="n">scsi_device_event</span> <span class="n">evt_type</span><span class="p">,</span>
				  <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_event</span> <span class="o">*</span><span class="n">evt</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_event</span><span class="p">),</span> <span class="n">gfpflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">evt</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">evt</span><span class="o">-&gt;</span><span class="n">evt_type</span> <span class="o">=</span> <span class="n">evt_type</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

	<span class="cm">/* evt_type-specific initialization, if any */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">evt_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SDEV_EVT_MEDIA_CHANGE</span>:
	<span class="nl">default:</span>
		<span class="cm">/* do nothing */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">evt</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sdev_evt_alloc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * 	sdev_evt_send_simple - send asserted event to uevent thread</span>
<span class="cm"> *	@sdev: scsi_device event occurred on</span>
<span class="cm"> *	@evt_type: type of event to send</span>
<span class="cm"> *	@gfpflags: GFP flags for allocation</span>
<span class="cm"> *</span>
<span class="cm"> *	Assert scsi device event asynchronously, given an event type.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sdev_evt_send_simple</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">scsi_device_event</span> <span class="n">evt_type</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_event</span> <span class="o">*</span><span class="n">evt</span> <span class="o">=</span> <span class="n">sdev_evt_alloc</span><span class="p">(</span><span class="n">evt_type</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">evt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span> <span class="s">&quot;event %d eaten due to OOM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">evt_type</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sdev_evt_send</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">evt</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sdev_evt_send_simple</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	scsi_device_quiesce - Block user issued commands.</span>
<span class="cm"> *	@sdev:	scsi device to quiesce.</span>
<span class="cm"> *</span>
<span class="cm"> *	This works by trying to transition to the SDEV_QUIESCE state</span>
<span class="cm"> *	(which must be a legal transition).  When the device is in this</span>
<span class="cm"> *	state, only special requests will be accepted, all others will</span>
<span class="cm"> *	be deferred.  Since special requests may also be requeued requests,</span>
<span class="cm"> *	a successful return doesn&#39;t guarantee the device will be </span>
<span class="cm"> *	totally quiescent.</span>
<span class="cm"> *</span>
<span class="cm"> *	Must be called with user context, may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns zero if unsuccessful or an error if not.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">scsi_device_quiesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">SDEV_QUIESCE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">scsi_run_queue</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">device_busy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
		<span class="n">scsi_run_queue</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_device_quiesce</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	scsi_device_resume - Restart user issued commands to a quiesced device.</span>
<span class="cm"> *	@sdev:	scsi device to resume.</span>
<span class="cm"> *</span>
<span class="cm"> *	Moves the device from quiesced back to running and restarts the</span>
<span class="cm"> *	queues.</span>
<span class="cm"> *</span>
<span class="cm"> *	Must be called with user context, may sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_device_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* check if the device state was mutated prior to resume, and if</span>
<span class="cm">	 * so assume the state is being managed elsewhere (for example</span>
<span class="cm">	 * device deleted during suspend)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">!=</span> <span class="n">SDEV_QUIESCE</span> <span class="o">||</span>
	    <span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">SDEV_RUNNING</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">scsi_run_queue</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_device_resume</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">device_quiesce_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scsi_device_quiesce</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">scsi_target_quiesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">starget_for_each_device</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">device_quiesce_fn</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_target_quiesce</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">device_resume_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scsi_device_resume</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">scsi_target_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">starget_for_each_device</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">device_resume_fn</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_target_resume</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_internal_device_block - internal function to put a device temporarily into the SDEV_BLOCK state</span>
<span class="cm"> * @sdev:	device to block</span>
<span class="cm"> *</span>
<span class="cm"> * Block request made by scsi lld&#39;s to temporarily stop all</span>
<span class="cm"> * scsi commands on the specified device.  Called from interrupt</span>
<span class="cm"> * or normal process context.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if successful or error if not</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:       </span>
<span class="cm"> *	This routine transitions the device to the SDEV_BLOCK state</span>
<span class="cm"> *	(which must be a legal transition).  When the device is in this</span>
<span class="cm"> *	state, all commands are deferred until the scsi lld reenables</span>
<span class="cm"> *	the device with scsi_device_unblock or device_block_tmo fires.</span>
<span class="cm"> *	This routine assumes the host_lock is held on entry.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">scsi_internal_device_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">SDEV_BLOCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">SDEV_CREATED_BLOCK</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* </span>
<span class="cm">	 * The device has transitioned to SDEV_BLOCK.  Stop the</span>
<span class="cm">	 * block layer from calling the midlayer with this device&#39;s</span>
<span class="cm">	 * request queue. </span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">blk_stop_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">scsi_internal_device_block</span><span class="p">);</span>
 
<span class="cm">/**</span>
<span class="cm"> * scsi_internal_device_unblock - resume a device after a block request</span>
<span class="cm"> * @sdev:	device to resume</span>
<span class="cm"> *</span>
<span class="cm"> * Called by scsi lld&#39;s or the midlayer to restart the device queue</span>
<span class="cm"> * for the previously suspended scsi device.  Called from interrupt or</span>
<span class="cm"> * normal process context.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if successful or error if not.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:       </span>
<span class="cm"> *	This routine transitions the device to the SDEV_RUNNING state</span>
<span class="cm"> *	(which must be a legal transition) allowing the midlayer to</span>
<span class="cm"> *	goose the queue for this device.  This routine assumes the </span>
<span class="cm"> *	host_lock is held upon entry.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">scsi_internal_device_unblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span> 
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="cm">/* </span>
<span class="cm">	 * Try to transition the scsi device to SDEV_RUNNING</span>
<span class="cm">	 * and goose the device queue if successful.  </span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">==</span> <span class="n">SDEV_BLOCK</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">=</span> <span class="n">SDEV_RUNNING</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">==</span> <span class="n">SDEV_CREATED_BLOCK</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">=</span> <span class="n">SDEV_CREATED</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">!=</span> <span class="n">SDEV_CANCEL</span> <span class="o">&amp;&amp;</span>
		 <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">!=</span> <span class="n">SDEV_OFFLINE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">blk_start_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">scsi_internal_device_unblock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">device_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scsi_internal_device_block</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">target_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_is_target_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">starget_for_each_device</span><span class="p">(</span><span class="n">to_scsi_target</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="n">device_block</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">scsi_target_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_is_target_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">starget_for_each_device</span><span class="p">(</span><span class="n">to_scsi_target</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="n">device_block</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">device_for_each_child</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">target_block</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">scsi_target_block</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">device_unblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scsi_internal_device_unblock</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">target_unblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_is_target_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">starget_for_each_device</span><span class="p">(</span><span class="n">to_scsi_target</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="n">device_unblock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">scsi_target_unblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_is_target_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">starget_for_each_device</span><span class="p">(</span><span class="n">to_scsi_target</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="n">device_unblock</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">device_for_each_child</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">target_unblock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">scsi_target_unblock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_kmap_atomic_sg - find and atomically map an sg-elemnt</span>
<span class="cm"> * @sgl:	scatter-gather list</span>
<span class="cm"> * @sg_count:	number of segments in sg</span>
<span class="cm"> * @offset:	offset in bytes into sg, on return offset into the mapped area</span>
<span class="cm"> * @len:	bytes to map, on return number of bytes mapped</span>
<span class="cm"> *</span>
<span class="cm"> * Returns virtual address of the start of the mapped page</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">scsi_kmap_atomic_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sg_count</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">sg_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len_complete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">sg_count</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len_complete</span> <span class="o">=</span> <span class="n">sg_len</span><span class="p">;</span> <span class="cm">/* Complete sg-entries */</span>
		<span class="n">sg_len</span> <span class="o">+=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sg_len</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">sg_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Bytes in sg: %zu, requested offset %zu, &quot;</span>
			<span class="s">&quot;elements %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">sg_len</span><span class="p">,</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="n">sg_count</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Offset starting from the beginning of first page in this sg-entry */</span>
	<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">offset</span> <span class="o">-</span> <span class="n">len_complete</span> <span class="o">+</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>

	<span class="cm">/* Assumption: contiguous pages can be accessed as &quot;page + i&quot; */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">nth_page</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
	<span class="o">*</span><span class="n">offset</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="cm">/* Bytes in this sg-entry from *offset to the end of the page */</span>
	<span class="n">sg_len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="o">*</span><span class="n">offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">sg_len</span><span class="p">)</span>
		<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">sg_len</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_kmap_atomic_sg</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_kunmap_atomic_sg - atomically unmap a virtual address, previously mapped with scsi_kmap_atomic_sg</span>
<span class="cm"> * @virt:	virtual address to be unmapped</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_kunmap_atomic_sg</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">virt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">virt</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_kunmap_atomic_sg</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
