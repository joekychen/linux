<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › scsi_transport_spi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>scsi_transport_spi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* </span>
<span class="cm"> *  Parallel SCSI (SPI) transport specific attributes exported to sysfs.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2003 Silicon Graphics, Inc.  All rights reserved.</span>
<span class="cm"> *  Copyright (c) 2004, 2005 James Bottomley &lt;James.Bottomley@SteelEye.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &quot;scsi_priv.h&quot;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_spi.h&gt;</span>

<span class="cp">#define SPI_NUM_ATTRS 14	</span><span class="cm">/* increase this if you add attributes */</span><span class="cp"></span>
<span class="cp">#define SPI_OTHER_ATTRS 1	</span><span class="cm">/* Increase this if you add &quot;always</span>
<span class="cm">				 * on&quot; attributes */</span><span class="cp"></span>
<span class="cp">#define SPI_HOST_ATTRS	1</span>

<span class="cp">#define SPI_MAX_ECHO_BUFFER_SIZE	4096</span>

<span class="cp">#define DV_LOOPS	3</span>
<span class="cp">#define DV_TIMEOUT	(10*HZ)</span>
<span class="cp">#define DV_RETRIES	3	</span><span class="cm">/* should only need at most </span>
<span class="cm">				 * two cc/ua clears */</span><span class="cp"></span>

<span class="cm">/* Our blacklist flags */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SPI_BLIST_NOIUS</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* blacklist table, modelled on scsi_devinfo.c */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">vendor</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">model</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">spi_static_device_list</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="s">&quot;HP&quot;</span><span class="p">,</span> <span class="s">&quot;Ultrium 3-SCSI&quot;</span><span class="p">,</span> <span class="n">SPI_BLIST_NOIUS</span> <span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;IBM&quot;</span><span class="p">,</span> <span class="s">&quot;ULTRIUM-TD3&quot;</span><span class="p">,</span> <span class="n">SPI_BLIST_NOIUS</span> <span class="p">},</span>
	<span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* Private data accessors (keep these out of the header file) */</span>
<span class="cp">#define spi_dv_in_progress(x) (((struct spi_transport_attrs *)&amp;(x)-&gt;starget_data)-&gt;dv_in_progress)</span>
<span class="cp">#define spi_dv_mutex(x) (((struct spi_transport_attrs *)&amp;(x)-&gt;starget_data)-&gt;dv_mutex)</span>

<span class="k">struct</span> <span class="n">spi_internal</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_function_template</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define to_spi_internal(tmpl)	container_of(tmpl, struct spi_internal, t)</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ppr_to_ps</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* The PPR values 0-6 are reserved, fill them in when</span>
<span class="cm">	 * the committee defines them */</span>
	<span class="o">-</span><span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 0x00 */</span>
	<span class="o">-</span><span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 0x01 */</span>
	<span class="o">-</span><span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 0x02 */</span>
	<span class="o">-</span><span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 0x03 */</span>
	<span class="o">-</span><span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 0x04 */</span>
	<span class="o">-</span><span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 0x05 */</span>
	<span class="o">-</span><span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 0x06 */</span>
	 <span class="mi">3125</span><span class="p">,</span>			<span class="cm">/* 0x07 */</span>
	 <span class="mi">6250</span><span class="p">,</span>			<span class="cm">/* 0x08 */</span>
	<span class="mi">12500</span><span class="p">,</span>			<span class="cm">/* 0x09 */</span>
	<span class="mi">25000</span><span class="p">,</span>			<span class="cm">/* 0x0a */</span>
	<span class="mi">30300</span><span class="p">,</span>			<span class="cm">/* 0x0b */</span>
	<span class="mi">50000</span><span class="p">,</span>			<span class="cm">/* 0x0c */</span>
<span class="p">};</span>
<span class="cm">/* The PPR values at which you calculate the period in ns by multiplying</span>
<span class="cm"> * by 4 */</span>
<span class="cp">#define SPI_STATIC_PPR	0x0c</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sprint_frac</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">denom</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">frac</span> <span class="o">=</span> <span class="n">value</span> <span class="o">%</span> <span class="n">denom</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">value</span> <span class="o">/</span> <span class="n">denom</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frac</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">dest</span><span class="p">[</span><span class="n">result</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;.&#39;</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">denom</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">dest</span> <span class="o">+</span> <span class="n">result</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">frac</span> <span class="o">/</span> <span class="n">denom</span><span class="p">);</span>
		<span class="n">result</span><span class="o">++</span><span class="p">;</span>
		<span class="n">frac</span> <span class="o">%=</span> <span class="n">denom</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">frac</span><span class="p">);</span>

	<span class="n">dest</span><span class="p">[</span><span class="n">result</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_execute</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
		       <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
		       <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">bufflen</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="n">sshdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sense</span><span class="p">[</span><span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">];</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DV_RETRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">scsi_execute</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">bufflen</span><span class="p">,</span>
				      <span class="n">sense</span><span class="p">,</span> <span class="n">DV_TIMEOUT</span><span class="p">,</span> <span class="cm">/* retries */</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="n">REQ_FAILFAST_DEV</span> <span class="o">|</span>
				      <span class="n">REQ_FAILFAST_TRANSPORT</span> <span class="o">|</span>
				      <span class="n">REQ_FAILFAST_DRIVER</span><span class="p">,</span>
				      <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">driver_byte</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DRIVER_SENSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr_tmp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sshdr</span><span class="p">)</span>
				<span class="n">sshdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sshdr_tmp</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">scsi_normalize_sense</span><span class="p">(</span><span class="n">sense</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span>
						 <span class="n">sshdr</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="o">-&gt;</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">UNIT_ATTENTION</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">spi_signal_type</span>	<span class="n">value</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">signal_types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">SPI_SIGNAL_UNKNOWN</span><span class="p">,</span> <span class="s">&quot;unknown&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">SPI_SIGNAL_SE</span><span class="p">,</span> <span class="s">&quot;SE&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">SPI_SIGNAL_LVD</span><span class="p">,</span> <span class="s">&quot;LVD&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">SPI_SIGNAL_HVD</span><span class="p">,</span> <span class="s">&quot;HVD&quot;</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">spi_signal_to_string</span><span class="p">(</span><span class="k">enum</span> <span class="n">spi_signal_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">signal_types</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">signal_types</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">signal_types</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">spi_signal_type</span> <span class="nf">spi_signal_to_value</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">signal_types</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span>  <span class="n">strlen</span><span class="p">(</span><span class="n">signal_types</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">signal_types</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span> <span class="o">||</span> <span class="n">name</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">signal_types</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">SPI_SIGNAL_UNKNOWN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_host_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spi_signalling</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">SPI_SIGNAL_UNKNOWN</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">spi_host_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DECLARE_TRANSPORT_CLASS</span><span class="p">(</span><span class="n">spi_host_class</span><span class="p">,</span>
			       <span class="s">&quot;spi_host&quot;</span><span class="p">,</span>
			       <span class="n">spi_host_setup</span><span class="p">,</span>
			       <span class="nb">NULL</span><span class="p">,</span>
			       <span class="n">spi_host_configure</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_host_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">attribute_container</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_is_host_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span>  <span class="o">||</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="o">-&gt;</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">class</span>
	    <span class="o">!=</span> <span class="o">&amp;</span><span class="n">spi_host_class</span><span class="p">.</span><span class="n">class</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="o">-&gt;</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span> <span class="o">==</span> <span class="n">cont</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">spi_target_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_device_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">bflags</span> <span class="o">=</span> <span class="n">scsi_get_device_flags_keyed</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>
						      <span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span>
						      <span class="n">SCSI_DEVINFO_SPI</span><span class="p">);</span>

	<span class="cm">/* Populate the target capability fields with the values</span>
<span class="cm">	 * gleaned from the device inquiry */</span>

	<span class="n">spi_support_sync</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">scsi_device_sync</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">spi_support_wide</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">scsi_device_wide</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">spi_support_dt</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">scsi_device_dt</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">spi_support_dt_only</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">scsi_device_dt_only</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">spi_support_ius</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">scsi_device_ius</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bflags</span> <span class="o">&amp;</span> <span class="n">SPI_BLIST_NOIUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Information Units disabled by blacklist</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spi_support_ius</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spi_support_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">scsi_device_qas</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_setup_transport_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">to_scsi_target</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spi_period</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* illegal value */</span>
	<span class="n">spi_min_period</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_offset</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* async */</span>
	<span class="n">spi_max_offset</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
	<span class="n">spi_width</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* narrow */</span>
	<span class="n">spi_max_width</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spi_iu</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* no IU */</span>
	<span class="n">spi_max_iu</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spi_dt</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* ST */</span>
	<span class="n">spi_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_max_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spi_wr_flow</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_rd_strm</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_rti</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_pcomp_en</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_hold_mcs</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_dv_pending</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_dv_in_progress</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_initial_dv</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_dv_mutex</span><span class="p">(</span><span class="n">starget</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define spi_transport_show_simple(field, format_string)			\</span>
<span class="cp">									\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">show_spi_transport_##field(struct device *dev, 			\</span>
<span class="cp">			   struct device_attribute *attr, char *buf)	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct scsi_target *starget = transport_class_to_starget(dev);	\</span>
<span class="cp">	struct spi_transport_attrs *tp;					\</span>
<span class="cp">									\</span>
<span class="cp">	tp = (struct spi_transport_attrs *)&amp;starget-&gt;starget_data;	\</span>
<span class="cp">	return snprintf(buf, 20, format_string, tp-&gt;field);		\</span>
<span class="cp">}</span>

<span class="cp">#define spi_transport_store_simple(field, format_string)		\</span>
<span class="cp">									\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">store_spi_transport_##field(struct device *dev, 			\</span>
<span class="cp">			    struct device_attribute *attr, 		\</span>
<span class="cp">			    const char *buf, size_t count)		\</span>
<span class="cp">{									\</span>
<span class="cp">	int val;							\</span>
<span class="cp">	struct scsi_target *starget = transport_class_to_starget(dev);	\</span>
<span class="cp">	struct spi_transport_attrs *tp;					\</span>
<span class="cp">									\</span>
<span class="cp">	tp = (struct spi_transport_attrs *)&amp;starget-&gt;starget_data;	\</span>
<span class="cp">	val = simple_strtoul(buf, NULL, 0);				\</span>
<span class="cp">	tp-&gt;field = val;						\</span>
<span class="cp">	return count;							\</span>
<span class="cp">}</span>

<span class="cp">#define spi_transport_show_function(field, format_string)		\</span>
<span class="cp">									\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">show_spi_transport_##field(struct device *dev, 			\</span>
<span class="cp">			   struct device_attribute *attr, char *buf)	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct scsi_target *starget = transport_class_to_starget(dev);	\</span>
<span class="cp">	struct Scsi_Host *shost = dev_to_shost(starget-&gt;dev.parent);	\</span>
<span class="cp">	struct spi_transport_attrs *tp;					\</span>
<span class="cp">	struct spi_internal *i = to_spi_internal(shost-&gt;transportt);	\</span>
<span class="cp">	tp = (struct spi_transport_attrs *)&amp;starget-&gt;starget_data;	\</span>
<span class="cp">	if (i-&gt;f-&gt;get_##field)						\</span>
<span class="cp">		i-&gt;f-&gt;get_##field(starget);				\</span>
<span class="cp">	return snprintf(buf, 20, format_string, tp-&gt;field);		\</span>
<span class="cp">}</span>

<span class="cp">#define spi_transport_store_function(field, format_string)		\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">store_spi_transport_##field(struct device *dev, 			\</span>
<span class="cp">			    struct device_attribute *attr,		\</span>
<span class="cp">			    const char *buf, size_t count)		\</span>
<span class="cp">{									\</span>
<span class="cp">	int val;							\</span>
<span class="cp">	struct scsi_target *starget = transport_class_to_starget(dev);	\</span>
<span class="cp">	struct Scsi_Host *shost = dev_to_shost(starget-&gt;dev.parent);	\</span>
<span class="cp">	struct spi_internal *i = to_spi_internal(shost-&gt;transportt);	\</span>
<span class="cp">									\</span>
<span class="cp">	if (!i-&gt;f-&gt;set_##field)						\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	val = simple_strtoul(buf, NULL, 0);				\</span>
<span class="cp">	i-&gt;f-&gt;set_##field(starget, val);				\</span>
<span class="cp">	return count;							\</span>
<span class="cp">}</span>

<span class="cp">#define spi_transport_store_max(field, format_string)			\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">store_spi_transport_##field(struct device *dev, 			\</span>
<span class="cp">			    struct device_attribute *attr,		\</span>
<span class="cp">			    const char *buf, size_t count)		\</span>
<span class="cp">{									\</span>
<span class="cp">	int val;							\</span>
<span class="cp">	struct scsi_target *starget = transport_class_to_starget(dev);	\</span>
<span class="cp">	struct Scsi_Host *shost = dev_to_shost(starget-&gt;dev.parent);	\</span>
<span class="cp">	struct spi_internal *i = to_spi_internal(shost-&gt;transportt);	\</span>
<span class="cp">	struct spi_transport_attrs *tp					\</span>
<span class="cp">		= (struct spi_transport_attrs *)&amp;starget-&gt;starget_data;	\</span>
<span class="cp">									\</span>
<span class="cp">	if (i-&gt;f-&gt;set_##field)						\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	val = simple_strtoul(buf, NULL, 0);				\</span>
<span class="cp">	if (val &gt; tp-&gt;max_##field)					\</span>
<span class="cp">		val = tp-&gt;max_##field;					\</span>
<span class="cp">	i-&gt;f-&gt;set_##field(starget, val);				\</span>
<span class="cp">	return count;							\</span>
<span class="cp">}</span>

<span class="cp">#define spi_transport_rd_attr(field, format_string)			\</span>
<span class="cp">	spi_transport_show_function(field, format_string)		\</span>
<span class="cp">	spi_transport_store_function(field, format_string)		\</span>
<span class="cp">static DEVICE_ATTR(field, S_IRUGO,				\</span>
<span class="cp">		   show_spi_transport_##field,			\</span>
<span class="cp">		   store_spi_transport_##field);</span>

<span class="cp">#define spi_transport_simple_attr(field, format_string)			\</span>
<span class="cp">	spi_transport_show_simple(field, format_string)			\</span>
<span class="cp">	spi_transport_store_simple(field, format_string)		\</span>
<span class="cp">static DEVICE_ATTR(field, S_IRUGO,				\</span>
<span class="cp">		   show_spi_transport_##field,			\</span>
<span class="cp">		   store_spi_transport_##field);</span>

<span class="cp">#define spi_transport_max_attr(field, format_string)			\</span>
<span class="cp">	spi_transport_show_function(field, format_string)		\</span>
<span class="cp">	spi_transport_store_max(field, format_string)			\</span>
<span class="cp">	spi_transport_simple_attr(max_##field, format_string)		\</span>
<span class="cp">static DEVICE_ATTR(field, S_IRUGO,				\</span>
<span class="cp">		   show_spi_transport_##field,			\</span>
<span class="cp">		   store_spi_transport_##field);</span>

<span class="cm">/* The Parallel SCSI Tranport Attributes: */</span>
<span class="n">spi_transport_max_attr</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">spi_transport_max_attr</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">spi_transport_max_attr</span><span class="p">(</span><span class="n">iu</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">spi_transport_rd_attr</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">spi_transport_max_attr</span><span class="p">(</span><span class="n">qas</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">spi_transport_rd_attr</span><span class="p">(</span><span class="n">wr_flow</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">spi_transport_rd_attr</span><span class="p">(</span><span class="n">rd_strm</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">spi_transport_rd_attr</span><span class="p">(</span><span class="n">rti</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">spi_transport_rd_attr</span><span class="p">(</span><span class="n">pcomp_en</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">spi_transport_rd_attr</span><span class="p">(</span><span class="n">hold_mcs</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/* we only care about the first child device that&#39;s a real SCSI device</span>
<span class="cm"> * so we return 1 to terminate the iteration when we find it */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">child_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_is_sdev_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spi_dv_device</span><span class="p">(</span><span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_spi_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">transport_class_to_starget</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">device_for_each_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">child_iter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">revalidate</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">store_spi_revalidate</span><span class="p">);</span>

<span class="cm">/* Translate the period into ns according to the current spec</span>
<span class="cm"> * for SDTR/PPR messages */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">period_to_str</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">period</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">picosec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">period</span> <span class="o">&gt;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">picosec</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="n">SPI_STATIC_PPR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">picosec</span> <span class="o">=</span> <span class="n">ppr_to_ps</span><span class="p">[</span><span class="n">period</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">picosec</span> <span class="o">=</span> <span class="n">period</span> <span class="o">*</span> <span class="mi">4000</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">picosec</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;reserved&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprint_frac</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">picosec</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_spi_transport_period_helper</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">period</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">period_to_str</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_spi_transport_period_helper</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">periodp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">picosec</span><span class="p">,</span> <span class="n">period</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>

	<span class="n">picosec</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">endp</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">mult</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">endp</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="o">*</span><span class="n">endp</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">picosec</span> <span class="o">+=</span> <span class="p">(</span><span class="o">*</span><span class="n">endp</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">mult</span><span class="p">;</span>
			<span class="n">mult</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mult</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">SPI_STATIC_PPR</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ppr_to_ps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">picosec</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">picosec</span> <span class="o">/</span> <span class="mi">4000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&gt;</span> <span class="mh">0xff</span><span class="p">)</span>
		<span class="n">period</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="o">*</span><span class="n">periodp</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_spi_transport_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">transport_class_to_starget</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_spi_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_transport_attrs</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">spi_transport_attrs</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">starget_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_period</span><span class="p">)</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_period</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">show_spi_transport_period_helper</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_spi_transport_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">transport_class_to_starget</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_spi_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_transport_attrs</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">spi_transport_attrs</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">starget_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">period</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">set_period</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">store_spi_transport_period_helper</span><span class="p">(</span><span class="n">cdev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">period</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">min_period</span><span class="p">)</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">min_period</span><span class="p">;</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">set_period</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		   <span class="n">show_spi_transport_period</span><span class="p">,</span>
		   <span class="n">store_spi_transport_period</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_spi_transport_min_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">transport_class_to_starget</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_spi_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_transport_attrs</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">spi_transport_attrs</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">starget_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">set_period</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">show_spi_transport_period_helper</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">min_period</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_spi_transport_min_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">transport_class_to_starget</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_transport_attrs</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">spi_transport_attrs</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">starget_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">store_spi_transport_period_helper</span><span class="p">(</span><span class="n">cdev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">min_period</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">min_period</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		   <span class="n">show_spi_transport_min_period</span><span class="p">,</span>
		   <span class="n">store_spi_transport_min_period</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_spi_host_signalling</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_spi_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_signalling</span><span class="p">)</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_signalling</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">spi_signal_to_string</span><span class="p">(</span><span class="n">spi_signalling</span><span class="p">(</span><span class="n">shost</span><span class="p">)));</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_spi_host_signalling</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_spi_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">spi_signal_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">spi_signal_to_value</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">set_signalling</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SPI_SIGNAL_UNKNOWN</span><span class="p">)</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">set_signalling</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">signalling</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		   <span class="n">show_spi_host_signalling</span><span class="p">,</span>
		   <span class="n">store_spi_host_signalling</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_spi_host_width</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">==</span> <span class="mi">16</span> <span class="o">?</span> <span class="s">&quot;wide&quot;</span> <span class="o">:</span> <span class="s">&quot;narrow&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">host_width</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		   <span class="n">show_spi_host_width</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_spi_host_hba_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">this_id</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">hba_id</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		   <span class="n">show_spi_host_hba_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cp">#define DV_SET(x, y)			\</span>
<span class="cp">	if(i-&gt;f-&gt;set_##x)		\</span>
<span class="cp">		i-&gt;f-&gt;set_##x(sdev-&gt;sdev_target, y)</span>

<span class="k">enum</span> <span class="n">spi_compare_returns</span> <span class="p">{</span>
	<span class="n">SPI_COMPARE_SUCCESS</span><span class="p">,</span>
	<span class="n">SPI_COMPARE_FAILURE</span><span class="p">,</span>
	<span class="n">SPI_COMPARE_SKIP_TEST</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* This is for read/write Domain Validation:  If the device supports</span>
<span class="cm"> * an echo buffer, we do read/write tests to it */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">spi_compare_returns</span>
<span class="nf">spi_dv_device_echo_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			  <span class="n">u8</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">retries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pattern</span> <span class="o">=</span> <span class="mh">0x0000ffff</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>

	<span class="k">const</span> <span class="kt">char</span> <span class="n">spi_write_buffer</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">WRITE_BUFFER</span><span class="p">,</span> <span class="mh">0x0a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="n">len</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mi">0</span>
	<span class="p">};</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">spi_read_buffer</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">READ_BUFFER</span><span class="p">,</span> <span class="mh">0x0a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="n">len</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mi">0</span>
	<span class="p">};</span>

	<span class="cm">/* set up the pattern buffer.  Doesn&#39;t matter if we spill</span>
<span class="cm">	 * slightly beyond since that&#39;s where the read buffer is */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* fill the buffer with counting (test a) */</span>
		<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">buffer</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="cm">/* fill the buffer with alternating words of 0x0 and</span>
<span class="cm">		 * 0xffff (test b) */</span>
		<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">32</span><span class="p">);</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			
			<span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x0000</span> <span class="o">:</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="cm">/* fill with crosstalk (alternating 0x5555 0xaaa)</span>
<span class="cm">                 * (test c) */</span>
		<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">32</span><span class="p">);</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

			<span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x5555</span> <span class="o">:</span> <span class="mh">0xaaaa</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="cm">/* fill with shifting bits (test d) */</span>
		<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">32</span><span class="p">);</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="n">u32</span> <span class="n">roll</span> <span class="o">=</span> <span class="p">(</span><span class="n">pattern</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
			
			<span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">;</span>
			<span class="n">pattern</span> <span class="o">=</span> <span class="p">(</span><span class="n">pattern</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">roll</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* don&#39;t bother with random data (test e) */</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">retries</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">spi_execute</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">spi_write_buffer</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">,</span>
				     <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">||</span> <span class="o">!</span><span class="n">scsi_device_online</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">SDEV_QUIESCE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scsi_sense_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sshdr</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">ILLEGAL_REQUEST</span>
			    <span class="cm">/* INVALID FIELD IN CDB */</span>
			    <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mh">0x24</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span>
				<span class="cm">/* This would mean that the drive lied</span>
<span class="cm">				 * to us about supporting an echo</span>
<span class="cm">				 * buffer (unfortunately some Western</span>
<span class="cm">				 * Digital drives do precisely this)</span>
<span class="cm">				 */</span>
				<span class="k">return</span> <span class="n">SPI_COMPARE_SKIP_TEST</span><span class="p">;</span>


			<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span> <span class="s">&quot;Write Buffer failure %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">SPI_COMPARE_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">spi_execute</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">spi_read_buffer</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">,</span>
			    <span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">SDEV_QUIESCE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SPI_COMPARE_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">SPI_COMPARE_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is for the simplest form of Domain Validation: a read test</span>
<span class="cm"> * on the inquiry data from the device */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">spi_compare_returns</span>
<span class="nf">spi_dv_device_compare_inquiry</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			      <span class="n">u8</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">retries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">spi_inquiry</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">INQUIRY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span>
	<span class="p">};</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">retries</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">spi_execute</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">spi_inquiry</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">,</span>
				     <span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		
		<span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">||</span> <span class="o">!</span><span class="n">scsi_device_online</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">SDEV_QUIESCE</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">SPI_COMPARE_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If we don&#39;t have the inquiry data already, the</span>
<span class="cm">		 * first read gets it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ptr</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="o">--</span><span class="n">r</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="cm">/* failure */</span>
			<span class="k">return</span> <span class="n">SPI_COMPARE_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">SPI_COMPARE_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">spi_compare_returns</span>
<span class="nf">spi_dv_retrain</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
	       <span class="k">enum</span> <span class="n">spi_compare_returns</span> 
	       <span class="p">(</span><span class="o">*</span><span class="n">compare_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_spi_internal</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">period</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">prevperiod</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
	<span class="k">enum</span> <span class="n">spi_compare_returns</span> <span class="n">retval</span><span class="p">;</span>


	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">newperiod</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">compare_fn</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">DV_LOOPS</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">SPI_COMPARE_SUCCESS</span>
		    <span class="o">||</span> <span class="n">retval</span> <span class="o">==</span> <span class="n">SPI_COMPARE_SKIP_TEST</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* OK, retrain, fallback */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_iu</span><span class="p">)</span>
			<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_iu</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_qas</span><span class="p">)</span>
			<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_period</span><span class="p">)</span>
			<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_period</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">);</span>

		<span class="cm">/* Here&#39;s the fallback sequence; first try turning off</span>
<span class="cm">		 * IU, then QAS (if we can control them), then finally</span>
<span class="cm">		 * fall down the periods */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">set_iu</span> <span class="o">&amp;&amp;</span> <span class="n">spi_iu</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">starget</span><span class="p">,</span> <span class="s">&quot;Domain Validation Disabing Information Units</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">DV_SET</span><span class="p">(</span><span class="n">iu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">set_qas</span> <span class="o">&amp;&amp;</span> <span class="n">spi_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">starget</span><span class="p">,</span> <span class="s">&quot;Domain Validation Disabing Quick Arbitration and Selection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">DV_SET</span><span class="p">(</span><span class="n">qas</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">newperiod</span> <span class="o">=</span> <span class="n">spi_period</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
			<span class="n">period</span> <span class="o">=</span> <span class="n">newperiod</span> <span class="o">&gt;</span> <span class="n">period</span> <span class="o">?</span> <span class="n">newperiod</span> <span class="o">:</span> <span class="n">period</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&lt;</span> <span class="mh">0x0d</span><span class="p">)</span>
				<span class="n">period</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">period</span> <span class="o">+=</span> <span class="n">period</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">period</span> <span class="o">&gt;</span> <span class="mh">0xff</span> <span class="o">||</span> <span class="n">period</span> <span class="o">==</span> <span class="n">prevperiod</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Total failure; set to async and return */</span>
				<span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">starget</span><span class="p">,</span> <span class="s">&quot;Domain Validation Failure, dropping back to Asynchronous</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">DV_SET</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">SPI_COMPARE_FAILURE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">starget</span><span class="p">,</span> <span class="s">&quot;Domain Validation detected failure, dropping back</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">DV_SET</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
			<span class="n">prevperiod</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spi_dv_device_get_echo_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* first off do a test unit ready.  This can error out </span>
<span class="cm">	 * because of reservations or some other reason.  If it</span>
<span class="cm">	 * fails, the device won&#39;t let us write to the echo buffer</span>
<span class="cm">	 * so just return failure */</span>
	
	<span class="k">const</span> <span class="kt">char</span> <span class="n">spi_test_unit_ready</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">TEST_UNIT_READY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="p">};</span>

	<span class="k">const</span> <span class="kt">char</span> <span class="n">spi_read_buffer_descriptor</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">READ_BUFFER</span><span class="p">,</span> <span class="mh">0x0b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span>
	<span class="p">};</span>

	
	<span class="cm">/* We send a set of three TURs to clear any outstanding </span>
<span class="cm">	 * unit attention conditions if they exist (Otherwise the</span>
<span class="cm">	 * buffer tests won&#39;t be happy).  If the TUR still fails</span>
<span class="cm">	 * (reservation conflict, device not ready, etc) just</span>
<span class="cm">	 * skip the write tests */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">spi_execute</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">spi_test_unit_ready</span><span class="p">,</span> <span class="n">DMA_NONE</span><span class="p">,</span> 
				     <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* TUR succeeded */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">spi_execute</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">spi_read_buffer_descriptor</span><span class="p">,</span> 
			     <span class="n">DMA_FROM_DEVICE</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="cm">/* Device has no echo buffer */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="p">((</span><span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">spi_dv_device_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_spi_internal</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_period</span> <span class="o">=</span> <span class="n">spi_min_period</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">max_width</span> <span class="o">=</span> <span class="n">spi_max_width</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
	<span class="cm">/* first set us up for narrow async */</span>
	<span class="n">DV_SET</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">DV_SET</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spi_dv_device_compare_inquiry</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">DV_LOOPS</span><span class="p">)</span>
	    <span class="o">!=</span> <span class="n">SPI_COMPARE_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">starget</span><span class="p">,</span> <span class="s">&quot;Domain Validation Initial Inquiry Failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* FIXME: should probably offline the device here? */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spi_support_wide</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spi_max_width</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">max_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* test width */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">set_width</span> <span class="o">&amp;&amp;</span> <span class="n">max_width</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">set_width</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">spi_dv_device_compare_inquiry</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span>
						   <span class="n">buffer</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span>
						   <span class="n">DV_LOOPS</span><span class="p">)</span>
		    <span class="o">!=</span> <span class="n">SPI_COMPARE_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">starget</span><span class="p">,</span> <span class="s">&quot;Wide Transfers Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">set_width</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="cm">/* Make sure we don&#39;t force wide back on by asking</span>
<span class="cm">			 * for a transfer period that requires it */</span>
			<span class="n">max_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">min_period</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
				<span class="n">min_period</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">set_period</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* device can&#39;t handle synchronous */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spi_support_sync</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">spi_support_dt</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* len == -1 is the signal that we need to ascertain the</span>
<span class="cm">	 * presence of an echo buffer before trying to use it.  len ==</span>
<span class="cm">	 * 0 means we don&#39;t have an echo buffer */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

 <span class="nl">retry:</span>

	<span class="cm">/* now set up to the maximum */</span>
	<span class="n">DV_SET</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">spi_max_offset</span><span class="p">(</span><span class="n">starget</span><span class="p">));</span>
	<span class="n">DV_SET</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="n">min_period</span><span class="p">);</span>

	<span class="cm">/* try QAS requests; this should be harmless to set if the</span>
<span class="cm">	 * target supports it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spi_support_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">spi_max_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DV_SET</span><span class="p">(</span><span class="n">qas</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DV_SET</span><span class="p">(</span><span class="n">qas</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spi_support_ius</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">spi_max_iu</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">min_period</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This u320 (or u640). Set IU transfers */</span>
		<span class="n">DV_SET</span><span class="p">(</span><span class="n">iu</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* Then set the optional parameters */</span>
		<span class="n">DV_SET</span><span class="p">(</span><span class="n">rd_strm</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">DV_SET</span><span class="p">(</span><span class="n">wr_flow</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">DV_SET</span><span class="p">(</span><span class="n">rti</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">min_period</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span>
			<span class="n">DV_SET</span><span class="p">(</span><span class="n">pcomp_en</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DV_SET</span><span class="p">(</span><span class="n">iu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* now that we&#39;ve done all this, actually check the bus</span>
<span class="cm">	 * signal type (if known).  Some devices are stupid on</span>
<span class="cm">	 * a SE bus and still claim they can try LVD only settings */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_signalling</span><span class="p">)</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_signalling</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spi_signalling</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">==</span> <span class="n">SPI_SIGNAL_SE</span> <span class="o">||</span>
	    <span class="n">spi_signalling</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">==</span> <span class="n">SPI_SIGNAL_HVD</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">spi_support_dt</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DV_SET</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DV_SET</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* set width last because it will pull all the other</span>
<span class="cm">	 * parameters down to required values */</span>
	<span class="n">DV_SET</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">max_width</span><span class="p">);</span>

	<span class="cm">/* Do the read only INQUIRY tests */</span>
	<span class="n">spi_dv_retrain</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span><span class="p">,</span>
		       <span class="n">spi_dv_device_compare_inquiry</span><span class="p">);</span>
	<span class="cm">/* See if we actually managed to negotiate and sustain DT */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_dt</span><span class="p">)</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">get_dt</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>

	<span class="cm">/* see if the device has an echo buffer.  If it does we can do</span>
<span class="cm">	 * the SPI pattern write tests.  Because of some broken</span>
<span class="cm">	 * devices, we *only* try this on a device that has actually</span>
<span class="cm">	 * negotiated DT */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">spi_dt</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">spi_dv_device_get_echo_buffer</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">starget</span><span class="p">,</span> <span class="s">&quot;Domain Validation skipping write tests</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">SPI_MAX_ECHO_BUFFER_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">starget</span><span class="p">,</span> <span class="s">&quot;Echo buffer size %d is too big, trimming to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">SPI_MAX_ECHO_BUFFER_SIZE</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">SPI_MAX_ECHO_BUFFER_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spi_dv_retrain</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span>
			   <span class="n">spi_dv_device_echo_buffer</span><span class="p">)</span>
	    <span class="o">==</span> <span class="n">SPI_COMPARE_SKIP_TEST</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* OK, the stupid drive can&#39;t do a write echo buffer</span>
<span class="cm">		 * test after all, fall back to the read tests */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**	spi_dv_device - Do Domain Validation on the device</span>
<span class="cm"> *	@sdev:		scsi device to validate</span>
<span class="cm"> *</span>
<span class="cm"> *	Performs the domain validation on the given device in the</span>
<span class="cm"> *	current execution thread.  Since DV operations may sleep,</span>
<span class="cm"> *	the current thread must have user context.  Also no SCSI</span>
<span class="cm"> *	related locks that would deadlock I/O issued by the DV may</span>
<span class="cm"> *	be held.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">spi_dv_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">SPI_MAX_ECHO_BUFFER_SIZE</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">spi_dv_in_progress</span><span class="p">(</span><span class="n">starget</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scsi_device_get</span><span class="p">(</span><span class="n">sdev</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spi_dv_in_progress</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="cm">/* We need to verify that the actual device will quiesce; the</span>
<span class="cm">	 * later target quiesce is just a nice to have */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scsi_device_quiesce</span><span class="p">(</span><span class="n">sdev</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">scsi_target_quiesce</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>

	<span class="n">spi_dv_pending</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_dv_mutex</span><span class="p">(</span><span class="n">starget</span><span class="p">));</span>

	<span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">starget</span><span class="p">,</span> <span class="s">&quot;Beginning Domain Validation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">spi_dv_device_internal</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

	<span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">starget</span><span class="p">,</span> <span class="s">&quot;Ending Domain Validation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_dv_mutex</span><span class="p">(</span><span class="n">starget</span><span class="p">));</span>
	<span class="n">spi_dv_pending</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">scsi_target_resume</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>

	<span class="n">spi_initial_dv</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

 <span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
 <span class="nl">out_put:</span>
	<span class="n">spi_dv_in_progress</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">spi_dv_device</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">work_queue_wrapper</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span>	<span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">spi_dv_device_work_wrapper</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_queue_wrapper</span> <span class="o">*</span><span class="n">wqw</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_queue_wrapper</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">wqw</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">wqw</span><span class="p">);</span>
	<span class="n">spi_dv_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">spi_dv_pending</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	spi_schedule_dv_device - schedule domain validation to occur on the device</span>
<span class="cm"> *	@sdev:	The device to validate</span>
<span class="cm"> *</span>
<span class="cm"> *	Identical to spi_dv_device() above, except that the DV will be</span>
<span class="cm"> *	scheduled to occur in a workqueue later.  All memory allocations</span>
<span class="cm"> *	are atomic, so may be called from any context including those holding</span>
<span class="cm"> *	SCSI locks.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">spi_schedule_dv_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_queue_wrapper</span> <span class="o">*</span><span class="n">wqw</span> <span class="o">=</span>
		<span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_queue_wrapper</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">wqw</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">spi_dv_pending</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">wqw</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Set pending early (dv_device doesn&#39;t check it, only sets it) */</span>
	<span class="n">spi_dv_pending</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scsi_device_get</span><span class="p">(</span><span class="n">sdev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">wqw</span><span class="p">);</span>
		<span class="n">spi_dv_pending</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wqw</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">spi_dv_device_work_wrapper</span><span class="p">);</span>
	<span class="n">wqw</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sdev</span><span class="p">;</span>

	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wqw</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">spi_schedule_dv_device</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * spi_display_xfer_agreement - Print the current target transfer agreement</span>
<span class="cm"> * @starget: The target for which to display the agreement</span>
<span class="cm"> *</span>
<span class="cm"> * Each SPI port is required to maintain a transfer agreement for each</span>
<span class="cm"> * other port on the bus.  This function prints a one-line summary of</span>
<span class="cm"> * the current agreement; more detailed information is available in sysfs.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">spi_display_xfer_agreement</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_transport_attrs</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">spi_transport_attrs</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">starget_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">picosec</span><span class="p">,</span> <span class="n">kb100</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">scsi</span> <span class="o">=</span> <span class="s">&quot;FAST-?&quot;</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="n">SPI_STATIC_PPR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">picosec</span> <span class="o">=</span> <span class="n">ppr_to_ps</span><span class="p">[</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">];</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span>  <span class="mi">7</span>: <span class="n">scsi</span> <span class="o">=</span> <span class="s">&quot;FAST-320&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
				<span class="k">case</span>  <span class="mi">8</span>: <span class="n">scsi</span> <span class="o">=</span> <span class="s">&quot;FAST-160&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
				<span class="k">case</span>  <span class="mi">9</span>: <span class="n">scsi</span> <span class="o">=</span> <span class="s">&quot;FAST-80&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="mi">10</span>:
				<span class="k">case</span> <span class="mi">11</span>: <span class="n">scsi</span> <span class="o">=</span> <span class="s">&quot;FAST-40&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="mi">12</span>: <span class="n">scsi</span> <span class="o">=</span> <span class="s">&quot;FAST-20&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">picosec</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">*</span> <span class="mi">4000</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">)</span>
				<span class="n">scsi</span> <span class="o">=</span> <span class="s">&quot;FAST-20&quot;</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">)</span>
				<span class="n">scsi</span> <span class="o">=</span> <span class="s">&quot;FAST-10&quot;</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">scsi</span> <span class="o">=</span> <span class="s">&quot;FAST-5&quot;</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">kb100</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10000000</span> <span class="o">+</span> <span class="n">picosec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">picosec</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">)</span>
			<span class="n">kb100</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">sprint_frac</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">picosec</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>

		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;%s %sSCSI %d.%d MB/s %s%s%s%s%s%s%s%s (%s ns, offset %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">scsi</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">?</span> <span class="s">&quot;WIDE &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">kb100</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="n">kb100</span> <span class="o">%</span> <span class="mi">10</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">dt</span> <span class="o">?</span> <span class="s">&quot;DT&quot;</span> <span class="o">:</span> <span class="s">&quot;ST&quot;</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">iu</span> <span class="o">?</span> <span class="s">&quot; IU&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">qas</span>  <span class="o">?</span> <span class="s">&quot; QAS&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rd_strm</span> <span class="o">?</span> <span class="s">&quot; RDSTRM&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rti</span> <span class="o">?</span> <span class="s">&quot; RTI&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">wr_flow</span> <span class="o">?</span> <span class="s">&quot; WRFLOW&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">pcomp_en</span> <span class="o">?</span> <span class="s">&quot; PCOMP&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">hold_mcs</span> <span class="o">?</span> <span class="s">&quot; HMCS&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="n">tmp</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%sasynchronous</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">?</span> <span class="s">&quot;wide &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">spi_display_xfer_agreement</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">spi_populate_width_msg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXTENDED_MESSAGE</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXTENDED_WDTR</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_populate_width_msg</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">spi_populate_sync_msg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">period</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXTENDED_MESSAGE</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXTENDED_SDTR</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_populate_sync_msg</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">spi_populate_ppr_msg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">period</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">options</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXTENDED_MESSAGE</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXTENDED_PPR</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_populate_ppr_msg</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SCSI_CONSTANTS</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">one_byte_msgs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/* 0x00 */</span> <span class="s">&quot;Task Complete&quot;</span><span class="p">,</span> <span class="nb">NULL</span> <span class="cm">/* Extended Message */</span><span class="p">,</span> <span class="s">&quot;Save Pointers&quot;</span><span class="p">,</span>
<span class="cm">/* 0x03 */</span> <span class="s">&quot;Restore Pointers&quot;</span><span class="p">,</span> <span class="s">&quot;Disconnect&quot;</span><span class="p">,</span> <span class="s">&quot;Initiator Error&quot;</span><span class="p">,</span> 
<span class="cm">/* 0x06 */</span> <span class="s">&quot;Abort Task Set&quot;</span><span class="p">,</span> <span class="s">&quot;Message Reject&quot;</span><span class="p">,</span> <span class="s">&quot;Nop&quot;</span><span class="p">,</span> <span class="s">&quot;Message Parity Error&quot;</span><span class="p">,</span>
<span class="cm">/* 0x0a */</span> <span class="s">&quot;Linked Command Complete&quot;</span><span class="p">,</span> <span class="s">&quot;Linked Command Complete w/flag&quot;</span><span class="p">,</span>
<span class="cm">/* 0x0c */</span> <span class="s">&quot;Target Reset&quot;</span><span class="p">,</span> <span class="s">&quot;Abort Task&quot;</span><span class="p">,</span> <span class="s">&quot;Clear Task Set&quot;</span><span class="p">,</span> 
<span class="cm">/* 0x0f */</span> <span class="s">&quot;Initiate Recovery&quot;</span><span class="p">,</span> <span class="s">&quot;Release Recovery&quot;</span><span class="p">,</span>
<span class="cm">/* 0x11 */</span> <span class="s">&quot;Terminate Process&quot;</span><span class="p">,</span> <span class="s">&quot;Continue Task&quot;</span><span class="p">,</span> <span class="s">&quot;Target Transfer Disable&quot;</span><span class="p">,</span>
<span class="cm">/* 0x14 */</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Clear ACA&quot;</span><span class="p">,</span> <span class="s">&quot;LUN Reset&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">two_byte_msgs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/* 0x20 */</span> <span class="s">&quot;Simple Queue Tag&quot;</span><span class="p">,</span> <span class="s">&quot;Head of Queue Tag&quot;</span><span class="p">,</span> <span class="s">&quot;Ordered Queue Tag&quot;</span><span class="p">,</span>
<span class="cm">/* 0x23 */</span> <span class="s">&quot;Ignore Wide Residue&quot;</span><span class="p">,</span> <span class="s">&quot;ACA&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">extended_msgs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/* 0x00 */</span> <span class="s">&quot;Modify Data Pointer&quot;</span><span class="p">,</span> <span class="s">&quot;Synchronous Data Transfer Request&quot;</span><span class="p">,</span>
<span class="cm">/* 0x02 */</span> <span class="s">&quot;SCSI-I Extended Identify&quot;</span><span class="p">,</span> <span class="s">&quot;Wide Data Transfer Request&quot;</span><span class="p">,</span>
<span class="cm">/* 0x04 */</span> <span class="s">&quot;Parallel Protocol Request&quot;</span><span class="p">,</span> <span class="s">&quot;Modify Bidirectional Data Pointer&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_nego</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">per</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">per</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
		<span class="n">period_to_str</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="n">per</span><span class="p">]);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;period = %s ns &quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">off</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;offset = %d &quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="n">off</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">width</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;width = %d &quot;</span><span class="p">,</span> <span class="mi">8</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span><span class="p">[</span><span class="n">width</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_ptr</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="n">msb</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="n">msb</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="n">msb</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">msg</span><span class="p">[</span><span class="n">msb</span><span class="o">+</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s = %d &quot;</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">spi_print_msg</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">EXTENDED_MESSAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="mi">256</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">extended_msgs</span><span class="p">))</span>
			<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">extended_msgs</span><span class="p">[</span><span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]]);</span> 
		<span class="k">else</span> 
			<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;Extended Message, reserved code (0x%02x) &quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">EXTENDED_MODIFY_DATA_POINTER</span>:
			<span class="n">print_ptr</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;pointer&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">EXTENDED_SDTR</span>:
			<span class="n">print_nego</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">EXTENDED_WDTR</span>:
			<span class="n">print_nego</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">EXTENDED_PPR</span>:
			<span class="n">print_nego</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">EXTENDED_MODIFY_BIDI_DATA_PTR</span>:
			<span class="n">print_ptr</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;out&quot;</span><span class="p">);</span>
			<span class="n">print_ptr</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="s">&quot;in&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="cm">/* Identify */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Identify disconnect %sallowed %s %d &quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;not &quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;target routine&quot;</span> <span class="o">:</span> <span class="s">&quot;lun&quot;</span><span class="p">,</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">);</span>
	<span class="cm">/* Normal One byte */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">one_byte_msgs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">one_byte_msgs</span><span class="p">[</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">one_byte_msgs</span><span class="p">[</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]]);</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;reserved (%02x) &quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x55</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;QAS Request &quot;</span><span class="p">);</span>
	<span class="cm">/* Two byte */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mh">0x2f</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">two_byte_msgs</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s %02x &quot;</span><span class="p">,</span> <span class="n">two_byte_msgs</span><span class="p">[</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">],</span> 
				<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">else</span> 
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;reserved two byte (%02x %02x) &quot;</span><span class="p">,</span> 
				<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> 
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;reserved &quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">spi_print_msg</span><span class="p">);</span>

<span class="cp">#else  </span><span class="cm">/* ifndef CONFIG_SCSI_CONSTANTS */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">spi_print_msg</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">EXTENDED_MESSAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="mi">256</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="cm">/* Identify */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="cm">/* Normal One byte */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x55</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="cm">/* Two byte */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mh">0x2f</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x %02x&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> 
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">spi_print_msg</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* ! CONFIG_SCSI_CONSTANTS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_device_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">attribute_container</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_internal</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_is_sdev_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">shost</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span>  <span class="o">||</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="o">-&gt;</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">class</span>
	    <span class="o">!=</span> <span class="o">&amp;</span><span class="n">spi_host_class</span><span class="p">.</span><span class="n">class</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Note: this class has no device attributes, so it has</span>
<span class="cm">	 * no per-HBA allocation and thus we don&#39;t need to distinguish</span>
<span class="cm">	 * the attribute containers for the device */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">to_spi_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">deny_binding</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">deny_binding</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_target_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">attribute_container</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_internal</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_is_target_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span>  <span class="o">||</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="o">-&gt;</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">class</span>
	    <span class="o">!=</span> <span class="o">&amp;</span><span class="n">spi_host_class</span><span class="p">.</span><span class="n">class</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">to_spi_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="n">starget</span> <span class="o">=</span> <span class="n">to_scsi_target</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">deny_binding</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">deny_binding</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">target_attrs</span><span class="p">.</span><span class="n">ac</span> <span class="o">==</span> <span class="n">cont</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DECLARE_TRANSPORT_CLASS</span><span class="p">(</span><span class="n">spi_transport_class</span><span class="p">,</span>
			       <span class="s">&quot;spi_transport&quot;</span><span class="p">,</span>
			       <span class="n">spi_setup_transport_attrs</span><span class="p">,</span>
			       <span class="nb">NULL</span><span class="p">,</span>
			       <span class="n">spi_target_configure</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DECLARE_ANON_TRANSPORT_CLASS</span><span class="p">(</span><span class="n">spi_device_class</span><span class="p">,</span>
				    <span class="n">spi_device_match</span><span class="p">,</span>
				    <span class="n">spi_device_configure</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">host_attributes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_signalling</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_host_width</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_hba_id</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">host_attribute_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">host_attributes</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_host_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_internal</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">to_spi_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_attr_signalling</span><span class="p">.</span><span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">set_signalling</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sysfs_chmod_file</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns true if we should be showing the variable.  Also</span>
<span class="cm"> * overloads the return by setting 1&lt;&lt;1 if the attribute should</span>
<span class="cm"> * be writeable */</span>
<span class="cp">#define TARGET_ATTRIBUTE_HELPER(name) \</span>
<span class="cp">	(si-&gt;f-&gt;show_##name ? S_IRUGO : 0) | \</span>
<span class="cp">	(si-&gt;f-&gt;set_##name ? S_IWUSR : 0)</span>

<span class="k">static</span> <span class="n">umode_t</span> <span class="nf">target_attribute_is_visible</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">transport_class_to_starget</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">transport_class_to_shost</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_internal</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">to_spi_internal</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_period</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
	    <span class="n">spi_support_sync</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">period</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_min_period</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_sync</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">period</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_offset</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_sync</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_max_offset</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_sync</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_width</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_wide</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">width</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_max_width</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_wide</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">width</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_iu</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_ius</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">iu</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_max_iu</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_ius</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">iu</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_dt</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_dt</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_qas</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">qas</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_max_qas</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">qas</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_wr_flow</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_ius</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">wr_flow</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_rd_strm</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_ius</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">rd_strm</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_rti</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_ius</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">rti</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_pcomp_en</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_ius</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">pcomp_en</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_hold_mcs</span><span class="p">.</span><span class="n">attr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">spi_support_ius</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TARGET_ATTRIBUTE_HELPER</span><span class="p">(</span><span class="n">hold_mcs</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_revalidate</span><span class="p">.</span><span class="n">attr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">S_IWUSR</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">target_attributes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_period</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_min_period</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_offset</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_max_offset</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_width</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_max_width</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_iu</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_max_iu</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_dt</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_qas</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_max_qas</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_wr_flow</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_rd_strm</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_rti</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_pcomp_en</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_hold_mcs</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_revalidate</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">target_attribute_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">target_attributes</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_visible</span> <span class="o">=</span> <span class="n">target_attribute_is_visible</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_target_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">;</span>

	<span class="cm">/* force an update based on parameters read from the device */</span>
	<span class="n">sysfs_update_group</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target_attribute_group</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span>
<span class="nf">spi_attach_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_function_template</span> <span class="o">*</span><span class="n">ft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_internal</span><span class="p">),</span>
					 <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">target_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spi_transport_class</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">target_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">grp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">target_attribute_group</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">target_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">spi_target_match</span><span class="p">;</span>
	<span class="n">transport_container_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">target_attrs</span><span class="p">);</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">target_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_transport_attrs</span><span class="p">);</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spi_host_class</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">grp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">host_attribute_group</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">host_attrs</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">spi_host_match</span><span class="p">;</span>
	<span class="n">transport_container_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">host_attrs</span><span class="p">);</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">host_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_host_attrs</span><span class="p">);</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">f</span> <span class="o">=</span> <span class="n">ft</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">spi_attach_transport</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">spi_release_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_internal</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">to_spi_internal</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

	<span class="n">transport_container_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">target_attrs</span><span class="p">);</span>
	<span class="n">transport_container_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">host_attrs</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">spi_release_transport</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">spi_transport_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">scsi_dev_info_add_list</span><span class="p">(</span><span class="n">SCSI_DEVINFO_SPI</span><span class="p">,</span>
					   <span class="s">&quot;SCSI Parallel Transport Class&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">spi_static_device_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vendor</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">scsi_dev_info_list_add_keyed</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* compatible */</span>
						     <span class="n">spi_static_device_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vendor</span><span class="p">,</span>
						     <span class="n">spi_static_device_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">model</span><span class="p">,</span>
						     <span class="nb">NULL</span><span class="p">,</span>
						     <span class="n">spi_static_device_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span><span class="p">,</span>
						     <span class="n">SCSI_DEVINFO_SPI</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">transport_class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_transport_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">anon_transport_class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_device_class</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">transport_class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_host_class</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">spi_transport_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transport_class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_transport_class</span><span class="p">);</span>
	<span class="n">anon_transport_class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_device_class</span><span class="p">);</span>
	<span class="n">transport_class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_host_class</span><span class="p">);</span>
	<span class="n">scsi_dev_info_remove_list</span><span class="p">(</span><span class="n">SCSI_DEVINFO_SPI</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Martin Hicks&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;SPI Transport Attributes&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">spi_transport_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">spi_transport_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
