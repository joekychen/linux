<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › advansys.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>advansys.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#define DRV_NAME &quot;advansys&quot;</span>
<span class="cp">#define ASC_VERSION &quot;3.4&quot;	</span><span class="cm">/* AdvanSys Driver Version */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 1995-2000 Advanced System Products, Inc.</span>
<span class="cm"> * Copyright (c) 2000-2001 ConnectCom Solutions, Inc.</span>
<span class="cm"> * Copyright (c) 2007 Matthew Wilcox &lt;matthew@wil.cx&gt;</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * As of March 8, 2000 Advanced System Products, Inc. (AdvanSys)</span>
<span class="cm"> * changed its name to ConnectCom Solutions, Inc.</span>
<span class="cm"> * On June 18, 2001 Initio Corp. acquired ConnectCom&#39;s SCSI assets</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/isa.h&gt;</span>
<span class="cp">#include &lt;linux/eisa.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>

<span class="cm">/* FIXME:</span>
<span class="cm"> *</span>
<span class="cm"> *  1. Although all of the necessary command mapping places have the</span>
<span class="cm"> *     appropriate dma_map.. APIs, the driver still processes its internal</span>
<span class="cm"> *     queue using bus_to_virt() and virt_to_bus() which are illegal under</span>
<span class="cm"> *     the API.  The entire queue processing structure will need to be</span>
<span class="cm"> *     altered to fix this.</span>
<span class="cm"> *  2. Need to add memory mapping workaround. Test the memory mapping.</span>
<span class="cm"> *     If it doesn&#39;t work revert to I/O port access. Can a test be done</span>
<span class="cm"> *     safely?</span>
<span class="cm"> *  3. Handle an interrupt not working. Keep an interrupt counter in</span>
<span class="cm"> *     the interrupt handler. In the timeout function if the interrupt</span>
<span class="cm"> *     has not occurred then print a message and run in polled mode.</span>
<span class="cm"> *  4. Need to add support for target mode commands, cf. CAM XPT.</span>
<span class="cm"> *  5. check DMA mapping functions for failure</span>
<span class="cm"> *  6. Use scsi_transport_spi</span>
<span class="cm"> *  7. advansys_info is not safe against multiple simultaneous callers</span>
<span class="cm"> *  8. Add module_param to override ISA/VLB ioport array</span>
<span class="cm"> */</span>
<span class="cp">#warning this driver is still not properly converted to the DMA API</span>

<span class="cm">/* Enable driver /proc statistics. */</span>
<span class="cp">#define ADVANSYS_STATS</span>

<span class="cm">/* Enable driver tracing. */</span>
<span class="cp">#undef ADVANSYS_DEBUG</span>

<span class="cm">/*</span>
<span class="cm"> * Portable Data Types</span>
<span class="cm"> *</span>
<span class="cm"> * Any instance where a 32-bit long or pointer type is assumed</span>
<span class="cm"> * for precision or HW defined structures, the following define</span>
<span class="cm"> * types must be used. In Linux the char, short, and int types</span>
<span class="cm"> * are all consistent at 8, 16, and 32 bits respectively. Pointers</span>
<span class="cm"> * and long types are 64 bits on Alpha and UltraSPARC.</span>
<span class="cm"> */</span>
<span class="cp">#define ASC_PADDR __u32		</span><span class="cm">/* Physical/Bus address data type. */</span><span class="cp"></span>
<span class="cp">#define ASC_VADDR __u32		</span><span class="cm">/* Virtual address data type. */</span><span class="cp"></span>
<span class="cp">#define ASC_DCNT  __u32		</span><span class="cm">/* Unsigned Data count type. */</span><span class="cp"></span>
<span class="cp">#define ASC_SDCNT __s32		</span><span class="cm">/* Signed Data count type. */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">uchar</span><span class="p">;</span>

<span class="cp">#ifndef TRUE</span>
<span class="cp">#define TRUE     (1)</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef FALSE</span>
<span class="cp">#define FALSE    (0)</span>
<span class="cp">#endif</span>

<span class="cp">#define ERR      (-1)</span>
<span class="cp">#define UW_ERR   (uint)(0xFFFF)</span>
<span class="cp">#define isodd_word(val)   ((((uint)val) &amp; (uint)0x0001) != 0)</span>

<span class="cp">#define PCI_VENDOR_ID_ASP		0x10cd</span>
<span class="cp">#define PCI_DEVICE_ID_ASP_1200A		0x1100</span>
<span class="cp">#define PCI_DEVICE_ID_ASP_ABP940	0x1200</span>
<span class="cp">#define PCI_DEVICE_ID_ASP_ABP940U	0x1300</span>
<span class="cp">#define PCI_DEVICE_ID_ASP_ABP940UW	0x2300</span>
<span class="cp">#define PCI_DEVICE_ID_38C0800_REV1	0x2500</span>
<span class="cp">#define PCI_DEVICE_ID_38C1600_REV1	0x2700</span>

<span class="cm">/*</span>
<span class="cm"> * Enable CC_VERY_LONG_SG_LIST to support up to 64K element SG lists.</span>
<span class="cm"> * The SRB structure will have to be changed and the ASC_SRB2SCSIQ()</span>
<span class="cm"> * macro re-defined to be able to obtain a ASC_SCSI_Q pointer from the</span>
<span class="cm"> * SRB structure.</span>
<span class="cm"> */</span>
<span class="cp">#define CC_VERY_LONG_SG_LIST 0</span>
<span class="cp">#define ASC_SRB2SCSIQ(srb_ptr)  (srb_ptr)</span>

<span class="cp">#define PortAddr                 unsigned int	</span><span class="cm">/* port address size  */</span><span class="cp"></span>
<span class="cp">#define inp(port)                inb(port)</span>
<span class="cp">#define outp(port, byte)         outb((byte), (port))</span>

<span class="cp">#define inpw(port)               inw(port)</span>
<span class="cp">#define outpw(port, word)        outw((word), (port))</span>

<span class="cp">#define ASC_MAX_SG_QUEUE    7</span>
<span class="cp">#define ASC_MAX_SG_LIST     255</span>

<span class="cp">#define ASC_CS_TYPE  unsigned short</span>

<span class="cp">#define ASC_IS_ISA          (0x0001)</span>
<span class="cp">#define ASC_IS_ISAPNP       (0x0081)</span>
<span class="cp">#define ASC_IS_EISA         (0x0002)</span>
<span class="cp">#define ASC_IS_PCI          (0x0004)</span>
<span class="cp">#define ASC_IS_PCI_ULTRA    (0x0104)</span>
<span class="cp">#define ASC_IS_PCMCIA       (0x0008)</span>
<span class="cp">#define ASC_IS_MCA          (0x0020)</span>
<span class="cp">#define ASC_IS_VL           (0x0040)</span>
<span class="cp">#define ASC_IS_WIDESCSI_16  (0x0100)</span>
<span class="cp">#define ASC_IS_WIDESCSI_32  (0x0200)</span>
<span class="cp">#define ASC_IS_BIG_ENDIAN   (0x8000)</span>

<span class="cp">#define ASC_CHIP_MIN_VER_VL      (0x01)</span>
<span class="cp">#define ASC_CHIP_MAX_VER_VL      (0x07)</span>
<span class="cp">#define ASC_CHIP_MIN_VER_PCI     (0x09)</span>
<span class="cp">#define ASC_CHIP_MAX_VER_PCI     (0x0F)</span>
<span class="cp">#define ASC_CHIP_VER_PCI_BIT     (0x08)</span>
<span class="cp">#define ASC_CHIP_MIN_VER_ISA     (0x11)</span>
<span class="cp">#define ASC_CHIP_MIN_VER_ISA_PNP (0x21)</span>
<span class="cp">#define ASC_CHIP_MAX_VER_ISA     (0x27)</span>
<span class="cp">#define ASC_CHIP_VER_ISA_BIT     (0x30)</span>
<span class="cp">#define ASC_CHIP_VER_ISAPNP_BIT  (0x20)</span>
<span class="cp">#define ASC_CHIP_VER_ASYN_BUG    (0x21)</span>
<span class="cp">#define ASC_CHIP_VER_PCI             0x08</span>
<span class="cp">#define ASC_CHIP_VER_PCI_ULTRA_3150  (ASC_CHIP_VER_PCI | 0x02)</span>
<span class="cp">#define ASC_CHIP_VER_PCI_ULTRA_3050  (ASC_CHIP_VER_PCI | 0x03)</span>
<span class="cp">#define ASC_CHIP_MIN_VER_EISA (0x41)</span>
<span class="cp">#define ASC_CHIP_MAX_VER_EISA (0x47)</span>
<span class="cp">#define ASC_CHIP_VER_EISA_BIT (0x40)</span>
<span class="cp">#define ASC_CHIP_LATEST_VER_EISA   ((ASC_CHIP_MIN_VER_EISA - 1) + 3)</span>
<span class="cp">#define ASC_MAX_VL_DMA_COUNT    (0x07FFFFFFL)</span>
<span class="cp">#define ASC_MAX_PCI_DMA_COUNT   (0xFFFFFFFFL)</span>
<span class="cp">#define ASC_MAX_ISA_DMA_COUNT   (0x00FFFFFFL)</span>

<span class="cp">#define ASC_SCSI_ID_BITS  3</span>
<span class="cp">#define ASC_SCSI_TIX_TYPE     uchar</span>
<span class="cp">#define ASC_ALL_DEVICE_BIT_SET  0xFF</span>
<span class="cp">#define ASC_SCSI_BIT_ID_TYPE  uchar</span>
<span class="cp">#define ASC_MAX_TID       7</span>
<span class="cp">#define ASC_MAX_LUN       7</span>
<span class="cp">#define ASC_SCSI_WIDTH_BIT_SET  0xFF</span>
<span class="cp">#define ASC_MAX_SENSE_LEN   32</span>
<span class="cp">#define ASC_MIN_SENSE_LEN   14</span>
<span class="cp">#define ASC_SCSI_RESET_HOLD_TIME_US  60</span>

<span class="cm">/*</span>
<span class="cm"> * Narrow boards only support 12-byte commands, while wide boards</span>
<span class="cm"> * extend to 16-byte commands.</span>
<span class="cm"> */</span>
<span class="cp">#define ASC_MAX_CDB_LEN     12</span>
<span class="cp">#define ADV_MAX_CDB_LEN     16</span>

<span class="cp">#define MS_SDTR_LEN    0x03</span>
<span class="cp">#define MS_WDTR_LEN    0x02</span>

<span class="cp">#define ASC_SG_LIST_PER_Q   7</span>
<span class="cp">#define QS_FREE        0x00</span>
<span class="cp">#define QS_READY       0x01</span>
<span class="cp">#define QS_DISC1       0x02</span>
<span class="cp">#define QS_DISC2       0x04</span>
<span class="cp">#define QS_BUSY        0x08</span>
<span class="cp">#define QS_ABORTED     0x40</span>
<span class="cp">#define QS_DONE        0x80</span>
<span class="cp">#define QC_NO_CALLBACK   0x01</span>
<span class="cp">#define QC_SG_SWAP_QUEUE 0x02</span>
<span class="cp">#define QC_SG_HEAD       0x04</span>
<span class="cp">#define QC_DATA_IN       0x08</span>
<span class="cp">#define QC_DATA_OUT      0x10</span>
<span class="cp">#define QC_URGENT        0x20</span>
<span class="cp">#define QC_MSG_OUT       0x40</span>
<span class="cp">#define QC_REQ_SENSE     0x80</span>
<span class="cp">#define QCSG_SG_XFER_LIST  0x02</span>
<span class="cp">#define QCSG_SG_XFER_MORE  0x04</span>
<span class="cp">#define QCSG_SG_XFER_END   0x08</span>
<span class="cp">#define QD_IN_PROGRESS       0x00</span>
<span class="cp">#define QD_NO_ERROR          0x01</span>
<span class="cp">#define QD_ABORTED_BY_HOST   0x02</span>
<span class="cp">#define QD_WITH_ERROR        0x04</span>
<span class="cp">#define QD_INVALID_REQUEST   0x80</span>
<span class="cp">#define QD_INVALID_HOST_NUM  0x81</span>
<span class="cp">#define QD_INVALID_DEVICE    0x82</span>
<span class="cp">#define QD_ERR_INTERNAL      0xFF</span>
<span class="cp">#define QHSTA_NO_ERROR               0x00</span>
<span class="cp">#define QHSTA_M_SEL_TIMEOUT          0x11</span>
<span class="cp">#define QHSTA_M_DATA_OVER_RUN        0x12</span>
<span class="cp">#define QHSTA_M_DATA_UNDER_RUN       0x12</span>
<span class="cp">#define QHSTA_M_UNEXPECTED_BUS_FREE  0x13</span>
<span class="cp">#define QHSTA_M_BAD_BUS_PHASE_SEQ    0x14</span>
<span class="cp">#define QHSTA_D_QDONE_SG_LIST_CORRUPTED 0x21</span>
<span class="cp">#define QHSTA_D_ASC_DVC_ERROR_CODE_SET  0x22</span>
<span class="cp">#define QHSTA_D_HOST_ABORT_FAILED       0x23</span>
<span class="cp">#define QHSTA_D_EXE_SCSI_Q_FAILED       0x24</span>
<span class="cp">#define QHSTA_D_EXE_SCSI_Q_BUSY_TIMEOUT 0x25</span>
<span class="cp">#define QHSTA_D_ASPI_NO_BUF_POOL        0x26</span>
<span class="cp">#define QHSTA_M_WTM_TIMEOUT         0x41</span>
<span class="cp">#define QHSTA_M_BAD_CMPL_STATUS_IN  0x42</span>
<span class="cp">#define QHSTA_M_NO_AUTO_REQ_SENSE   0x43</span>
<span class="cp">#define QHSTA_M_AUTO_REQ_SENSE_FAIL 0x44</span>
<span class="cp">#define QHSTA_M_TARGET_STATUS_BUSY  0x45</span>
<span class="cp">#define QHSTA_M_BAD_TAG_CODE        0x46</span>
<span class="cp">#define QHSTA_M_BAD_QUEUE_FULL_OR_BUSY  0x47</span>
<span class="cp">#define QHSTA_M_HUNG_REQ_SCSI_BUS_RESET 0x48</span>
<span class="cp">#define QHSTA_D_LRAM_CMP_ERROR        0x81</span>
<span class="cp">#define QHSTA_M_MICRO_CODE_ERROR_HALT 0xA1</span>
<span class="cp">#define ASC_FLAG_SCSIQ_REQ        0x01</span>
<span class="cp">#define ASC_FLAG_BIOS_SCSIQ_REQ   0x02</span>
<span class="cp">#define ASC_FLAG_BIOS_ASYNC_IO    0x04</span>
<span class="cp">#define ASC_FLAG_SRB_LINEAR_ADDR  0x08</span>
<span class="cp">#define ASC_FLAG_WIN16            0x10</span>
<span class="cp">#define ASC_FLAG_WIN32            0x20</span>
<span class="cp">#define ASC_FLAG_ISA_OVER_16MB    0x40</span>
<span class="cp">#define ASC_FLAG_DOS_VM_CALLBACK  0x80</span>
<span class="cp">#define ASC_TAG_FLAG_EXTRA_BYTES               0x10</span>
<span class="cp">#define ASC_TAG_FLAG_DISABLE_DISCONNECT        0x04</span>
<span class="cp">#define ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX  0x08</span>
<span class="cp">#define ASC_TAG_FLAG_DISABLE_CHK_COND_INT_HOST 0x40</span>
<span class="cp">#define ASC_SCSIQ_CPY_BEG              4</span>
<span class="cp">#define ASC_SCSIQ_SGHD_CPY_BEG         2</span>
<span class="cp">#define ASC_SCSIQ_B_FWD                0</span>
<span class="cp">#define ASC_SCSIQ_B_BWD                1</span>
<span class="cp">#define ASC_SCSIQ_B_STATUS             2</span>
<span class="cp">#define ASC_SCSIQ_B_QNO                3</span>
<span class="cp">#define ASC_SCSIQ_B_CNTL               4</span>
<span class="cp">#define ASC_SCSIQ_B_SG_QUEUE_CNT       5</span>
<span class="cp">#define ASC_SCSIQ_D_DATA_ADDR          8</span>
<span class="cp">#define ASC_SCSIQ_D_DATA_CNT          12</span>
<span class="cp">#define ASC_SCSIQ_B_SENSE_LEN         20</span>
<span class="cp">#define ASC_SCSIQ_DONE_INFO_BEG       22</span>
<span class="cp">#define ASC_SCSIQ_D_SRBPTR            22</span>
<span class="cp">#define ASC_SCSIQ_B_TARGET_IX         26</span>
<span class="cp">#define ASC_SCSIQ_B_CDB_LEN           28</span>
<span class="cp">#define ASC_SCSIQ_B_TAG_CODE          29</span>
<span class="cp">#define ASC_SCSIQ_W_VM_ID             30</span>
<span class="cp">#define ASC_SCSIQ_DONE_STATUS         32</span>
<span class="cp">#define ASC_SCSIQ_HOST_STATUS         33</span>
<span class="cp">#define ASC_SCSIQ_SCSI_STATUS         34</span>
<span class="cp">#define ASC_SCSIQ_CDB_BEG             36</span>
<span class="cp">#define ASC_SCSIQ_DW_REMAIN_XFER_ADDR 56</span>
<span class="cp">#define ASC_SCSIQ_DW_REMAIN_XFER_CNT  60</span>
<span class="cp">#define ASC_SCSIQ_B_FIRST_SG_WK_QP    48</span>
<span class="cp">#define ASC_SCSIQ_B_SG_WK_QP          49</span>
<span class="cp">#define ASC_SCSIQ_B_SG_WK_IX          50</span>
<span class="cp">#define ASC_SCSIQ_W_ALT_DC1           52</span>
<span class="cp">#define ASC_SCSIQ_B_LIST_CNT          6</span>
<span class="cp">#define ASC_SCSIQ_B_CUR_LIST_CNT      7</span>
<span class="cp">#define ASC_SGQ_B_SG_CNTL             4</span>
<span class="cp">#define ASC_SGQ_B_SG_HEAD_QP          5</span>
<span class="cp">#define ASC_SGQ_B_SG_LIST_CNT         6</span>
<span class="cp">#define ASC_SGQ_B_SG_CUR_LIST_CNT     7</span>
<span class="cp">#define ASC_SGQ_LIST_BEG              8</span>
<span class="cp">#define ASC_DEF_SCSI1_QNG    4</span>
<span class="cp">#define ASC_MAX_SCSI1_QNG    4</span>
<span class="cp">#define ASC_DEF_SCSI2_QNG    16</span>
<span class="cp">#define ASC_MAX_SCSI2_QNG    32</span>
<span class="cp">#define ASC_TAG_CODE_MASK    0x23</span>
<span class="cp">#define ASC_STOP_REQ_RISC_STOP      0x01</span>
<span class="cp">#define ASC_STOP_ACK_RISC_STOP      0x03</span>
<span class="cp">#define ASC_STOP_CLEAN_UP_BUSY_Q    0x10</span>
<span class="cp">#define ASC_STOP_CLEAN_UP_DISC_Q    0x20</span>
<span class="cp">#define ASC_STOP_HOST_REQ_RISC_HALT 0x40</span>
<span class="cp">#define ASC_TIDLUN_TO_IX(tid, lun)  (ASC_SCSI_TIX_TYPE)((tid) + ((lun)&lt;&lt;ASC_SCSI_ID_BITS))</span>
<span class="cp">#define ASC_TID_TO_TARGET_ID(tid)   (ASC_SCSI_BIT_ID_TYPE)(0x01 &lt;&lt; (tid))</span>
<span class="cp">#define ASC_TIX_TO_TARGET_ID(tix)   (0x01 &lt;&lt; ((tix) &amp; ASC_MAX_TID))</span>
<span class="cp">#define ASC_TIX_TO_TID(tix)         ((tix) &amp; ASC_MAX_TID)</span>
<span class="cp">#define ASC_TID_TO_TIX(tid)         ((tid) &amp; ASC_MAX_TID)</span>
<span class="cp">#define ASC_TIX_TO_LUN(tix)         (((tix) &gt;&gt; ASC_SCSI_ID_BITS) &amp; ASC_MAX_LUN)</span>
<span class="cp">#define ASC_QNO_TO_QADDR(q_no)      ((ASC_QADR_BEG)+((int)(q_no) &lt;&lt; 6))</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_scsiq_1</span> <span class="p">{</span>
	<span class="n">uchar</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">q_no</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">cntl</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sg_queue_cnt</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">target_id</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">target_lun</span><span class="p">;</span>
	<span class="n">ASC_PADDR</span> <span class="n">data_addr</span><span class="p">;</span>
	<span class="n">ASC_DCNT</span> <span class="n">data_cnt</span><span class="p">;</span>
	<span class="n">ASC_PADDR</span> <span class="n">sense_addr</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sense_len</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">extra_bytes</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ASC_SCSIQ_1</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_scsiq_2</span> <span class="p">{</span>
	<span class="n">ASC_VADDR</span> <span class="n">srb_ptr</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">target_ix</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">flag</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">cdb_len</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">tag_code</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">vm_id</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ASC_SCSIQ_2</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_scsiq_3</span> <span class="p">{</span>
	<span class="n">uchar</span> <span class="n">done_stat</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">host_stat</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">scsi_stat</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">scsi_msg</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ASC_SCSIQ_3</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_scsiq_4</span> <span class="p">{</span>
	<span class="n">uchar</span> <span class="n">cdb</span><span class="p">[</span><span class="n">ASC_MAX_CDB_LEN</span><span class="p">];</span>
	<span class="n">uchar</span> <span class="n">y_first_sg_list_qp</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">y_working_sg_qp</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">y_working_sg_ix</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">y_res</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">x_req_count</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">x_reconnect_rtn</span><span class="p">;</span>
	<span class="n">ASC_PADDR</span> <span class="n">x_saved_data_addr</span><span class="p">;</span>
	<span class="n">ASC_DCNT</span> <span class="n">x_saved_data_cnt</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ASC_SCSIQ_4</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_q_done_info</span> <span class="p">{</span>
	<span class="n">ASC_SCSIQ_2</span> <span class="n">d2</span><span class="p">;</span>
	<span class="n">ASC_SCSIQ_3</span> <span class="n">d3</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">q_status</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">q_no</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">cntl</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sense_len</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">extra_bytes</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">ASC_DCNT</span> <span class="n">remain_bytes</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ASC_QDONE_INFO</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_sg_list</span> <span class="p">{</span>
	<span class="n">ASC_PADDR</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">ASC_DCNT</span> <span class="n">bytes</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ASC_SG_LIST</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_sg_head</span> <span class="p">{</span>
	<span class="n">ushort</span> <span class="n">entry_cnt</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">queue_cnt</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">entry_to_copy</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">ASC_SG_LIST</span> <span class="n">sg_list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">ASC_SG_HEAD</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_scsi_q</span> <span class="p">{</span>
	<span class="n">ASC_SCSIQ_1</span> <span class="n">q1</span><span class="p">;</span>
	<span class="n">ASC_SCSIQ_2</span> <span class="n">q2</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="o">*</span><span class="n">cdbptr</span><span class="p">;</span>
	<span class="n">ASC_SG_HEAD</span> <span class="o">*</span><span class="n">sg_head</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">remain_sg_entry_cnt</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">next_sg_index</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ASC_SCSI_Q</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_scsi_req_q</span> <span class="p">{</span>
	<span class="n">ASC_SCSIQ_1</span> <span class="n">r1</span><span class="p">;</span>
	<span class="n">ASC_SCSIQ_2</span> <span class="n">r2</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="o">*</span><span class="n">cdbptr</span><span class="p">;</span>
	<span class="n">ASC_SG_HEAD</span> <span class="o">*</span><span class="n">sg_head</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="o">*</span><span class="n">sense_ptr</span><span class="p">;</span>
	<span class="n">ASC_SCSIQ_3</span> <span class="n">r3</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">cdb</span><span class="p">[</span><span class="n">ASC_MAX_CDB_LEN</span><span class="p">];</span>
	<span class="n">uchar</span> <span class="n">sense</span><span class="p">[</span><span class="n">ASC_MIN_SENSE_LEN</span><span class="p">];</span>
<span class="p">}</span> <span class="n">ASC_SCSI_REQ_Q</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_scsi_bios_req_q</span> <span class="p">{</span>
	<span class="n">ASC_SCSIQ_1</span> <span class="n">r1</span><span class="p">;</span>
	<span class="n">ASC_SCSIQ_2</span> <span class="n">r2</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="o">*</span><span class="n">cdbptr</span><span class="p">;</span>
	<span class="n">ASC_SG_HEAD</span> <span class="o">*</span><span class="n">sg_head</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="o">*</span><span class="n">sense_ptr</span><span class="p">;</span>
	<span class="n">ASC_SCSIQ_3</span> <span class="n">r3</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">cdb</span><span class="p">[</span><span class="n">ASC_MAX_CDB_LEN</span><span class="p">];</span>
	<span class="n">uchar</span> <span class="n">sense</span><span class="p">[</span><span class="n">ASC_MIN_SENSE_LEN</span><span class="p">];</span>
<span class="p">}</span> <span class="n">ASC_SCSI_BIOS_REQ_Q</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_risc_q</span> <span class="p">{</span>
	<span class="n">uchar</span> <span class="n">fwd</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">bwd</span><span class="p">;</span>
	<span class="n">ASC_SCSIQ_1</span> <span class="n">i1</span><span class="p">;</span>
	<span class="n">ASC_SCSIQ_2</span> <span class="n">i2</span><span class="p">;</span>
	<span class="n">ASC_SCSIQ_3</span> <span class="n">i3</span><span class="p">;</span>
	<span class="n">ASC_SCSIQ_4</span> <span class="n">i4</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ASC_RISC_Q</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_sg_list_q</span> <span class="p">{</span>
	<span class="n">uchar</span> <span class="n">seq_no</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">q_no</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">cntl</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sg_head_qp</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sg_list_cnt</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sg_cur_list_cnt</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ASC_SG_LIST_Q</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_risc_sg_list_q</span> <span class="p">{</span>
	<span class="n">uchar</span> <span class="n">fwd</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">bwd</span><span class="p">;</span>
	<span class="n">ASC_SG_LIST_Q</span> <span class="n">sg</span><span class="p">;</span>
	<span class="n">ASC_SG_LIST</span> <span class="n">sg_list</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">}</span> <span class="n">ASC_RISC_SG_LIST_Q</span><span class="p">;</span>

<span class="cp">#define ASCQ_ERR_Q_STATUS             0x0D</span>
<span class="cp">#define ASCQ_ERR_CUR_QNG              0x17</span>
<span class="cp">#define ASCQ_ERR_SG_Q_LINKS           0x18</span>
<span class="cp">#define ASCQ_ERR_ISR_RE_ENTRY         0x1A</span>
<span class="cp">#define ASCQ_ERR_CRITICAL_RE_ENTRY    0x1B</span>
<span class="cp">#define ASCQ_ERR_ISR_ON_CRITICAL      0x1C</span>

<span class="cm">/*</span>
<span class="cm"> * Warning code values are set in ASC_DVC_VAR  &#39;warn_code&#39;.</span>
<span class="cm"> */</span>
<span class="cp">#define ASC_WARN_NO_ERROR             0x0000</span>
<span class="cp">#define ASC_WARN_IO_PORT_ROTATE       0x0001</span>
<span class="cp">#define ASC_WARN_EEPROM_CHKSUM        0x0002</span>
<span class="cp">#define ASC_WARN_IRQ_MODIFIED         0x0004</span>
<span class="cp">#define ASC_WARN_AUTO_CONFIG          0x0008</span>
<span class="cp">#define ASC_WARN_CMD_QNG_CONFLICT     0x0010</span>
<span class="cp">#define ASC_WARN_EEPROM_RECOVER       0x0020</span>
<span class="cp">#define ASC_WARN_CFG_MSW_RECOVER      0x0040</span>

<span class="cm">/*</span>
<span class="cm"> * Error code values are set in {ASC/ADV}_DVC_VAR  &#39;err_code&#39;.</span>
<span class="cm"> */</span>
<span class="cp">#define ASC_IERR_NO_CARRIER		0x0001	</span><span class="cm">/* No more carrier memory */</span><span class="cp"></span>
<span class="cp">#define ASC_IERR_MCODE_CHKSUM		0x0002	</span><span class="cm">/* micro code check sum error */</span><span class="cp"></span>
<span class="cp">#define ASC_IERR_SET_PC_ADDR		0x0004</span>
<span class="cp">#define ASC_IERR_START_STOP_CHIP	0x0008	</span><span class="cm">/* start/stop chip failed */</span><span class="cp"></span>
<span class="cp">#define ASC_IERR_ILLEGAL_CONNECTION	0x0010	</span><span class="cm">/* Illegal cable connection */</span><span class="cp"></span>
<span class="cp">#define ASC_IERR_SINGLE_END_DEVICE	0x0020	</span><span class="cm">/* SE device on DIFF bus */</span><span class="cp"></span>
<span class="cp">#define ASC_IERR_REVERSED_CABLE		0x0040	</span><span class="cm">/* Narrow flat cable reversed */</span><span class="cp"></span>
<span class="cp">#define ASC_IERR_SET_SCSI_ID		0x0080	</span><span class="cm">/* set SCSI ID failed */</span><span class="cp"></span>
<span class="cp">#define ASC_IERR_HVD_DEVICE		0x0100	</span><span class="cm">/* HVD device on LVD port */</span><span class="cp"></span>
<span class="cp">#define ASC_IERR_BAD_SIGNATURE		0x0200	</span><span class="cm">/* signature not found */</span><span class="cp"></span>
<span class="cp">#define ASC_IERR_NO_BUS_TYPE		0x0400</span>
<span class="cp">#define ASC_IERR_BIST_PRE_TEST		0x0800	</span><span class="cm">/* BIST pre-test error */</span><span class="cp"></span>
<span class="cp">#define ASC_IERR_BIST_RAM_TEST		0x1000	</span><span class="cm">/* BIST RAM test error */</span><span class="cp"></span>
<span class="cp">#define ASC_IERR_BAD_CHIPTYPE		0x2000	</span><span class="cm">/* Invalid chip_type setting */</span><span class="cp"></span>

<span class="cp">#define ASC_DEF_MAX_TOTAL_QNG   (0xF0)</span>
<span class="cp">#define ASC_MIN_TAG_Q_PER_DVC   (0x04)</span>
<span class="cp">#define ASC_MIN_FREE_Q        (0x02)</span>
<span class="cp">#define ASC_MIN_TOTAL_QNG     ((ASC_MAX_SG_QUEUE)+(ASC_MIN_FREE_Q))</span>
<span class="cp">#define ASC_MAX_TOTAL_QNG 240</span>
<span class="cp">#define ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG 16</span>
<span class="cp">#define ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG   8</span>
<span class="cp">#define ASC_MAX_PCI_INRAM_TOTAL_QNG  20</span>
<span class="cp">#define ASC_MAX_INRAM_TAG_QNG   16</span>
<span class="cp">#define ASC_IOADR_GAP   0x10</span>
<span class="cp">#define ASC_SYN_MAX_OFFSET         0x0F</span>
<span class="cp">#define ASC_DEF_SDTR_OFFSET        0x0F</span>
<span class="cp">#define ASC_SDTR_ULTRA_PCI_10MB_INDEX  0x02</span>
<span class="cp">#define ASYN_SDTR_DATA_FIX_PCI_REV_AB 0x41</span>

<span class="cm">/* The narrow chip only supports a limited selection of transfer rates.</span>
<span class="cm"> * These are encoded in the range 0..7 or 0..15 depending whether the chip</span>
<span class="cm"> * is Ultra-capable or not.  These tables let us convert from one to the other.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">asc_syn_xfer_period</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">85</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">asc_syn_ultra_xfer_period</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">12</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">69</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">107</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ext_msg</span> <span class="p">{</span>
	<span class="n">uchar</span> <span class="n">msg_type</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">msg_len</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">msg_req</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">uchar</span> <span class="n">sdtr_xfer_period</span><span class="p">;</span>
			<span class="n">uchar</span> <span class="n">sdtr_req_ack_offset</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">sdtr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">uchar</span> <span class="n">wdtr_width</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">wdtr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">uchar</span> <span class="n">mdp_b3</span><span class="p">;</span>
			<span class="n">uchar</span> <span class="n">mdp_b2</span><span class="p">;</span>
			<span class="n">uchar</span> <span class="n">mdp_b1</span><span class="p">;</span>
			<span class="n">uchar</span> <span class="n">mdp_b0</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">mdp</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u_ext_msg</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span> <span class="n">EXT_MSG</span><span class="p">;</span>

<span class="cp">#define xfer_period     u_ext_msg.sdtr.sdtr_xfer_period</span>
<span class="cp">#define req_ack_offset  u_ext_msg.sdtr.sdtr_req_ack_offset</span>
<span class="cp">#define wdtr_width      u_ext_msg.wdtr.wdtr_width</span>
<span class="cp">#define mdp_b3          u_ext_msg.mdp_b3</span>
<span class="cp">#define mdp_b2          u_ext_msg.mdp_b2</span>
<span class="cp">#define mdp_b1          u_ext_msg.mdp_b1</span>
<span class="cp">#define mdp_b0          u_ext_msg.mdp_b0</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_dvc_cfg</span> <span class="p">{</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">can_tagged_qng</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">cmd_qng_enabled</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">disc_enable</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">sdtr_enable</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">chip_scsi_id</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">isa_dma_speed</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">isa_dma_channel</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">chip_version</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">mcode_date</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">mcode_version</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">max_tag_qng</span><span class="p">[</span><span class="n">ASC_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">uchar</span> <span class="n">sdtr_period_offset</span><span class="p">[</span><span class="n">ASC_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">uchar</span> <span class="n">adapter_info</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="p">}</span> <span class="n">ASC_DVC_CFG</span><span class="p">;</span>

<span class="cp">#define ASC_DEF_DVC_CNTL       0xFFFF</span>
<span class="cp">#define ASC_DEF_CHIP_SCSI_ID   7</span>
<span class="cp">#define ASC_DEF_ISA_DMA_SPEED  4</span>
<span class="cp">#define ASC_INIT_STATE_BEG_GET_CFG   0x0001</span>
<span class="cp">#define ASC_INIT_STATE_END_GET_CFG   0x0002</span>
<span class="cp">#define ASC_INIT_STATE_BEG_SET_CFG   0x0004</span>
<span class="cp">#define ASC_INIT_STATE_END_SET_CFG   0x0008</span>
<span class="cp">#define ASC_INIT_STATE_BEG_LOAD_MC   0x0010</span>
<span class="cp">#define ASC_INIT_STATE_END_LOAD_MC   0x0020</span>
<span class="cp">#define ASC_INIT_STATE_BEG_INQUIRY   0x0040</span>
<span class="cp">#define ASC_INIT_STATE_END_INQUIRY   0x0080</span>
<span class="cp">#define ASC_INIT_RESET_SCSI_DONE     0x0100</span>
<span class="cp">#define ASC_INIT_STATE_WITHOUT_EEP   0x8000</span>
<span class="cp">#define ASC_BUG_FIX_IF_NOT_DWB       0x0001</span>
<span class="cp">#define ASC_BUG_FIX_ASYN_USE_SYN     0x0002</span>
<span class="cp">#define ASC_MIN_TAGGED_CMD  7</span>
<span class="cp">#define ASC_MAX_SCSI_RESET_WAIT      30</span>
<span class="cp">#define ASC_OVERRUN_BSIZE		64</span>

<span class="k">struct</span> <span class="n">asc_dvc_var</span><span class="p">;</span>		<span class="cm">/* Forward Declaration. */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_dvc_var</span> <span class="p">{</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">err_code</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">dvc_cntl</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">bug_fix_cntl</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">bus_type</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">init_sdtr</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">sdtr_done</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">use_tagged_qng</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">unit_not_ready</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">queue_full_or_busy</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">start_motor</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="o">*</span><span class="n">overrun_buf</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">overrun_dma</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">scsi_reset_wait</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">chip_no</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">is_in_int</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">max_total_qng</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">cur_total_qng</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">in_critical_cnt</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">last_q_shortage</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">init_state</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">cur_dvc_qng</span><span class="p">[</span><span class="n">ASC_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">uchar</span> <span class="n">max_dvc_qng</span><span class="p">[</span><span class="n">ASC_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">ASC_SCSI_Q</span> <span class="o">*</span><span class="n">scsiq_busy_head</span><span class="p">[</span><span class="n">ASC_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">ASC_SCSI_Q</span> <span class="o">*</span><span class="n">scsiq_busy_tail</span><span class="p">[</span><span class="n">ASC_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">const</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">sdtr_period_tbl</span><span class="p">;</span>
	<span class="n">ASC_DVC_CFG</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">pci_fix_asyn_xfer_always</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">redo_scam</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">res2</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">dos_int13_table</span><span class="p">[</span><span class="n">ASC_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">ASC_DCNT</span> <span class="n">max_dma_count</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">no_scam</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">pci_fix_asyn_xfer</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">min_sdtr_index</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">max_sdtr_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">drv_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ptr_map_count</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">ptr_map</span><span class="p">;</span>
	<span class="n">ASC_DCNT</span> <span class="n">uc_break</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ASC_DVC_VAR</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_dvc_inq_info</span> <span class="p">{</span>
	<span class="n">uchar</span> <span class="n">type</span><span class="p">[</span><span class="n">ASC_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">ASC_MAX_LUN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">ASC_DVC_INQ_INFO</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_cap_info</span> <span class="p">{</span>
	<span class="n">ASC_DCNT</span> <span class="n">lba</span><span class="p">;</span>
	<span class="n">ASC_DCNT</span> <span class="n">blk_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ASC_CAP_INFO</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_cap_info_array</span> <span class="p">{</span>
	<span class="n">ASC_CAP_INFO</span> <span class="n">cap_info</span><span class="p">[</span><span class="n">ASC_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">ASC_MAX_LUN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">ASC_CAP_INFO_ARRAY</span><span class="p">;</span>

<span class="cp">#define ASC_MCNTL_NO_SEL_TIMEOUT  (ushort)0x0001</span>
<span class="cp">#define ASC_MCNTL_NULL_TARGET     (ushort)0x0002</span>
<span class="cp">#define ASC_CNTL_INITIATOR         (ushort)0x0001</span>
<span class="cp">#define ASC_CNTL_BIOS_GT_1GB       (ushort)0x0002</span>
<span class="cp">#define ASC_CNTL_BIOS_GT_2_DISK    (ushort)0x0004</span>
<span class="cp">#define ASC_CNTL_BIOS_REMOVABLE    (ushort)0x0008</span>
<span class="cp">#define ASC_CNTL_NO_SCAM           (ushort)0x0010</span>
<span class="cp">#define ASC_CNTL_INT_MULTI_Q       (ushort)0x0080</span>
<span class="cp">#define ASC_CNTL_NO_LUN_SUPPORT    (ushort)0x0040</span>
<span class="cp">#define ASC_CNTL_NO_VERIFY_COPY    (ushort)0x0100</span>
<span class="cp">#define ASC_CNTL_RESET_SCSI        (ushort)0x0200</span>
<span class="cp">#define ASC_CNTL_INIT_INQUIRY      (ushort)0x0400</span>
<span class="cp">#define ASC_CNTL_INIT_VERBOSE      (ushort)0x0800</span>
<span class="cp">#define ASC_CNTL_SCSI_PARITY       (ushort)0x1000</span>
<span class="cp">#define ASC_CNTL_BURST_MODE        (ushort)0x2000</span>
<span class="cp">#define ASC_CNTL_SDTR_ENABLE_ULTRA (ushort)0x4000</span>
<span class="cp">#define ASC_EEP_DVC_CFG_BEG_VL    2</span>
<span class="cp">#define ASC_EEP_MAX_DVC_ADDR_VL   15</span>
<span class="cp">#define ASC_EEP_DVC_CFG_BEG      32</span>
<span class="cp">#define ASC_EEP_MAX_DVC_ADDR     45</span>
<span class="cp">#define ASC_EEP_MAX_RETRY        20</span>

<span class="cm">/*</span>
<span class="cm"> * These macros keep the chip SCSI id and ISA DMA speed</span>
<span class="cm"> * bitfields in board order. C bitfields aren&#39;t portable</span>
<span class="cm"> * between big and little-endian platforms so they are</span>
<span class="cm"> * not used.</span>
<span class="cm"> */</span>

<span class="cp">#define ASC_EEP_GET_CHIP_ID(cfg)    ((cfg)-&gt;id_speed &amp; 0x0f)</span>
<span class="cp">#define ASC_EEP_GET_DMA_SPD(cfg)    (((cfg)-&gt;id_speed &amp; 0xf0) &gt;&gt; 4)</span>
<span class="cp">#define ASC_EEP_SET_CHIP_ID(cfg, sid) \</span>
<span class="cp">   ((cfg)-&gt;id_speed = ((cfg)-&gt;id_speed &amp; 0xf0) | ((sid) &amp; ASC_MAX_TID))</span>
<span class="cp">#define ASC_EEP_SET_DMA_SPD(cfg, spd) \</span>
<span class="cp">   ((cfg)-&gt;id_speed = ((cfg)-&gt;id_speed &amp; 0x0f) | ((spd) &amp; 0x0f) &lt;&lt; 4)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asceep_config</span> <span class="p">{</span>
	<span class="n">ushort</span> <span class="n">cfg_lsw</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">cfg_msw</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">init_sdtr</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">disc_enable</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">use_cmd_qng</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">start_motor</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">max_total_qng</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">max_tag_qng</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">bios_scan</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">power_up_wait</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">no_scam</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">id_speed</span><span class="p">;</span>		<span class="cm">/* low order 4 bits is chip scsi id */</span>
	<span class="cm">/* high order 4 bits is isa dma speed */</span>
	<span class="n">uchar</span> <span class="n">dos_int13_table</span><span class="p">[</span><span class="n">ASC_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">uchar</span> <span class="n">adapter_info</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">ushort</span> <span class="n">cntl</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">chksum</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ASCEEP_CONFIG</span><span class="p">;</span>

<span class="cp">#define ASC_EEP_CMD_READ          0x80</span>
<span class="cp">#define ASC_EEP_CMD_WRITE         0x40</span>
<span class="cp">#define ASC_EEP_CMD_WRITE_ABLE    0x30</span>
<span class="cp">#define ASC_EEP_CMD_WRITE_DISABLE 0x00</span>
<span class="cp">#define ASCV_MSGOUT_BEG         0x0000</span>
<span class="cp">#define ASCV_MSGOUT_SDTR_PERIOD (ASCV_MSGOUT_BEG+3)</span>
<span class="cp">#define ASCV_MSGOUT_SDTR_OFFSET (ASCV_MSGOUT_BEG+4)</span>
<span class="cp">#define ASCV_BREAK_SAVED_CODE   (ushort)0x0006</span>
<span class="cp">#define ASCV_MSGIN_BEG          (ASCV_MSGOUT_BEG+8)</span>
<span class="cp">#define ASCV_MSGIN_SDTR_PERIOD  (ASCV_MSGIN_BEG+3)</span>
<span class="cp">#define ASCV_MSGIN_SDTR_OFFSET  (ASCV_MSGIN_BEG+4)</span>
<span class="cp">#define ASCV_SDTR_DATA_BEG      (ASCV_MSGIN_BEG+8)</span>
<span class="cp">#define ASCV_SDTR_DONE_BEG      (ASCV_SDTR_DATA_BEG+8)</span>
<span class="cp">#define ASCV_MAX_DVC_QNG_BEG    (ushort)0x0020</span>
<span class="cp">#define ASCV_BREAK_ADDR           (ushort)0x0028</span>
<span class="cp">#define ASCV_BREAK_NOTIFY_COUNT   (ushort)0x002A</span>
<span class="cp">#define ASCV_BREAK_CONTROL        (ushort)0x002C</span>
<span class="cp">#define ASCV_BREAK_HIT_COUNT      (ushort)0x002E</span>

<span class="cp">#define ASCV_ASCDVC_ERR_CODE_W  (ushort)0x0030</span>
<span class="cp">#define ASCV_MCODE_CHKSUM_W   (ushort)0x0032</span>
<span class="cp">#define ASCV_MCODE_SIZE_W     (ushort)0x0034</span>
<span class="cp">#define ASCV_STOP_CODE_B      (ushort)0x0036</span>
<span class="cp">#define ASCV_DVC_ERR_CODE_B   (ushort)0x0037</span>
<span class="cp">#define ASCV_OVERRUN_PADDR_D  (ushort)0x0038</span>
<span class="cp">#define ASCV_OVERRUN_BSIZE_D  (ushort)0x003C</span>
<span class="cp">#define ASCV_HALTCODE_W       (ushort)0x0040</span>
<span class="cp">#define ASCV_CHKSUM_W         (ushort)0x0042</span>
<span class="cp">#define ASCV_MC_DATE_W        (ushort)0x0044</span>
<span class="cp">#define ASCV_MC_VER_W         (ushort)0x0046</span>
<span class="cp">#define ASCV_NEXTRDY_B        (ushort)0x0048</span>
<span class="cp">#define ASCV_DONENEXT_B       (ushort)0x0049</span>
<span class="cp">#define ASCV_USE_TAGGED_QNG_B (ushort)0x004A</span>
<span class="cp">#define ASCV_SCSIBUSY_B       (ushort)0x004B</span>
<span class="cp">#define ASCV_Q_DONE_IN_PROGRESS_B  (ushort)0x004C</span>
<span class="cp">#define ASCV_CURCDB_B         (ushort)0x004D</span>
<span class="cp">#define ASCV_RCLUN_B          (ushort)0x004E</span>
<span class="cp">#define ASCV_BUSY_QHEAD_B     (ushort)0x004F</span>
<span class="cp">#define ASCV_DISC1_QHEAD_B    (ushort)0x0050</span>
<span class="cp">#define ASCV_DISC_ENABLE_B    (ushort)0x0052</span>
<span class="cp">#define ASCV_CAN_TAGGED_QNG_B (ushort)0x0053</span>
<span class="cp">#define ASCV_HOSTSCSI_ID_B    (ushort)0x0055</span>
<span class="cp">#define ASCV_MCODE_CNTL_B     (ushort)0x0056</span>
<span class="cp">#define ASCV_NULL_TARGET_B    (ushort)0x0057</span>
<span class="cp">#define ASCV_FREE_Q_HEAD_W    (ushort)0x0058</span>
<span class="cp">#define ASCV_DONE_Q_TAIL_W    (ushort)0x005A</span>
<span class="cp">#define ASCV_FREE_Q_HEAD_B    (ushort)(ASCV_FREE_Q_HEAD_W+1)</span>
<span class="cp">#define ASCV_DONE_Q_TAIL_B    (ushort)(ASCV_DONE_Q_TAIL_W+1)</span>
<span class="cp">#define ASCV_HOST_FLAG_B      (ushort)0x005D</span>
<span class="cp">#define ASCV_TOTAL_READY_Q_B  (ushort)0x0064</span>
<span class="cp">#define ASCV_VER_SERIAL_B     (ushort)0x0065</span>
<span class="cp">#define ASCV_HALTCODE_SAVED_W (ushort)0x0066</span>
<span class="cp">#define ASCV_WTM_FLAG_B       (ushort)0x0068</span>
<span class="cp">#define ASCV_RISC_FLAG_B      (ushort)0x006A</span>
<span class="cp">#define ASCV_REQ_SG_LIST_QP   (ushort)0x006B</span>
<span class="cp">#define ASC_HOST_FLAG_IN_ISR        0x01</span>
<span class="cp">#define ASC_HOST_FLAG_ACK_INT       0x02</span>
<span class="cp">#define ASC_RISC_FLAG_GEN_INT      0x01</span>
<span class="cp">#define ASC_RISC_FLAG_REQ_SG_LIST  0x02</span>
<span class="cp">#define IOP_CTRL         (0x0F)</span>
<span class="cp">#define IOP_STATUS       (0x0E)</span>
<span class="cp">#define IOP_INT_ACK      IOP_STATUS</span>
<span class="cp">#define IOP_REG_IFC      (0x0D)</span>
<span class="cp">#define IOP_SYN_OFFSET    (0x0B)</span>
<span class="cp">#define IOP_EXTRA_CONTROL (0x0D)</span>
<span class="cp">#define IOP_REG_PC        (0x0C)</span>
<span class="cp">#define IOP_RAM_ADDR      (0x0A)</span>
<span class="cp">#define IOP_RAM_DATA      (0x08)</span>
<span class="cp">#define IOP_EEP_DATA      (0x06)</span>
<span class="cp">#define IOP_EEP_CMD       (0x07)</span>
<span class="cp">#define IOP_VERSION       (0x03)</span>
<span class="cp">#define IOP_CONFIG_HIGH   (0x04)</span>
<span class="cp">#define IOP_CONFIG_LOW    (0x02)</span>
<span class="cp">#define IOP_SIG_BYTE      (0x01)</span>
<span class="cp">#define IOP_SIG_WORD      (0x00)</span>
<span class="cp">#define IOP_REG_DC1      (0x0E)</span>
<span class="cp">#define IOP_REG_DC0      (0x0C)</span>
<span class="cp">#define IOP_REG_SB       (0x0B)</span>
<span class="cp">#define IOP_REG_DA1      (0x0A)</span>
<span class="cp">#define IOP_REG_DA0      (0x08)</span>
<span class="cp">#define IOP_REG_SC       (0x09)</span>
<span class="cp">#define IOP_DMA_SPEED    (0x07)</span>
<span class="cp">#define IOP_REG_FLAG     (0x07)</span>
<span class="cp">#define IOP_FIFO_H       (0x06)</span>
<span class="cp">#define IOP_FIFO_L       (0x04)</span>
<span class="cp">#define IOP_REG_ID       (0x05)</span>
<span class="cp">#define IOP_REG_QP       (0x03)</span>
<span class="cp">#define IOP_REG_IH       (0x02)</span>
<span class="cp">#define IOP_REG_IX       (0x01)</span>
<span class="cp">#define IOP_REG_AX       (0x00)</span>
<span class="cp">#define IFC_REG_LOCK      (0x00)</span>
<span class="cp">#define IFC_REG_UNLOCK    (0x09)</span>
<span class="cp">#define IFC_WR_EN_FILTER  (0x10)</span>
<span class="cp">#define IFC_RD_NO_EEPROM  (0x10)</span>
<span class="cp">#define IFC_SLEW_RATE     (0x20)</span>
<span class="cp">#define IFC_ACT_NEG       (0x40)</span>
<span class="cp">#define IFC_INP_FILTER    (0x80)</span>
<span class="cp">#define IFC_INIT_DEFAULT  (IFC_ACT_NEG | IFC_REG_UNLOCK)</span>
<span class="cp">#define SC_SEL   (uchar)(0x80)</span>
<span class="cp">#define SC_BSY   (uchar)(0x40)</span>
<span class="cp">#define SC_ACK   (uchar)(0x20)</span>
<span class="cp">#define SC_REQ   (uchar)(0x10)</span>
<span class="cp">#define SC_ATN   (uchar)(0x08)</span>
<span class="cp">#define SC_IO    (uchar)(0x04)</span>
<span class="cp">#define SC_CD    (uchar)(0x02)</span>
<span class="cp">#define SC_MSG   (uchar)(0x01)</span>
<span class="cp">#define SEC_SCSI_CTL         (uchar)(0x80)</span>
<span class="cp">#define SEC_ACTIVE_NEGATE    (uchar)(0x40)</span>
<span class="cp">#define SEC_SLEW_RATE        (uchar)(0x20)</span>
<span class="cp">#define SEC_ENABLE_FILTER    (uchar)(0x10)</span>
<span class="cp">#define ASC_HALT_EXTMSG_IN     (ushort)0x8000</span>
<span class="cp">#define ASC_HALT_CHK_CONDITION (ushort)0x8100</span>
<span class="cp">#define ASC_HALT_SS_QUEUE_FULL (ushort)0x8200</span>
<span class="cp">#define ASC_HALT_DISABLE_ASYN_USE_SYN_FIX  (ushort)0x8300</span>
<span class="cp">#define ASC_HALT_ENABLE_ASYN_USE_SYN_FIX   (ushort)0x8400</span>
<span class="cp">#define ASC_HALT_SDTR_REJECTED (ushort)0x4000</span>
<span class="cp">#define ASC_HALT_HOST_COPY_SG_LIST_TO_RISC ( ushort )0x2000</span>
<span class="cp">#define ASC_MAX_QNO        0xF8</span>
<span class="cp">#define ASC_DATA_SEC_BEG   (ushort)0x0080</span>
<span class="cp">#define ASC_DATA_SEC_END   (ushort)0x0080</span>
<span class="cp">#define ASC_CODE_SEC_BEG   (ushort)0x0080</span>
<span class="cp">#define ASC_CODE_SEC_END   (ushort)0x0080</span>
<span class="cp">#define ASC_QADR_BEG       (0x4000)</span>
<span class="cp">#define ASC_QADR_USED      (ushort)(ASC_MAX_QNO * 64)</span>
<span class="cp">#define ASC_QADR_END       (ushort)0x7FFF</span>
<span class="cp">#define ASC_QLAST_ADR      (ushort)0x7FC0</span>
<span class="cp">#define ASC_QBLK_SIZE      0x40</span>
<span class="cp">#define ASC_BIOS_DATA_QBEG 0xF8</span>
<span class="cp">#define ASC_MIN_ACTIVE_QNO 0x01</span>
<span class="cp">#define ASC_QLINK_END      0xFF</span>
<span class="cp">#define ASC_EEPROM_WORDS   0x10</span>
<span class="cp">#define ASC_MAX_MGS_LEN    0x10</span>
<span class="cp">#define ASC_BIOS_ADDR_DEF  0xDC00</span>
<span class="cp">#define ASC_BIOS_SIZE      0x3800</span>
<span class="cp">#define ASC_BIOS_RAM_OFF   0x3800</span>
<span class="cp">#define ASC_BIOS_RAM_SIZE  0x800</span>
<span class="cp">#define ASC_BIOS_MIN_ADDR  0xC000</span>
<span class="cp">#define ASC_BIOS_MAX_ADDR  0xEC00</span>
<span class="cp">#define ASC_BIOS_BANK_SIZE 0x0400</span>
<span class="cp">#define ASC_MCODE_START_ADDR  0x0080</span>
<span class="cp">#define ASC_CFG0_HOST_INT_ON    0x0020</span>
<span class="cp">#define ASC_CFG0_BIOS_ON        0x0040</span>
<span class="cp">#define ASC_CFG0_VERA_BURST_ON  0x0080</span>
<span class="cp">#define ASC_CFG0_SCSI_PARITY_ON 0x0800</span>
<span class="cp">#define ASC_CFG1_SCSI_TARGET_ON 0x0080</span>
<span class="cp">#define ASC_CFG1_LRAM_8BITS_ON  0x0800</span>
<span class="cp">#define ASC_CFG_MSW_CLR_MASK    0x3080</span>
<span class="cp">#define CSW_TEST1             (ASC_CS_TYPE)0x8000</span>
<span class="cp">#define CSW_AUTO_CONFIG       (ASC_CS_TYPE)0x4000</span>
<span class="cp">#define CSW_RESERVED1         (ASC_CS_TYPE)0x2000</span>
<span class="cp">#define CSW_IRQ_WRITTEN       (ASC_CS_TYPE)0x1000</span>
<span class="cp">#define CSW_33MHZ_SELECTED    (ASC_CS_TYPE)0x0800</span>
<span class="cp">#define CSW_TEST2             (ASC_CS_TYPE)0x0400</span>
<span class="cp">#define CSW_TEST3             (ASC_CS_TYPE)0x0200</span>
<span class="cp">#define CSW_RESERVED2         (ASC_CS_TYPE)0x0100</span>
<span class="cp">#define CSW_DMA_DONE          (ASC_CS_TYPE)0x0080</span>
<span class="cp">#define CSW_FIFO_RDY          (ASC_CS_TYPE)0x0040</span>
<span class="cp">#define CSW_EEP_READ_DONE     (ASC_CS_TYPE)0x0020</span>
<span class="cp">#define CSW_HALTED            (ASC_CS_TYPE)0x0010</span>
<span class="cp">#define CSW_SCSI_RESET_ACTIVE (ASC_CS_TYPE)0x0008</span>
<span class="cp">#define CSW_PARITY_ERR        (ASC_CS_TYPE)0x0004</span>
<span class="cp">#define CSW_SCSI_RESET_LATCH  (ASC_CS_TYPE)0x0002</span>
<span class="cp">#define CSW_INT_PENDING       (ASC_CS_TYPE)0x0001</span>
<span class="cp">#define CIW_CLR_SCSI_RESET_INT (ASC_CS_TYPE)0x1000</span>
<span class="cp">#define CIW_INT_ACK      (ASC_CS_TYPE)0x0100</span>
<span class="cp">#define CIW_TEST1        (ASC_CS_TYPE)0x0200</span>
<span class="cp">#define CIW_TEST2        (ASC_CS_TYPE)0x0400</span>
<span class="cp">#define CIW_SEL_33MHZ    (ASC_CS_TYPE)0x0800</span>
<span class="cp">#define CIW_IRQ_ACT      (ASC_CS_TYPE)0x1000</span>
<span class="cp">#define CC_CHIP_RESET   (uchar)0x80</span>
<span class="cp">#define CC_SCSI_RESET   (uchar)0x40</span>
<span class="cp">#define CC_HALT         (uchar)0x20</span>
<span class="cp">#define CC_SINGLE_STEP  (uchar)0x10</span>
<span class="cp">#define CC_DMA_ABLE     (uchar)0x08</span>
<span class="cp">#define CC_TEST         (uchar)0x04</span>
<span class="cp">#define CC_BANK_ONE     (uchar)0x02</span>
<span class="cp">#define CC_DIAG         (uchar)0x01</span>
<span class="cp">#define ASC_1000_ID0W      0x04C1</span>
<span class="cp">#define ASC_1000_ID0W_FIX  0x00C1</span>
<span class="cp">#define ASC_1000_ID1B      0x25</span>
<span class="cp">#define ASC_EISA_REV_IOP_MASK  (0x0C83)</span>
<span class="cp">#define ASC_EISA_CFG_IOP_MASK  (0x0C86)</span>
<span class="cp">#define ASC_GET_EISA_SLOT(iop)  (PortAddr)((iop) &amp; 0xF000)</span>
<span class="cp">#define INS_HALTINT        (ushort)0x6281</span>
<span class="cp">#define INS_HALT           (ushort)0x6280</span>
<span class="cp">#define INS_SINT           (ushort)0x6200</span>
<span class="cp">#define INS_RFLAG_WTM      (ushort)0x7380</span>
<span class="cp">#define ASC_MC_SAVE_CODE_WSIZE  0x500</span>
<span class="cp">#define ASC_MC_SAVE_DATA_WSIZE  0x40</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_mc_saved</span> <span class="p">{</span>
	<span class="n">ushort</span> <span class="n">data</span><span class="p">[</span><span class="n">ASC_MC_SAVE_DATA_WSIZE</span><span class="p">];</span>
	<span class="n">ushort</span> <span class="n">code</span><span class="p">[</span><span class="n">ASC_MC_SAVE_CODE_WSIZE</span><span class="p">];</span>
<span class="p">}</span> <span class="n">ASC_MC_SAVED</span><span class="p">;</span>

<span class="cp">#define AscGetQDoneInProgress(port)         AscReadLramByte((port), ASCV_Q_DONE_IN_PROGRESS_B)</span>
<span class="cp">#define AscPutQDoneInProgress(port, val)    AscWriteLramByte((port), ASCV_Q_DONE_IN_PROGRESS_B, val)</span>
<span class="cp">#define AscGetVarFreeQHead(port)            AscReadLramWord((port), ASCV_FREE_Q_HEAD_W)</span>
<span class="cp">#define AscGetVarDoneQTail(port)            AscReadLramWord((port), ASCV_DONE_Q_TAIL_W)</span>
<span class="cp">#define AscPutVarFreeQHead(port, val)       AscWriteLramWord((port), ASCV_FREE_Q_HEAD_W, val)</span>
<span class="cp">#define AscPutVarDoneQTail(port, val)       AscWriteLramWord((port), ASCV_DONE_Q_TAIL_W, val)</span>
<span class="cp">#define AscGetRiscVarFreeQHead(port)        AscReadLramByte((port), ASCV_NEXTRDY_B)</span>
<span class="cp">#define AscGetRiscVarDoneQTail(port)        AscReadLramByte((port), ASCV_DONENEXT_B)</span>
<span class="cp">#define AscPutRiscVarFreeQHead(port, val)   AscWriteLramByte((port), ASCV_NEXTRDY_B, val)</span>
<span class="cp">#define AscPutRiscVarDoneQTail(port, val)   AscWriteLramByte((port), ASCV_DONENEXT_B, val)</span>
<span class="cp">#define AscPutMCodeSDTRDoneAtID(port, id, data)  AscWriteLramByte((port), (ushort)((ushort)ASCV_SDTR_DONE_BEG+(ushort)id), (data))</span>
<span class="cp">#define AscGetMCodeSDTRDoneAtID(port, id)        AscReadLramByte((port), (ushort)((ushort)ASCV_SDTR_DONE_BEG+(ushort)id))</span>
<span class="cp">#define AscPutMCodeInitSDTRAtID(port, id, data)  AscWriteLramByte((port), (ushort)((ushort)ASCV_SDTR_DATA_BEG+(ushort)id), data)</span>
<span class="cp">#define AscGetMCodeInitSDTRAtID(port, id)        AscReadLramByte((port), (ushort)((ushort)ASCV_SDTR_DATA_BEG+(ushort)id))</span>
<span class="cp">#define AscGetChipSignatureByte(port)     (uchar)inp((port)+IOP_SIG_BYTE)</span>
<span class="cp">#define AscGetChipSignatureWord(port)     (ushort)inpw((port)+IOP_SIG_WORD)</span>
<span class="cp">#define AscGetChipVerNo(port)             (uchar)inp((port)+IOP_VERSION)</span>
<span class="cp">#define AscGetChipCfgLsw(port)            (ushort)inpw((port)+IOP_CONFIG_LOW)</span>
<span class="cp">#define AscGetChipCfgMsw(port)            (ushort)inpw((port)+IOP_CONFIG_HIGH)</span>
<span class="cp">#define AscSetChipCfgLsw(port, data)      outpw((port)+IOP_CONFIG_LOW, data)</span>
<span class="cp">#define AscSetChipCfgMsw(port, data)      outpw((port)+IOP_CONFIG_HIGH, data)</span>
<span class="cp">#define AscGetChipEEPCmd(port)            (uchar)inp((port)+IOP_EEP_CMD)</span>
<span class="cp">#define AscSetChipEEPCmd(port, data)      outp((port)+IOP_EEP_CMD, data)</span>
<span class="cp">#define AscGetChipEEPData(port)           (ushort)inpw((port)+IOP_EEP_DATA)</span>
<span class="cp">#define AscSetChipEEPData(port, data)     outpw((port)+IOP_EEP_DATA, data)</span>
<span class="cp">#define AscGetChipLramAddr(port)          (ushort)inpw((PortAddr)((port)+IOP_RAM_ADDR))</span>
<span class="cp">#define AscSetChipLramAddr(port, addr)    outpw((PortAddr)((port)+IOP_RAM_ADDR), addr)</span>
<span class="cp">#define AscGetChipLramData(port)          (ushort)inpw((port)+IOP_RAM_DATA)</span>
<span class="cp">#define AscSetChipLramData(port, data)    outpw((port)+IOP_RAM_DATA, data)</span>
<span class="cp">#define AscGetChipIFC(port)               (uchar)inp((port)+IOP_REG_IFC)</span>
<span class="cp">#define AscSetChipIFC(port, data)          outp((port)+IOP_REG_IFC, data)</span>
<span class="cp">#define AscGetChipStatus(port)            (ASC_CS_TYPE)inpw((port)+IOP_STATUS)</span>
<span class="cp">#define AscSetChipStatus(port, cs_val)    outpw((port)+IOP_STATUS, cs_val)</span>
<span class="cp">#define AscGetChipControl(port)           (uchar)inp((port)+IOP_CTRL)</span>
<span class="cp">#define AscSetChipControl(port, cc_val)   outp((port)+IOP_CTRL, cc_val)</span>
<span class="cp">#define AscGetChipSyn(port)               (uchar)inp((port)+IOP_SYN_OFFSET)</span>
<span class="cp">#define AscSetChipSyn(port, data)         outp((port)+IOP_SYN_OFFSET, data)</span>
<span class="cp">#define AscSetPCAddr(port, data)          outpw((port)+IOP_REG_PC, data)</span>
<span class="cp">#define AscGetPCAddr(port)                (ushort)inpw((port)+IOP_REG_PC)</span>
<span class="cp">#define AscIsIntPending(port)             (AscGetChipStatus(port) &amp; (CSW_INT_PENDING | CSW_SCSI_RESET_LATCH))</span>
<span class="cp">#define AscGetChipScsiID(port)            ((AscGetChipCfgLsw(port) &gt;&gt; 8) &amp; ASC_MAX_TID)</span>
<span class="cp">#define AscGetExtraControl(port)          (uchar)inp((port)+IOP_EXTRA_CONTROL)</span>
<span class="cp">#define AscSetExtraControl(port, data)    outp((port)+IOP_EXTRA_CONTROL, data)</span>
<span class="cp">#define AscReadChipAX(port)               (ushort)inpw((port)+IOP_REG_AX)</span>
<span class="cp">#define AscWriteChipAX(port, data)        outpw((port)+IOP_REG_AX, data)</span>
<span class="cp">#define AscReadChipIX(port)               (uchar)inp((port)+IOP_REG_IX)</span>
<span class="cp">#define AscWriteChipIX(port, data)        outp((port)+IOP_REG_IX, data)</span>
<span class="cp">#define AscReadChipIH(port)               (ushort)inpw((port)+IOP_REG_IH)</span>
<span class="cp">#define AscWriteChipIH(port, data)        outpw((port)+IOP_REG_IH, data)</span>
<span class="cp">#define AscReadChipQP(port)               (uchar)inp((port)+IOP_REG_QP)</span>
<span class="cp">#define AscWriteChipQP(port, data)        outp((port)+IOP_REG_QP, data)</span>
<span class="cp">#define AscReadChipFIFO_L(port)           (ushort)inpw((port)+IOP_REG_FIFO_L)</span>
<span class="cp">#define AscWriteChipFIFO_L(port, data)    outpw((port)+IOP_REG_FIFO_L, data)</span>
<span class="cp">#define AscReadChipFIFO_H(port)           (ushort)inpw((port)+IOP_REG_FIFO_H)</span>
<span class="cp">#define AscWriteChipFIFO_H(port, data)    outpw((port)+IOP_REG_FIFO_H, data)</span>
<span class="cp">#define AscReadChipDmaSpeed(port)         (uchar)inp((port)+IOP_DMA_SPEED)</span>
<span class="cp">#define AscWriteChipDmaSpeed(port, data)  outp((port)+IOP_DMA_SPEED, data)</span>
<span class="cp">#define AscReadChipDA0(port)              (ushort)inpw((port)+IOP_REG_DA0)</span>
<span class="cp">#define AscWriteChipDA0(port)             outpw((port)+IOP_REG_DA0, data)</span>
<span class="cp">#define AscReadChipDA1(port)              (ushort)inpw((port)+IOP_REG_DA1)</span>
<span class="cp">#define AscWriteChipDA1(port)             outpw((port)+IOP_REG_DA1, data)</span>
<span class="cp">#define AscReadChipDC0(port)              (ushort)inpw((port)+IOP_REG_DC0)</span>
<span class="cp">#define AscWriteChipDC0(port)             outpw((port)+IOP_REG_DC0, data)</span>
<span class="cp">#define AscReadChipDC1(port)              (ushort)inpw((port)+IOP_REG_DC1)</span>
<span class="cp">#define AscWriteChipDC1(port)             outpw((port)+IOP_REG_DC1, data)</span>
<span class="cp">#define AscReadChipDvcID(port)            (uchar)inp((port)+IOP_REG_ID)</span>
<span class="cp">#define AscWriteChipDvcID(port, data)     outp((port)+IOP_REG_ID, data)</span>

<span class="cm">/*</span>
<span class="cm"> * Portable Data Types</span>
<span class="cm"> *</span>
<span class="cm"> * Any instance where a 32-bit long or pointer type is assumed</span>
<span class="cm"> * for precision or HW defined structures, the following define</span>
<span class="cm"> * types must be used. In Linux the char, short, and int types</span>
<span class="cm"> * are all consistent at 8, 16, and 32 bits respectively. Pointers</span>
<span class="cm"> * and long types are 64 bits on Alpha and UltraSPARC.</span>
<span class="cm"> */</span>
<span class="cp">#define ADV_PADDR __u32		</span><span class="cm">/* Physical address data type. */</span><span class="cp"></span>
<span class="cp">#define ADV_VADDR __u32		</span><span class="cm">/* Virtual address data type. */</span><span class="cp"></span>
<span class="cp">#define ADV_DCNT  __u32		</span><span class="cm">/* Unsigned Data count type. */</span><span class="cp"></span>
<span class="cp">#define ADV_SDCNT __s32		</span><span class="cm">/* Signed Data count type. */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * These macros are used to convert a virtual address to a</span>
<span class="cm"> * 32-bit value. This currently can be used on Linux Alpha</span>
<span class="cm"> * which uses 64-bit virtual address but a 32-bit bus address.</span>
<span class="cm"> * This is likely to break in the future, but doing this now</span>
<span class="cm"> * will give us time to change the HW and FW to handle 64-bit</span>
<span class="cm"> * addresses.</span>
<span class="cm"> */</span>
<span class="cp">#define ADV_VADDR_TO_U32   virt_to_bus</span>
<span class="cp">#define ADV_U32_TO_VADDR   bus_to_virt</span>

<span class="cp">#define AdvPortAddr  void __iomem *	</span><span class="cm">/* Virtual memory address size */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Define Adv Library required memory access macros.</span>
<span class="cm"> */</span>
<span class="cp">#define ADV_MEM_READB(addr) readb(addr)</span>
<span class="cp">#define ADV_MEM_READW(addr) readw(addr)</span>
<span class="cp">#define ADV_MEM_WRITEB(addr, byte) writeb(byte, addr)</span>
<span class="cp">#define ADV_MEM_WRITEW(addr, word) writew(word, addr)</span>
<span class="cp">#define ADV_MEM_WRITEDW(addr, dword) writel(dword, addr)</span>

<span class="cp">#define ADV_CARRIER_COUNT (ASC_DEF_MAX_HOST_QNG + 15)</span>

<span class="cm">/*</span>
<span class="cm"> * Define total number of simultaneous maximum element scatter-gather</span>
<span class="cm"> * request blocks per wide adapter. ASC_DEF_MAX_HOST_QNG (253) is the</span>
<span class="cm"> * maximum number of outstanding commands per wide host adapter. Each</span>
<span class="cm"> * command uses one or more ADV_SG_BLOCK each with 15 scatter-gather</span>
<span class="cm"> * elements. Allow each command to have at least one ADV_SG_BLOCK structure.</span>
<span class="cm"> * This allows about 15 commands to have the maximum 17 ADV_SG_BLOCK</span>
<span class="cm"> * structures or 255 scatter-gather elements.</span>
<span class="cm"> */</span>
<span class="cp">#define ADV_TOT_SG_BLOCK        ASC_DEF_MAX_HOST_QNG</span>

<span class="cm">/*</span>
<span class="cm"> * Define maximum number of scatter-gather elements per request.</span>
<span class="cm"> */</span>
<span class="cp">#define ADV_MAX_SG_LIST         255</span>
<span class="cp">#define NO_OF_SG_PER_BLOCK              15</span>

<span class="cp">#define ADV_EEP_DVC_CFG_BEGIN           (0x00)</span>
<span class="cp">#define ADV_EEP_DVC_CFG_END             (0x15)</span>
<span class="cp">#define ADV_EEP_DVC_CTL_BEGIN           (0x16)	</span><span class="cm">/* location of OEM name */</span><span class="cp"></span>
<span class="cp">#define ADV_EEP_MAX_WORD_ADDR           (0x1E)</span>

<span class="cp">#define ADV_EEP_DELAY_MS                100</span>

<span class="cp">#define ADV_EEPROM_BIG_ENDIAN          0x8000	</span><span class="cm">/* EEPROM Bit 15 */</span><span class="cp"></span>
<span class="cp">#define ADV_EEPROM_BIOS_ENABLE         0x4000	</span><span class="cm">/* EEPROM Bit 14 */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * For the ASC3550 Bit 13 is Termination Polarity control bit.</span>
<span class="cm"> * For later ICs Bit 13 controls whether the CIS (Card Information</span>
<span class="cm"> * Service Section) is loaded from EEPROM.</span>
<span class="cm"> */</span>
<span class="cp">#define ADV_EEPROM_TERM_POL            0x2000	</span><span class="cm">/* EEPROM Bit 13 */</span><span class="cp"></span>
<span class="cp">#define ADV_EEPROM_CIS_LD              0x2000	</span><span class="cm">/* EEPROM Bit 13 */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * ASC38C1600 Bit 11</span>
<span class="cm"> *</span>
<span class="cm"> * If EEPROM Bit 11 is 0 for Function 0, then Function 0 will specify</span>
<span class="cm"> * INT A in the PCI Configuration Space Int Pin field. If it is 1, then</span>
<span class="cm"> * Function 0 will specify INT B.</span>
<span class="cm"> *</span>
<span class="cm"> * If EEPROM Bit 11 is 0 for Function 1, then Function 1 will specify</span>
<span class="cm"> * INT B in the PCI Configuration Space Int Pin field. If it is 1, then</span>
<span class="cm"> * Function 1 will specify INT A.</span>
<span class="cm"> */</span>
<span class="cp">#define ADV_EEPROM_INTAB               0x0800	</span><span class="cm">/* EEPROM Bit 11 */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">adveep_3550_config</span> <span class="p">{</span>
	<span class="cm">/* Word Offset, Description */</span>

	<span class="n">ushort</span> <span class="n">cfg_lsw</span><span class="p">;</span>		<span class="cm">/* 00 power up initialization */</span>
	<span class="cm">/*  bit 13 set - Term Polarity Control */</span>
	<span class="cm">/*  bit 14 set - BIOS Enable */</span>
	<span class="cm">/*  bit 15 set - Big Endian Mode */</span>
	<span class="n">ushort</span> <span class="n">cfg_msw</span><span class="p">;</span>		<span class="cm">/* 01 unused      */</span>
	<span class="n">ushort</span> <span class="n">disc_enable</span><span class="p">;</span>	<span class="cm">/* 02 disconnect enable */</span>
	<span class="n">ushort</span> <span class="n">wdtr_able</span><span class="p">;</span>	<span class="cm">/* 03 Wide DTR able */</span>
	<span class="n">ushort</span> <span class="n">sdtr_able</span><span class="p">;</span>	<span class="cm">/* 04 Synchronous DTR able */</span>
	<span class="n">ushort</span> <span class="n">start_motor</span><span class="p">;</span>	<span class="cm">/* 05 send start up motor */</span>
	<span class="n">ushort</span> <span class="n">tagqng_able</span><span class="p">;</span>	<span class="cm">/* 06 tag queuing able */</span>
	<span class="n">ushort</span> <span class="n">bios_scan</span><span class="p">;</span>	<span class="cm">/* 07 BIOS device control */</span>
	<span class="n">ushort</span> <span class="n">scam_tolerant</span><span class="p">;</span>	<span class="cm">/* 08 no scam */</span>

	<span class="n">uchar</span> <span class="n">adapter_scsi_id</span><span class="p">;</span>	<span class="cm">/* 09 Host Adapter ID */</span>
	<span class="n">uchar</span> <span class="n">bios_boot_delay</span><span class="p">;</span>	<span class="cm">/*    power up wait */</span>

	<span class="n">uchar</span> <span class="n">scsi_reset_delay</span><span class="p">;</span>	<span class="cm">/* 10 reset delay */</span>
	<span class="n">uchar</span> <span class="n">bios_id_lun</span><span class="p">;</span>	<span class="cm">/*    first boot device scsi id &amp; lun */</span>
	<span class="cm">/*    high nibble is lun */</span>
	<span class="cm">/*    low nibble is scsi id */</span>

	<span class="n">uchar</span> <span class="n">termination</span><span class="p">;</span>	<span class="cm">/* 11 0 - automatic */</span>
	<span class="cm">/*    1 - low off / high off */</span>
	<span class="cm">/*    2 - low off / high on */</span>
	<span class="cm">/*    3 - low on  / high on */</span>
	<span class="cm">/*    There is no low on  / high off */</span>

	<span class="n">uchar</span> <span class="n">reserved1</span><span class="p">;</span>	<span class="cm">/*    reserved byte (not used) */</span>

	<span class="n">ushort</span> <span class="n">bios_ctrl</span><span class="p">;</span>	<span class="cm">/* 12 BIOS control bits */</span>
	<span class="cm">/*  bit 0  BIOS don&#39;t act as initiator. */</span>
	<span class="cm">/*  bit 1  BIOS &gt; 1 GB support */</span>
	<span class="cm">/*  bit 2  BIOS &gt; 2 Disk Support */</span>
	<span class="cm">/*  bit 3  BIOS don&#39;t support removables */</span>
	<span class="cm">/*  bit 4  BIOS support bootable CD */</span>
	<span class="cm">/*  bit 5  BIOS scan enabled */</span>
	<span class="cm">/*  bit 6  BIOS support multiple LUNs */</span>
	<span class="cm">/*  bit 7  BIOS display of message */</span>
	<span class="cm">/*  bit 8  SCAM disabled */</span>
	<span class="cm">/*  bit 9  Reset SCSI bus during init. */</span>
	<span class="cm">/*  bit 10 */</span>
	<span class="cm">/*  bit 11 No verbose initialization. */</span>
	<span class="cm">/*  bit 12 SCSI parity enabled */</span>
	<span class="cm">/*  bit 13 */</span>
	<span class="cm">/*  bit 14 */</span>
	<span class="cm">/*  bit 15 */</span>
	<span class="n">ushort</span> <span class="n">ultra_able</span><span class="p">;</span>	<span class="cm">/* 13 ULTRA speed able */</span>
	<span class="n">ushort</span> <span class="n">reserved2</span><span class="p">;</span>	<span class="cm">/* 14 reserved */</span>
	<span class="n">uchar</span> <span class="n">max_host_qng</span><span class="p">;</span>	<span class="cm">/* 15 maximum host queuing */</span>
	<span class="n">uchar</span> <span class="n">max_dvc_qng</span><span class="p">;</span>	<span class="cm">/*    maximum per device queuing */</span>
	<span class="n">ushort</span> <span class="n">dvc_cntl</span><span class="p">;</span>	<span class="cm">/* 16 control bit for driver */</span>
	<span class="n">ushort</span> <span class="n">bug_fix</span><span class="p">;</span>		<span class="cm">/* 17 control bit for bug fix */</span>
	<span class="n">ushort</span> <span class="n">serial_number_word1</span><span class="p">;</span>	<span class="cm">/* 18 Board serial number word 1 */</span>
	<span class="n">ushort</span> <span class="n">serial_number_word2</span><span class="p">;</span>	<span class="cm">/* 19 Board serial number word 2 */</span>
	<span class="n">ushort</span> <span class="n">serial_number_word3</span><span class="p">;</span>	<span class="cm">/* 20 Board serial number word 3 */</span>
	<span class="n">ushort</span> <span class="n">check_sum</span><span class="p">;</span>	<span class="cm">/* 21 EEP check sum */</span>
	<span class="n">uchar</span> <span class="n">oem_name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* 22 OEM name */</span>
	<span class="n">ushort</span> <span class="n">dvc_err_code</span><span class="p">;</span>	<span class="cm">/* 30 last device driver error code */</span>
	<span class="n">ushort</span> <span class="n">adv_err_code</span><span class="p">;</span>	<span class="cm">/* 31 last uc and Adv Lib error code */</span>
	<span class="n">ushort</span> <span class="n">adv_err_addr</span><span class="p">;</span>	<span class="cm">/* 32 last uc error address */</span>
	<span class="n">ushort</span> <span class="n">saved_dvc_err_code</span><span class="p">;</span>	<span class="cm">/* 33 saved last dev. driver error code   */</span>
	<span class="n">ushort</span> <span class="n">saved_adv_err_code</span><span class="p">;</span>	<span class="cm">/* 34 saved last uc and Adv Lib error code */</span>
	<span class="n">ushort</span> <span class="n">saved_adv_err_addr</span><span class="p">;</span>	<span class="cm">/* 35 saved last uc error address         */</span>
	<span class="n">ushort</span> <span class="n">num_of_err</span><span class="p">;</span>	<span class="cm">/* 36 number of error */</span>
<span class="p">}</span> <span class="n">ADVEEP_3550_CONFIG</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">adveep_38C0800_config</span> <span class="p">{</span>
	<span class="cm">/* Word Offset, Description */</span>

	<span class="n">ushort</span> <span class="n">cfg_lsw</span><span class="p">;</span>		<span class="cm">/* 00 power up initialization */</span>
	<span class="cm">/*  bit 13 set - Load CIS */</span>
	<span class="cm">/*  bit 14 set - BIOS Enable */</span>
	<span class="cm">/*  bit 15 set - Big Endian Mode */</span>
	<span class="n">ushort</span> <span class="n">cfg_msw</span><span class="p">;</span>		<span class="cm">/* 01 unused      */</span>
	<span class="n">ushort</span> <span class="n">disc_enable</span><span class="p">;</span>	<span class="cm">/* 02 disconnect enable */</span>
	<span class="n">ushort</span> <span class="n">wdtr_able</span><span class="p">;</span>	<span class="cm">/* 03 Wide DTR able */</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed1</span><span class="p">;</span>	<span class="cm">/* 04 SDTR Speed TID 0-3 */</span>
	<span class="n">ushort</span> <span class="n">start_motor</span><span class="p">;</span>	<span class="cm">/* 05 send start up motor */</span>
	<span class="n">ushort</span> <span class="n">tagqng_able</span><span class="p">;</span>	<span class="cm">/* 06 tag queuing able */</span>
	<span class="n">ushort</span> <span class="n">bios_scan</span><span class="p">;</span>	<span class="cm">/* 07 BIOS device control */</span>
	<span class="n">ushort</span> <span class="n">scam_tolerant</span><span class="p">;</span>	<span class="cm">/* 08 no scam */</span>

	<span class="n">uchar</span> <span class="n">adapter_scsi_id</span><span class="p">;</span>	<span class="cm">/* 09 Host Adapter ID */</span>
	<span class="n">uchar</span> <span class="n">bios_boot_delay</span><span class="p">;</span>	<span class="cm">/*    power up wait */</span>

	<span class="n">uchar</span> <span class="n">scsi_reset_delay</span><span class="p">;</span>	<span class="cm">/* 10 reset delay */</span>
	<span class="n">uchar</span> <span class="n">bios_id_lun</span><span class="p">;</span>	<span class="cm">/*    first boot device scsi id &amp; lun */</span>
	<span class="cm">/*    high nibble is lun */</span>
	<span class="cm">/*    low nibble is scsi id */</span>

	<span class="n">uchar</span> <span class="n">termination_se</span><span class="p">;</span>	<span class="cm">/* 11 0 - automatic */</span>
	<span class="cm">/*    1 - low off / high off */</span>
	<span class="cm">/*    2 - low off / high on */</span>
	<span class="cm">/*    3 - low on  / high on */</span>
	<span class="cm">/*    There is no low on  / high off */</span>

	<span class="n">uchar</span> <span class="n">termination_lvd</span><span class="p">;</span>	<span class="cm">/* 11 0 - automatic */</span>
	<span class="cm">/*    1 - low off / high off */</span>
	<span class="cm">/*    2 - low off / high on */</span>
	<span class="cm">/*    3 - low on  / high on */</span>
	<span class="cm">/*    There is no low on  / high off */</span>

	<span class="n">ushort</span> <span class="n">bios_ctrl</span><span class="p">;</span>	<span class="cm">/* 12 BIOS control bits */</span>
	<span class="cm">/*  bit 0  BIOS don&#39;t act as initiator. */</span>
	<span class="cm">/*  bit 1  BIOS &gt; 1 GB support */</span>
	<span class="cm">/*  bit 2  BIOS &gt; 2 Disk Support */</span>
	<span class="cm">/*  bit 3  BIOS don&#39;t support removables */</span>
	<span class="cm">/*  bit 4  BIOS support bootable CD */</span>
	<span class="cm">/*  bit 5  BIOS scan enabled */</span>
	<span class="cm">/*  bit 6  BIOS support multiple LUNs */</span>
	<span class="cm">/*  bit 7  BIOS display of message */</span>
	<span class="cm">/*  bit 8  SCAM disabled */</span>
	<span class="cm">/*  bit 9  Reset SCSI bus during init. */</span>
	<span class="cm">/*  bit 10 */</span>
	<span class="cm">/*  bit 11 No verbose initialization. */</span>
	<span class="cm">/*  bit 12 SCSI parity enabled */</span>
	<span class="cm">/*  bit 13 */</span>
	<span class="cm">/*  bit 14 */</span>
	<span class="cm">/*  bit 15 */</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed2</span><span class="p">;</span>	<span class="cm">/* 13 SDTR speed TID 4-7 */</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed3</span><span class="p">;</span>	<span class="cm">/* 14 SDTR speed TID 8-11 */</span>
	<span class="n">uchar</span> <span class="n">max_host_qng</span><span class="p">;</span>	<span class="cm">/* 15 maximum host queueing */</span>
	<span class="n">uchar</span> <span class="n">max_dvc_qng</span><span class="p">;</span>	<span class="cm">/*    maximum per device queuing */</span>
	<span class="n">ushort</span> <span class="n">dvc_cntl</span><span class="p">;</span>	<span class="cm">/* 16 control bit for driver */</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed4</span><span class="p">;</span>	<span class="cm">/* 17 SDTR speed 4 TID 12-15 */</span>
	<span class="n">ushort</span> <span class="n">serial_number_word1</span><span class="p">;</span>	<span class="cm">/* 18 Board serial number word 1 */</span>
	<span class="n">ushort</span> <span class="n">serial_number_word2</span><span class="p">;</span>	<span class="cm">/* 19 Board serial number word 2 */</span>
	<span class="n">ushort</span> <span class="n">serial_number_word3</span><span class="p">;</span>	<span class="cm">/* 20 Board serial number word 3 */</span>
	<span class="n">ushort</span> <span class="n">check_sum</span><span class="p">;</span>	<span class="cm">/* 21 EEP check sum */</span>
	<span class="n">uchar</span> <span class="n">oem_name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* 22 OEM name */</span>
	<span class="n">ushort</span> <span class="n">dvc_err_code</span><span class="p">;</span>	<span class="cm">/* 30 last device driver error code */</span>
	<span class="n">ushort</span> <span class="n">adv_err_code</span><span class="p">;</span>	<span class="cm">/* 31 last uc and Adv Lib error code */</span>
	<span class="n">ushort</span> <span class="n">adv_err_addr</span><span class="p">;</span>	<span class="cm">/* 32 last uc error address */</span>
	<span class="n">ushort</span> <span class="n">saved_dvc_err_code</span><span class="p">;</span>	<span class="cm">/* 33 saved last dev. driver error code   */</span>
	<span class="n">ushort</span> <span class="n">saved_adv_err_code</span><span class="p">;</span>	<span class="cm">/* 34 saved last uc and Adv Lib error code */</span>
	<span class="n">ushort</span> <span class="n">saved_adv_err_addr</span><span class="p">;</span>	<span class="cm">/* 35 saved last uc error address         */</span>
	<span class="n">ushort</span> <span class="n">reserved36</span><span class="p">;</span>	<span class="cm">/* 36 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved37</span><span class="p">;</span>	<span class="cm">/* 37 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved38</span><span class="p">;</span>	<span class="cm">/* 38 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved39</span><span class="p">;</span>	<span class="cm">/* 39 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved40</span><span class="p">;</span>	<span class="cm">/* 40 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved41</span><span class="p">;</span>	<span class="cm">/* 41 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved42</span><span class="p">;</span>	<span class="cm">/* 42 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved43</span><span class="p">;</span>	<span class="cm">/* 43 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved44</span><span class="p">;</span>	<span class="cm">/* 44 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved45</span><span class="p">;</span>	<span class="cm">/* 45 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved46</span><span class="p">;</span>	<span class="cm">/* 46 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved47</span><span class="p">;</span>	<span class="cm">/* 47 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved48</span><span class="p">;</span>	<span class="cm">/* 48 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved49</span><span class="p">;</span>	<span class="cm">/* 49 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved50</span><span class="p">;</span>	<span class="cm">/* 50 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved51</span><span class="p">;</span>	<span class="cm">/* 51 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved52</span><span class="p">;</span>	<span class="cm">/* 52 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved53</span><span class="p">;</span>	<span class="cm">/* 53 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved54</span><span class="p">;</span>	<span class="cm">/* 54 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved55</span><span class="p">;</span>	<span class="cm">/* 55 reserved */</span>
	<span class="n">ushort</span> <span class="n">cisptr_lsw</span><span class="p">;</span>	<span class="cm">/* 56 CIS PTR LSW */</span>
	<span class="n">ushort</span> <span class="n">cisprt_msw</span><span class="p">;</span>	<span class="cm">/* 57 CIS PTR MSW */</span>
	<span class="n">ushort</span> <span class="n">subsysvid</span><span class="p">;</span>	<span class="cm">/* 58 SubSystem Vendor ID */</span>
	<span class="n">ushort</span> <span class="n">subsysid</span><span class="p">;</span>	<span class="cm">/* 59 SubSystem ID */</span>
	<span class="n">ushort</span> <span class="n">reserved60</span><span class="p">;</span>	<span class="cm">/* 60 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved61</span><span class="p">;</span>	<span class="cm">/* 61 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved62</span><span class="p">;</span>	<span class="cm">/* 62 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved63</span><span class="p">;</span>	<span class="cm">/* 63 reserved */</span>
<span class="p">}</span> <span class="n">ADVEEP_38C0800_CONFIG</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">adveep_38C1600_config</span> <span class="p">{</span>
	<span class="cm">/* Word Offset, Description */</span>

	<span class="n">ushort</span> <span class="n">cfg_lsw</span><span class="p">;</span>		<span class="cm">/* 00 power up initialization */</span>
	<span class="cm">/*  bit 11 set - Func. 0 INTB, Func. 1 INTA */</span>
	<span class="cm">/*       clear - Func. 0 INTA, Func. 1 INTB */</span>
	<span class="cm">/*  bit 13 set - Load CIS */</span>
	<span class="cm">/*  bit 14 set - BIOS Enable */</span>
	<span class="cm">/*  bit 15 set - Big Endian Mode */</span>
	<span class="n">ushort</span> <span class="n">cfg_msw</span><span class="p">;</span>		<span class="cm">/* 01 unused */</span>
	<span class="n">ushort</span> <span class="n">disc_enable</span><span class="p">;</span>	<span class="cm">/* 02 disconnect enable */</span>
	<span class="n">ushort</span> <span class="n">wdtr_able</span><span class="p">;</span>	<span class="cm">/* 03 Wide DTR able */</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed1</span><span class="p">;</span>	<span class="cm">/* 04 SDTR Speed TID 0-3 */</span>
	<span class="n">ushort</span> <span class="n">start_motor</span><span class="p">;</span>	<span class="cm">/* 05 send start up motor */</span>
	<span class="n">ushort</span> <span class="n">tagqng_able</span><span class="p">;</span>	<span class="cm">/* 06 tag queuing able */</span>
	<span class="n">ushort</span> <span class="n">bios_scan</span><span class="p">;</span>	<span class="cm">/* 07 BIOS device control */</span>
	<span class="n">ushort</span> <span class="n">scam_tolerant</span><span class="p">;</span>	<span class="cm">/* 08 no scam */</span>

	<span class="n">uchar</span> <span class="n">adapter_scsi_id</span><span class="p">;</span>	<span class="cm">/* 09 Host Adapter ID */</span>
	<span class="n">uchar</span> <span class="n">bios_boot_delay</span><span class="p">;</span>	<span class="cm">/*    power up wait */</span>

	<span class="n">uchar</span> <span class="n">scsi_reset_delay</span><span class="p">;</span>	<span class="cm">/* 10 reset delay */</span>
	<span class="n">uchar</span> <span class="n">bios_id_lun</span><span class="p">;</span>	<span class="cm">/*    first boot device scsi id &amp; lun */</span>
	<span class="cm">/*    high nibble is lun */</span>
	<span class="cm">/*    low nibble is scsi id */</span>

	<span class="n">uchar</span> <span class="n">termination_se</span><span class="p">;</span>	<span class="cm">/* 11 0 - automatic */</span>
	<span class="cm">/*    1 - low off / high off */</span>
	<span class="cm">/*    2 - low off / high on */</span>
	<span class="cm">/*    3 - low on  / high on */</span>
	<span class="cm">/*    There is no low on  / high off */</span>

	<span class="n">uchar</span> <span class="n">termination_lvd</span><span class="p">;</span>	<span class="cm">/* 11 0 - automatic */</span>
	<span class="cm">/*    1 - low off / high off */</span>
	<span class="cm">/*    2 - low off / high on */</span>
	<span class="cm">/*    3 - low on  / high on */</span>
	<span class="cm">/*    There is no low on  / high off */</span>

	<span class="n">ushort</span> <span class="n">bios_ctrl</span><span class="p">;</span>	<span class="cm">/* 12 BIOS control bits */</span>
	<span class="cm">/*  bit 0  BIOS don&#39;t act as initiator. */</span>
	<span class="cm">/*  bit 1  BIOS &gt; 1 GB support */</span>
	<span class="cm">/*  bit 2  BIOS &gt; 2 Disk Support */</span>
	<span class="cm">/*  bit 3  BIOS don&#39;t support removables */</span>
	<span class="cm">/*  bit 4  BIOS support bootable CD */</span>
	<span class="cm">/*  bit 5  BIOS scan enabled */</span>
	<span class="cm">/*  bit 6  BIOS support multiple LUNs */</span>
	<span class="cm">/*  bit 7  BIOS display of message */</span>
	<span class="cm">/*  bit 8  SCAM disabled */</span>
	<span class="cm">/*  bit 9  Reset SCSI bus during init. */</span>
	<span class="cm">/*  bit 10 Basic Integrity Checking disabled */</span>
	<span class="cm">/*  bit 11 No verbose initialization. */</span>
	<span class="cm">/*  bit 12 SCSI parity enabled */</span>
	<span class="cm">/*  bit 13 AIPP (Asyn. Info. Ph. Prot.) dis. */</span>
	<span class="cm">/*  bit 14 */</span>
	<span class="cm">/*  bit 15 */</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed2</span><span class="p">;</span>	<span class="cm">/* 13 SDTR speed TID 4-7 */</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed3</span><span class="p">;</span>	<span class="cm">/* 14 SDTR speed TID 8-11 */</span>
	<span class="n">uchar</span> <span class="n">max_host_qng</span><span class="p">;</span>	<span class="cm">/* 15 maximum host queueing */</span>
	<span class="n">uchar</span> <span class="n">max_dvc_qng</span><span class="p">;</span>	<span class="cm">/*    maximum per device queuing */</span>
	<span class="n">ushort</span> <span class="n">dvc_cntl</span><span class="p">;</span>	<span class="cm">/* 16 control bit for driver */</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed4</span><span class="p">;</span>	<span class="cm">/* 17 SDTR speed 4 TID 12-15 */</span>
	<span class="n">ushort</span> <span class="n">serial_number_word1</span><span class="p">;</span>	<span class="cm">/* 18 Board serial number word 1 */</span>
	<span class="n">ushort</span> <span class="n">serial_number_word2</span><span class="p">;</span>	<span class="cm">/* 19 Board serial number word 2 */</span>
	<span class="n">ushort</span> <span class="n">serial_number_word3</span><span class="p">;</span>	<span class="cm">/* 20 Board serial number word 3 */</span>
	<span class="n">ushort</span> <span class="n">check_sum</span><span class="p">;</span>	<span class="cm">/* 21 EEP check sum */</span>
	<span class="n">uchar</span> <span class="n">oem_name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* 22 OEM name */</span>
	<span class="n">ushort</span> <span class="n">dvc_err_code</span><span class="p">;</span>	<span class="cm">/* 30 last device driver error code */</span>
	<span class="n">ushort</span> <span class="n">adv_err_code</span><span class="p">;</span>	<span class="cm">/* 31 last uc and Adv Lib error code */</span>
	<span class="n">ushort</span> <span class="n">adv_err_addr</span><span class="p">;</span>	<span class="cm">/* 32 last uc error address */</span>
	<span class="n">ushort</span> <span class="n">saved_dvc_err_code</span><span class="p">;</span>	<span class="cm">/* 33 saved last dev. driver error code   */</span>
	<span class="n">ushort</span> <span class="n">saved_adv_err_code</span><span class="p">;</span>	<span class="cm">/* 34 saved last uc and Adv Lib error code */</span>
	<span class="n">ushort</span> <span class="n">saved_adv_err_addr</span><span class="p">;</span>	<span class="cm">/* 35 saved last uc error address         */</span>
	<span class="n">ushort</span> <span class="n">reserved36</span><span class="p">;</span>	<span class="cm">/* 36 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved37</span><span class="p">;</span>	<span class="cm">/* 37 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved38</span><span class="p">;</span>	<span class="cm">/* 38 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved39</span><span class="p">;</span>	<span class="cm">/* 39 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved40</span><span class="p">;</span>	<span class="cm">/* 40 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved41</span><span class="p">;</span>	<span class="cm">/* 41 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved42</span><span class="p">;</span>	<span class="cm">/* 42 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved43</span><span class="p">;</span>	<span class="cm">/* 43 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved44</span><span class="p">;</span>	<span class="cm">/* 44 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved45</span><span class="p">;</span>	<span class="cm">/* 45 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved46</span><span class="p">;</span>	<span class="cm">/* 46 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved47</span><span class="p">;</span>	<span class="cm">/* 47 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved48</span><span class="p">;</span>	<span class="cm">/* 48 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved49</span><span class="p">;</span>	<span class="cm">/* 49 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved50</span><span class="p">;</span>	<span class="cm">/* 50 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved51</span><span class="p">;</span>	<span class="cm">/* 51 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved52</span><span class="p">;</span>	<span class="cm">/* 52 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved53</span><span class="p">;</span>	<span class="cm">/* 53 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved54</span><span class="p">;</span>	<span class="cm">/* 54 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved55</span><span class="p">;</span>	<span class="cm">/* 55 reserved */</span>
	<span class="n">ushort</span> <span class="n">cisptr_lsw</span><span class="p">;</span>	<span class="cm">/* 56 CIS PTR LSW */</span>
	<span class="n">ushort</span> <span class="n">cisprt_msw</span><span class="p">;</span>	<span class="cm">/* 57 CIS PTR MSW */</span>
	<span class="n">ushort</span> <span class="n">subsysvid</span><span class="p">;</span>	<span class="cm">/* 58 SubSystem Vendor ID */</span>
	<span class="n">ushort</span> <span class="n">subsysid</span><span class="p">;</span>	<span class="cm">/* 59 SubSystem ID */</span>
	<span class="n">ushort</span> <span class="n">reserved60</span><span class="p">;</span>	<span class="cm">/* 60 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved61</span><span class="p">;</span>	<span class="cm">/* 61 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved62</span><span class="p">;</span>	<span class="cm">/* 62 reserved */</span>
	<span class="n">ushort</span> <span class="n">reserved63</span><span class="p">;</span>	<span class="cm">/* 63 reserved */</span>
<span class="p">}</span> <span class="n">ADVEEP_38C1600_CONFIG</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * EEPROM Commands</span>
<span class="cm"> */</span>
<span class="cp">#define ASC_EEP_CMD_DONE             0x0200</span>

<span class="cm">/* bios_ctrl */</span>
<span class="cp">#define BIOS_CTRL_BIOS               0x0001</span>
<span class="cp">#define BIOS_CTRL_EXTENDED_XLAT      0x0002</span>
<span class="cp">#define BIOS_CTRL_GT_2_DISK          0x0004</span>
<span class="cp">#define BIOS_CTRL_BIOS_REMOVABLE     0x0008</span>
<span class="cp">#define BIOS_CTRL_BOOTABLE_CD        0x0010</span>
<span class="cp">#define BIOS_CTRL_MULTIPLE_LUN       0x0040</span>
<span class="cp">#define BIOS_CTRL_DISPLAY_MSG        0x0080</span>
<span class="cp">#define BIOS_CTRL_NO_SCAM            0x0100</span>
<span class="cp">#define BIOS_CTRL_RESET_SCSI_BUS     0x0200</span>
<span class="cp">#define BIOS_CTRL_INIT_VERBOSE       0x0800</span>
<span class="cp">#define BIOS_CTRL_SCSI_PARITY        0x1000</span>
<span class="cp">#define BIOS_CTRL_AIPP_DIS           0x2000</span>

<span class="cp">#define ADV_3550_MEMSIZE   0x2000	</span><span class="cm">/* 8 KB Internal Memory */</span><span class="cp"></span>

<span class="cp">#define ADV_38C0800_MEMSIZE  0x4000	</span><span class="cm">/* 16 KB Internal Memory */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * XXX - Since ASC38C1600 Rev.3 has a local RAM failure issue, there is</span>
<span class="cm"> * a special 16K Adv Library and Microcode version. After the issue is</span>
<span class="cm"> * resolved, should restore 32K support.</span>
<span class="cm"> *</span>
<span class="cm"> * #define ADV_38C1600_MEMSIZE  0x8000L   * 32 KB Internal Memory *</span>
<span class="cm"> */</span>
<span class="cp">#define ADV_38C1600_MEMSIZE  0x4000	</span><span class="cm">/* 16 KB Internal Memory */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Byte I/O register address from base of &#39;iop_base&#39;.</span>
<span class="cm"> */</span>
<span class="cp">#define IOPB_INTR_STATUS_REG    0x00</span>
<span class="cp">#define IOPB_CHIP_ID_1          0x01</span>
<span class="cp">#define IOPB_INTR_ENABLES       0x02</span>
<span class="cp">#define IOPB_CHIP_TYPE_REV      0x03</span>
<span class="cp">#define IOPB_RES_ADDR_4         0x04</span>
<span class="cp">#define IOPB_RES_ADDR_5         0x05</span>
<span class="cp">#define IOPB_RAM_DATA           0x06</span>
<span class="cp">#define IOPB_RES_ADDR_7         0x07</span>
<span class="cp">#define IOPB_FLAG_REG           0x08</span>
<span class="cp">#define IOPB_RES_ADDR_9         0x09</span>
<span class="cp">#define IOPB_RISC_CSR           0x0A</span>
<span class="cp">#define IOPB_RES_ADDR_B         0x0B</span>
<span class="cp">#define IOPB_RES_ADDR_C         0x0C</span>
<span class="cp">#define IOPB_RES_ADDR_D         0x0D</span>
<span class="cp">#define IOPB_SOFT_OVER_WR       0x0E</span>
<span class="cp">#define IOPB_RES_ADDR_F         0x0F</span>
<span class="cp">#define IOPB_MEM_CFG            0x10</span>
<span class="cp">#define IOPB_RES_ADDR_11        0x11</span>
<span class="cp">#define IOPB_GPIO_DATA          0x12</span>
<span class="cp">#define IOPB_RES_ADDR_13        0x13</span>
<span class="cp">#define IOPB_FLASH_PAGE         0x14</span>
<span class="cp">#define IOPB_RES_ADDR_15        0x15</span>
<span class="cp">#define IOPB_GPIO_CNTL          0x16</span>
<span class="cp">#define IOPB_RES_ADDR_17        0x17</span>
<span class="cp">#define IOPB_FLASH_DATA         0x18</span>
<span class="cp">#define IOPB_RES_ADDR_19        0x19</span>
<span class="cp">#define IOPB_RES_ADDR_1A        0x1A</span>
<span class="cp">#define IOPB_RES_ADDR_1B        0x1B</span>
<span class="cp">#define IOPB_RES_ADDR_1C        0x1C</span>
<span class="cp">#define IOPB_RES_ADDR_1D        0x1D</span>
<span class="cp">#define IOPB_RES_ADDR_1E        0x1E</span>
<span class="cp">#define IOPB_RES_ADDR_1F        0x1F</span>
<span class="cp">#define IOPB_DMA_CFG0           0x20</span>
<span class="cp">#define IOPB_DMA_CFG1           0x21</span>
<span class="cp">#define IOPB_TICKLE             0x22</span>
<span class="cp">#define IOPB_DMA_REG_WR         0x23</span>
<span class="cp">#define IOPB_SDMA_STATUS        0x24</span>
<span class="cp">#define IOPB_SCSI_BYTE_CNT      0x25</span>
<span class="cp">#define IOPB_HOST_BYTE_CNT      0x26</span>
<span class="cp">#define IOPB_BYTE_LEFT_TO_XFER  0x27</span>
<span class="cp">#define IOPB_BYTE_TO_XFER_0     0x28</span>
<span class="cp">#define IOPB_BYTE_TO_XFER_1     0x29</span>
<span class="cp">#define IOPB_BYTE_TO_XFER_2     0x2A</span>
<span class="cp">#define IOPB_BYTE_TO_XFER_3     0x2B</span>
<span class="cp">#define IOPB_ACC_GRP            0x2C</span>
<span class="cp">#define IOPB_RES_ADDR_2D        0x2D</span>
<span class="cp">#define IOPB_DEV_ID             0x2E</span>
<span class="cp">#define IOPB_RES_ADDR_2F        0x2F</span>
<span class="cp">#define IOPB_SCSI_DATA          0x30</span>
<span class="cp">#define IOPB_RES_ADDR_31        0x31</span>
<span class="cp">#define IOPB_RES_ADDR_32        0x32</span>
<span class="cp">#define IOPB_SCSI_DATA_HSHK     0x33</span>
<span class="cp">#define IOPB_SCSI_CTRL          0x34</span>
<span class="cp">#define IOPB_RES_ADDR_35        0x35</span>
<span class="cp">#define IOPB_RES_ADDR_36        0x36</span>
<span class="cp">#define IOPB_RES_ADDR_37        0x37</span>
<span class="cp">#define IOPB_RAM_BIST           0x38</span>
<span class="cp">#define IOPB_PLL_TEST           0x39</span>
<span class="cp">#define IOPB_PCI_INT_CFG        0x3A</span>
<span class="cp">#define IOPB_RES_ADDR_3B        0x3B</span>
<span class="cp">#define IOPB_RFIFO_CNT          0x3C</span>
<span class="cp">#define IOPB_RES_ADDR_3D        0x3D</span>
<span class="cp">#define IOPB_RES_ADDR_3E        0x3E</span>
<span class="cp">#define IOPB_RES_ADDR_3F        0x3F</span>

<span class="cm">/*</span>
<span class="cm"> * Word I/O register address from base of &#39;iop_base&#39;.</span>
<span class="cm"> */</span>
<span class="cp">#define IOPW_CHIP_ID_0          0x00	</span><span class="cm">/* CID0  */</span><span class="cp"></span>
<span class="cp">#define IOPW_CTRL_REG           0x02	</span><span class="cm">/* CC    */</span><span class="cp"></span>
<span class="cp">#define IOPW_RAM_ADDR           0x04	</span><span class="cm">/* LA    */</span><span class="cp"></span>
<span class="cp">#define IOPW_RAM_DATA           0x06	</span><span class="cm">/* LD    */</span><span class="cp"></span>
<span class="cp">#define IOPW_RES_ADDR_08        0x08</span>
<span class="cp">#define IOPW_RISC_CSR           0x0A	</span><span class="cm">/* CSR   */</span><span class="cp"></span>
<span class="cp">#define IOPW_SCSI_CFG0          0x0C	</span><span class="cm">/* CFG0  */</span><span class="cp"></span>
<span class="cp">#define IOPW_SCSI_CFG1          0x0E	</span><span class="cm">/* CFG1  */</span><span class="cp"></span>
<span class="cp">#define IOPW_RES_ADDR_10        0x10</span>
<span class="cp">#define IOPW_SEL_MASK           0x12	</span><span class="cm">/* SM    */</span><span class="cp"></span>
<span class="cp">#define IOPW_RES_ADDR_14        0x14</span>
<span class="cp">#define IOPW_FLASH_ADDR         0x16	</span><span class="cm">/* FA    */</span><span class="cp"></span>
<span class="cp">#define IOPW_RES_ADDR_18        0x18</span>
<span class="cp">#define IOPW_EE_CMD             0x1A	</span><span class="cm">/* EC    */</span><span class="cp"></span>
<span class="cp">#define IOPW_EE_DATA            0x1C	</span><span class="cm">/* ED    */</span><span class="cp"></span>
<span class="cp">#define IOPW_SFIFO_CNT          0x1E	</span><span class="cm">/* SFC   */</span><span class="cp"></span>
<span class="cp">#define IOPW_RES_ADDR_20        0x20</span>
<span class="cp">#define IOPW_Q_BASE             0x22	</span><span class="cm">/* QB    */</span><span class="cp"></span>
<span class="cp">#define IOPW_QP                 0x24	</span><span class="cm">/* QP    */</span><span class="cp"></span>
<span class="cp">#define IOPW_IX                 0x26	</span><span class="cm">/* IX    */</span><span class="cp"></span>
<span class="cp">#define IOPW_SP                 0x28	</span><span class="cm">/* SP    */</span><span class="cp"></span>
<span class="cp">#define IOPW_PC                 0x2A	</span><span class="cm">/* PC    */</span><span class="cp"></span>
<span class="cp">#define IOPW_RES_ADDR_2C        0x2C</span>
<span class="cp">#define IOPW_RES_ADDR_2E        0x2E</span>
<span class="cp">#define IOPW_SCSI_DATA          0x30	</span><span class="cm">/* SD    */</span><span class="cp"></span>
<span class="cp">#define IOPW_SCSI_DATA_HSHK     0x32	</span><span class="cm">/* SDH   */</span><span class="cp"></span>
<span class="cp">#define IOPW_SCSI_CTRL          0x34	</span><span class="cm">/* SC    */</span><span class="cp"></span>
<span class="cp">#define IOPW_HSHK_CFG           0x36	</span><span class="cm">/* HCFG  */</span><span class="cp"></span>
<span class="cp">#define IOPW_SXFR_STATUS        0x36	</span><span class="cm">/* SXS   */</span><span class="cp"></span>
<span class="cp">#define IOPW_SXFR_CNTL          0x38	</span><span class="cm">/* SXL   */</span><span class="cp"></span>
<span class="cp">#define IOPW_SXFR_CNTH          0x3A	</span><span class="cm">/* SXH   */</span><span class="cp"></span>
<span class="cp">#define IOPW_RES_ADDR_3C        0x3C</span>
<span class="cp">#define IOPW_RFIFO_DATA         0x3E	</span><span class="cm">/* RFD   */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Doubleword I/O register address from base of &#39;iop_base&#39;.</span>
<span class="cm"> */</span>
<span class="cp">#define IOPDW_RES_ADDR_0         0x00</span>
<span class="cp">#define IOPDW_RAM_DATA           0x04</span>
<span class="cp">#define IOPDW_RES_ADDR_8         0x08</span>
<span class="cp">#define IOPDW_RES_ADDR_C         0x0C</span>
<span class="cp">#define IOPDW_RES_ADDR_10        0x10</span>
<span class="cp">#define IOPDW_COMMA              0x14</span>
<span class="cp">#define IOPDW_COMMB              0x18</span>
<span class="cp">#define IOPDW_RES_ADDR_1C        0x1C</span>
<span class="cp">#define IOPDW_SDMA_ADDR0         0x20</span>
<span class="cp">#define IOPDW_SDMA_ADDR1         0x24</span>
<span class="cp">#define IOPDW_SDMA_COUNT         0x28</span>
<span class="cp">#define IOPDW_SDMA_ERROR         0x2C</span>
<span class="cp">#define IOPDW_RDMA_ADDR0         0x30</span>
<span class="cp">#define IOPDW_RDMA_ADDR1         0x34</span>
<span class="cp">#define IOPDW_RDMA_COUNT         0x38</span>
<span class="cp">#define IOPDW_RDMA_ERROR         0x3C</span>

<span class="cp">#define ADV_CHIP_ID_BYTE         0x25</span>
<span class="cp">#define ADV_CHIP_ID_WORD         0x04C1</span>

<span class="cp">#define ADV_INTR_ENABLE_HOST_INTR                   0x01</span>
<span class="cp">#define ADV_INTR_ENABLE_SEL_INTR                    0x02</span>
<span class="cp">#define ADV_INTR_ENABLE_DPR_INTR                    0x04</span>
<span class="cp">#define ADV_INTR_ENABLE_RTA_INTR                    0x08</span>
<span class="cp">#define ADV_INTR_ENABLE_RMA_INTR                    0x10</span>
<span class="cp">#define ADV_INTR_ENABLE_RST_INTR                    0x20</span>
<span class="cp">#define ADV_INTR_ENABLE_DPE_INTR                    0x40</span>
<span class="cp">#define ADV_INTR_ENABLE_GLOBAL_INTR                 0x80</span>

<span class="cp">#define ADV_INTR_STATUS_INTRA            0x01</span>
<span class="cp">#define ADV_INTR_STATUS_INTRB            0x02</span>
<span class="cp">#define ADV_INTR_STATUS_INTRC            0x04</span>

<span class="cp">#define ADV_RISC_CSR_STOP           (0x0000)</span>
<span class="cp">#define ADV_RISC_TEST_COND          (0x2000)</span>
<span class="cp">#define ADV_RISC_CSR_RUN            (0x4000)</span>
<span class="cp">#define ADV_RISC_CSR_SINGLE_STEP    (0x8000)</span>

<span class="cp">#define ADV_CTRL_REG_HOST_INTR      0x0100</span>
<span class="cp">#define ADV_CTRL_REG_SEL_INTR       0x0200</span>
<span class="cp">#define ADV_CTRL_REG_DPR_INTR       0x0400</span>
<span class="cp">#define ADV_CTRL_REG_RTA_INTR       0x0800</span>
<span class="cp">#define ADV_CTRL_REG_RMA_INTR       0x1000</span>
<span class="cp">#define ADV_CTRL_REG_RES_BIT14      0x2000</span>
<span class="cp">#define ADV_CTRL_REG_DPE_INTR       0x4000</span>
<span class="cp">#define ADV_CTRL_REG_POWER_DONE     0x8000</span>
<span class="cp">#define ADV_CTRL_REG_ANY_INTR       0xFF00</span>

<span class="cp">#define ADV_CTRL_REG_CMD_RESET             0x00C6</span>
<span class="cp">#define ADV_CTRL_REG_CMD_WR_IO_REG         0x00C5</span>
<span class="cp">#define ADV_CTRL_REG_CMD_RD_IO_REG         0x00C4</span>
<span class="cp">#define ADV_CTRL_REG_CMD_WR_PCI_CFG_SPACE  0x00C3</span>
<span class="cp">#define ADV_CTRL_REG_CMD_RD_PCI_CFG_SPACE  0x00C2</span>

<span class="cp">#define ADV_TICKLE_NOP                      0x00</span>
<span class="cp">#define ADV_TICKLE_A                        0x01</span>
<span class="cp">#define ADV_TICKLE_B                        0x02</span>
<span class="cp">#define ADV_TICKLE_C                        0x03</span>

<span class="cp">#define AdvIsIntPending(port) \</span>
<span class="cp">    (AdvReadWordRegister(port, IOPW_CTRL_REG) &amp; ADV_CTRL_REG_HOST_INTR)</span>

<span class="cm">/*</span>
<span class="cm"> * SCSI_CFG0 Register bit definitions</span>
<span class="cm"> */</span>
<span class="cp">#define TIMER_MODEAB    0xC000	</span><span class="cm">/* Watchdog, Second, and Select. Timer Ctrl. */</span><span class="cp"></span>
<span class="cp">#define PARITY_EN       0x2000	</span><span class="cm">/* Enable SCSI Parity Error detection */</span><span class="cp"></span>
<span class="cp">#define EVEN_PARITY     0x1000	</span><span class="cm">/* Select Even Parity */</span><span class="cp"></span>
<span class="cp">#define WD_LONG         0x0800	</span><span class="cm">/* Watchdog Interval, 1: 57 min, 0: 13 sec */</span><span class="cp"></span>
<span class="cp">#define QUEUE_128       0x0400	</span><span class="cm">/* Queue Size, 1: 128 byte, 0: 64 byte */</span><span class="cp"></span>
<span class="cp">#define PRIM_MODE       0x0100	</span><span class="cm">/* Primitive SCSI mode */</span><span class="cp"></span>
<span class="cp">#define SCAM_EN         0x0080	</span><span class="cm">/* Enable SCAM selection */</span><span class="cp"></span>
<span class="cp">#define SEL_TMO_LONG    0x0040	</span><span class="cm">/* Sel/Resel Timeout, 1: 400 ms, 0: 1.6 ms */</span><span class="cp"></span>
<span class="cp">#define CFRM_ID         0x0020	</span><span class="cm">/* SCAM id sel. confirm., 1: fast, 0: 6.4 ms */</span><span class="cp"></span>
<span class="cp">#define OUR_ID_EN       0x0010	</span><span class="cm">/* Enable OUR_ID bits */</span><span class="cp"></span>
<span class="cp">#define OUR_ID          0x000F	</span><span class="cm">/* SCSI ID */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * SCSI_CFG1 Register bit definitions</span>
<span class="cm"> */</span>
<span class="cp">#define BIG_ENDIAN      0x8000	</span><span class="cm">/* Enable Big Endian Mode MIO:15, EEP:15 */</span><span class="cp"></span>
<span class="cp">#define TERM_POL        0x2000	</span><span class="cm">/* Terminator Polarity Ctrl. MIO:13, EEP:13 */</span><span class="cp"></span>
<span class="cp">#define SLEW_RATE       0x1000	</span><span class="cm">/* SCSI output buffer slew rate */</span><span class="cp"></span>
<span class="cp">#define FILTER_SEL      0x0C00	</span><span class="cm">/* Filter Period Selection */</span><span class="cp"></span>
<span class="cp">#define  FLTR_DISABLE    0x0000	</span><span class="cm">/* Input Filtering Disabled */</span><span class="cp"></span>
<span class="cp">#define  FLTR_11_TO_20NS 0x0800	</span><span class="cm">/* Input Filtering 11ns to 20ns */</span><span class="cp"></span>
<span class="cp">#define  FLTR_21_TO_39NS 0x0C00	</span><span class="cm">/* Input Filtering 21ns to 39ns */</span><span class="cp"></span>
<span class="cp">#define ACTIVE_DBL      0x0200	</span><span class="cm">/* Disable Active Negation */</span><span class="cp"></span>
<span class="cp">#define DIFF_MODE       0x0100	</span><span class="cm">/* SCSI differential Mode (Read-Only) */</span><span class="cp"></span>
<span class="cp">#define DIFF_SENSE      0x0080	</span><span class="cm">/* 1: No SE cables, 0: SE cable (Read-Only) */</span><span class="cp"></span>
<span class="cp">#define TERM_CTL_SEL    0x0040	</span><span class="cm">/* Enable TERM_CTL_H and TERM_CTL_L */</span><span class="cp"></span>
<span class="cp">#define TERM_CTL        0x0030	</span><span class="cm">/* External SCSI Termination Bits */</span><span class="cp"></span>
<span class="cp">#define  TERM_CTL_H      0x0020	</span><span class="cm">/* Enable External SCSI Upper Termination */</span><span class="cp"></span>
<span class="cp">#define  TERM_CTL_L      0x0010	</span><span class="cm">/* Enable External SCSI Lower Termination */</span><span class="cp"></span>
<span class="cp">#define CABLE_DETECT    0x000F	</span><span class="cm">/* External SCSI Cable Connection Status */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Addendum for ASC-38C0800 Chip</span>
<span class="cm"> *</span>
<span class="cm"> * The ASC-38C1600 Chip uses the same definitions except that the</span>
<span class="cm"> * bus mode override bits [12:10] have been moved to byte register</span>
<span class="cm"> * offset 0xE (IOPB_SOFT_OVER_WR) bits [12:10]. The [12:10] bits in</span>
<span class="cm"> * SCSI_CFG1 are read-only and always available. Bit 14 (DIS_TERM_DRV)</span>
<span class="cm"> * is not needed. The [12:10] bits in IOPB_SOFT_OVER_WR are write-only.</span>
<span class="cm"> * Also each ASC-38C1600 function or channel uses only cable bits [5:4]</span>
<span class="cm"> * and [1:0]. Bits [14], [7:6], [3:2] are unused.</span>
<span class="cm"> */</span>
<span class="cp">#define DIS_TERM_DRV    0x4000	</span><span class="cm">/* 1: Read c_det[3:0], 0: cannot read */</span><span class="cp"></span>
<span class="cp">#define HVD_LVD_SE      0x1C00	</span><span class="cm">/* Device Detect Bits */</span><span class="cp"></span>
<span class="cp">#define  HVD             0x1000	</span><span class="cm">/* HVD Device Detect */</span><span class="cp"></span>
<span class="cp">#define  LVD             0x0800	</span><span class="cm">/* LVD Device Detect */</span><span class="cp"></span>
<span class="cp">#define  SE              0x0400	</span><span class="cm">/* SE Device Detect */</span><span class="cp"></span>
<span class="cp">#define TERM_LVD        0x00C0	</span><span class="cm">/* LVD Termination Bits */</span><span class="cp"></span>
<span class="cp">#define  TERM_LVD_HI     0x0080	</span><span class="cm">/* Enable LVD Upper Termination */</span><span class="cp"></span>
<span class="cp">#define  TERM_LVD_LO     0x0040	</span><span class="cm">/* Enable LVD Lower Termination */</span><span class="cp"></span>
<span class="cp">#define TERM_SE         0x0030	</span><span class="cm">/* SE Termination Bits */</span><span class="cp"></span>
<span class="cp">#define  TERM_SE_HI      0x0020	</span><span class="cm">/* Enable SE Upper Termination */</span><span class="cp"></span>
<span class="cp">#define  TERM_SE_LO      0x0010	</span><span class="cm">/* Enable SE Lower Termination */</span><span class="cp"></span>
<span class="cp">#define C_DET_LVD       0x000C	</span><span class="cm">/* LVD Cable Detect Bits */</span><span class="cp"></span>
<span class="cp">#define  C_DET3          0x0008	</span><span class="cm">/* Cable Detect for LVD External Wide */</span><span class="cp"></span>
<span class="cp">#define  C_DET2          0x0004	</span><span class="cm">/* Cable Detect for LVD Internal Wide */</span><span class="cp"></span>
<span class="cp">#define C_DET_SE        0x0003	</span><span class="cm">/* SE Cable Detect Bits */</span><span class="cp"></span>
<span class="cp">#define  C_DET1          0x0002	</span><span class="cm">/* Cable Detect for SE Internal Wide */</span><span class="cp"></span>
<span class="cp">#define  C_DET0          0x0001	</span><span class="cm">/* Cable Detect for SE Internal Narrow */</span><span class="cp"></span>

<span class="cp">#define CABLE_ILLEGAL_A 0x7</span>
    <span class="cm">/* x 0 0 0  | on  on | Illegal (all 3 connectors are used) */</span>

<span class="cp">#define CABLE_ILLEGAL_B 0xB</span>
    <span class="cm">/* 0 x 0 0  | on  on | Illegal (all 3 connectors are used) */</span>

<span class="cm">/*</span>
<span class="cm"> * MEM_CFG Register bit definitions</span>
<span class="cm"> */</span>
<span class="cp">#define BIOS_EN         0x40	</span><span class="cm">/* BIOS Enable MIO:14,EEP:14 */</span><span class="cp"></span>
<span class="cp">#define FAST_EE_CLK     0x20	</span><span class="cm">/* Diagnostic Bit */</span><span class="cp"></span>
<span class="cp">#define RAM_SZ          0x1C	</span><span class="cm">/* Specify size of RAM to RISC */</span><span class="cp"></span>
<span class="cp">#define  RAM_SZ_2KB      0x00	</span><span class="cm">/* 2 KB */</span><span class="cp"></span>
<span class="cp">#define  RAM_SZ_4KB      0x04	</span><span class="cm">/* 4 KB */</span><span class="cp"></span>
<span class="cp">#define  RAM_SZ_8KB      0x08	</span><span class="cm">/* 8 KB */</span><span class="cp"></span>
<span class="cp">#define  RAM_SZ_16KB     0x0C	</span><span class="cm">/* 16 KB */</span><span class="cp"></span>
<span class="cp">#define  RAM_SZ_32KB     0x10	</span><span class="cm">/* 32 KB */</span><span class="cp"></span>
<span class="cp">#define  RAM_SZ_64KB     0x14	</span><span class="cm">/* 64 KB */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * DMA_CFG0 Register bit definitions</span>
<span class="cm"> *</span>
<span class="cm"> * This register is only accessible to the host.</span>
<span class="cm"> */</span>
<span class="cp">#define BC_THRESH_ENB   0x80	</span><span class="cm">/* PCI DMA Start Conditions */</span><span class="cp"></span>
<span class="cp">#define FIFO_THRESH     0x70	</span><span class="cm">/* PCI DMA FIFO Threshold */</span><span class="cp"></span>
<span class="cp">#define  FIFO_THRESH_16B  0x00	</span><span class="cm">/* 16 bytes */</span><span class="cp"></span>
<span class="cp">#define  FIFO_THRESH_32B  0x20	</span><span class="cm">/* 32 bytes */</span><span class="cp"></span>
<span class="cp">#define  FIFO_THRESH_48B  0x30	</span><span class="cm">/* 48 bytes */</span><span class="cp"></span>
<span class="cp">#define  FIFO_THRESH_64B  0x40	</span><span class="cm">/* 64 bytes */</span><span class="cp"></span>
<span class="cp">#define  FIFO_THRESH_80B  0x50	</span><span class="cm">/* 80 bytes (default) */</span><span class="cp"></span>
<span class="cp">#define  FIFO_THRESH_96B  0x60	</span><span class="cm">/* 96 bytes */</span><span class="cp"></span>
<span class="cp">#define  FIFO_THRESH_112B 0x70	</span><span class="cm">/* 112 bytes */</span><span class="cp"></span>
<span class="cp">#define START_CTL       0x0C	</span><span class="cm">/* DMA start conditions */</span><span class="cp"></span>
<span class="cp">#define  START_CTL_TH    0x00	</span><span class="cm">/* Wait threshold level (default) */</span><span class="cp"></span>
<span class="cp">#define  START_CTL_ID    0x04	</span><span class="cm">/* Wait SDMA/SBUS idle */</span><span class="cp"></span>
<span class="cp">#define  START_CTL_THID  0x08	</span><span class="cm">/* Wait threshold and SDMA/SBUS idle */</span><span class="cp"></span>
<span class="cp">#define  START_CTL_EMFU  0x0C	</span><span class="cm">/* Wait SDMA FIFO empty/full */</span><span class="cp"></span>
<span class="cp">#define READ_CMD        0x03	</span><span class="cm">/* Memory Read Method */</span><span class="cp"></span>
<span class="cp">#define  READ_CMD_MR     0x00	</span><span class="cm">/* Memory Read */</span><span class="cp"></span>
<span class="cp">#define  READ_CMD_MRL    0x02	</span><span class="cm">/* Memory Read Long */</span><span class="cp"></span>
<span class="cp">#define  READ_CMD_MRM    0x03	</span><span class="cm">/* Memory Read Multiple (default) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * ASC-38C0800 RAM BIST Register bit definitions</span>
<span class="cm"> */</span>
<span class="cp">#define RAM_TEST_MODE         0x80</span>
<span class="cp">#define PRE_TEST_MODE         0x40</span>
<span class="cp">#define NORMAL_MODE           0x00</span>
<span class="cp">#define RAM_TEST_DONE         0x10</span>
<span class="cp">#define RAM_TEST_STATUS       0x0F</span>
<span class="cp">#define  RAM_TEST_HOST_ERROR   0x08</span>
<span class="cp">#define  RAM_TEST_INTRAM_ERROR 0x04</span>
<span class="cp">#define  RAM_TEST_RISC_ERROR   0x02</span>
<span class="cp">#define  RAM_TEST_SCSI_ERROR   0x01</span>
<span class="cp">#define  RAM_TEST_SUCCESS      0x00</span>
<span class="cp">#define PRE_TEST_VALUE        0x05</span>
<span class="cp">#define NORMAL_VALUE          0x00</span>

<span class="cm">/*</span>
<span class="cm"> * ASC38C1600 Definitions</span>
<span class="cm"> *</span>
<span class="cm"> * IOPB_PCI_INT_CFG Bit Field Definitions</span>
<span class="cm"> */</span>

<span class="cp">#define INTAB_LD        0x80	</span><span class="cm">/* Value loaded from EEPROM Bit 11. */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Bit 1 can be set to change the interrupt for the Function to operate in</span>
<span class="cm"> * Totem Pole mode. By default Bit 1 is 0 and the interrupt operates in</span>
<span class="cm"> * Open Drain mode. Both functions of the ASC38C1600 must be set to the same</span>
<span class="cm"> * mode, otherwise the operating mode is undefined.</span>
<span class="cm"> */</span>
<span class="cp">#define TOTEMPOLE       0x02</span>

<span class="cm">/*</span>
<span class="cm"> * Bit 0 can be used to change the Int Pin for the Function. The value is</span>
<span class="cm"> * 0 by default for both Functions with Function 0 using INT A and Function</span>
<span class="cm"> * B using INT B. For Function 0 if set, INT B is used. For Function 1 if set,</span>
<span class="cm"> * INT A is used.</span>
<span class="cm"> *</span>
<span class="cm"> * EEPROM Word 0 Bit 11 for each Function may change the initial Int Pin</span>
<span class="cm"> * value specified in the PCI Configuration Space.</span>
<span class="cm"> */</span>
<span class="cp">#define INTAB           0x01</span>

<span class="cm">/*</span>
<span class="cm"> * Adv Library Status Definitions</span>
<span class="cm"> */</span>
<span class="cp">#define ADV_TRUE        1</span>
<span class="cp">#define ADV_FALSE       0</span>
<span class="cp">#define ADV_SUCCESS     1</span>
<span class="cp">#define ADV_BUSY        0</span>
<span class="cp">#define ADV_ERROR       (-1)</span>

<span class="cm">/*</span>
<span class="cm"> * ADV_DVC_VAR &#39;warn_code&#39; values</span>
<span class="cm"> */</span>
<span class="cp">#define ASC_WARN_BUSRESET_ERROR         0x0001	</span><span class="cm">/* SCSI Bus Reset error */</span><span class="cp"></span>
<span class="cp">#define ASC_WARN_EEPROM_CHKSUM          0x0002	</span><span class="cm">/* EEP check sum error */</span><span class="cp"></span>
<span class="cp">#define ASC_WARN_EEPROM_TERMINATION     0x0004	</span><span class="cm">/* EEP termination bad field */</span><span class="cp"></span>
<span class="cp">#define ASC_WARN_ERROR                  0xFFFF	</span><span class="cm">/* ADV_ERROR return */</span><span class="cp"></span>

<span class="cp">#define ADV_MAX_TID                     15	</span><span class="cm">/* max. target identifier */</span><span class="cp"></span>
<span class="cp">#define ADV_MAX_LUN                     7	</span><span class="cm">/* max. logical unit number */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Fixed locations of microcode operating variables.</span>
<span class="cm"> */</span>
<span class="cp">#define ASC_MC_CODE_BEGIN_ADDR          0x0028	</span><span class="cm">/* microcode start address */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_CODE_END_ADDR            0x002A	</span><span class="cm">/* microcode end address */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_CODE_CHK_SUM             0x002C	</span><span class="cm">/* microcode code checksum */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_VERSION_DATE             0x0038	</span><span class="cm">/* microcode version */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_VERSION_NUM              0x003A	</span><span class="cm">/* microcode number */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_BIOSMEM                  0x0040	</span><span class="cm">/* BIOS RISC Memory Start */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_BIOSLEN                  0x0050	</span><span class="cm">/* BIOS RISC Memory Length */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_BIOS_SIGNATURE           0x0058	</span><span class="cm">/* BIOS Signature 0x55AA */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_BIOS_VERSION             0x005A	</span><span class="cm">/* BIOS Version (2 bytes) */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_SDTR_SPEED1              0x0090	</span><span class="cm">/* SDTR Speed for TID 0-3 */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_SDTR_SPEED2              0x0092	</span><span class="cm">/* SDTR Speed for TID 4-7 */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_SDTR_SPEED3              0x0094	</span><span class="cm">/* SDTR Speed for TID 8-11 */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_SDTR_SPEED4              0x0096	</span><span class="cm">/* SDTR Speed for TID 12-15 */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_CHIP_TYPE                0x009A</span>
<span class="cp">#define ASC_MC_INTRB_CODE               0x009B</span>
<span class="cp">#define ASC_MC_WDTR_ABLE                0x009C</span>
<span class="cp">#define ASC_MC_SDTR_ABLE                0x009E</span>
<span class="cp">#define ASC_MC_TAGQNG_ABLE              0x00A0</span>
<span class="cp">#define ASC_MC_DISC_ENABLE              0x00A2</span>
<span class="cp">#define ASC_MC_IDLE_CMD_STATUS          0x00A4</span>
<span class="cp">#define ASC_MC_IDLE_CMD                 0x00A6</span>
<span class="cp">#define ASC_MC_IDLE_CMD_PARAMETER       0x00A8</span>
<span class="cp">#define ASC_MC_DEFAULT_SCSI_CFG0        0x00AC</span>
<span class="cp">#define ASC_MC_DEFAULT_SCSI_CFG1        0x00AE</span>
<span class="cp">#define ASC_MC_DEFAULT_MEM_CFG          0x00B0</span>
<span class="cp">#define ASC_MC_DEFAULT_SEL_MASK         0x00B2</span>
<span class="cp">#define ASC_MC_SDTR_DONE                0x00B6</span>
<span class="cp">#define ASC_MC_NUMBER_OF_QUEUED_CMD     0x00C0</span>
<span class="cp">#define ASC_MC_NUMBER_OF_MAX_CMD        0x00D0</span>
<span class="cp">#define ASC_MC_DEVICE_HSHK_CFG_TABLE    0x0100</span>
<span class="cp">#define ASC_MC_CONTROL_FLAG             0x0122	</span><span class="cm">/* Microcode control flag. */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_WDTR_DONE                0x0124</span>
<span class="cp">#define ASC_MC_CAM_MODE_MASK            0x015E	</span><span class="cm">/* CAM mode TID bitmask. */</span><span class="cp"></span>
<span class="cp">#define ASC_MC_ICQ                      0x0160</span>
<span class="cp">#define ASC_MC_IRQ                      0x0164</span>
<span class="cp">#define ASC_MC_PPR_ABLE                 0x017A</span>

<span class="cm">/*</span>
<span class="cm"> * BIOS LRAM variable absolute offsets.</span>
<span class="cm"> */</span>
<span class="cp">#define BIOS_CODESEG    0x54</span>
<span class="cp">#define BIOS_CODELEN    0x56</span>
<span class="cp">#define BIOS_SIGNATURE  0x58</span>
<span class="cp">#define BIOS_VERSION    0x5A</span>

<span class="cm">/*</span>
<span class="cm"> * Microcode Control Flags</span>
<span class="cm"> *</span>
<span class="cm"> * Flags set by the Adv Library in RISC variable &#39;control_flag&#39; (0x122)</span>
<span class="cm"> * and handled by the microcode.</span>
<span class="cm"> */</span>
<span class="cp">#define CONTROL_FLAG_IGNORE_PERR        0x0001	</span><span class="cm">/* Ignore DMA Parity Errors */</span><span class="cp"></span>
<span class="cp">#define CONTROL_FLAG_ENABLE_AIPP        0x0002	</span><span class="cm">/* Enabled AIPP checking. */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * ASC_MC_DEVICE_HSHK_CFG_TABLE microcode table or HSHK_CFG register format</span>
<span class="cm"> */</span>
<span class="cp">#define HSHK_CFG_WIDE_XFR       0x8000</span>
<span class="cp">#define HSHK_CFG_RATE           0x0F00</span>
<span class="cp">#define HSHK_CFG_OFFSET         0x001F</span>

<span class="cp">#define ASC_DEF_MAX_HOST_QNG    0xFD	</span><span class="cm">/* Max. number of host commands (253) */</span><span class="cp"></span>
<span class="cp">#define ASC_DEF_MIN_HOST_QNG    0x10	</span><span class="cm">/* Min. number of host commands (16) */</span><span class="cp"></span>
<span class="cp">#define ASC_DEF_MAX_DVC_QNG     0x3F	</span><span class="cm">/* Max. number commands per device (63) */</span><span class="cp"></span>
<span class="cp">#define ASC_DEF_MIN_DVC_QNG     0x04	</span><span class="cm">/* Min. number commands per device (4) */</span><span class="cp"></span>

<span class="cp">#define ASC_QC_DATA_CHECK  0x01	</span><span class="cm">/* Require ASC_QC_DATA_OUT set or clear. */</span><span class="cp"></span>
<span class="cp">#define ASC_QC_DATA_OUT    0x02	</span><span class="cm">/* Data out DMA transfer. */</span><span class="cp"></span>
<span class="cp">#define ASC_QC_START_MOTOR 0x04	</span><span class="cm">/* Send auto-start motor before request. */</span><span class="cp"></span>
<span class="cp">#define ASC_QC_NO_OVERRUN  0x08	</span><span class="cm">/* Don&#39;t report overrun. */</span><span class="cp"></span>
<span class="cp">#define ASC_QC_FREEZE_TIDQ 0x10	</span><span class="cm">/* Freeze TID queue after request. XXX TBD */</span><span class="cp"></span>

<span class="cp">#define ASC_QSC_NO_DISC     0x01	</span><span class="cm">/* Don&#39;t allow disconnect for request. */</span><span class="cp"></span>
<span class="cp">#define ASC_QSC_NO_TAGMSG   0x02	</span><span class="cm">/* Don&#39;t allow tag queuing for request. */</span><span class="cp"></span>
<span class="cp">#define ASC_QSC_NO_SYNC     0x04	</span><span class="cm">/* Don&#39;t use Synch. transfer on request. */</span><span class="cp"></span>
<span class="cp">#define ASC_QSC_NO_WIDE     0x08	</span><span class="cm">/* Don&#39;t use Wide transfer on request. */</span><span class="cp"></span>
<span class="cp">#define ASC_QSC_REDO_DTR    0x10	</span><span class="cm">/* Renegotiate WDTR/SDTR before request. */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * Note: If a Tag Message is to be sent and neither ASC_QSC_HEAD_TAG or</span>
<span class="cm"> * ASC_QSC_ORDERED_TAG is set, then a Simple Tag Message (0x20) is used.</span>
<span class="cm"> */</span>
<span class="cp">#define ASC_QSC_HEAD_TAG    0x40	</span><span class="cm">/* Use Head Tag Message (0x21). */</span><span class="cp"></span>
<span class="cp">#define ASC_QSC_ORDERED_TAG 0x80	</span><span class="cm">/* Use Ordered Tag Message (0x22). */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * All fields here are accessed by the board microcode and need to be</span>
<span class="cm"> * little-endian.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">adv_carr_t</span> <span class="p">{</span>
	<span class="n">ADV_VADDR</span> <span class="n">carr_va</span><span class="p">;</span>	<span class="cm">/* Carrier Virtual Address */</span>
	<span class="n">ADV_PADDR</span> <span class="n">carr_pa</span><span class="p">;</span>	<span class="cm">/* Carrier Physical Address */</span>
	<span class="n">ADV_VADDR</span> <span class="n">areq_vpa</span><span class="p">;</span>	<span class="cm">/* ASC_SCSI_REQ_Q Virtual or Physical Address */</span>
	<span class="cm">/*</span>
<span class="cm">	 * next_vpa [31:4]            Carrier Virtual or Physical Next Pointer</span>
<span class="cm">	 *</span>
<span class="cm">	 * next_vpa [3:1]             Reserved Bits</span>
<span class="cm">	 * next_vpa [0]               Done Flag set in Response Queue.</span>
<span class="cm">	 */</span>
	<span class="n">ADV_VADDR</span> <span class="n">next_vpa</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ADV_CARR_T</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Mask used to eliminate low 4 bits of carrier &#39;next_vpa&#39; field.</span>
<span class="cm"> */</span>
<span class="cp">#define ASC_NEXT_VPA_MASK       0xFFFFFFF0</span>

<span class="cp">#define ASC_RQ_DONE             0x00000001</span>
<span class="cp">#define ASC_RQ_GOOD             0x00000002</span>
<span class="cp">#define ASC_CQ_STOPPER          0x00000000</span>

<span class="cp">#define ASC_GET_CARRP(carrp) ((carrp) &amp; ASC_NEXT_VPA_MASK)</span>

<span class="cp">#define ADV_CARRIER_NUM_PAGE_CROSSING \</span>
<span class="cp">    (((ADV_CARRIER_COUNT * sizeof(ADV_CARR_T)) + (PAGE_SIZE - 1))/PAGE_SIZE)</span>

<span class="cp">#define ADV_CARRIER_BUFSIZE \</span>
<span class="cp">    ((ADV_CARRIER_COUNT + ADV_CARRIER_NUM_PAGE_CROSSING) * sizeof(ADV_CARR_T))</span>

<span class="cm">/*</span>
<span class="cm"> * ASC_SCSI_REQ_Q &#39;a_flag&#39; definitions</span>
<span class="cm"> *</span>
<span class="cm"> * The Adv Library should limit use to the lower nibble (4 bits) of</span>
<span class="cm"> * a_flag. Drivers are free to use the upper nibble (4 bits) of a_flag.</span>
<span class="cm"> */</span>
<span class="cp">#define ADV_POLL_REQUEST                0x01	</span><span class="cm">/* poll for request completion */</span><span class="cp"></span>
<span class="cp">#define ADV_SCSIQ_DONE                  0x02	</span><span class="cm">/* request done */</span><span class="cp"></span>
<span class="cp">#define ADV_DONT_RETRY                  0x08	</span><span class="cm">/* don&#39;t do retry */</span><span class="cp"></span>

<span class="cp">#define ADV_CHIP_ASC3550          0x01	</span><span class="cm">/* Ultra-Wide IC */</span><span class="cp"></span>
<span class="cp">#define ADV_CHIP_ASC38C0800       0x02	</span><span class="cm">/* Ultra2-Wide/LVD IC */</span><span class="cp"></span>
<span class="cp">#define ADV_CHIP_ASC38C1600       0x03	</span><span class="cm">/* Ultra3-Wide/LVD2 IC */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Adapter temporary configuration structure</span>
<span class="cm"> *</span>
<span class="cm"> * This structure can be discarded after initialization. Don&#39;t add</span>
<span class="cm"> * fields here needed after initialization.</span>
<span class="cm"> *</span>
<span class="cm"> * Field naming convention:</span>
<span class="cm"> *</span>
<span class="cm"> *  *_enable indicates the field enables or disables a feature. The</span>
<span class="cm"> *  value of the field is never reset.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">adv_dvc_cfg</span> <span class="p">{</span>
	<span class="n">ushort</span> <span class="n">disc_enable</span><span class="p">;</span>	<span class="cm">/* enable disconnection */</span>
	<span class="n">uchar</span> <span class="n">chip_version</span><span class="p">;</span>	<span class="cm">/* chip version */</span>
	<span class="n">uchar</span> <span class="n">termination</span><span class="p">;</span>	<span class="cm">/* Term. Ctrl. bits 6-5 of SCSI_CFG1 register */</span>
	<span class="n">ushort</span> <span class="n">control_flag</span><span class="p">;</span>	<span class="cm">/* Microcode Control Flag */</span>
	<span class="n">ushort</span> <span class="n">mcode_date</span><span class="p">;</span>	<span class="cm">/* Microcode date */</span>
	<span class="n">ushort</span> <span class="n">mcode_version</span><span class="p">;</span>	<span class="cm">/* Microcode version */</span>
	<span class="n">ushort</span> <span class="n">serial1</span><span class="p">;</span>		<span class="cm">/* EEPROM serial number word 1 */</span>
	<span class="n">ushort</span> <span class="n">serial2</span><span class="p">;</span>		<span class="cm">/* EEPROM serial number word 2 */</span>
	<span class="n">ushort</span> <span class="n">serial3</span><span class="p">;</span>		<span class="cm">/* EEPROM serial number word 3 */</span>
<span class="p">}</span> <span class="n">ADV_DVC_CFG</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">adv_dvc_var</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">adv_scsi_req_q</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">asc_sg_block</span> <span class="p">{</span>
	<span class="n">uchar</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">reserved2</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">reserved3</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sg_cnt</span><span class="p">;</span>		<span class="cm">/* Valid entries in block. */</span>
	<span class="n">ADV_PADDR</span> <span class="n">sg_ptr</span><span class="p">;</span>	<span class="cm">/* Pointer to next sg block. */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">ADV_PADDR</span> <span class="n">sg_addr</span><span class="p">;</span>	<span class="cm">/* SG element address. */</span>
		<span class="n">ADV_DCNT</span> <span class="n">sg_count</span><span class="p">;</span>	<span class="cm">/* SG element count. */</span>
	<span class="p">}</span> <span class="n">sg_list</span><span class="p">[</span><span class="n">NO_OF_SG_PER_BLOCK</span><span class="p">];</span>
<span class="p">}</span> <span class="n">ADV_SG_BLOCK</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * ADV_SCSI_REQ_Q - microcode request structure</span>
<span class="cm"> *</span>
<span class="cm"> * All fields in this structure up to byte 60 are used by the microcode.</span>
<span class="cm"> * The microcode makes assumptions about the size and ordering of fields</span>
<span class="cm"> * in this structure. Do not change the structure definition here without</span>
<span class="cm"> * coordinating the change with the microcode.</span>
<span class="cm"> *</span>
<span class="cm"> * All fields accessed by microcode must be maintained in little_endian</span>
<span class="cm"> * order.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">adv_scsi_req_q</span> <span class="p">{</span>
	<span class="n">uchar</span> <span class="n">cntl</span><span class="p">;</span>		<span class="cm">/* Ucode flags and state (ASC_MC_QC_*). */</span>
	<span class="n">uchar</span> <span class="n">target_cmd</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">target_id</span><span class="p">;</span>	<span class="cm">/* Device target identifier. */</span>
	<span class="n">uchar</span> <span class="n">target_lun</span><span class="p">;</span>	<span class="cm">/* Device target logical unit number. */</span>
	<span class="n">ADV_PADDR</span> <span class="n">data_addr</span><span class="p">;</span>	<span class="cm">/* Data buffer physical address. */</span>
	<span class="n">ADV_DCNT</span> <span class="n">data_cnt</span><span class="p">;</span>	<span class="cm">/* Data count. Ucode sets to residual. */</span>
	<span class="n">ADV_PADDR</span> <span class="n">sense_addr</span><span class="p">;</span>
	<span class="n">ADV_PADDR</span> <span class="n">carr_pa</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">mflag</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sense_len</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">cdb_len</span><span class="p">;</span>		<span class="cm">/* SCSI CDB length. Must &lt;= 16 bytes. */</span>
	<span class="n">uchar</span> <span class="n">scsi_cntl</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">done_status</span><span class="p">;</span>	<span class="cm">/* Completion status. */</span>
	<span class="n">uchar</span> <span class="n">scsi_status</span><span class="p">;</span>	<span class="cm">/* SCSI status byte. */</span>
	<span class="n">uchar</span> <span class="n">host_status</span><span class="p">;</span>	<span class="cm">/* Ucode host status. */</span>
	<span class="n">uchar</span> <span class="n">sg_working_ix</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>		<span class="cm">/* SCSI CDB bytes 0-11. */</span>
	<span class="n">ADV_PADDR</span> <span class="n">sg_real_addr</span><span class="p">;</span>	<span class="cm">/* SG list physical address. */</span>
	<span class="n">ADV_PADDR</span> <span class="n">scsiq_rptr</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">cdb16</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* SCSI CDB bytes 12-15. */</span>
	<span class="n">ADV_VADDR</span> <span class="n">scsiq_ptr</span><span class="p">;</span>
	<span class="n">ADV_VADDR</span> <span class="n">carr_va</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * End of microcode structure - 60 bytes. The rest of the structure</span>
<span class="cm">	 * is used by the Adv Library and ignored by the microcode.</span>
<span class="cm">	 */</span>
	<span class="n">ADV_VADDR</span> <span class="n">srb_ptr</span><span class="p">;</span>
	<span class="n">ADV_SG_BLOCK</span> <span class="o">*</span><span class="n">sg_list_ptr</span><span class="p">;</span>	<span class="cm">/* SG list virtual address. */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">vdata_addr</span><span class="p">;</span>	<span class="cm">/* Data buffer virtual address. */</span>
	<span class="n">uchar</span> <span class="n">a_flag</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">pad</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>		<span class="cm">/* Pad out to a word boundary. */</span>
<span class="p">}</span> <span class="n">ADV_SCSI_REQ_Q</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The following two structures are used to process Wide Board requests.</span>
<span class="cm"> *</span>
<span class="cm"> * The ADV_SCSI_REQ_Q structure in adv_req_t is passed to the Adv Library</span>
<span class="cm"> * and microcode with the ADV_SCSI_REQ_Q field &#39;srb_ptr&#39; pointing to the</span>
<span class="cm"> * adv_req_t. The adv_req_t structure &#39;cmndp&#39; field in turn points to the</span>
<span class="cm"> * Mid-Level SCSI request structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Zero or more ADV_SG_BLOCK are used with each ADV_SCSI_REQ_Q. Each</span>
<span class="cm"> * ADV_SG_BLOCK structure holds 15 scatter-gather elements. Under Linux</span>
<span class="cm"> * up to 255 scatter-gather elements may be used per request or</span>
<span class="cm"> * ADV_SCSI_REQ_Q.</span>
<span class="cm"> *</span>
<span class="cm"> * Both structures must be 32 byte aligned.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">adv_sgblk</span> <span class="p">{</span>
	<span class="n">ADV_SG_BLOCK</span> <span class="n">sg_block</span><span class="p">;</span>	<span class="cm">/* Sgblock structure. */</span>
	<span class="n">uchar</span> <span class="n">align</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="cm">/* Sgblock structure padding. */</span>
	<span class="k">struct</span> <span class="n">adv_sgblk</span> <span class="o">*</span><span class="n">next_sgblkp</span><span class="p">;</span>	<span class="cm">/* Next scatter-gather structure. */</span>
<span class="p">}</span> <span class="n">adv_sgblk_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">adv_req</span> <span class="p">{</span>
	<span class="n">ADV_SCSI_REQ_Q</span> <span class="n">scsi_req_q</span><span class="p">;</span>	<span class="cm">/* Adv Library request structure. */</span>
	<span class="n">uchar</span> <span class="n">align</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="cm">/* Request structure padding. */</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmndp</span><span class="p">;</span>	<span class="cm">/* Mid-Level SCSI command pointer. */</span>
	<span class="n">adv_sgblk_t</span> <span class="o">*</span><span class="n">sgblkp</span><span class="p">;</span>	<span class="cm">/* Adv Library scatter-gather pointer. */</span>
	<span class="k">struct</span> <span class="n">adv_req</span> <span class="o">*</span><span class="n">next_reqp</span><span class="p">;</span>	<span class="cm">/* Next Request Structure. */</span>
<span class="p">}</span> <span class="n">adv_req_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Adapter operation variable structure.</span>
<span class="cm"> *</span>
<span class="cm"> * One structure is required per host adapter.</span>
<span class="cm"> *</span>
<span class="cm"> * Field naming convention:</span>
<span class="cm"> *</span>
<span class="cm"> *  *_able indicates both whether a feature should be enabled or disabled</span>
<span class="cm"> *  and whether a device isi capable of the feature. At initialization</span>
<span class="cm"> *  this field may be set, but later if a device is found to be incapable</span>
<span class="cm"> *  of the feature, the field is cleared.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">adv_dvc_var</span> <span class="p">{</span>
	<span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">;</span>	<span class="cm">/* I/O port address */</span>
	<span class="n">ushort</span> <span class="n">err_code</span><span class="p">;</span>	<span class="cm">/* fatal error code */</span>
	<span class="n">ushort</span> <span class="n">bios_ctrl</span><span class="p">;</span>	<span class="cm">/* BIOS control word, EEPROM word 12 */</span>
	<span class="n">ushort</span> <span class="n">wdtr_able</span><span class="p">;</span>	<span class="cm">/* try WDTR for a device */</span>
	<span class="n">ushort</span> <span class="n">sdtr_able</span><span class="p">;</span>	<span class="cm">/* try SDTR for a device */</span>
	<span class="n">ushort</span> <span class="n">ultra_able</span><span class="p">;</span>	<span class="cm">/* try SDTR Ultra speed for a device */</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed1</span><span class="p">;</span>	<span class="cm">/* EEPROM SDTR Speed for TID 0-3   */</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed2</span><span class="p">;</span>	<span class="cm">/* EEPROM SDTR Speed for TID 4-7   */</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed3</span><span class="p">;</span>	<span class="cm">/* EEPROM SDTR Speed for TID 8-11  */</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed4</span><span class="p">;</span>	<span class="cm">/* EEPROM SDTR Speed for TID 12-15 */</span>
	<span class="n">ushort</span> <span class="n">tagqng_able</span><span class="p">;</span>	<span class="cm">/* try tagged queuing with a device */</span>
	<span class="n">ushort</span> <span class="n">ppr_able</span><span class="p">;</span>	<span class="cm">/* PPR message capable per TID bitmask. */</span>
	<span class="n">uchar</span> <span class="n">max_dvc_qng</span><span class="p">;</span>	<span class="cm">/* maximum number of tagged commands per device */</span>
	<span class="n">ushort</span> <span class="n">start_motor</span><span class="p">;</span>	<span class="cm">/* start motor command allowed */</span>
	<span class="n">uchar</span> <span class="n">scsi_reset_wait</span><span class="p">;</span>	<span class="cm">/* delay in seconds after scsi bus reset */</span>
	<span class="n">uchar</span> <span class="n">chip_no</span><span class="p">;</span>		<span class="cm">/* should be assigned by caller */</span>
	<span class="n">uchar</span> <span class="n">max_host_qng</span><span class="p">;</span>	<span class="cm">/* maximum number of Q&#39;ed command allowed */</span>
	<span class="n">ushort</span> <span class="n">no_scam</span><span class="p">;</span>		<span class="cm">/* scam_tolerant of EEPROM */</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">drv_ptr</span><span class="p">;</span>	<span class="cm">/* driver pointer to private structure */</span>
	<span class="n">uchar</span> <span class="n">chip_scsi_id</span><span class="p">;</span>	<span class="cm">/* chip SCSI target ID */</span>
	<span class="n">uchar</span> <span class="n">chip_type</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">bist_err_code</span><span class="p">;</span>
	<span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="n">carrier_buf</span><span class="p">;</span>
	<span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="n">carr_freelist</span><span class="p">;</span>	<span class="cm">/* Carrier free list. */</span>
	<span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="n">icq_sp</span><span class="p">;</span>	<span class="cm">/* Initiator command queue stopper pointer. */</span>
	<span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="n">irq_sp</span><span class="p">;</span>	<span class="cm">/* Initiator response queue stopper pointer. */</span>
	<span class="n">ushort</span> <span class="n">carr_pending_cnt</span><span class="p">;</span>	<span class="cm">/* Count of pending carriers. */</span>
	<span class="k">struct</span> <span class="n">adv_req</span> <span class="o">*</span><span class="n">orig_reqp</span><span class="p">;</span>	<span class="cm">/* adv_req_t memory block. */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note: The following fields will not be used after initialization. The</span>
<span class="cm">	 * driver may discard the buffer after initialization is done.</span>
<span class="cm">	 */</span>
	<span class="n">ADV_DVC_CFG</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>	<span class="cm">/* temporary configuration structure  */</span>
<span class="p">}</span> <span class="n">ADV_DVC_VAR</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Microcode idle loop commands</span>
<span class="cm"> */</span>
<span class="cp">#define IDLE_CMD_COMPLETED           0</span>
<span class="cp">#define IDLE_CMD_STOP_CHIP           0x0001</span>
<span class="cp">#define IDLE_CMD_STOP_CHIP_SEND_INT  0x0002</span>
<span class="cp">#define IDLE_CMD_SEND_INT            0x0004</span>
<span class="cp">#define IDLE_CMD_ABORT               0x0008</span>
<span class="cp">#define IDLE_CMD_DEVICE_RESET        0x0010</span>
<span class="cp">#define IDLE_CMD_SCSI_RESET_START    0x0020	</span><span class="cm">/* Assert SCSI Bus Reset */</span><span class="cp"></span>
<span class="cp">#define IDLE_CMD_SCSI_RESET_END      0x0040	</span><span class="cm">/* Deassert SCSI Bus Reset */</span><span class="cp"></span>
<span class="cp">#define IDLE_CMD_SCSIREQ             0x0080</span>

<span class="cp">#define IDLE_CMD_STATUS_SUCCESS      0x0001</span>
<span class="cp">#define IDLE_CMD_STATUS_FAILURE      0x0002</span>

<span class="cm">/*</span>
<span class="cm"> * AdvSendIdleCmd() flag definitions.</span>
<span class="cm"> */</span>
<span class="cp">#define ADV_NOWAIT     0x01</span>

<span class="cm">/*</span>
<span class="cm"> * Wait loop time out values.</span>
<span class="cm"> */</span>
<span class="cp">#define SCSI_WAIT_100_MSEC           100UL	</span><span class="cm">/* 100 milliseconds */</span><span class="cp"></span>
<span class="cp">#define SCSI_US_PER_MSEC             1000	</span><span class="cm">/* microseconds per millisecond */</span><span class="cp"></span>
<span class="cp">#define SCSI_MAX_RETRY               10	</span><span class="cm">/* retry count */</span><span class="cp"></span>

<span class="cp">#define ADV_ASYNC_RDMA_FAILURE          0x01	</span><span class="cm">/* Fatal RDMA failure. */</span><span class="cp"></span>
<span class="cp">#define ADV_ASYNC_SCSI_BUS_RESET_DET    0x02	</span><span class="cm">/* Detected SCSI Bus Reset. */</span><span class="cp"></span>
<span class="cp">#define ADV_ASYNC_CARRIER_READY_FAILURE 0x03	</span><span class="cm">/* Carrier Ready failure. */</span><span class="cp"></span>
<span class="cp">#define ADV_RDMA_IN_CARR_AND_Q_INVALID  0x04	</span><span class="cm">/* RDMAed-in data invalid. */</span><span class="cp"></span>

<span class="cp">#define ADV_HOST_SCSI_BUS_RESET      0x80	</span><span class="cm">/* Host Initiated SCSI Bus Reset. */</span><span class="cp"></span>

<span class="cm">/* Read byte from a register. */</span>
<span class="cp">#define AdvReadByteRegister(iop_base, reg_off) \</span>
<span class="cp">     (ADV_MEM_READB((iop_base) + (reg_off)))</span>

<span class="cm">/* Write byte to a register. */</span>
<span class="cp">#define AdvWriteByteRegister(iop_base, reg_off, byte) \</span>
<span class="cp">     (ADV_MEM_WRITEB((iop_base) + (reg_off), (byte)))</span>

<span class="cm">/* Read word (2 bytes) from a register. */</span>
<span class="cp">#define AdvReadWordRegister(iop_base, reg_off) \</span>
<span class="cp">     (ADV_MEM_READW((iop_base) + (reg_off)))</span>

<span class="cm">/* Write word (2 bytes) to a register. */</span>
<span class="cp">#define AdvWriteWordRegister(iop_base, reg_off, word) \</span>
<span class="cp">     (ADV_MEM_WRITEW((iop_base) + (reg_off), (word)))</span>

<span class="cm">/* Write dword (4 bytes) to a register. */</span>
<span class="cp">#define AdvWriteDWordRegister(iop_base, reg_off, dword) \</span>
<span class="cp">     (ADV_MEM_WRITEDW((iop_base) + (reg_off), (dword)))</span>

<span class="cm">/* Read byte from LRAM. */</span>
<span class="cp">#define AdvReadByteLram(iop_base, addr, byte) \</span>
<span class="cp">do { \</span>
<span class="cp">    ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)); \</span>
<span class="cp">    (byte) = ADV_MEM_READB((iop_base) + IOPB_RAM_DATA); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/* Write byte to LRAM. */</span>
<span class="cp">#define AdvWriteByteLram(iop_base, addr, byte) \</span>
<span class="cp">    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \</span>
<span class="cp">     ADV_MEM_WRITEB((iop_base) + IOPB_RAM_DATA, (byte)))</span>

<span class="cm">/* Read word (2 bytes) from LRAM. */</span>
<span class="cp">#define AdvReadWordLram(iop_base, addr, word) \</span>
<span class="cp">do { \</span>
<span class="cp">    ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)); \</span>
<span class="cp">    (word) = (ADV_MEM_READW((iop_base) + IOPW_RAM_DATA)); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/* Write word (2 bytes) to LRAM. */</span>
<span class="cp">#define AdvWriteWordLram(iop_base, addr, word) \</span>
<span class="cp">    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \</span>
<span class="cp">     ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, (word)))</span>

<span class="cm">/* Write little-endian double word (4 bytes) to LRAM */</span>
<span class="cm">/* Because of unspecified C language ordering don&#39;t use auto-increment. */</span>
<span class="cp">#define AdvWriteDWordLramNoSwap(iop_base, addr, dword) \</span>
<span class="cp">    ((ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \</span>
<span class="cp">      ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, \</span>
<span class="cp">                     cpu_to_le16((ushort) ((dword) &amp; 0xFFFF)))), \</span>
<span class="cp">     (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr) + 2), \</span>
<span class="cp">      ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, \</span>
<span class="cp">                     cpu_to_le16((ushort) ((dword &gt;&gt; 16) &amp; 0xFFFF)))))</span>

<span class="cm">/* Read word (2 bytes) from LRAM assuming that the address is already set. */</span>
<span class="cp">#define AdvReadWordAutoIncLram(iop_base) \</span>
<span class="cp">     (ADV_MEM_READW((iop_base) + IOPW_RAM_DATA))</span>

<span class="cm">/* Write word (2 bytes) to LRAM assuming that the address is already set. */</span>
<span class="cp">#define AdvWriteWordAutoIncLram(iop_base, word) \</span>
<span class="cp">     (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, (word)))</span>

<span class="cm">/*</span>
<span class="cm"> * Define macro to check for Condor signature.</span>
<span class="cm"> *</span>
<span class="cm"> * Evaluate to ADV_TRUE if a Condor chip is found the specified port</span>
<span class="cm"> * address &#39;iop_base&#39;. Otherwise evalue to ADV_FALSE.</span>
<span class="cm"> */</span>
<span class="cp">#define AdvFindSignature(iop_base) \</span>
<span class="cp">    (((AdvReadByteRegister((iop_base), IOPB_CHIP_ID_1) == \</span>
<span class="cp">    ADV_CHIP_ID_BYTE) &amp;&amp; \</span>
<span class="cp">     (AdvReadWordRegister((iop_base), IOPW_CHIP_ID_0) == \</span>
<span class="cp">    ADV_CHIP_ID_WORD)) ?  ADV_TRUE : ADV_FALSE)</span>

<span class="cm">/*</span>
<span class="cm"> * Define macro to Return the version number of the chip at &#39;iop_base&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * The second parameter &#39;bus_type&#39; is currently unused.</span>
<span class="cm"> */</span>
<span class="cp">#define AdvGetChipVersion(iop_base, bus_type) \</span>
<span class="cp">    AdvReadByteRegister((iop_base), IOPB_CHIP_TYPE_REV)</span>

<span class="cm">/*</span>
<span class="cm"> * Abort an SRB in the chip&#39;s RISC Memory. The &#39;srb_ptr&#39; argument must</span>
<span class="cm"> * match the ASC_SCSI_REQ_Q &#39;srb_ptr&#39; field.</span>
<span class="cm"> *</span>
<span class="cm"> * If the request has not yet been sent to the device it will simply be</span>
<span class="cm"> * aborted from RISC memory. If the request is disconnected it will be</span>
<span class="cm"> * aborted on reselection by sending an Abort Message to the target ID.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *      ADV_TRUE(1) - Queue was successfully aborted.</span>
<span class="cm"> *      ADV_FALSE(0) - Queue was not found on the active queue list.</span>
<span class="cm"> */</span>
<span class="cp">#define AdvAbortQueue(asc_dvc, scsiq) \</span>
<span class="cp">        AdvSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_ABORT, \</span>
<span class="cp">                       (ADV_DCNT) (scsiq))</span>

<span class="cm">/*</span>
<span class="cm"> * Send a Bus Device Reset Message to the specified target ID.</span>
<span class="cm"> *</span>
<span class="cm"> * All outstanding commands will be purged if sending the</span>
<span class="cm"> * Bus Device Reset Message is successful.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *      ADV_TRUE(1) - All requests on the target are purged.</span>
<span class="cm"> *      ADV_FALSE(0) - Couldn&#39;t issue Bus Device Reset Message; Requests</span>
<span class="cm"> *                     are not purged.</span>
<span class="cm"> */</span>
<span class="cp">#define AdvResetDevice(asc_dvc, target_id) \</span>
<span class="cp">        AdvSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_DEVICE_RESET, \</span>
<span class="cp">                    (ADV_DCNT) (target_id))</span>

<span class="cm">/*</span>
<span class="cm"> * SCSI Wide Type definition.</span>
<span class="cm"> */</span>
<span class="cp">#define ADV_SCSI_BIT_ID_TYPE   ushort</span>

<span class="cm">/*</span>
<span class="cm"> * AdvInitScsiTarget() &#39;cntl_flag&#39; options.</span>
<span class="cm"> */</span>
<span class="cp">#define ADV_SCAN_LUN           0x01</span>
<span class="cp">#define ADV_CAPINFO_NOLUN      0x02</span>

<span class="cm">/*</span>
<span class="cm"> * Convert target id to target id bit mask.</span>
<span class="cm"> */</span>
<span class="cp">#define ADV_TID_TO_TIDMASK(tid)   (0x01 &lt;&lt; ((tid) &amp; ADV_MAX_TID))</span>

<span class="cm">/*</span>
<span class="cm"> * ASC_SCSI_REQ_Q &#39;done_status&#39; and &#39;host_status&#39; return values.</span>
<span class="cm"> */</span>

<span class="cp">#define QD_NO_STATUS         0x00	</span><span class="cm">/* Request not completed yet. */</span><span class="cp"></span>
<span class="cp">#define QD_NO_ERROR          0x01</span>
<span class="cp">#define QD_ABORTED_BY_HOST   0x02</span>
<span class="cp">#define QD_WITH_ERROR        0x04</span>

<span class="cp">#define QHSTA_NO_ERROR              0x00</span>
<span class="cp">#define QHSTA_M_SEL_TIMEOUT         0x11</span>
<span class="cp">#define QHSTA_M_DATA_OVER_RUN       0x12</span>
<span class="cp">#define QHSTA_M_UNEXPECTED_BUS_FREE 0x13</span>
<span class="cp">#define QHSTA_M_QUEUE_ABORTED       0x15</span>
<span class="cp">#define QHSTA_M_SXFR_SDMA_ERR       0x16	</span><span class="cm">/* SXFR_STATUS SCSI DMA Error */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_SXFR_SXFR_PERR      0x17	</span><span class="cm">/* SXFR_STATUS SCSI Bus Parity Error */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_RDMA_PERR           0x18	</span><span class="cm">/* RISC PCI DMA parity error */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_SXFR_OFF_UFLW       0x19	</span><span class="cm">/* SXFR_STATUS Offset Underflow */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_SXFR_OFF_OFLW       0x20	</span><span class="cm">/* SXFR_STATUS Offset Overflow */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_SXFR_WD_TMO         0x21	</span><span class="cm">/* SXFR_STATUS Watchdog Timeout */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_SXFR_DESELECTED     0x22	</span><span class="cm">/* SXFR_STATUS Deselected */</span><span class="cp"></span>
<span class="cm">/* Note: QHSTA_M_SXFR_XFR_OFLW is identical to QHSTA_M_DATA_OVER_RUN. */</span>
<span class="cp">#define QHSTA_M_SXFR_XFR_OFLW       0x12	</span><span class="cm">/* SXFR_STATUS Transfer Overflow */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_SXFR_XFR_PH_ERR     0x24	</span><span class="cm">/* SXFR_STATUS Transfer Phase Error */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_SXFR_UNKNOWN_ERROR  0x25	</span><span class="cm">/* SXFR_STATUS Unknown Error */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_SCSI_BUS_RESET      0x30	</span><span class="cm">/* Request aborted from SBR */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_SCSI_BUS_RESET_UNSOL 0x31	</span><span class="cm">/* Request aborted from unsol. SBR */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_BUS_DEVICE_RESET    0x32	</span><span class="cm">/* Request aborted from BDR */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_DIRECTION_ERR       0x35	</span><span class="cm">/* Data Phase mismatch */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_DIRECTION_ERR_HUNG  0x36	</span><span class="cm">/* Data Phase mismatch and bus hang */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_WTM_TIMEOUT         0x41</span>
<span class="cp">#define QHSTA_M_BAD_CMPL_STATUS_IN  0x42</span>
<span class="cp">#define QHSTA_M_NO_AUTO_REQ_SENSE   0x43</span>
<span class="cp">#define QHSTA_M_AUTO_REQ_SENSE_FAIL 0x44</span>
<span class="cp">#define QHSTA_M_INVALID_DEVICE      0x45	</span><span class="cm">/* Bad target ID */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_FROZEN_TIDQ         0x46	</span><span class="cm">/* TID Queue frozen. */</span><span class="cp"></span>
<span class="cp">#define QHSTA_M_SGBACKUP_ERROR      0x47	</span><span class="cm">/* Scatter-Gather backup error */</span><span class="cp"></span>

<span class="cm">/* Return the address that is aligned at the next doubleword &gt;= to &#39;addr&#39;. */</span>
<span class="cp">#define ADV_8BALIGN(addr)      (((ulong) (addr) + 0x7) &amp; ~0x7)</span>
<span class="cp">#define ADV_16BALIGN(addr)     (((ulong) (addr) + 0xF) &amp; ~0xF)</span>
<span class="cp">#define ADV_32BALIGN(addr)     (((ulong) (addr) + 0x1F) &amp; ~0x1F)</span>

<span class="cm">/*</span>
<span class="cm"> * Total contiguous memory needed for driver SG blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * ADV_MAX_SG_LIST must be defined by a driver. It is the maximum</span>
<span class="cm"> * number of scatter-gather elements the driver supports in a</span>
<span class="cm"> * single request.</span>
<span class="cm"> */</span>

<span class="cp">#define ADV_SG_LIST_MAX_BYTE_SIZE \</span>
<span class="cp">         (sizeof(ADV_SG_BLOCK) * \</span>
<span class="cp">          ((ADV_MAX_SG_LIST + (NO_OF_SG_PER_BLOCK - 1))/NO_OF_SG_PER_BLOCK))</span>

<span class="cm">/* struct asc_board flags */</span>
<span class="cp">#define ASC_IS_WIDE_BOARD       0x04	</span><span class="cm">/* AdvanSys Wide Board */</span><span class="cp"></span>

<span class="cp">#define ASC_NARROW_BOARD(boardp) (((boardp)-&gt;flags &amp; ASC_IS_WIDE_BOARD) == 0)</span>

<span class="cp">#define NO_ISA_DMA              0xff	</span><span class="cm">/* No ISA DMA Channel Used */</span><span class="cp"></span>

<span class="cp">#define ASC_INFO_SIZE           128	</span><span class="cm">/* advansys_info() line size */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cm">/* /proc/scsi/advansys/[0...] related definitions */</span>
<span class="cp">#define ASC_PRTBUF_SIZE         2048</span>
<span class="cp">#define ASC_PRTLINE_SIZE        160</span>

<span class="cp">#define ASC_PRT_NEXT() \</span>
<span class="cp">    if (cp) { \</span>
<span class="cp">        totlen += len; \</span>
<span class="cp">        leftlen -= len; \</span>
<span class="cp">        if (leftlen == 0) { \</span>
<span class="cp">            return totlen; \</span>
<span class="cp">        } \</span>
<span class="cp">        cp += len; \</span>
<span class="cp">    }</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="cm">/* Asc Library return codes */</span>
<span class="cp">#define ASC_TRUE        1</span>
<span class="cp">#define ASC_FALSE       0</span>
<span class="cp">#define ASC_NOERROR     1</span>
<span class="cp">#define ASC_BUSY        0</span>
<span class="cp">#define ASC_ERROR       (-1)</span>

<span class="cm">/* struct scsi_cmnd function return codes */</span>
<span class="cp">#define STATUS_BYTE(byte)   (byte)</span>
<span class="cp">#define MSG_BYTE(byte)      ((byte) &lt;&lt; 8)</span>
<span class="cp">#define HOST_BYTE(byte)     ((byte) &lt;&lt; 16)</span>
<span class="cp">#define DRIVER_BYTE(byte)   ((byte) &lt;&lt; 24)</span>

<span class="cp">#define ASC_STATS(shost, counter) ASC_STATS_ADD(shost, counter, 1)</span>
<span class="cp">#ifndef ADVANSYS_STATS</span>
<span class="cp">#define ASC_STATS_ADD(shost, counter, count)</span>
<span class="cp">#else </span><span class="cm">/* ADVANSYS_STATS */</span><span class="cp"></span>
<span class="cp">#define ASC_STATS_ADD(shost, counter, count) \</span>
<span class="cp">	(((struct asc_board *) shost_priv(shost))-&gt;asc_stats.counter += (count))</span>
<span class="cp">#endif </span><span class="cm">/* ADVANSYS_STATS */</span><span class="cp"></span>

<span class="cm">/* If the result wraps when calculating tenths, return 0. */</span>
<span class="cp">#define ASC_TENTHS(num, den) \</span>
<span class="cp">    (((10 * ((num)/(den))) &gt; (((num) * 10)/(den))) ? \</span>
<span class="cp">    0 : ((((num) * 10)/(den)) - (10 * ((num)/(den)))))</span>

<span class="cm">/*</span>
<span class="cm"> * Display a message to the console.</span>
<span class="cm"> */</span>
<span class="cp">#define ASC_PRINT(s) \</span>
<span class="cp">    { \</span>
<span class="cp">        printk(&quot;advansys: &quot;); \</span>
<span class="cp">        printk(s); \</span>
<span class="cp">    }</span>

<span class="cp">#define ASC_PRINT1(s, a1) \</span>
<span class="cp">    { \</span>
<span class="cp">        printk(&quot;advansys: &quot;); \</span>
<span class="cp">        printk((s), (a1)); \</span>
<span class="cp">    }</span>

<span class="cp">#define ASC_PRINT2(s, a1, a2) \</span>
<span class="cp">    { \</span>
<span class="cp">        printk(&quot;advansys: &quot;); \</span>
<span class="cp">        printk((s), (a1), (a2)); \</span>
<span class="cp">    }</span>

<span class="cp">#define ASC_PRINT3(s, a1, a2, a3) \</span>
<span class="cp">    { \</span>
<span class="cp">        printk(&quot;advansys: &quot;); \</span>
<span class="cp">        printk((s), (a1), (a2), (a3)); \</span>
<span class="cp">    }</span>

<span class="cp">#define ASC_PRINT4(s, a1, a2, a3, a4) \</span>
<span class="cp">    { \</span>
<span class="cp">        printk(&quot;advansys: &quot;); \</span>
<span class="cp">        printk((s), (a1), (a2), (a3), (a4)); \</span>
<span class="cp">    }</span>

<span class="cp">#ifndef ADVANSYS_DEBUG</span>

<span class="cp">#define ASC_DBG(lvl, s...)</span>
<span class="cp">#define ASC_DBG_PRT_SCSI_HOST(lvl, s)</span>
<span class="cp">#define ASC_DBG_PRT_ASC_SCSI_Q(lvl, scsiqp)</span>
<span class="cp">#define ASC_DBG_PRT_ADV_SCSI_REQ_Q(lvl, scsiqp)</span>
<span class="cp">#define ASC_DBG_PRT_ASC_QDONE_INFO(lvl, qdone)</span>
<span class="cp">#define ADV_DBG_PRT_ADV_SCSI_REQ_Q(lvl, scsiqp)</span>
<span class="cp">#define ASC_DBG_PRT_HEX(lvl, name, start, length)</span>
<span class="cp">#define ASC_DBG_PRT_CDB(lvl, cdb, len)</span>
<span class="cp">#define ASC_DBG_PRT_SENSE(lvl, sense, len)</span>
<span class="cp">#define ASC_DBG_PRT_INQUIRY(lvl, inq, len)</span>

<span class="cp">#else </span><span class="cm">/* ADVANSYS_DEBUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Debugging Message Levels:</span>
<span class="cm"> * 0: Errors Only</span>
<span class="cm"> * 1: High-Level Tracing</span>
<span class="cm"> * 2-N: Verbose Tracing</span>
<span class="cm"> */</span>

<span class="cp">#define ASC_DBG(lvl, format, arg...) {					\</span>
<span class="cp">	if (asc_dbglvl &gt;= (lvl))					\</span>
<span class="cp">		printk(KERN_DEBUG &quot;%s: %s: &quot; format, DRV_NAME,		\</span>
<span class="cp">			__func__ , ## arg);				\</span>
<span class="cp">}</span>

<span class="cp">#define ASC_DBG_PRT_SCSI_HOST(lvl, s) \</span>
<span class="cp">    { \</span>
<span class="cp">        if (asc_dbglvl &gt;= (lvl)) { \</span>
<span class="cp">            asc_prt_scsi_host(s); \</span>
<span class="cp">        } \</span>
<span class="cp">    }</span>

<span class="cp">#define ASC_DBG_PRT_ASC_SCSI_Q(lvl, scsiqp) \</span>
<span class="cp">    { \</span>
<span class="cp">        if (asc_dbglvl &gt;= (lvl)) { \</span>
<span class="cp">            asc_prt_asc_scsi_q(scsiqp); \</span>
<span class="cp">        } \</span>
<span class="cp">    }</span>

<span class="cp">#define ASC_DBG_PRT_ASC_QDONE_INFO(lvl, qdone) \</span>
<span class="cp">    { \</span>
<span class="cp">        if (asc_dbglvl &gt;= (lvl)) { \</span>
<span class="cp">            asc_prt_asc_qdone_info(qdone); \</span>
<span class="cp">        } \</span>
<span class="cp">    }</span>

<span class="cp">#define ASC_DBG_PRT_ADV_SCSI_REQ_Q(lvl, scsiqp) \</span>
<span class="cp">    { \</span>
<span class="cp">        if (asc_dbglvl &gt;= (lvl)) { \</span>
<span class="cp">            asc_prt_adv_scsi_req_q(scsiqp); \</span>
<span class="cp">        } \</span>
<span class="cp">    }</span>

<span class="cp">#define ASC_DBG_PRT_HEX(lvl, name, start, length) \</span>
<span class="cp">    { \</span>
<span class="cp">        if (asc_dbglvl &gt;= (lvl)) { \</span>
<span class="cp">            asc_prt_hex((name), (start), (length)); \</span>
<span class="cp">        } \</span>
<span class="cp">    }</span>

<span class="cp">#define ASC_DBG_PRT_CDB(lvl, cdb, len) \</span>
<span class="cp">        ASC_DBG_PRT_HEX((lvl), &quot;CDB&quot;, (uchar *) (cdb), (len));</span>

<span class="cp">#define ASC_DBG_PRT_SENSE(lvl, sense, len) \</span>
<span class="cp">        ASC_DBG_PRT_HEX((lvl), &quot;SENSE&quot;, (uchar *) (sense), (len));</span>

<span class="cp">#define ASC_DBG_PRT_INQUIRY(lvl, inq, len) \</span>
<span class="cp">        ASC_DBG_PRT_HEX((lvl), &quot;INQUIRY&quot;, (uchar *) (inq), (len));</span>
<span class="cp">#endif </span><span class="cm">/* ADVANSYS_DEBUG */</span><span class="cp"></span>

<span class="cp">#ifdef ADVANSYS_STATS</span>

<span class="cm">/* Per board statistics structure */</span>
<span class="k">struct</span> <span class="n">asc_stats</span> <span class="p">{</span>
	<span class="cm">/* Driver Entrypoint Statistics */</span>
	<span class="n">ADV_DCNT</span> <span class="n">queuecommand</span><span class="p">;</span>	<span class="cm">/* # calls to advansys_queuecommand() */</span>
	<span class="n">ADV_DCNT</span> <span class="n">reset</span><span class="p">;</span>		<span class="cm">/* # calls to advansys_eh_bus_reset() */</span>
	<span class="n">ADV_DCNT</span> <span class="n">biosparam</span><span class="p">;</span>	<span class="cm">/* # calls to advansys_biosparam() */</span>
	<span class="n">ADV_DCNT</span> <span class="n">interrupt</span><span class="p">;</span>	<span class="cm">/* # advansys_interrupt() calls */</span>
	<span class="n">ADV_DCNT</span> <span class="n">callback</span><span class="p">;</span>	<span class="cm">/* # calls to asc/adv_isr_callback() */</span>
	<span class="n">ADV_DCNT</span> <span class="n">done</span><span class="p">;</span>		<span class="cm">/* # calls to request&#39;s scsi_done function */</span>
	<span class="n">ADV_DCNT</span> <span class="n">build_error</span><span class="p">;</span>	<span class="cm">/* # asc/adv_build_req() ASC_ERROR returns. */</span>
	<span class="n">ADV_DCNT</span> <span class="n">adv_build_noreq</span><span class="p">;</span>	<span class="cm">/* # adv_build_req() adv_req_t alloc. fail. */</span>
	<span class="n">ADV_DCNT</span> <span class="n">adv_build_nosg</span><span class="p">;</span>	<span class="cm">/* # adv_build_req() adv_sgblk_t alloc. fail. */</span>
	<span class="cm">/* AscExeScsiQueue()/AdvExeScsiQueue() Statistics */</span>
	<span class="n">ADV_DCNT</span> <span class="n">exe_noerror</span><span class="p">;</span>	<span class="cm">/* # ASC_NOERROR returns. */</span>
	<span class="n">ADV_DCNT</span> <span class="n">exe_busy</span><span class="p">;</span>	<span class="cm">/* # ASC_BUSY returns. */</span>
	<span class="n">ADV_DCNT</span> <span class="n">exe_error</span><span class="p">;</span>	<span class="cm">/* # ASC_ERROR returns. */</span>
	<span class="n">ADV_DCNT</span> <span class="n">exe_unknown</span><span class="p">;</span>	<span class="cm">/* # unknown returns. */</span>
	<span class="cm">/* Data Transfer Statistics */</span>
	<span class="n">ADV_DCNT</span> <span class="n">xfer_cnt</span><span class="p">;</span>	<span class="cm">/* # I/O requests received */</span>
	<span class="n">ADV_DCNT</span> <span class="n">xfer_elem</span><span class="p">;</span>	<span class="cm">/* # scatter-gather elements */</span>
	<span class="n">ADV_DCNT</span> <span class="n">xfer_sect</span><span class="p">;</span>	<span class="cm">/* # 512-byte blocks */</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* ADVANSYS_STATS */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Structure allocated for each board.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is allocated by scsi_host_alloc() at the end</span>
<span class="cm"> * of the &#39;Scsi_Host&#39; structure starting at the &#39;hostdata&#39;</span>
<span class="cm"> * field. It is guaranteed to be allocated from DMA-able memory.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">asc_board</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* Board flags */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">ASC_DVC_VAR</span> <span class="n">asc_dvc_var</span><span class="p">;</span>	<span class="cm">/* Narrow board */</span>
		<span class="n">ADV_DVC_VAR</span> <span class="n">adv_dvc_var</span><span class="p">;</span>	<span class="cm">/* Wide board */</span>
	<span class="p">}</span> <span class="n">dvc_var</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">ASC_DVC_CFG</span> <span class="n">asc_dvc_cfg</span><span class="p">;</span>	<span class="cm">/* Narrow board */</span>
		<span class="n">ADV_DVC_CFG</span> <span class="n">adv_dvc_cfg</span><span class="p">;</span>	<span class="cm">/* Wide board */</span>
	<span class="p">}</span> <span class="n">dvc_cfg</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">asc_n_io_port</span><span class="p">;</span>	<span class="cm">/* Number I/O ports. */</span>
	<span class="n">ADV_SCSI_BIT_ID_TYPE</span> <span class="n">init_tidmask</span><span class="p">;</span>	<span class="cm">/* Target init./valid mask */</span>
	<span class="n">ushort</span> <span class="n">reqcnt</span><span class="p">[</span><span class="n">ADV_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>	<span class="cm">/* Starvation request count */</span>
	<span class="n">ADV_SCSI_BIT_ID_TYPE</span> <span class="n">queue_full</span><span class="p">;</span>	<span class="cm">/* Queue full mask */</span>
	<span class="n">ushort</span> <span class="n">queue_full_cnt</span><span class="p">[</span><span class="n">ADV_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>	<span class="cm">/* Queue full count */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">ASCEEP_CONFIG</span> <span class="n">asc_eep</span><span class="p">;</span>	<span class="cm">/* Narrow EEPROM config. */</span>
		<span class="n">ADVEEP_3550_CONFIG</span> <span class="n">adv_3550_eep</span><span class="p">;</span>	<span class="cm">/* 3550 EEPROM config. */</span>
		<span class="n">ADVEEP_38C0800_CONFIG</span> <span class="n">adv_38C0800_eep</span><span class="p">;</span>	<span class="cm">/* 38C0800 EEPROM config. */</span>
		<span class="n">ADVEEP_38C1600_CONFIG</span> <span class="n">adv_38C1600_eep</span><span class="p">;</span>	<span class="cm">/* 38C1600 EEPROM config. */</span>
	<span class="p">}</span> <span class="n">eep_config</span><span class="p">;</span>
	<span class="n">ulong</span> <span class="n">last_reset</span><span class="p">;</span>	<span class="cm">/* Saved last reset time */</span>
	<span class="cm">/* /proc/scsi/advansys/[0...] */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">prtbuf</span><span class="p">;</span>		<span class="cm">/* /proc print buffer */</span>
<span class="cp">#ifdef ADVANSYS_STATS</span>
	<span class="k">struct</span> <span class="n">asc_stats</span> <span class="n">asc_stats</span><span class="p">;</span>	<span class="cm">/* Board statistics */</span>
<span class="cp">#endif				</span><span class="cm">/* ADVANSYS_STATS */</span><span class="cp"></span>
	<span class="cm">/*</span>
<span class="cm">	 * The following fields are used only for Narrow Boards.</span>
<span class="cm">	 */</span>
	<span class="n">uchar</span> <span class="n">sdtr_data</span><span class="p">[</span><span class="n">ASC_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>	<span class="cm">/* SDTR information */</span>
	<span class="cm">/*</span>
<span class="cm">	 * The following fields are used only for Wide Boards.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioremap_addr</span><span class="p">;</span>	<span class="cm">/* I/O Memory remap address. */</span>
	<span class="n">ushort</span> <span class="n">ioport</span><span class="p">;</span>		<span class="cm">/* I/O Port address. */</span>
	<span class="n">adv_req_t</span> <span class="o">*</span><span class="n">adv_reqp</span><span class="p">;</span>	<span class="cm">/* Request structures. */</span>
	<span class="n">adv_sgblk_t</span> <span class="o">*</span><span class="n">adv_sgblkp</span><span class="p">;</span>	<span class="cm">/* Scatter-gather structures. */</span>
	<span class="n">ushort</span> <span class="n">bios_signature</span><span class="p">;</span>	<span class="cm">/* BIOS Signature. */</span>
	<span class="n">ushort</span> <span class="n">bios_version</span><span class="p">;</span>	<span class="cm">/* BIOS Version. */</span>
	<span class="n">ushort</span> <span class="n">bios_codeseg</span><span class="p">;</span>	<span class="cm">/* BIOS Code Segment. */</span>
	<span class="n">ushort</span> <span class="n">bios_codelen</span><span class="p">;</span>	<span class="cm">/* BIOS Code Segment Length. */</span>
<span class="p">};</span>

<span class="cp">#define asc_dvc_to_board(asc_dvc) container_of(asc_dvc, struct asc_board, \</span>
<span class="cp">							dvc_var.asc_dvc_var)</span>
<span class="cp">#define adv_dvc_to_board(adv_dvc) container_of(adv_dvc, struct asc_board, \</span>
<span class="cp">							dvc_var.adv_dvc_var)</span>
<span class="cp">#define adv_dvc_to_pdev(adv_dvc) to_pci_dev(adv_dvc_to_board(adv_dvc)-&gt;dev)</span>

<span class="cp">#ifdef ADVANSYS_DEBUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">asc_dbglvl</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_asc_dvc_var()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">asc_prt_asc_dvc_var</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ASC_DVC_VAR at addr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">h</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; iop_base 0x%x, err_code 0x%x, dvc_cntl 0x%x, bug_fix_cntl &quot;</span>
	       <span class="s">&quot;%d,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">dvc_cntl</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">bug_fix_cntl</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; bus_type %d, init_sdtr 0x%x,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">bus_type</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">init_sdtr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; sdtr_done 0x%x, use_tagged_qng 0x%x, unit_not_ready 0x%x, &quot;</span>
	       <span class="s">&quot;chip_no 0x%x,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">sdtr_done</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">use_tagged_qng</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">unit_not_ready</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">chip_no</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; queue_full_or_busy 0x%x, start_motor 0x%x, scsi_reset_wait &quot;</span>
	       <span class="s">&quot;%u,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">queue_full_or_busy</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">start_motor</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_reset_wait</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; is_in_int %u, max_total_qng %u, cur_total_qng %u, &quot;</span>
	       <span class="s">&quot;in_critical_cnt %u,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">is_in_int</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">max_total_qng</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cur_total_qng</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">in_critical_cnt</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; last_q_shortage %u, init_state 0x%x, no_scam 0x%x, &quot;</span>
	       <span class="s">&quot;pci_fix_asyn_xfer 0x%x,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">last_q_shortage</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">init_state</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">no_scam</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; cfg 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_asc_dvc_cfg()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">asc_prt_asc_dvc_cfg</span><span class="p">(</span><span class="n">ASC_DVC_CFG</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ASC_DVC_CFG at addr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">h</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; can_tagged_qng 0x%x, cmd_qng_enabled 0x%x,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">h</span><span class="o">-&gt;</span><span class="n">can_tagged_qng</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">cmd_qng_enabled</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; disc_enable 0x%x, sdtr_enable 0x%x,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">h</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">sdtr_enable</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; chip_scsi_id %d, isa_dma_speed %d, isa_dma_channel %d, &quot;</span>
		<span class="s">&quot;chip_version %d,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">isa_dma_speed</span><span class="p">,</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">isa_dma_channel</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; mcode_date 0x%x, mcode_version %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">mcode_date</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mcode_version</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_adv_dvc_var()</span>
<span class="cm"> *</span>
<span class="cm"> * Display an ADV_DVC_VAR structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">asc_prt_adv_dvc_var</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; ADV_DVC_VAR at addr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">h</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  iop_base 0x%lx, err_code 0x%x, ultra_able 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">ultra_able</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  sdtr_able 0x%x, wdtr_able 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">sdtr_able</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">wdtr_able</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  start_motor 0x%x, scsi_reset_wait 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">start_motor</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">scsi_reset_wait</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  max_host_qng %u, max_dvc_qng %u, carr_freelist 0x%lxn</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">max_host_qng</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">carr_freelist</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  icq_sp 0x%lx, irq_sp 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">irq_sp</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  no_scam 0x%x, tagqng_able 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">no_scam</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">tagqng_able</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  chip_scsi_id 0x%x, cfg 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_adv_dvc_cfg()</span>
<span class="cm"> *</span>
<span class="cm"> * Display an ADV_DVC_CFG structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">asc_prt_adv_dvc_cfg</span><span class="p">(</span><span class="n">ADV_DVC_CFG</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; ADV_DVC_CFG at addr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">h</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  disc_enable 0x%x, termination 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">h</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">termination</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  chip_version 0x%x, mcode_date 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">h</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mcode_date</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  mcode_version 0x%x, control_flag 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">h</span><span class="o">-&gt;</span><span class="n">mcode_version</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">control_flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_scsi_host()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">asc_prt_scsi_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Scsi_Host at addr 0x%p, device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; host_busy %u, host_no %d, last_reset %d,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">s</span><span class="o">-&gt;</span><span class="n">host_busy</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">last_reset</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; base 0x%lx, io_port 0x%lx, irq %d,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">io_port</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; dma_channel %d, this_id %d, can_queue %d,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">s</span><span class="o">-&gt;</span><span class="n">dma_channel</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">this_id</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">can_queue</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; cmd_per_lun %d, sg_tablesize %d, unchecked_isa_dma %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">s</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asc_prt_asc_dvc_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">);</span>
		<span class="n">asc_prt_asc_dvc_cfg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_cfg</span><span class="p">.</span><span class="n">asc_dvc_cfg</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">asc_prt_adv_dvc_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">);</span>
		<span class="n">asc_prt_adv_dvc_cfg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_cfg</span><span class="p">.</span><span class="n">adv_dvc_cfg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_hex()</span>
<span class="cm"> *</span>
<span class="cm"> * Print hexadecimal output in 4 byte groupings 32 bytes</span>
<span class="cm"> * or 8 double-words per line.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">asc_prt_hex</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">m</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: (%d bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Display a maximum of 8 double-words per line. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">k</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %2.2X%2.2X%2.2X%2.2X&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)],</span>
			       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
			       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span>
			       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]);</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %2.2X&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %2.2X%2.2X&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)],</span>
			       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %2.2X%2.2X%2.2X&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
			       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span>
			       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_asc_scsi_q()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">asc_prt_asc_scsi_q</span><span class="p">(</span><span class="n">ASC_SCSI_Q</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASC_SG_HEAD</span> <span class="o">*</span><span class="n">sgp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ASC_SCSI_Q at addr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">q</span><span class="p">);</span>

	<span class="n">printk</span>
	    <span class="p">(</span><span class="s">&quot; target_ix 0x%x, target_lun %u, srb_ptr 0x%lx, tag_code 0x%x,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">q</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">target_ix</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">target_lun</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">srb_ptr</span><span class="p">,</span>
	     <span class="n">q</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">tag_code</span><span class="p">);</span>

	<span class="n">printk</span>
	    <span class="p">(</span><span class="s">&quot; data_addr 0x%lx, data_cnt %lu, sense_addr 0x%lx, sense_len %u,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_addr</span><span class="p">),</span>
	     <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_cnt</span><span class="p">),</span>
	     <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">sense_addr</span><span class="p">),</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">sense_len</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; cdbptr 0x%lx, cdb_len %u, sg_head 0x%lx, sg_queue_cnt %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cdbptr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">cdb_len</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sg_head</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">sg_queue_cnt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sg_head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sgp</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sg_head</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ASC_SG_HEAD at addr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">sgp</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; entry_cnt %u, queue_cnt %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sgp</span><span class="o">-&gt;</span><span class="n">entry_cnt</span><span class="p">,</span>
		       <span class="n">sgp</span><span class="o">-&gt;</span><span class="n">queue_cnt</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sgp</span><span class="o">-&gt;</span><span class="n">entry_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; [%u]: addr 0x%lx, bytes %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">),</span>
			       <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bytes</span><span class="p">));</span>
		<span class="p">}</span>

	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_asc_qdone_info()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">asc_prt_asc_qdone_info</span><span class="p">(</span><span class="n">ASC_QDONE_INFO</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ASC_QDONE_INFO at addr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">q</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; srb_ptr 0x%lx, target_ix %u, cdb_len %u, tag_code %u,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">d2</span><span class="p">.</span><span class="n">srb_ptr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">d2</span><span class="p">.</span><span class="n">target_ix</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">d2</span><span class="p">.</span><span class="n">cdb_len</span><span class="p">,</span>
	       <span class="n">q</span><span class="o">-&gt;</span><span class="n">d2</span><span class="p">.</span><span class="n">tag_code</span><span class="p">);</span>
	<span class="n">printk</span>
	    <span class="p">(</span><span class="s">&quot; done_stat 0x%x, host_stat 0x%x, scsi_stat 0x%x, scsi_msg 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">q</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">done_stat</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">host_stat</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">scsi_stat</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">scsi_msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_adv_sgblock()</span>
<span class="cm"> *</span>
<span class="cm"> * Display an ADV_SG_BLOCK structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">asc_prt_adv_sgblock</span><span class="p">(</span><span class="kt">int</span> <span class="n">sgblockno</span><span class="p">,</span> <span class="n">ADV_SG_BLOCK</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; ASC_SG_BLOCK at addr 0x%lx (sgblockno %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">b</span><span class="p">,</span> <span class="n">sgblockno</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  sg_cnt %u, sg_ptr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">b</span><span class="o">-&gt;</span><span class="n">sg_cnt</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">sg_ptr</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">sg_cnt</span> <span class="o">&gt;</span> <span class="n">NO_OF_SG_PER_BLOCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">sg_ptr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">sg_cnt</span> <span class="o">!=</span> <span class="n">NO_OF_SG_PER_BLOCK</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">sg_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  [%u]: sg_addr 0x%lx, sg_count 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg_addr</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg_count</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_adv_scsi_req_q()</span>
<span class="cm"> *</span>
<span class="cm"> * Display an ADV_SCSI_REQ_Q structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">asc_prt_adv_scsi_req_q</span><span class="p">(</span><span class="n">ADV_SCSI_REQ_Q</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sg_blk_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asc_sg_block</span> <span class="o">*</span><span class="n">sg_ptr</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ADV_SCSI_REQ_Q at addr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">q</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  target_id %u, target_lun %u, srb_ptr 0x%lx, a_flag 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">q</span><span class="o">-&gt;</span><span class="n">target_id</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">target_lun</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">srb_ptr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">a_flag</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  cntl 0x%x, data_addr 0x%lx, vdata_addr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">q</span><span class="o">-&gt;</span><span class="n">cntl</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">data_addr</span><span class="p">),</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">vdata_addr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  data_cnt %lu, sense_addr 0x%lx, sense_len %u,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">data_cnt</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sense_addr</span><span class="p">),</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sense_len</span><span class="p">);</span>

	<span class="n">printk</span>
	    <span class="p">(</span><span class="s">&quot;  cdb_len %u, done_status 0x%x, host_status 0x%x, scsi_status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">q</span><span class="o">-&gt;</span><span class="n">cdb_len</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">done_status</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  sg_working_ix 0x%x, target_cmd %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">q</span><span class="o">-&gt;</span><span class="n">sg_working_ix</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">target_cmd</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  scsiq_rptr 0x%lx, sg_real_addr 0x%lx, sg_list_ptr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">scsiq_rptr</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sg_real_addr</span><span class="p">),</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sg_list_ptr</span><span class="p">);</span>

	<span class="cm">/* Display the request&#39;s ADV_SG_BLOCK structures. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sg_list_ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg_blk_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * &#39;sg_ptr&#39; is a physical address. Convert it to a virtual</span>
<span class="cm">			 * address by indexing &#39;sg_blk_cnt&#39; into the virtual address</span>
<span class="cm">			 * array &#39;sg_list_ptr&#39;.</span>
<span class="cm">			 *</span>
<span class="cm">			 * XXX - Assumes all SG physical blocks are virtually contiguous.</span>
<span class="cm">			 */</span>
			<span class="n">sg_ptr</span> <span class="o">=</span>
			    <span class="o">&amp;</span><span class="p">(((</span><span class="n">ADV_SG_BLOCK</span> <span class="o">*</span><span class="p">)(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sg_list_ptr</span><span class="p">))[</span><span class="n">sg_blk_cnt</span><span class="p">]);</span>
			<span class="n">asc_prt_adv_sgblock</span><span class="p">(</span><span class="n">sg_blk_cnt</span><span class="p">,</span> <span class="n">sg_ptr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sg_ptr</span><span class="o">-&gt;</span><span class="n">sg_ptr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sg_blk_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* ADVANSYS_DEBUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The advansys chip/microcode contains a 32-bit identifier for each command</span>
<span class="cm"> * known as the &#39;srb&#39;.  I don&#39;t know what it stands for.  The driver used</span>
<span class="cm"> * to encode the scsi_cmnd pointer by calling virt_to_bus and retrieve it</span>
<span class="cm"> * with bus_to_virt.  Now the driver keeps a per-host map of integers to</span>
<span class="cm"> * pointers.  It auto-expands when full, unless it can&#39;t allocate memory.</span>
<span class="cm"> * Note that an srb of 0 is treated specially by the chip/firmware, hence</span>
<span class="cm"> * the return of i+1 in this routine, and the corresponding subtraction in</span>
<span class="cm"> * the inverse routine.</span>
<span class="cm"> */</span>
<span class="cp">#define BAD_SRB 0</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">advansys_ptr_to_srb</span><span class="p">(</span><span class="k">struct</span> <span class="n">asc_dvc_var</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">new_ptr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ptr_map_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ptr_map</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ptr_map_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ptr_map_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ptr_map_count</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">new_ptr</span> <span class="o">=</span> <span class="n">krealloc</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ptr_map</span><span class="p">,</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ptr_map_count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_ptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">BAD_SRB</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ptr_map</span> <span class="o">=</span> <span class="n">new_ptr</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Putting ptr %p into array offset %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ptr_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="nf">advansys_srb_to_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">asc_dvc_var</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">srb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="n">srb</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span> <span class="o">&gt;=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ptr_map_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;advansys: bad SRB %u, max %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">srb</span><span class="p">,</span>
							<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ptr_map_count</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ptr_map</span><span class="p">[</span><span class="n">srb</span><span class="p">];</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ptr_map</span><span class="p">[</span><span class="n">srb</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Returning ptr %p from array offset %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">srb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * advansys_info()</span>
<span class="cm"> *</span>
<span class="cm"> * Return suitable for printing on the console with the argument</span>
<span class="cm"> * adapter&#39;s configuration information.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The information line should not exceed ASC_INFO_SIZE bytes,</span>
<span class="cm"> * otherwise the static &#39;info&#39; array will be overrun.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">advansys_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">info</span><span class="p">[</span><span class="n">ASC_INFO_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc_varp</span><span class="p">;</span>
	<span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">adv_dvc_varp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">busname</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">widename</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asc_dvc_varp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">;</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;begin</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_ISA</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_ISAPNP</span><span class="p">)</span> <span class="o">==</span>
			    <span class="n">ASC_IS_ISAPNP</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">busname</span> <span class="o">=</span> <span class="s">&quot;ISA PnP&quot;</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">busname</span> <span class="o">=</span> <span class="s">&quot;ISA&quot;</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">info</span><span class="p">,</span>
				<span class="s">&quot;AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X, DMA 0x%X&quot;</span><span class="p">,</span>
				<span class="n">ASC_VERSION</span><span class="p">,</span> <span class="n">busname</span><span class="p">,</span>
				<span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">io_port</span><span class="p">,</span>
				<span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">io_port</span> <span class="o">+</span> <span class="n">ASC_IOADR_GAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_channel</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_VL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">busname</span> <span class="o">=</span> <span class="s">&quot;VL&quot;</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_EISA</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">busname</span> <span class="o">=</span> <span class="s">&quot;EISA&quot;</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_PCI</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_PCI_ULTRA</span><span class="p">)</span>
				    <span class="o">==</span> <span class="n">ASC_IS_PCI_ULTRA</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">busname</span> <span class="o">=</span> <span class="s">&quot;PCI Ultra&quot;</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">busname</span> <span class="o">=</span> <span class="s">&quot;PCI&quot;</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">busname</span> <span class="o">=</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>
				<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;unknown bus &quot;</span>
					<span class="s">&quot;type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">bus_type</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">info</span><span class="p">,</span>
				<span class="s">&quot;AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X&quot;</span><span class="p">,</span>
				<span class="n">ASC_VERSION</span><span class="p">,</span> <span class="n">busname</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">io_port</span><span class="p">,</span>
				<span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">io_port</span> <span class="o">+</span> <span class="n">ASC_IOADR_GAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Wide Adapter Information</span>
<span class="cm">		 *</span>
<span class="cm">		 * Memory-mapped I/O is used instead of I/O space to access</span>
<span class="cm">		 * the adapter, but display the I/O Port range. The Memory</span>
<span class="cm">		 * I/O address is displayed through the driver /proc file.</span>
<span class="cm">		 */</span>
		<span class="n">adv_dvc_varp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">widename</span> <span class="o">=</span> <span class="s">&quot;Ultra-Wide&quot;</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">widename</span> <span class="o">=</span> <span class="s">&quot;Ultra2-Wide&quot;</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">widename</span> <span class="o">=</span> <span class="s">&quot;Ultra3-Wide&quot;</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">info</span><span class="p">,</span>
			<span class="s">&quot;AdvanSys SCSI %s: PCI %s: PCIMEM 0x%lX-0x%lX, IRQ 0x%X&quot;</span><span class="p">,</span>
			<span class="n">ASC_VERSION</span><span class="p">,</span> <span class="n">widename</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span>
			<span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">iop_base</span> <span class="o">+</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">asc_n_io_port</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ASC_INFO_SIZE</span><span class="p">);</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">info</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cm">/*</span>
<span class="cm"> * asc_prt_line()</span>
<span class="cm"> *</span>
<span class="cm"> * If &#39;cp&#39; is NULL print to the console, otherwise print to a buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if printing to the console, otherwise return the number of</span>
<span class="cm"> * bytes written to the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: If any single line is greater than ASC_PRTLINE_SIZE bytes the stack</span>
<span class="cm"> * will be corrupted. &#39;s[]&#39; is defined to be ASC_PRTLINE_SIZE bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asc_prt_line</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="n">ASC_PRTLINE_SIZE</span><span class="p">];</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vsprintf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="n">ASC_PRTLINE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">printk</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">buflen</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_board_devices()</span>
<span class="cm"> *</span>
<span class="cm"> * Print driver information for devices attached to the board.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: no single line should be greater than ASC_PRTLINE_SIZE,</span>
<span class="cm"> * cf. asc_prt_line().</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of characters copied into &#39;cp&#39;. No more than</span>
<span class="cm"> * &#39;cplen&#39; characters will be copied to &#39;cp&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asc_prt_board_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cplen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">leftlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">totlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chip_scsi_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">leftlen</span> <span class="o">=</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="n">totlen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot;</span><span class="se">\n</span><span class="s">Device Information for AdvanSys SCSI Host %d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">chip_scsi_id</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_cfg</span><span class="p">.</span><span class="n">asc_dvc_cfg</span><span class="p">.</span><span class="n">chip_scsi_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">chip_scsi_id</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">.</span><span class="n">chip_scsi_id</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;Target IDs Detected:&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %X,&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; (%X=Host Adapter)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip_scsi_id</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">totlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Display Wide Board BIOS Information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asc_prt_adv_bios</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cplen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">leftlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">totlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">letter</span><span class="p">;</span>

	<span class="n">leftlen</span> <span class="o">=</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="n">totlen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">ROM BIOS Version: &quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the BIOS saved a valid signature, then fill in</span>
<span class="cm">	 * the BIOS code segment base address.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">bios_signature</span> <span class="o">!=</span> <span class="mh">0x55AA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;Disabled or Pre-3.1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
				   <span class="s">&quot;BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
				   <span class="s">&quot;can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">major</span> <span class="o">=</span> <span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">bios_version</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">minor</span> <span class="o">=</span> <span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">bios_version</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">letter</span> <span class="o">=</span> <span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">bios_version</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;%d.%d%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span>
				   <span class="n">letter</span> <span class="o">&gt;=</span> <span class="mi">26</span> <span class="o">?</span> <span class="sc">&#39;?&#39;</span> <span class="o">:</span> <span class="n">letter</span> <span class="o">+</span> <span class="sc">&#39;A&#39;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * Current available ROM BIOS release is 3.1I for UW</span>
<span class="cm">		 * and 3.2I for U2W. This code doesn&#39;t differentiate</span>
<span class="cm">		 * UW and U2W boards.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">major</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">||</span> <span class="p">(</span><span class="n">major</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">minor</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">major</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">minor</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">letter</span> <span class="o">&lt;</span> <span class="p">(</span><span class="sc">&#39;I&#39;</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
					   <span class="s">&quot;Newer version of ROM BIOS is available at the ConnectCom FTP site:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
					   <span class="s">&quot;ftp://ftp.connectcom.net/pub</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">totlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add serial number to information bar if signature AAh</span>
<span class="cm"> * is found in at bit 15-9 (7 bits) of word 1.</span>
<span class="cm"> *</span>
<span class="cm"> * Serial Number consists fo 12 alpha-numeric digits.</span>
<span class="cm"> *</span>
<span class="cm"> *       1 - Product type (A,B,C,D..)  Word0: 15-13 (3 bits)</span>
<span class="cm"> *       2 - MFG Location (A,B,C,D..)  Word0: 12-10 (3 bits)</span>
<span class="cm"> *     3-4 - Product ID (0-99)         Word0: 9-0 (10 bits)</span>
<span class="cm"> *       5 - Product revision (A-J)    Word0:  &quot;         &quot;</span>
<span class="cm"> *</span>
<span class="cm"> *           Signature                 Word1: 15-9 (7 bits)</span>
<span class="cm"> *       6 - Year (0-9)                Word1: 8-6 (3 bits) &amp; Word2: 15 (1 bit)</span>
<span class="cm"> *     7-8 - Week of the year (1-52)   Word1: 5-0 (6 bits)</span>
<span class="cm"> *</span>
<span class="cm"> *    9-12 - Serial Number (A001-Z999) Word2: 14-0 (15 bits)</span>
<span class="cm"> *</span>
<span class="cm"> * Note 1: Only production cards will have a serial number.</span>
<span class="cm"> *</span>
<span class="cm"> * Note 2: Signature is most significant 7 bits (0xFE).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns ASC_TRUE if serial number found, otherwise returns ASC_FALSE.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asc_get_eeprom_string</span><span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="n">serialnum</span><span class="p">,</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">w</span><span class="p">,</span> <span class="n">num</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">serialnum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFE00</span><span class="p">)</span> <span class="o">!=</span> <span class="p">((</span><span class="n">ushort</span><span class="p">)</span><span class="mh">0xAA</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ASC_FALSE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * First word - 6 digits.</span>
<span class="cm">		 */</span>
		<span class="n">w</span> <span class="o">=</span> <span class="n">serialnum</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="cm">/* Product type - 1st digit. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="p">((</span><span class="n">w</span> <span class="o">&amp;</span> <span class="mh">0xE000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">))</span> <span class="o">==</span> <span class="sc">&#39;H&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Product type is P=Prototype */</span>
			<span class="o">*</span><span class="n">cp</span> <span class="o">+=</span> <span class="mh">0x8</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cp</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Manufacturing location - 2nd digit. */</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="p">((</span><span class="n">w</span> <span class="o">&amp;</span> <span class="mh">0x1C00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>

		<span class="cm">/* Product ID - 3rd, 4th digits. */</span>
		<span class="n">num</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&amp;</span> <span class="mh">0x3FF</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>
		<span class="n">num</span> <span class="o">%=</span> <span class="mi">100</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>

		<span class="cm">/* Product revision - 5th digit. */</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Second word</span>
<span class="cm">		 */</span>
		<span class="n">w</span> <span class="o">=</span> <span class="n">serialnum</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * Year - 6th digit.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If bit 15 of third word is set, then the</span>
<span class="cm">		 * last digit of the year is greater than 7.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">serialnum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;8&#39;</span> <span class="o">+</span> <span class="p">((</span><span class="n">w</span> <span class="o">&amp;</span> <span class="mh">0x1C0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">((</span><span class="n">w</span> <span class="o">&amp;</span> <span class="mh">0x1C0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Week of year - 7th, 8th digits. */</span>
		<span class="n">num</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&amp;</span> <span class="mh">0x003F</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">num</span> <span class="o">%=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="n">num</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Third word</span>
<span class="cm">		 */</span>
		<span class="n">w</span> <span class="o">=</span> <span class="n">serialnum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7FFF</span><span class="p">;</span>

		<span class="cm">/* Serial number - 9th digit. */</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">w</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>

		<span class="cm">/* 10th, 11th, 12th digits. */</span>
		<span class="n">num</span> <span class="o">=</span> <span class="n">w</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
		<span class="n">num</span> <span class="o">%=</span> <span class="mi">100</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">num</span> <span class="o">%=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="n">num</span><span class="p">;</span>

		<span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>	<span class="cm">/* Null Terminate the string. */</span>
		<span class="k">return</span> <span class="n">ASC_TRUE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_asc_board_eeprom()</span>
<span class="cm"> *</span>
<span class="cm"> * Print board EEPROM configuration.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: no single line should be greater than ASC_PRTLINE_SIZE,</span>
<span class="cm"> * cf. asc_prt_line().</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of characters copied into &#39;cp&#39;. No more than</span>
<span class="cm"> * &#39;cplen&#39; characters will be copied to &#39;cp&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asc_prt_asc_board_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cplen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc_varp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leftlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">totlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">ASCEEP_CONFIG</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ISA</span>
	<span class="kt">int</span> <span class="n">isa_dma_speed</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ISA */</span><span class="cp"></span>
	<span class="n">uchar</span> <span class="n">serialstr</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>

	<span class="n">asc_dvc_varp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">;</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">eep_config</span><span class="p">.</span><span class="n">asc_eep</span><span class="p">;</span>

	<span class="n">leftlen</span> <span class="o">=</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="n">totlen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot;</span><span class="se">\n</span><span class="s">EEPROM Settings for AdvanSys SCSI Host %d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asc_get_eeprom_string</span><span class="p">((</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">serialstr</span><span class="p">)</span>
	    <span class="o">==</span> <span class="n">ASC_TRUE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span>
		    <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Serial Number: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">serialstr</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xBB</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
					   <span class="s">&quot; Default Settings Used for EEPROM-less Adapter.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
					   <span class="s">&quot; Serial Number Signature Not Present.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot; Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">ASC_EEP_GET_CHIP_ID</span><span class="p">(</span><span class="n">ep</span><span class="p">),</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">max_total_qng</span><span class="p">,</span>
			   <span class="n">ep</span><span class="o">-&gt;</span><span class="n">max_tag_qng</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot; cntl 0x%x, no_scam 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">cntl</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">no_scam</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Target ID:           &quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Disconnects:         &quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %c&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span>
				    <span class="n">disc_enable</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;Y&#39;</span> <span class="o">:</span>
				   <span class="sc">&#39;N&#39;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Command Queuing:     &quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %c&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span>
				    <span class="n">use_cmd_qng</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;Y&#39;</span> <span class="o">:</span>
				   <span class="sc">&#39;N&#39;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Start Motor:         &quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %c&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span>
				    <span class="n">start_motor</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;Y&#39;</span> <span class="o">:</span>
				   <span class="sc">&#39;N&#39;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Synchronous Transfer:&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %c&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span>
				    <span class="n">init_sdtr</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;Y&#39;</span> <span class="o">:</span>
				   <span class="sc">&#39;N&#39;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_ISA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_ISA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
				   <span class="s">&quot; Host ISA DMA speed:   %d MB/S</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">isa_dma_speed</span><span class="p">[</span><span class="n">ASC_EEP_GET_DMA_SPD</span><span class="p">(</span><span class="n">ep</span><span class="p">)]);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ISA */</span><span class="cp"></span>

	<span class="k">return</span> <span class="n">totlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_adv_board_eeprom()</span>
<span class="cm"> *</span>
<span class="cm"> * Print board EEPROM configuration.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: no single line should be greater than ASC_PRTLINE_SIZE,</span>
<span class="cm"> * cf. asc_prt_line().</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of characters copied into &#39;cp&#39;. No more than</span>
<span class="cm"> * &#39;cplen&#39; characters will be copied to &#39;cp&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asc_prt_adv_board_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cplen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">adv_dvc_varp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leftlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">totlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">termstr</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">serialstr</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>
	<span class="n">ADVEEP_3550_CONFIG</span> <span class="o">*</span><span class="n">ep_3550</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ADVEEP_38C0800_CONFIG</span> <span class="o">*</span><span class="n">ep_38C0800</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ADVEEP_38C1600_CONFIG</span> <span class="o">*</span><span class="n">ep_38C1600</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">word</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">wordp</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">adv_dvc_varp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_3550</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">eep_config</span><span class="p">.</span><span class="n">adv_3550_eep</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_38C0800</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">eep_config</span><span class="p">.</span><span class="n">adv_38C0800_eep</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ep_38C1600</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">eep_config</span><span class="p">.</span><span class="n">adv_38C1600_eep</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">leftlen</span> <span class="o">=</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="n">totlen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot;</span><span class="se">\n</span><span class="s">EEPROM Settings for AdvanSys SCSI Host %d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wordp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">serial_number_word1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wordp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">serial_number_word1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">wordp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">serial_number_word1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asc_get_eeprom_string</span><span class="p">(</span><span class="n">wordp</span><span class="p">,</span> <span class="n">serialstr</span><span class="p">)</span> <span class="o">==</span> <span class="n">ASC_TRUE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span>
		    <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Serial Number: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">serialstr</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
				   <span class="s">&quot; Serial Number Signature Not Present.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
				   <span class="s">&quot; Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">adapter_scsi_id</span><span class="p">,</span>
				   <span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">max_host_qng</span><span class="p">,</span> <span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
				   <span class="s">&quot; Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">adapter_scsi_id</span><span class="p">,</span>
				   <span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">max_host_qng</span><span class="p">,</span>
				   <span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
				   <span class="s">&quot; Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">adapter_scsi_id</span><span class="p">,</span>
				   <span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">max_host_qng</span><span class="p">,</span>
				   <span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">termination</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">termination_lvd</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">termination_lvd</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">termstr</span> <span class="o">=</span> <span class="s">&quot;Low Off/High Off&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">termstr</span> <span class="o">=</span> <span class="s">&quot;Low Off/High On&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">termstr</span> <span class="o">=</span> <span class="s">&quot;Low On/High On&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">termstr</span> <span class="o">=</span> <span class="s">&quot;Automatic&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
				   <span class="s">&quot; termination: %u (%s), bios_ctrl: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">termination</span><span class="p">,</span> <span class="n">termstr</span><span class="p">,</span>
				   <span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
				   <span class="s">&quot; termination: %u (%s), bios_ctrl: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">termination_lvd</span><span class="p">,</span> <span class="n">termstr</span><span class="p">,</span>
				   <span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
				   <span class="s">&quot; termination: %u (%s), bios_ctrl: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">termination_lvd</span><span class="p">,</span> <span class="n">termstr</span><span class="p">,</span>
				   <span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Target ID:           &quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %X&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Disconnects:         &quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %c&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">word</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;Y&#39;</span> <span class="o">:</span> <span class="sc">&#39;N&#39;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">tagqng_able</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">tagqng_able</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">tagqng_able</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Command Queuing:     &quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %c&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">word</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;Y&#39;</span> <span class="o">:</span> <span class="sc">&#39;N&#39;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">start_motor</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">start_motor</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">start_motor</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Start Motor:         &quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %c&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">word</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;Y&#39;</span> <span class="o">:</span> <span class="sc">&#39;N&#39;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Synchronous Transfer:&quot;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %c&quot;</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">ep_3550</span><span class="o">-&gt;</span>
					    <span class="n">sdtr_able</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">?</span>
					   <span class="sc">&#39;Y&#39;</span> <span class="o">:</span> <span class="sc">&#39;N&#39;</span><span class="p">);</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Ultra Transfer:      &quot;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %c&quot;</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">ep_3550</span><span class="o">-&gt;</span>
					    <span class="n">ultra_able</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
					   <span class="o">?</span> <span class="sc">&#39;Y&#39;</span> <span class="o">:</span> <span class="sc">&#39;N&#39;</span><span class="p">);</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">wdtr_able</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">wdtr_able</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">wdtr_able</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Wide Transfer:       &quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %c&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">word</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;Y&#39;</span> <span class="o">:</span> <span class="sc">&#39;N&#39;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span> <span class="o">||</span>
	    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C1600</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
				   <span class="s">&quot; Synchronous Transfer Speed (Mhz):</span><span class="se">\n</span><span class="s">  &quot;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">speed_str</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sdtr_speed</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">sdtr_speed1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sdtr_speed</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">sdtr_speed2</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sdtr_speed</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">sdtr_speed3</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sdtr_speed</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">sdtr_speed4</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">sdtr_speed</span> <span class="o">&amp;</span> <span class="n">ADV_MAX_TID</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="n">speed_str</span> <span class="o">=</span> <span class="s">&quot;Off&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="n">speed_str</span> <span class="o">=</span> <span class="s">&quot;  5&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
				<span class="n">speed_str</span> <span class="o">=</span> <span class="s">&quot; 10&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">3</span>:
				<span class="n">speed_str</span> <span class="o">=</span> <span class="s">&quot; 20&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">4</span>:
				<span class="n">speed_str</span> <span class="o">=</span> <span class="s">&quot; 40&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">5</span>:
				<span class="n">speed_str</span> <span class="o">=</span> <span class="s">&quot; 80&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">speed_str</span> <span class="o">=</span> <span class="s">&quot;Unk&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;%X:%s &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">speed_str</span><span class="p">);</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">  &quot;</span><span class="p">);</span>
				<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">sdtr_speed</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">totlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_driver_conf()</span>
<span class="cm"> *</span>
<span class="cm"> * Note: no single line should be greater than ASC_PRTLINE_SIZE,</span>
<span class="cm"> * cf. asc_prt_line().</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of characters copied into &#39;cp&#39;. No more than</span>
<span class="cm"> * &#39;cplen&#39; characters will be copied to &#39;cp&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asc_prt_driver_conf</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cplen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">leftlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">totlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chip_scsi_id</span><span class="p">;</span>

	<span class="n">leftlen</span> <span class="o">=</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="n">totlen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot;</span><span class="se">\n</span><span class="s">Linux Driver Configuration and Information for AdvanSys SCSI Host %d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot; host_busy %u, last_reset %u, max_id %u, max_lun %u, max_channel %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_busy</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">last_reset</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_id</span><span class="p">,</span>
			   <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_lun</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_channel</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot; unique_id %d, can_queue %d, this_id %d, sg_tablesize %u, cmd_per_lun %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">shost</span><span class="o">-&gt;</span><span class="n">unique_id</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">can_queue</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">this_id</span><span class="p">,</span>
			   <span class="n">shost</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot; unchecked_isa_dma %d, use_clustering %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">shost</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">use_clustering</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot; flags 0x%x, last_reset 0x%x, jiffies 0x%x, asc_n_io_port 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">last_reset</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">,</span>
			   <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">asc_n_io_port</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; io_port 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">io_port</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">chip_scsi_id</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_cfg</span><span class="p">.</span><span class="n">asc_dvc_cfg</span><span class="p">.</span><span class="n">chip_scsi_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">chip_scsi_id</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">.</span><span class="n">chip_scsi_id</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">totlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_asc_board_info()</span>
<span class="cm"> *</span>
<span class="cm"> * Print dynamic board configuration information.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: no single line should be greater than ASC_PRTLINE_SIZE,</span>
<span class="cm"> * cf. asc_prt_line().</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of characters copied into &#39;cp&#39;. No more than</span>
<span class="cm"> * &#39;cplen&#39; characters will be copied to &#39;cp&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asc_prt_asc_board_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cplen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">chip_scsi_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leftlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">totlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
	<span class="n">ASC_DVC_CFG</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">renegotiate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">;</span>
	<span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_cfg</span><span class="p">.</span><span class="n">asc_dvc_cfg</span><span class="p">;</span>
	<span class="n">chip_scsi_id</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">;</span>

	<span class="n">leftlen</span> <span class="o">=</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="n">totlen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot;</span><span class="se">\n</span><span class="s">Asc Library Configuration and Statistics for AdvanSys SCSI Host %d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; chip_version %u, mcode_date 0x%x, &quot;</span>
			   <span class="s">&quot;mcode_version 0x%x, err_code %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">c</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mcode_date</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mcode_version</span><span class="p">,</span>
			   <span class="n">v</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="cm">/* Current number of commands waiting for the host. */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot; Total Command Pending: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">cur_total_qng</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Command Queuing:&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chip_scsi_id</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %X:%c&quot;</span><span class="p">,</span>
				   <span class="n">i</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span>
				    <span class="n">use_tagged_qng</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">?</span>
				   <span class="sc">&#39;Y&#39;</span> <span class="o">:</span> <span class="sc">&#39;N&#39;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="cm">/* Current number of commands waiting for a device. */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Command Queue Pending:&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chip_scsi_id</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %X:%u&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">cur_dvc_qng</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="cm">/* Current limit on number of commands that can be sent to a device. */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Command Queue Limit:&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chip_scsi_id</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %X:%u&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="cm">/* Indicate whether the device has returned queue full status. */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Command Queue Full:&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chip_scsi_id</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">queue_full</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %X:Y-%d&quot;</span><span class="p">,</span>
					   <span class="n">i</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">queue_full_cnt</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %X:N&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Synchronous Transfer:&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chip_scsi_id</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %X:%c&quot;</span><span class="p">,</span>
				   <span class="n">i</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span>
				    <span class="n">sdtr_done</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;Y&#39;</span> <span class="o">:</span>
				   <span class="sc">&#39;N&#39;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uchar</span> <span class="n">syn_period_ix</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">chip_scsi_id</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;  %X:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">sdtr_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">ASC_SYN_MAX_OFFSET</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Asynchronous&quot;</span><span class="p">);</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">syn_period_ix</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">sdtr_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">max_sdtr_index</span> <span class="o">-</span>
							   <span class="mi">1</span><span class="p">);</span>

			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
					   <span class="s">&quot; Transfer Period Factor: %d (%d.%d Mhz),&quot;</span><span class="p">,</span>
					   <span class="n">v</span><span class="o">-&gt;</span><span class="n">sdtr_period_tbl</span><span class="p">[</span><span class="n">syn_period_ix</span><span class="p">],</span>
					   <span class="mi">250</span> <span class="o">/</span>
					   <span class="n">v</span><span class="o">-&gt;</span><span class="n">sdtr_period_tbl</span><span class="p">[</span><span class="n">syn_period_ix</span><span class="p">],</span>
					   <span class="n">ASC_TENTHS</span><span class="p">(</span><span class="mi">250</span><span class="p">,</span>
						      <span class="n">v</span><span class="o">-&gt;</span>
						      <span class="n">sdtr_period_tbl</span>
						      <span class="p">[</span><span class="n">syn_period_ix</span><span class="p">]));</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; REQ/ACK Offset: %d&quot;</span><span class="p">,</span>
					   <span class="n">boardp</span><span class="o">-&gt;</span>
					   <span class="n">sdtr_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">ASC_SYN_MAX_OFFSET</span><span class="p">);</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">sdtr_done</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;*</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">renegotiate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">renegotiate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
				   <span class="s">&quot; * = Re-negotiation pending before next command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">totlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_prt_adv_board_info()</span>
<span class="cm"> *</span>
<span class="cm"> * Print dynamic board configuration information.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: no single line should be greater than ASC_PRTLINE_SIZE,</span>
<span class="cm"> * cf. asc_prt_line().</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of characters copied into &#39;cp&#39;. No more than</span>
<span class="cm"> * &#39;cplen&#39; characters will be copied to &#39;cp&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asc_prt_adv_board_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cplen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">leftlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">totlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
	<span class="n">ADV_DVC_CFG</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">chip_scsi_id</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">lramword</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">lrambyte</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">tagqng_able</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">sdtr_able</span><span class="p">,</span> <span class="n">wdtr_able</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">wdtr_done</span><span class="p">,</span> <span class="n">sdtr_done</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">period</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">renegotiate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">;</span>
	<span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_cfg</span><span class="p">.</span><span class="n">adv_dvc_cfg</span><span class="p">;</span>
	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">chip_scsi_id</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">;</span>

	<span class="n">leftlen</span> <span class="o">=</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="n">totlen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot;</span><span class="se">\n</span><span class="s">Adv Library Configuration and Statistics for AdvanSys SCSI Host %d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot; iop_base 0x%lx, cable_detect: %X, err_code %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">v</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span>
			   <span class="n">AdvReadWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					       <span class="n">IOPW_SCSI_CFG1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CABLE_DETECT</span><span class="p">,</span>
			   <span class="n">v</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; chip_version %u, mcode_date 0x%x, &quot;</span>
			   <span class="s">&quot;mcode_version 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">,</span>
			   <span class="n">c</span><span class="o">-&gt;</span><span class="n">mcode_date</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mcode_version</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_TAGQNG_ABLE</span><span class="p">,</span> <span class="n">tagqng_able</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Queuing Enabled:&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chip_scsi_id</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %X:%c&quot;</span><span class="p">,</span>
				   <span class="n">i</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">tagqng_able</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;Y&#39;</span> <span class="o">:</span>
				   <span class="sc">&#39;N&#39;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Queue Limit:&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chip_scsi_id</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">AdvReadByteLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_NUMBER_OF_MAX_CMD</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">lrambyte</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %X:%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">lrambyte</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Command Pending:&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chip_scsi_id</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">AdvReadByteLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_NUMBER_OF_QUEUED_CMD</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">lrambyte</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %X:%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">lrambyte</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_ABLE</span><span class="p">,</span> <span class="n">wdtr_able</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Wide Enabled:&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chip_scsi_id</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %X:%c&quot;</span><span class="p">,</span>
				   <span class="n">i</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">wdtr_able</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;Y&#39;</span> <span class="o">:</span>
				   <span class="sc">&#39;N&#39;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_DONE</span><span class="p">,</span> <span class="n">wdtr_done</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Transfer Bit Width:&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chip_scsi_id</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				<span class="n">ASC_MC_DEVICE_HSHK_CFG_TABLE</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span>
				<span class="n">lramword</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %X:%d&quot;</span><span class="p">,</span>
				   <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">lramword</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">wdtr_able</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">wdtr_done</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;*&quot;</span><span class="p">);</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
			<span class="n">renegotiate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_ABLE</span><span class="p">,</span> <span class="n">sdtr_able</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Synchronous Enabled:&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chip_scsi_id</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; %X:%c&quot;</span><span class="p">,</span>
				   <span class="n">i</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">sdtr_able</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;Y&#39;</span> <span class="o">:</span>
				   <span class="sc">&#39;N&#39;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_DONE</span><span class="p">,</span> <span class="n">sdtr_done</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				<span class="n">ASC_MC_DEVICE_HSHK_CFG_TABLE</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span>
				<span class="n">lramword</span><span class="p">);</span>
		<span class="n">lramword</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x8000</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">chip_scsi_id</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">sdtr_able</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;  %X:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">lramword</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Check for REQ/ACK Offset 0. */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; Asynchronous&quot;</span><span class="p">);</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span>
			    <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
					 <span class="s">&quot; Transfer Period Factor: &quot;</span><span class="p">);</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">lramword</span> <span class="o">&amp;</span> <span class="mh">0x1F00</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x1100</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* 80 Mhz */</span>
				<span class="n">len</span> <span class="o">=</span>
				    <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;9 (80.0 Mhz),&quot;</span><span class="p">);</span>
				<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">lramword</span> <span class="o">&amp;</span> <span class="mh">0x1F00</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* 40 Mhz */</span>
				<span class="n">len</span> <span class="o">=</span>
				    <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;10 (40.0 Mhz),&quot;</span><span class="p">);</span>
				<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* 20 Mhz or below. */</span>

				<span class="n">period</span> <span class="o">=</span> <span class="p">(((</span><span class="n">lramword</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">25</span><span class="p">)</span> <span class="o">+</span> <span class="mi">50</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Should never happen. */</span>
					<span class="n">len</span> <span class="o">=</span>
					    <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
							 <span class="s">&quot;%d (? Mhz), &quot;</span><span class="p">);</span>
					<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
							   <span class="s">&quot;%d (%d.%d Mhz),&quot;</span><span class="p">,</span>
							   <span class="n">period</span><span class="p">,</span> <span class="mi">250</span> <span class="o">/</span> <span class="n">period</span><span class="p">,</span>
							   <span class="n">ASC_TENTHS</span><span class="p">(</span><span class="mi">250</span><span class="p">,</span>
								      <span class="n">period</span><span class="p">));</span>
					<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; REQ/ACK Offset: %d&quot;</span><span class="p">,</span>
					   <span class="n">lramword</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">);</span>
			<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">sdtr_done</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;*</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">renegotiate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">renegotiate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
				   <span class="s">&quot; * = Re-negotiation pending before next command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">totlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_proc_copy()</span>
<span class="cm"> *</span>
<span class="cm"> * Copy proc information to a read buffer taking into account the current</span>
<span class="cm"> * read offset in the file and the remaining space in the read buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">asc_proc_copy</span><span class="p">(</span><span class="kt">off_t</span> <span class="n">advoffset</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">curbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">leftlen</span><span class="p">,</span>
	      <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cplen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;offset %d, advoffset %d, cplen %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">offset</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">advoffset</span><span class="p">,</span> <span class="n">cplen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">advoffset</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read offset below current offset, copy everything. */</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">cplen</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">);</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;curbuf 0x%lx, cp 0x%lx, cnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">curbuf</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">cp</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">curbuf</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">advoffset</span> <span class="o">+</span> <span class="n">cplen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read offset within current range, partial copy. */</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">advoffset</span> <span class="o">+</span> <span class="n">cplen</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="p">(</span><span class="n">cp</span> <span class="o">+</span> <span class="n">cplen</span><span class="p">)</span> <span class="o">-</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">);</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;curbuf 0x%lx, cp 0x%lx, cnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">curbuf</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">cp</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">curbuf</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef ADVANSYS_STATS</span>
<span class="cm">/*</span>
<span class="cm"> * asc_prt_board_stats()</span>
<span class="cm"> *</span>
<span class="cm"> * Note: no single line should be greater than ASC_PRTLINE_SIZE,</span>
<span class="cm"> * cf. asc_prt_line().</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of characters copied into &#39;cp&#39;. No more than</span>
<span class="cm"> * &#39;cplen&#39; characters will be copied to &#39;cp&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asc_prt_board_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cplen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">asc_stats</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">asc_stats</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">leftlen</span> <span class="o">=</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">totlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot;</span><span class="se">\n</span><span class="s">Linux Driver Statistics for AdvanSys SCSI Host %d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot; queuecommand %lu, reset %lu, biosparam %lu, interrupt %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">s</span><span class="o">-&gt;</span><span class="n">queuecommand</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">biosparam</span><span class="p">,</span>
			   <span class="n">s</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot; callback %lu, done %lu, build_error %lu, build_noreq %lu, build_nosg %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">s</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">build_error</span><span class="p">,</span>
			   <span class="n">s</span><span class="o">-&gt;</span><span class="n">adv_build_noreq</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">adv_build_nosg</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span>
			   <span class="s">&quot; exe_noerror %lu, exe_busy %lu, exe_error %lu, exe_unknown %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">s</span><span class="o">-&gt;</span><span class="n">exe_noerror</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">exe_busy</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">exe_error</span><span class="p">,</span>
			   <span class="n">s</span><span class="o">-&gt;</span><span class="n">exe_unknown</span><span class="p">);</span>
	<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Display data transfer statistics.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; xfer_cnt %lu, xfer_elem %lu, &quot;</span><span class="p">,</span>
				   <span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_cnt</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_elem</span><span class="p">);</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;xfer_bytes %lu.%01lu kb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_sect</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ASC_TENTHS</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_sect</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

		<span class="cm">/* Scatter gather transfer statistics */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot; avg_num_elem %lu.%01lu, &quot;</span><span class="p">,</span>
				   <span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_elem</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_cnt</span><span class="p">,</span>
				   <span class="n">ASC_TENTHS</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_elem</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_cnt</span><span class="p">));</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;avg_elem_size %lu.%01lu kb, &quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_sect</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_elem</span><span class="p">,</span>
				   <span class="n">ASC_TENTHS</span><span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_sect</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_elem</span><span class="p">));</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">asc_prt_line</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="s">&quot;avg_xfer_size %lu.%01lu kb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_sect</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_cnt</span><span class="p">,</span>
				   <span class="n">ASC_TENTHS</span><span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_sect</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">xfer_cnt</span><span class="p">));</span>
		<span class="n">ASC_PRT_NEXT</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">totlen</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* ADVANSYS_STATS */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * advansys_proc_info() - /proc/scsi/advansys/{0,1,2,3,...}</span>
<span class="cm"> *</span>
<span class="cm"> * *buffer: I/O buffer</span>
<span class="cm"> * **start: if inout == FALSE pointer into buffer where user read should start</span>
<span class="cm"> * offset: current offset into a /proc/scsi/advansys/[0...] file</span>
<span class="cm"> * length: length of buffer</span>
<span class="cm"> * hostno: Scsi_Host host_no</span>
<span class="cm"> * inout: TRUE - user is writing; FALSE - user is reading</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of bytes read from or written to a</span>
<span class="cm"> * /proc/scsi/advansys/[0...] file.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: This function uses the per board buffer &#39;prtbuf&#39; which is</span>
<span class="cm"> * allocated when the board is initialized in advansys_detect(). The</span>
<span class="cm"> * buffer is ASC_PRTBUF_SIZE bytes. The function asc_proc_copy() is</span>
<span class="cm"> * used to write to the buffer. The way asc_proc_copy() is written</span>
<span class="cm"> * if &#39;prtbuf&#39; is too small it will not be overwritten. Instead the</span>
<span class="cm"> * user just won&#39;t get all the available statistics.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">advansys_proc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span>
		   <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">totcnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leftlen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">curbuf</span><span class="p">;</span>
	<span class="kt">off_t</span> <span class="n">advoffset</span><span class="p">;</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;begin</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * User write not supported.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inout</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * User read of /proc/scsi/advansys/[0...] file.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Copy read data starting at the beginning of the buffer. */</span>
	<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="n">curbuf</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="n">advoffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">totcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">leftlen</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get board configuration information.</span>
<span class="cm">	 *</span>
<span class="cm">	 * advansys_info() returns the board string from its own static buffer.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">advansys_info</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">strcat</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">cplen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="cm">/* Copy board information. */</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="n">asc_proc_copy</span><span class="p">(</span><span class="n">advoffset</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">curbuf</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cplen</span><span class="p">);</span>
	<span class="n">totcnt</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">leftlen</span> <span class="o">-=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leftlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;totcnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">totcnt</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">totcnt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">advoffset</span> <span class="o">+=</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="n">curbuf</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Display Wide Board BIOS Information.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">prtbuf</span><span class="p">;</span>
		<span class="n">cplen</span> <span class="o">=</span> <span class="n">asc_prt_adv_bios</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cplen</span> <span class="o">&gt;=</span> <span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">asc_proc_copy</span><span class="p">(</span><span class="n">advoffset</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">curbuf</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span>
				  <span class="n">cplen</span><span class="p">);</span>
		<span class="n">totcnt</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="n">leftlen</span> <span class="o">-=</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">leftlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;totcnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">totcnt</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">totcnt</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">advoffset</span> <span class="o">+=</span> <span class="n">cplen</span><span class="p">;</span>
		<span class="n">curbuf</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Display driver information for each device attached to the board.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">prtbuf</span><span class="p">;</span>
	<span class="n">cplen</span> <span class="o">=</span> <span class="n">asc_prt_board_devices</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cplen</span> <span class="o">&gt;=</span> <span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="n">asc_proc_copy</span><span class="p">(</span><span class="n">advoffset</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">curbuf</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cplen</span><span class="p">);</span>
	<span class="n">totcnt</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">leftlen</span> <span class="o">-=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leftlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;totcnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">totcnt</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">totcnt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">advoffset</span> <span class="o">+=</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="n">curbuf</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Display EEPROM configuration for the board.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">prtbuf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cplen</span> <span class="o">=</span> <span class="n">asc_prt_asc_board_eeprom</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cplen</span> <span class="o">=</span> <span class="n">asc_prt_adv_board_eeprom</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cplen</span> <span class="o">&gt;=</span> <span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="n">asc_proc_copy</span><span class="p">(</span><span class="n">advoffset</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">curbuf</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cplen</span><span class="p">);</span>
	<span class="n">totcnt</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">leftlen</span> <span class="o">-=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leftlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;totcnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">totcnt</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">totcnt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">advoffset</span> <span class="o">+=</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="n">curbuf</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Display driver configuration and information for the board.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">prtbuf</span><span class="p">;</span>
	<span class="n">cplen</span> <span class="o">=</span> <span class="n">asc_prt_driver_conf</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cplen</span> <span class="o">&gt;=</span> <span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="n">asc_proc_copy</span><span class="p">(</span><span class="n">advoffset</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">curbuf</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cplen</span><span class="p">);</span>
	<span class="n">totcnt</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">leftlen</span> <span class="o">-=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leftlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;totcnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">totcnt</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">totcnt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">advoffset</span> <span class="o">+=</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="n">curbuf</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

<span class="cp">#ifdef ADVANSYS_STATS</span>
	<span class="cm">/*</span>
<span class="cm">	 * Display driver statistics for the board.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">prtbuf</span><span class="p">;</span>
	<span class="n">cplen</span> <span class="o">=</span> <span class="n">asc_prt_board_stats</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cplen</span> <span class="o">&gt;=</span> <span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="n">asc_proc_copy</span><span class="p">(</span><span class="n">advoffset</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">curbuf</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cplen</span><span class="p">);</span>
	<span class="n">totcnt</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">leftlen</span> <span class="o">-=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leftlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;totcnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">totcnt</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">totcnt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">advoffset</span> <span class="o">+=</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="n">curbuf</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* ADVANSYS_STATS */</span><span class="cp"></span>

	<span class="cm">/*</span>
<span class="cm">	 * Display Asc Library dynamic configuration information</span>
<span class="cm">	 * for the board.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">prtbuf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cplen</span> <span class="o">=</span> <span class="n">asc_prt_asc_board_info</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cplen</span> <span class="o">=</span> <span class="n">asc_prt_adv_board_info</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cplen</span> <span class="o">&gt;=</span> <span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="n">asc_proc_copy</span><span class="p">(</span><span class="n">advoffset</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">curbuf</span><span class="p">,</span> <span class="n">leftlen</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cplen</span><span class="p">);</span>
	<span class="n">totcnt</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">leftlen</span> <span class="o">-=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leftlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;totcnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">totcnt</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">totcnt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">advoffset</span> <span class="o">+=</span> <span class="n">cplen</span><span class="p">;</span>
	<span class="n">curbuf</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;totcnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">totcnt</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">totcnt</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asc_scsi_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">done</span><span class="p">);</span>
	<span class="n">scp</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">AscSetBank</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">bank</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uchar</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">AscGetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">&amp;</span>
	    <span class="p">(</span><span class="o">~</span>
	     <span class="p">(</span><span class="n">CC_SINGLE_STEP</span> <span class="o">|</span> <span class="n">CC_TEST</span> <span class="o">|</span> <span class="n">CC_DIAG</span> <span class="o">|</span> <span class="n">CC_SCSI_RESET</span> <span class="o">|</span>
	      <span class="n">CC_CHIP_RESET</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bank</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CC_BANK_ONE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bank</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CC_DIAG</span> <span class="o">|</span> <span class="n">CC_BANK_ONE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CC_BANK_ONE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">AscSetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">AscSetChipIH</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">ins_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AscSetBank</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">AscWriteChipIH</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ins_code</span><span class="p">);</span>
	<span class="n">AscSetBank</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscStartChip</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AscSetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">AscGetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CSW_HALTED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscStopChip</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uchar</span> <span class="n">cc_val</span><span class="p">;</span>

	<span class="n">cc_val</span> <span class="o">=</span>
	    <span class="n">AscGetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">&amp;</span>
	    <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">CC_SINGLE_STEP</span> <span class="o">|</span> <span class="n">CC_TEST</span> <span class="o">|</span> <span class="n">CC_DIAG</span><span class="p">));</span>
	<span class="n">AscSetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">cc_val</span> <span class="o">|</span> <span class="n">CC_HALT</span><span class="p">));</span>
	<span class="n">AscSetChipIH</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">INS_HALT</span><span class="p">);</span>
	<span class="n">AscSetChipIH</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">INS_RFLAG_WTM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">AscGetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CSW_HALTED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscIsChipHalted</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">AscGetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CSW_HALTED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">AscGetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CC_HALT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscResetChipAndScsiBus</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">AscGetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CSW_SCSI_RESET_ACTIVE</span><span class="p">)</span>
	       <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">AscStopChip</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">AscSetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">CC_CHIP_RESET</span> <span class="o">|</span> <span class="n">CC_SCSI_RESET</span> <span class="o">|</span> <span class="n">CC_HALT</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">60</span><span class="p">);</span>
	<span class="n">AscSetChipIH</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">INS_RFLAG_WTM</span><span class="p">);</span>
	<span class="n">AscSetChipIH</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">INS_HALT</span><span class="p">);</span>
	<span class="n">AscSetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">CC_CHIP_RESET</span> <span class="o">|</span> <span class="n">CC_HALT</span><span class="p">);</span>
	<span class="n">AscSetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">CC_HALT</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
	<span class="n">AscSetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">CIW_CLR_SCSI_RESET_INT</span><span class="p">);</span>
	<span class="n">AscSetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">AscIsChipHalted</span><span class="p">(</span><span class="n">iop_base</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscFindSignature</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">sig_word</span><span class="p">;</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;AscGetChipSignatureByte(0x%x) 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">iop_base</span><span class="p">,</span> <span class="n">AscGetChipSignatureByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AscGetChipSignatureByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">ASC_1000_ID1B</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;AscGetChipSignatureWord(0x%x) 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">iop_base</span><span class="p">,</span> <span class="n">AscGetChipSignatureWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">));</span>
		<span class="n">sig_word</span> <span class="o">=</span> <span class="n">AscGetChipSignatureWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sig_word</span> <span class="o">==</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_1000_ID0W</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">sig_word</span> <span class="o">==</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_1000_ID0W_FIX</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">AscEnableInterrupt</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">cfg</span><span class="p">;</span>

	<span class="n">cfg</span> <span class="o">=</span> <span class="n">AscGetChipCfgLsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">AscSetChipCfgLsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">cfg</span> <span class="o">|</span> <span class="n">ASC_CFG0_HOST_INT_ON</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">AscDisableInterrupt</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">cfg</span><span class="p">;</span>

	<span class="n">cfg</span> <span class="o">=</span> <span class="n">AscGetChipCfgLsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">AscSetChipCfgLsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">cfg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">ASC_CFG0_HOST_INT_ON</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">uchar</span> <span class="nf">AscReadLramByte</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">byte_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">word_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isodd_word</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">AscSetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">addr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">word_data</span> <span class="o">=</span> <span class="n">AscGetChipLramData</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
		<span class="n">byte_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">word_data</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">AscSetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">word_data</span> <span class="o">=</span> <span class="n">AscGetChipLramData</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
		<span class="n">byte_data</span> <span class="o">=</span> <span class="n">word_data</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">byte_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ushort</span> <span class="nf">AscReadLramWord</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">word_data</span><span class="p">;</span>

	<span class="n">AscSetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">word_data</span> <span class="o">=</span> <span class="n">AscGetChipLramData</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">word_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if CC_VERY_LONG_SG_LIST</span>
<span class="k">static</span> <span class="n">ASC_DCNT</span> <span class="nf">AscReadLramDWord</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">val_low</span><span class="p">,</span> <span class="n">val_high</span><span class="p">;</span>
	<span class="n">ASC_DCNT</span> <span class="n">dword_data</span><span class="p">;</span>

	<span class="n">AscSetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">val_low</span> <span class="o">=</span> <span class="n">AscGetChipLramData</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">val_high</span> <span class="o">=</span> <span class="n">AscGetChipLramData</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">dword_data</span> <span class="o">=</span> <span class="p">((</span><span class="n">ASC_DCNT</span><span class="p">)</span> <span class="n">val_high</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ASC_DCNT</span><span class="p">)</span> <span class="n">val_low</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dword_data</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CC_VERY_LONG_SG_LIST */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">AscMemWordSetLram</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">s_addr</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">set_wval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">words</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">AscSetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">s_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscSetChipLramData</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">set_wval</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">AscWriteLramWord</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">word_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AscSetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">AscSetChipLramData</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">word_val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">AscWriteLramByte</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">addr</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">byte_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">word_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isodd_word</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">addr</span><span class="o">--</span><span class="p">;</span>
		<span class="n">word_data</span> <span class="o">=</span> <span class="n">AscReadLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">word_data</span> <span class="o">&amp;=</span> <span class="mh">0x00FF</span><span class="p">;</span>
		<span class="n">word_data</span> <span class="o">|=</span> <span class="p">(((</span><span class="n">ushort</span><span class="p">)</span><span class="n">byte_val</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF00</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">word_data</span> <span class="o">=</span> <span class="n">AscReadLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">word_data</span> <span class="o">&amp;=</span> <span class="mh">0xFF00</span><span class="p">;</span>
		<span class="n">word_data</span> <span class="o">|=</span> <span class="p">((</span><span class="n">ushort</span><span class="p">)</span><span class="n">byte_val</span> <span class="o">&amp;</span> <span class="mh">0x00FF</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">word_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy 2 bytes to LRAM.</span>
<span class="cm"> *</span>
<span class="cm"> * The source data is assumed to be in little-endian order in memory</span>
<span class="cm"> * and is maintained in little-endian order when written to LRAM.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">AscMemWordCopyPtrToLram</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">s_addr</span><span class="p">,</span>
			<span class="k">const</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">s_buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">words</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">AscSetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">s_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * On a little-endian system the second argument below</span>
<span class="cm">		 * produces a little-endian ushort which is written to</span>
<span class="cm">		 * LRAM in little-endian order. On a big-endian system</span>
<span class="cm">		 * the second argument produces a big-endian ushort which</span>
<span class="cm">		 * is &quot;transparently&quot; byte-swapped by outpw() and written</span>
<span class="cm">		 * in little-endian order to LRAM.</span>
<span class="cm">		 */</span>
		<span class="n">outpw</span><span class="p">(</span><span class="n">iop_base</span> <span class="o">+</span> <span class="n">IOP_RAM_DATA</span><span class="p">,</span>
		      <span class="p">((</span><span class="n">ushort</span><span class="p">)</span><span class="n">s_buffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">s_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy 4 bytes to LRAM.</span>
<span class="cm"> *</span>
<span class="cm"> * The source data is assumed to be in little-endian order in memory</span>
<span class="cm"> * and is maintained in little-endian order when written to LRAM.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">AscMemDWordCopyPtrToLram</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span>
			 <span class="n">ushort</span> <span class="n">s_addr</span><span class="p">,</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">s_buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dwords</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">AscSetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">s_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">dwords</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outpw</span><span class="p">(</span><span class="n">iop_base</span> <span class="o">+</span> <span class="n">IOP_RAM_DATA</span><span class="p">,</span> <span class="p">((</span><span class="n">ushort</span><span class="p">)</span><span class="n">s_buffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">s_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>	<span class="cm">/* LSW */</span>
		<span class="n">outpw</span><span class="p">(</span><span class="n">iop_base</span> <span class="o">+</span> <span class="n">IOP_RAM_DATA</span><span class="p">,</span> <span class="p">((</span><span class="n">ushort</span><span class="p">)</span><span class="n">s_buffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">s_buffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]);</span>	<span class="cm">/* MSW */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy 2 bytes from LRAM.</span>
<span class="cm"> *</span>
<span class="cm"> * The source data is assumed to be in little-endian order in LRAM</span>
<span class="cm"> * and is maintained in little-endian order when written to memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">AscMemWordCopyPtrFromLram</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span>
			  <span class="n">ushort</span> <span class="n">s_addr</span><span class="p">,</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">d_buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">words</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">word</span><span class="p">;</span>

	<span class="n">AscSetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">s_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">inpw</span><span class="p">(</span><span class="n">iop_base</span> <span class="o">+</span> <span class="n">IOP_RAM_DATA</span><span class="p">);</span>
		<span class="n">d_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">word</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">d_buffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">word</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ASC_DCNT</span> <span class="nf">AscMemSumLramWord</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">s_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">words</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASC_DCNT</span> <span class="n">sum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sum</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">s_addr</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">AscReadLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">s_addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sum</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ushort</span> <span class="nf">AscInitLram</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uchar</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">s_addr</span><span class="p">;</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">warn_code</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">warn_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">AscMemWordSetLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_QADR_BEG</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">ushort</span><span class="p">)(((</span><span class="kt">int</span><span class="p">)(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
				    <span class="mi">64</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">ASC_MIN_ACTIVE_QNO</span><span class="p">;</span>
	<span class="n">s_addr</span> <span class="o">=</span> <span class="n">ASC_QADR_BEG</span> <span class="o">+</span> <span class="n">ASC_QBLK_SIZE</span><span class="p">;</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">s_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_B_FWD</span><span class="p">),</span>
			 <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">s_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_B_BWD</span><span class="p">),</span>
			 <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span><span class="p">));</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">s_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_B_QNO</span><span class="p">),</span>
			 <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">i</span><span class="p">);</span>
	<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="n">s_addr</span> <span class="o">+=</span> <span class="n">ASC_QBLK_SIZE</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">s_addr</span> <span class="o">+=</span> <span class="n">ASC_QBLK_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">s_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_B_FWD</span><span class="p">),</span>
				 <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">s_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_B_BWD</span><span class="p">),</span>
				 <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">s_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_B_QNO</span><span class="p">),</span>
				 <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">s_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_B_FWD</span><span class="p">),</span>
			 <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">ASC_QLINK_END</span><span class="p">);</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">s_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_B_BWD</span><span class="p">),</span>
			 <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">s_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_B_QNO</span><span class="p">),</span>
			 <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span><span class="p">);</span>
	<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="n">s_addr</span> <span class="o">+=</span> <span class="n">ASC_QBLK_SIZE</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
	     <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">s_addr</span> <span class="o">+=</span> <span class="n">ASC_QBLK_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">s_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_FWD</span><span class="p">),</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">s_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_BWD</span><span class="p">),</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">s_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_QNO</span><span class="p">),</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">warn_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ASC_DCNT</span>
<span class="nf">AscLoadMicroCode</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">s_addr</span><span class="p">,</span>
		 <span class="k">const</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">mcode_buf</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">mcode_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASC_DCNT</span> <span class="n">chksum</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">mcode_word_size</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">mcode_chksum</span><span class="p">;</span>

	<span class="cm">/* Write the microcode buffer starting at LRAM address 0. */</span>
	<span class="n">mcode_word_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">mcode_size</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">AscMemWordSetLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">s_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mcode_word_size</span><span class="p">);</span>
	<span class="n">AscMemWordCopyPtrToLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">s_addr</span><span class="p">,</span> <span class="n">mcode_buf</span><span class="p">,</span> <span class="n">mcode_word_size</span><span class="p">);</span>

	<span class="n">chksum</span> <span class="o">=</span> <span class="n">AscMemSumLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">s_addr</span><span class="p">,</span> <span class="n">mcode_word_size</span><span class="p">);</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;chksum 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">chksum</span><span class="p">);</span>
	<span class="n">mcode_chksum</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">AscMemSumLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						 <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_CODE_SEC_BEG</span><span class="p">,</span>
						 <span class="p">(</span><span class="n">ushort</span><span class="p">)((</span><span class="n">mcode_size</span> <span class="o">-</span>
							   <span class="n">s_addr</span> <span class="o">-</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span>
							   <span class="n">ASC_CODE_SEC_BEG</span><span class="p">)</span> <span class="o">/</span>
							  <span class="mi">2</span><span class="p">));</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;mcode_chksum 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">mcode_chksum</span><span class="p">);</span>
	<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_MCODE_CHKSUM_W</span><span class="p">,</span> <span class="n">mcode_chksum</span><span class="p">);</span>
	<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_MCODE_SIZE_W</span><span class="p">,</span> <span class="n">mcode_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">chksum</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">AscInitQLinkVar</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">lram_addr</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">AscPutRiscVarFreeQHead</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">AscPutRiscVarDoneQTail</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span><span class="p">);</span>
	<span class="n">AscPutVarFreeQHead</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">AscPutVarDoneQTail</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span><span class="p">);</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_BUSY_QHEAD_B</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">uchar</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_DISC1_QHEAD_B</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">uchar</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASCV_TOTAL_READY_Q_B</span><span class="p">,</span>
			 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span><span class="p">);</span>
	<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_ASCDVC_ERR_CODE_W</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HALTCODE_W</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_STOP_CODE_B</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_SCSIBUSY_B</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_WTM_FLAG_B</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">AscPutQDoneInProgress</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">lram_addr</span> <span class="o">=</span> <span class="n">ASC_QADR_BEG</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">lram_addr</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">lram_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ushort</span> <span class="nf">AscInitMicroCodeVar</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">warn_code</span><span class="p">;</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ASC_PADDR</span> <span class="n">phy_addr</span><span class="p">;</span>
	<span class="n">ASC_DCNT</span> <span class="n">phy_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">board</span> <span class="o">=</span> <span class="n">asc_dvc_to_board</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">warn_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscPutMCodeInitSDTRAtID</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">sdtr_period_offset</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">AscInitQLinkVar</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_DISC_ENABLE_B</span><span class="p">,</span>
			 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">);</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HOSTSCSI_ID_B</span><span class="p">,</span>
			 <span class="n">ASC_TID_TO_TARGET_ID</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">));</span>

	<span class="cm">/* Ensure overrun buffer is aligned on an 8 byte boundary. */</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">overrun_buf</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">overrun_dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">overrun_buf</span><span class="p">,</span>
					<span class="n">ASC_OVERRUN_BSIZE</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">overrun_dma</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">warn_code</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_dma_map</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phy_addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">overrun_dma</span><span class="p">);</span>
	<span class="n">AscMemDWordCopyPtrToLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_OVERRUN_PADDR_D</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">phy_addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">phy_size</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ASC_OVERRUN_BSIZE</span><span class="p">);</span>
	<span class="n">AscMemDWordCopyPtrToLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_OVERRUN_BSIZE_D</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">phy_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">mcode_date</span> <span class="o">=</span>
	    <span class="n">AscReadLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASCV_MC_DATE_W</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">mcode_version</span> <span class="o">=</span>
	    <span class="n">AscReadLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASCV_MC_VER_W</span><span class="p">);</span>

	<span class="n">AscSetPCAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MCODE_START_ADDR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AscGetPCAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ASC_MCODE_START_ADDR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_SET_PC_ADDR</span><span class="p">;</span>
		<span class="n">warn_code</span> <span class="o">=</span> <span class="n">UW_ERR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_mcode_start</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AscStartChip</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_START_STOP_CHIP</span><span class="p">;</span>
		<span class="n">warn_code</span> <span class="o">=</span> <span class="n">UW_ERR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_mcode_start</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">warn_code</span><span class="p">;</span>

<span class="nl">err_mcode_start:</span>
	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">overrun_dma</span><span class="p">,</span>
			 <span class="n">ASC_OVERRUN_BSIZE</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
<span class="nl">err_dma_map:</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">overrun_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">warn_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ushort</span> <span class="nf">AscInitAsc1000Driver</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">fwname</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;advansys/mcode.bin&quot;</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">chksum</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">warn_code</span><span class="p">;</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">warn_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">dvc_cntl</span> <span class="o">&amp;</span> <span class="n">ASC_CNTL_RESET_SCSI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_state</span> <span class="o">&amp;</span> <span class="n">ASC_INIT_RESET_SCSI_DONE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">AscResetChipAndScsiBus</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">scsi_reset_wait</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span> <span class="cm">/* XXX: msleep? */</span>
	<span class="p">}</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_state</span> <span class="o">|=</span> <span class="n">ASC_INIT_STATE_BEG_LOAD_MC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">UW_ERR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AscFindSignature</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_BAD_SIGNATURE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">warn_code</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">AscDisableInterrupt</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">AscInitLram</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">UW_ERR</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">fwname</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">drv_ptr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to load image </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">fwname</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_MCODE_CHKSUM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Bogus length %zu in image </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">fwname</span><span class="p">);</span>
		<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_MCODE_CHKSUM</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chksum</span> <span class="o">=</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		 <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;_asc_mcode_chksum 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">chksum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AscLoadMicroCode</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
			     <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="n">chksum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_MCODE_CHKSUM</span><span class="p">;</span>
		<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">warn_code</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
	<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">AscInitMicroCodeVar</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">overrun_dma</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">warn_code</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_state</span> <span class="o">|=</span> <span class="n">ASC_INIT_STATE_END_LOAD_MC</span><span class="p">;</span>
	<span class="n">AscEnableInterrupt</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">warn_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Load the Microcode</span>
<span class="cm"> *</span>
<span class="cm"> * Write the microcode image to RISC memory starting at address 0.</span>
<span class="cm"> *</span>
<span class="cm"> * The microcode is stored compressed in the following format:</span>
<span class="cm"> *</span>
<span class="cm"> *  254 word (508 byte) table indexed by byte code followed</span>
<span class="cm"> *  by the following byte codes:</span>
<span class="cm"> *</span>
<span class="cm"> *    1-Byte Code:</span>
<span class="cm"> *      00: Emit word 0 in table.</span>
<span class="cm"> *      01: Emit word 1 in table.</span>
<span class="cm"> *      .</span>
<span class="cm"> *      FD: Emit word 253 in table.</span>
<span class="cm"> *</span>
<span class="cm"> *    Multi-Byte Code:</span>
<span class="cm"> *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.</span>
<span class="cm"> *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 or an error if the checksum doesn&#39;t match</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">AdvLoadMicrocode</span><span class="p">(</span><span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">memsize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chksum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ADV_DCNT</span> <span class="n">sum</span><span class="p">;</span>

	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_RAM_ADDR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">253</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">AdvWriteWordAutoIncLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
				<span class="n">len</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xfe</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
			<span class="n">AdvWriteWordAutoIncLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">off</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">];</span>
			<span class="n">AdvWriteWordAutoIncLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">memsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvWriteWordAutoIncLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Verify the microcode checksum. */</span>
	<span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_RAM_ADDR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">len</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">AdvReadWordAutoIncLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">!=</span> <span class="n">chksum</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ASC_IERR_MCODE_CHKSUM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">AdvBuildCarrierFreelist</span><span class="p">(</span><span class="k">struct</span> <span class="n">adv_dvc_var</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="n">carrp</span><span class="p">;</span>
	<span class="n">ADV_SDCNT</span> <span class="n">buf_size</span><span class="p">;</span>
	<span class="n">ADV_PADDR</span> <span class="n">carr_paddr</span><span class="p">;</span>

	<span class="n">carrp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="p">)</span> <span class="n">ADV_16BALIGN</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carrier_buf</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carrp</span> <span class="o">==</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carrier_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf_size</span> <span class="o">=</span> <span class="n">ADV_CARRIER_BUFSIZE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">buf_size</span> <span class="o">=</span> <span class="n">ADV_CARRIER_BUFSIZE</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ADV_CARR_T</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Get physical address of the carrier &#39;carrp&#39;. */</span>
		<span class="n">carr_paddr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">virt_to_bus</span><span class="p">(</span><span class="n">carrp</span><span class="p">));</span>

		<span class="n">buf_size</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ADV_CARR_T</span><span class="p">);</span>

		<span class="n">carrp</span><span class="o">-&gt;</span><span class="n">carr_pa</span> <span class="o">=</span> <span class="n">carr_paddr</span><span class="p">;</span>
		<span class="n">carrp</span><span class="o">-&gt;</span><span class="n">carr_va</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ADV_VADDR_TO_U32</span><span class="p">(</span><span class="n">carrp</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Insert the carrier at the beginning of the freelist.</span>
<span class="cm">		 */</span>
		<span class="n">carrp</span><span class="o">-&gt;</span><span class="n">next_vpa</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ADV_VADDR_TO_U32</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span><span class="p">));</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span> <span class="o">=</span> <span class="n">carrp</span><span class="p">;</span>

		<span class="n">carrp</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">buf_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send an idle command to the chip and wait for completion.</span>
<span class="cm"> *</span>
<span class="cm"> * Command completion is polled for once per microsecond.</span>
<span class="cm"> *</span>
<span class="cm"> * The function can be called from anywhere including an interrupt handler.</span>
<span class="cm"> * But the function is not re-entrant, so it uses the DvcEnter/LeaveCritical()</span>
<span class="cm"> * functions to prevent reentrancy.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Values:</span>
<span class="cm"> *   ADV_TRUE - command completed successfully</span>
<span class="cm"> *   ADV_FALSE - command failed</span>
<span class="cm"> *   ADV_ERROR - command timed out</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">AdvSendIdleCmd</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">,</span>
	       <span class="n">ushort</span> <span class="n">idle_cmd</span><span class="p">,</span> <span class="n">ADV_DCNT</span> <span class="n">idle_cmd_parameter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">ADV_DCNT</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the idle command status which is set by the microcode</span>
<span class="cm">	 * to a non-zero value to indicate when the command is completed.</span>
<span class="cm">	 * The non-zero result is one of the IDLE_CMD_STATUS_* values</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_IDLE_CMD_STATUS</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write the idle command value after the idle command parameter</span>
<span class="cm">	 * has been written to avoid a race condition. If the order is not</span>
<span class="cm">	 * followed, the microcode may process the idle command before the</span>
<span class="cm">	 * parameters have been written to LRAM.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteDWordLramNoSwap</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_IDLE_CMD_PARAMETER</span><span class="p">,</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">idle_cmd_parameter</span><span class="p">));</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_IDLE_CMD</span><span class="p">,</span> <span class="n">idle_cmd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tickle the RISC to tell it to process the idle command.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_TICKLE</span><span class="p">,</span> <span class="n">ADV_TICKLE_B</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear the tickle value. In the ASC-3550 the RISC flag</span>
<span class="cm">		 * command &#39;clr_tickle_b&#39; does not work unless the host</span>
<span class="cm">		 * value is cleared.</span>
<span class="cm">		 */</span>
		<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_TICKLE</span><span class="p">,</span> <span class="n">ADV_TICKLE_NOP</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Wait for up to 100 millisecond for the idle command to timeout. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCSI_WAIT_100_MSEC</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Poll once each microsecond for command completion. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">SCSI_US_PER_MSEC</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_IDLE_CMD_STATUS</span><span class="p">,</span>
					<span class="n">result</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">BUG</span><span class="p">();</span>		<span class="cm">/* The idle command should never timeout. */</span>
	<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reset SCSI Bus and purge all outstanding requests.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *      ADV_TRUE(1) -   All requests are purged and SCSI Bus is reset.</span>
<span class="cm"> *      ADV_FALSE(0) -  Microcode command failed.</span>
<span class="cm"> *      ADV_ERROR(-1) - Microcode command timed-out. Microcode or IC</span>
<span class="cm"> *                      may be hung which requires driver recovery.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">AdvResetSB</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send the SCSI Bus Reset idle start idle command which asserts</span>
<span class="cm">	 * the SCSI Bus Reset signal.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">AdvSendIdleCmd</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">IDLE_CMD_SCSI_RESET_START</span><span class="p">,</span> <span class="mi">0L</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">ADV_TRUE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Delay for the specified SCSI Bus Reset hold time.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The hold time delay is done on the host because the RISC has no</span>
<span class="cm">	 * microsecond accurate timer.</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">ASC_SCSI_RESET_HOLD_TIME_US</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send the SCSI Bus Reset end idle command which de-asserts</span>
<span class="cm">	 * the SCSI Bus Reset signal and purges any pending requests.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">AdvSendIdleCmd</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">IDLE_CMD_SCSI_RESET_END</span><span class="p">,</span> <span class="mi">0L</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">ADV_TRUE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mdelay</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">scsi_reset_wait</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>	<span class="cm">/* XXX: msleep? */</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the ASC-3550.</span>
<span class="cm"> *</span>
<span class="cm"> * On failure set the ADV_DVC_VAR field &#39;err_code&#39; and return ADV_ERROR.</span>
<span class="cm"> *</span>
<span class="cm"> * For a non-fatal error return a warning code. If there are no warnings</span>
<span class="cm"> * then 0 is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Needed after initialization for error recovery.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">AdvInitAsc3550Driver</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">fwname</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;advansys/3550.bin&quot;</span><span class="p">;</span>
	<span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">warn_code</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">begin_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end_addr</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">code_sum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">word</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">chksum</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">scsi_cfg1</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">tid</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">bios_mem</span><span class="p">[</span><span class="n">ASC_MC_BIOSLEN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>	<span class="cm">/* BIOS RISC Memory 0x40-0x8F. */</span>
	<span class="n">ushort</span> <span class="n">wdtr_able</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sdtr_able</span><span class="p">,</span> <span class="n">tagqng_able</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">max_cmd</span><span class="p">[</span><span class="n">ADV_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* If there is already an error, don&#39;t continue. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The caller must set &#39;chip_type&#39; to ADV_CHIP_ASC3550.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">!=</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_BAD_CHIPTYPE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">warn_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save the RISC memory BIOS region before writing the microcode.</span>
<span class="cm">	 * The BIOS may already be loaded and using its RISC LRAM region</span>
<span class="cm">	 * so its region must be saved and restored.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: This code makes the assumption, which is currently true,</span>
<span class="cm">	 * that a chip reset does not clear RISC LRAM.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ASC_MC_BIOSLEN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_BIOSMEM</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span>
				<span class="n">bios_mem</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save current per TID negotiated values.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bios_mem</span><span class="p">[(</span><span class="n">ASC_MC_BIOS_SIGNATURE</span> <span class="o">-</span> <span class="n">ASC_MC_BIOSMEM</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x55AA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ushort</span> <span class="n">bios_version</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">;</span>

		<span class="n">bios_version</span> <span class="o">=</span>
		    <span class="n">bios_mem</span><span class="p">[(</span><span class="n">ASC_MC_BIOS_VERSION</span> <span class="o">-</span> <span class="n">ASC_MC_BIOSMEM</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
		<span class="n">major</span> <span class="o">=</span> <span class="p">(</span><span class="n">bios_version</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">minor</span> <span class="o">=</span> <span class="p">(</span><span class="n">bios_version</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">major</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">||</span> <span class="p">(</span><span class="n">major</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">minor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* BIOS 3.1 and earlier location of &#39;wdtr_able&#39; variable. */</span>
			<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mh">0x120</span><span class="p">,</span> <span class="n">wdtr_able</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_ABLE</span><span class="p">,</span> <span class="n">wdtr_able</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_ABLE</span><span class="p">,</span> <span class="n">sdtr_able</span><span class="p">);</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_TAGQNG_ABLE</span><span class="p">,</span> <span class="n">tagqng_able</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tid</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">tid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvReadByteLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_NUMBER_OF_MAX_CMD</span> <span class="o">+</span> <span class="n">tid</span><span class="p">,</span>
				<span class="n">max_cmd</span><span class="p">[</span><span class="n">tid</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">fwname</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">drv_ptr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to load image </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">fwname</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_MCODE_CHKSUM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Bogus length %zu in image </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">fwname</span><span class="p">);</span>
		<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_MCODE_CHKSUM</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chksum</span> <span class="o">=</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		 <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">AdvLoadMicrocode</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
					     <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="n">ADV_3550_MEMSIZE</span><span class="p">,</span>
					     <span class="n">chksum</span><span class="p">);</span>
	<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore the RISC memory BIOS region.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ASC_MC_BIOSLEN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_BIOSMEM</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span>
				 <span class="n">bios_mem</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate and write the microcode code checksum to the microcode</span>
<span class="cm">	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).</span>
<span class="cm">	 */</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CODE_BEGIN_ADDR</span><span class="p">,</span> <span class="n">begin_addr</span><span class="p">);</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CODE_END_ADDR</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">);</span>
	<span class="n">code_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_RAM_ADDR</span><span class="p">,</span> <span class="n">begin_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">word</span> <span class="o">=</span> <span class="n">begin_addr</span><span class="p">;</span> <span class="n">word</span> <span class="o">&lt;</span> <span class="n">end_addr</span><span class="p">;</span> <span class="n">word</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">code_sum</span> <span class="o">+=</span> <span class="n">AdvReadWordAutoIncLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CODE_CHK_SUM</span><span class="p">,</span> <span class="n">code_sum</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read and save microcode version and date.</span>
<span class="cm">	 */</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_VERSION_DATE</span><span class="p">,</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">mcode_date</span><span class="p">);</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_VERSION_NUM</span><span class="p">,</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">mcode_version</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the chip type to indicate the ASC3550.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CHIP_TYPE</span><span class="p">,</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the PCI Configuration Command Register &quot;Parity Error Response</span>
<span class="cm">	 * Control&quot; Bit was clear (0), then set the microcode variable</span>
<span class="cm">	 * &#39;control_flag&#39; CONTROL_FLAG_IGNORE_PERR flag to tell the microcode</span>
<span class="cm">	 * to ignore DMA parity errors.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">control_flag</span> <span class="o">&amp;</span> <span class="n">CONTROL_FLAG_IGNORE_PERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CONTROL_FLAG</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
		<span class="n">word</span> <span class="o">|=</span> <span class="n">CONTROL_FLAG_IGNORE_PERR</span><span class="p">;</span>
		<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CONTROL_FLAG</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO</span>
<span class="cm">	 * threshold of 128 bytes. This register is only accessible to the host.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_DMA_CFG0</span><span class="p">,</span>
			     <span class="n">START_CTL_EMFU</span> <span class="o">|</span> <span class="n">READ_CMD_MRM</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Microcode operating variables for WDTR, SDTR, and command tag</span>
<span class="cm">	 * queuing will be set in slave_configure() based on what a</span>
<span class="cm">	 * device reports it is capable of in Inquiry byte 7.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If SCSI Bus Resets have been disabled, then directly set</span>
<span class="cm">	 * SDTR and WDTR from the EEPROM configuration. This will allow</span>
<span class="cm">	 * the BIOS and warm boot to work without a SCSI bus hang on</span>
<span class="cm">	 * the Inquiry caused by host and target mismatched DTR values.</span>
<span class="cm">	 * Without the SCSI Bus Reset, before an Inquiry a device can&#39;t</span>
<span class="cm">	 * be assumed to be in Asynchronous, Narrow mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span> <span class="o">&amp;</span> <span class="n">BIOS_CTRL_RESET_SCSI_BUS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_ABLE</span><span class="p">,</span>
				 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">wdtr_able</span><span class="p">);</span>
		<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_ABLE</span><span class="p">,</span>
				 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_able</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,</span>
<span class="cm">	 * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID</span>
<span class="cm">	 * bitmask. These values determine the maximum SDTR speed negotiated</span>
<span class="cm">	 * with a device.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,</span>
<span class="cm">	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them</span>
<span class="cm">	 * without determining here whether the device supports SDTR.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 4-bit speed  SDTR speed name</span>
<span class="cm">	 * ===========  ===============</span>
<span class="cm">	 * 0000b (0x0)  SDTR disabled</span>
<span class="cm">	 * 0001b (0x1)  5 Mhz</span>
<span class="cm">	 * 0010b (0x2)  10 Mhz</span>
<span class="cm">	 * 0011b (0x3)  20 Mhz (Ultra)</span>
<span class="cm">	 * 0100b (0x4)  40 Mhz (LVD/Ultra2)</span>
<span class="cm">	 * 0101b (0x5)  80 Mhz (LVD2/Ultra3)</span>
<span class="cm">	 * 0110b (0x6)  Undefined</span>
<span class="cm">	 * .</span>
<span class="cm">	 * 1111b (0xF)  Undefined</span>
<span class="cm">	 */</span>
	<span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tid</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">tid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ultra_able</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Set Ultra speed for TID &#39;tid&#39;. */</span>
			<span class="n">word</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">tid</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Set Fast speed for TID &#39;tid&#39;. */</span>
			<span class="n">word</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">tid</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)));</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Check if done with sdtr_speed1. */</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_SPEED1</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
			<span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Check if done with sdtr_speed2. */</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_SPEED2</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
			<span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">11</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Check if done with sdtr_speed3. */</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_SPEED3</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
			<span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Check if done with sdtr_speed4. */</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_SPEED4</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
			<span class="cm">/* End of loop. */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set microcode operating variable for the disconnect per TID bitmask.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DISC_ENABLE</span><span class="p">,</span>
			 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set SCSI_CFG0 Microcode Default Value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the SCSI_CFG0 register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DEFAULT_SCSI_CFG0</span><span class="p">,</span>
			 <span class="n">PARITY_EN</span> <span class="o">|</span> <span class="n">QUEUE_128</span> <span class="o">|</span> <span class="n">SEL_TMO_LONG</span> <span class="o">|</span> <span class="n">OUR_ID_EN</span> <span class="o">|</span>
			 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine SCSI_CFG1 Microcode Default Value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the SCSI_CFG1 register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Read current SCSI_CFG1 Register value. */</span>
	<span class="n">scsi_cfg1</span> <span class="o">=</span> <span class="n">AdvReadWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_SCSI_CFG1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If all three connectors are in use, return an error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">scsi_cfg1</span> <span class="o">&amp;</span> <span class="n">CABLE_ILLEGAL_A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">scsi_cfg1</span> <span class="o">&amp;</span> <span class="n">CABLE_ILLEGAL_B</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_ILLEGAL_CONNECTION</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the internal narrow cable is reversed all of the SCSI_CTRL</span>
<span class="cm">	 * register signals will be set. Check for and return an error if</span>
<span class="cm">	 * this condition is found.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">AdvReadWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_SCSI_CTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3F07</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x3F07</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_REVERSED_CABLE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a differential board and a single-ended device</span>
<span class="cm">	 * is attached to one of the connectors, return an error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">scsi_cfg1</span> <span class="o">&amp;</span> <span class="n">DIFF_MODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">scsi_cfg1</span> <span class="o">&amp;</span> <span class="n">DIFF_SENSE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_SINGLE_END_DEVICE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If automatic termination control is enabled, then set the</span>
<span class="cm">	 * termination value based on a table listed in a_condor.h.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If manual termination was specified with an EEPROM setting</span>
<span class="cm">	 * then &#39;termination&#39; was set-up in AdvInitFrom3550EEPROM() and</span>
<span class="cm">	 * is ready to be &#39;ored&#39; into SCSI_CFG1.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The software always controls termination by setting TERM_CTL_SEL.</span>
<span class="cm">		 * If TERM_CTL_SEL were set to 0, the hardware would set termination.</span>
<span class="cm">		 */</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">|=</span> <span class="n">TERM_CTL_SEL</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">scsi_cfg1</span> <span class="o">&amp;</span> <span class="n">CABLE_DETECT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* TERM_CTL_H: on, TERM_CTL_L: on */</span>
		<span class="k">case</span> <span class="mh">0x3</span>:
		<span class="k">case</span> <span class="mh">0x7</span>:
		<span class="k">case</span> <span class="mh">0xB</span>:
		<span class="k">case</span> <span class="mh">0xD</span>:
		<span class="k">case</span> <span class="mh">0xE</span>:
		<span class="k">case</span> <span class="mh">0xF</span>:
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">|=</span> <span class="p">(</span><span class="n">TERM_CTL_H</span> <span class="o">|</span> <span class="n">TERM_CTL_L</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* TERM_CTL_H: on, TERM_CTL_L: off */</span>
		<span class="k">case</span> <span class="mh">0x1</span>:
		<span class="k">case</span> <span class="mh">0x5</span>:
		<span class="k">case</span> <span class="mh">0x9</span>:
		<span class="k">case</span> <span class="mh">0xA</span>:
		<span class="k">case</span> <span class="mh">0xC</span>:
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">|=</span> <span class="n">TERM_CTL_H</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* TERM_CTL_H: off, TERM_CTL_L: off */</span>
		<span class="k">case</span> <span class="mh">0x2</span>:
		<span class="k">case</span> <span class="mh">0x6</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear any set TERM_CTL_H and TERM_CTL_L bits.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_cfg1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TERM_CTL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Invert the TERM_CTL_H and TERM_CTL_L bits and then</span>
<span class="cm">	 * set &#39;scsi_cfg1&#39;. The TERM_POL bit does not need to be</span>
<span class="cm">	 * referenced, because the hardware internally inverts</span>
<span class="cm">	 * the Termination High and Low bits if TERM_POL is set.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_cfg1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">TERM_CTL_SEL</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">&amp;</span> <span class="n">TERM_CTL</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set SCSI_CFG1 Microcode Default Value</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set filter value and possibly modified termination control</span>
<span class="cm">	 * bits in the Microcode SCSI_CFG1 Register Value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the SCSI_CFG1 register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DEFAULT_SCSI_CFG1</span><span class="p">,</span>
			 <span class="n">FLTR_DISABLE</span> <span class="o">|</span> <span class="n">scsi_cfg1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set MEM_CFG Microcode Default Value</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the MEM_CFG register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 *</span>
<span class="cm">	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7</span>
<span class="cm">	 * are defined.</span>
<span class="cm">	 *</span>
<span class="cm">	 * ASC-3550 has 8KB internal memory.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DEFAULT_MEM_CFG</span><span class="p">,</span>
			 <span class="n">BIOS_EN</span> <span class="o">|</span> <span class="n">RAM_SZ_8KB</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set SEL_MASK Microcode Default Value</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the SEL_MASK register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DEFAULT_SEL_MASK</span><span class="p">,</span>
			 <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">));</span>

	<span class="n">AdvBuildCarrierFreelist</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set-up the Host-&gt;RISC Initiator Command Queue (ICQ).</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_NO_CARRIER</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="p">)</span>
	    <span class="n">ADV_U32_TO_VADDR</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="o">-&gt;</span><span class="n">next_vpa</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * The first command issued will be placed in the stopper carrier.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="o">-&gt;</span><span class="n">next_vpa</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ASC_CQ_STOPPER</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set RISC ICQ physical address start value.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteDWordLramNoSwap</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_ICQ</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="o">-&gt;</span><span class="n">carr_pa</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set-up the RISC-&gt;Host Initiator Response Queue (IRQ).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_NO_CARRIER</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="p">)</span>
	    <span class="n">ADV_U32_TO_VADDR</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span><span class="o">-&gt;</span><span class="n">next_vpa</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * The first command completed by the RISC will be placed in</span>
<span class="cm">	 * the stopper.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: Set &#39;next_vpa&#39; to ASC_CQ_STOPPER. When the request is</span>
<span class="cm">	 * completed the RISC will set the ASC_RQ_STOPPER bit.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span><span class="o">-&gt;</span><span class="n">next_vpa</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ASC_CQ_STOPPER</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set RISC IRQ physical address start value.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteDWordLramNoSwap</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_IRQ</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span><span class="o">-&gt;</span><span class="n">carr_pa</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_pending_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_INTR_ENABLES</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">ADV_INTR_ENABLE_HOST_INTR</span> <span class="o">|</span>
			      <span class="n">ADV_INTR_ENABLE_GLOBAL_INTR</span><span class="p">));</span>

	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CODE_BEGIN_ADDR</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_PC</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>

	<span class="cm">/* finally, finally, gentlemen, start your engine */</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_RISC_CSR</span><span class="p">,</span> <span class="n">ADV_RISC_CSR_RUN</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus</span>
<span class="cm">	 * Resets should be performed. The RISC has to be running</span>
<span class="cm">	 * to issue a SCSI Bus Reset.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span> <span class="o">&amp;</span> <span class="n">BIOS_CTRL_RESET_SCSI_BUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the BIOS Signature is present in memory, restore the</span>
<span class="cm">		 * BIOS Handshake Configuration Table and do not perform</span>
<span class="cm">		 * a SCSI Bus Reset.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bios_mem</span><span class="p">[(</span><span class="n">ASC_MC_BIOS_SIGNATURE</span> <span class="o">-</span> <span class="n">ASC_MC_BIOSMEM</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span>
		    <span class="mh">0x55AA</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Restore per TID negotiated values.</span>
<span class="cm">			 */</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_ABLE</span><span class="p">,</span> <span class="n">wdtr_able</span><span class="p">);</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_ABLE</span><span class="p">,</span> <span class="n">sdtr_able</span><span class="p">);</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_TAGQNG_ABLE</span><span class="p">,</span>
					 <span class="n">tagqng_able</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tid</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">tid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">AdvWriteByteLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						 <span class="n">ASC_MC_NUMBER_OF_MAX_CMD</span> <span class="o">+</span> <span class="n">tid</span><span class="p">,</span>
						 <span class="n">max_cmd</span><span class="p">[</span><span class="n">tid</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">AdvResetSB</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ADV_TRUE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">warn_code</span> <span class="o">=</span> <span class="n">ASC_WARN_BUSRESET_ERROR</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">warn_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the ASC-38C0800.</span>
<span class="cm"> *</span>
<span class="cm"> * On failure set the ADV_DVC_VAR field &#39;err_code&#39; and return ADV_ERROR.</span>
<span class="cm"> *</span>
<span class="cm"> * For a non-fatal error return a warning code. If there are no warnings</span>
<span class="cm"> * then 0 is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Needed after initialization for error recovery.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">AdvInitAsc38C0800Driver</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">fwname</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;advansys/38C0800.bin&quot;</span><span class="p">;</span>
	<span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">warn_code</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">begin_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end_addr</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">code_sum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">word</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">chksum</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">scsi_cfg1</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">byte</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">tid</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">bios_mem</span><span class="p">[</span><span class="n">ASC_MC_BIOSLEN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>	<span class="cm">/* BIOS RISC Memory 0x40-0x8F. */</span>
	<span class="n">ushort</span> <span class="n">wdtr_able</span><span class="p">,</span> <span class="n">sdtr_able</span><span class="p">,</span> <span class="n">tagqng_able</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">max_cmd</span><span class="p">[</span><span class="n">ADV_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* If there is already an error, don&#39;t continue. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The caller must set &#39;chip_type&#39; to ADV_CHIP_ASC38C0800.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">!=</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_BAD_CHIPTYPE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">warn_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save the RISC memory BIOS region before writing the microcode.</span>
<span class="cm">	 * The BIOS may already be loaded and using its RISC LRAM region</span>
<span class="cm">	 * so its region must be saved and restored.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: This code makes the assumption, which is currently true,</span>
<span class="cm">	 * that a chip reset does not clear RISC LRAM.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ASC_MC_BIOSLEN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_BIOSMEM</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span>
				<span class="n">bios_mem</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save current per TID negotiated values.</span>
<span class="cm">	 */</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_ABLE</span><span class="p">,</span> <span class="n">wdtr_able</span><span class="p">);</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_ABLE</span><span class="p">,</span> <span class="n">sdtr_able</span><span class="p">);</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_TAGQNG_ABLE</span><span class="p">,</span> <span class="n">tagqng_able</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tid</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">tid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvReadByteLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_NUMBER_OF_MAX_CMD</span> <span class="o">+</span> <span class="n">tid</span><span class="p">,</span>
				<span class="n">max_cmd</span><span class="p">[</span><span class="n">tid</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * RAM BIST (RAM Built-In Self Test)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Address : I/O base + offset 0x38h register (byte).</span>
<span class="cm">	 * Function: Bit 7-6(RW) : RAM mode</span>
<span class="cm">	 *                          Normal Mode   : 0x00</span>
<span class="cm">	 *                          Pre-test Mode : 0x40</span>
<span class="cm">	 *                          RAM Test Mode : 0x80</span>
<span class="cm">	 *           Bit 5       : unused</span>
<span class="cm">	 *           Bit 4(RO)   : Done bit</span>
<span class="cm">	 *           Bit 3-0(RO) : Status</span>
<span class="cm">	 *                          Host Error    : 0x08</span>
<span class="cm">	 *                          Int_RAM Error : 0x04</span>
<span class="cm">	 *                          RISC Error    : 0x02</span>
<span class="cm">	 *                          SCSI Error    : 0x01</span>
<span class="cm">	 *                          No Error      : 0x00</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: RAM BIST code should be put right here, before loading the</span>
<span class="cm">	 * microcode and after saving the RISC memory BIOS region.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * LRAM Pre-test</span>
<span class="cm">	 *</span>
<span class="cm">	 * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.</span>
<span class="cm">	 * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return</span>
<span class="cm">	 * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset</span>
<span class="cm">	 * to NORMAL_MODE, return an error too.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_RAM_BIST</span><span class="p">,</span> <span class="n">PRE_TEST_MODE</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>	<span class="cm">/* Wait for 10ms before reading back. */</span>
		<span class="n">byte</span> <span class="o">=</span> <span class="n">AdvReadByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_RAM_BIST</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="n">RAM_TEST_DONE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PRE_TEST_VALUE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_BIST_PRE_TEST</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_RAM_BIST</span><span class="p">,</span> <span class="n">NORMAL_MODE</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>	<span class="cm">/* Wait for 10ms before reading back. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AdvReadByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_RAM_BIST</span><span class="p">)</span>
		    <span class="o">!=</span> <span class="n">NORMAL_VALUE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_BIST_PRE_TEST</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * LRAM Test - It takes about 1.5 ms to run through the test.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.</span>
<span class="cm">	 * If Done bit not set or Status not 0, save register byte, set the</span>
<span class="cm">	 * err_code, and return an error.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_RAM_BIST</span><span class="p">,</span> <span class="n">RAM_TEST_MODE</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>	<span class="cm">/* Wait for 10ms before checking status. */</span>

	<span class="n">byte</span> <span class="o">=</span> <span class="n">AdvReadByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_RAM_BIST</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="n">RAM_TEST_DONE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="n">RAM_TEST_STATUS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get here if Done bit not set or Status not 0. */</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bist_err_code</span> <span class="o">=</span> <span class="n">byte</span><span class="p">;</span>	<span class="cm">/* for BIOS display message */</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_BIST_RAM_TEST</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We need to reset back to normal mode after LRAM test passes. */</span>
	<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_RAM_BIST</span><span class="p">,</span> <span class="n">NORMAL_MODE</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">fwname</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">drv_ptr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to load image </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">fwname</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_MCODE_CHKSUM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Bogus length %zu in image </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">fwname</span><span class="p">);</span>
		<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_MCODE_CHKSUM</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chksum</span> <span class="o">=</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		 <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">AdvLoadMicrocode</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
					     <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="n">ADV_38C0800_MEMSIZE</span><span class="p">,</span>
					     <span class="n">chksum</span><span class="p">);</span>
	<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore the RISC memory BIOS region.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ASC_MC_BIOSLEN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_BIOSMEM</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span>
				 <span class="n">bios_mem</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate and write the microcode code checksum to the microcode</span>
<span class="cm">	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).</span>
<span class="cm">	 */</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CODE_BEGIN_ADDR</span><span class="p">,</span> <span class="n">begin_addr</span><span class="p">);</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CODE_END_ADDR</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">);</span>
	<span class="n">code_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_RAM_ADDR</span><span class="p">,</span> <span class="n">begin_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">word</span> <span class="o">=</span> <span class="n">begin_addr</span><span class="p">;</span> <span class="n">word</span> <span class="o">&lt;</span> <span class="n">end_addr</span><span class="p">;</span> <span class="n">word</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">code_sum</span> <span class="o">+=</span> <span class="n">AdvReadWordAutoIncLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CODE_CHK_SUM</span><span class="p">,</span> <span class="n">code_sum</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read microcode version and date.</span>
<span class="cm">	 */</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_VERSION_DATE</span><span class="p">,</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">mcode_date</span><span class="p">);</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_VERSION_NUM</span><span class="p">,</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">mcode_version</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the chip type to indicate the ASC38C0800.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CHIP_TYPE</span><span class="p">,</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write 1 to bit 14 &#39;DIS_TERM_DRV&#39; in the SCSI_CFG1 register.</span>
<span class="cm">	 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current</span>
<span class="cm">	 * cable detection and then we are able to read C_DET[3:0].</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: We will reset DIS_TERM_DRV to 0 in the &#39;Set SCSI_CFG1</span>
<span class="cm">	 * Microcode Default Value&#39; section below.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_cfg1</span> <span class="o">=</span> <span class="n">AdvReadWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_SCSI_CFG1</span><span class="p">);</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_SCSI_CFG1</span><span class="p">,</span>
			     <span class="n">scsi_cfg1</span> <span class="o">|</span> <span class="n">DIS_TERM_DRV</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the PCI Configuration Command Register &quot;Parity Error Response</span>
<span class="cm">	 * Control&quot; Bit was clear (0), then set the microcode variable</span>
<span class="cm">	 * &#39;control_flag&#39; CONTROL_FLAG_IGNORE_PERR flag to tell the microcode</span>
<span class="cm">	 * to ignore DMA parity errors.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">control_flag</span> <span class="o">&amp;</span> <span class="n">CONTROL_FLAG_IGNORE_PERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CONTROL_FLAG</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
		<span class="n">word</span> <span class="o">|=</span> <span class="n">CONTROL_FLAG_IGNORE_PERR</span><span class="p">;</span>
		<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CONTROL_FLAG</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]</span>
<span class="cm">	 * bits for the default FIFO threshold.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For DMA Errata #4 set the BC_THRESH_ENB bit.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_DMA_CFG0</span><span class="p">,</span>
			     <span class="n">BC_THRESH_ENB</span> <span class="o">|</span> <span class="n">FIFO_THRESH_80B</span> <span class="o">|</span> <span class="n">START_CTL_TH</span> <span class="o">|</span>
			     <span class="n">READ_CMD_MRM</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Microcode operating variables for WDTR, SDTR, and command tag</span>
<span class="cm">	 * queuing will be set in slave_configure() based on what a</span>
<span class="cm">	 * device reports it is capable of in Inquiry byte 7.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If SCSI Bus Resets have been disabled, then directly set</span>
<span class="cm">	 * SDTR and WDTR from the EEPROM configuration. This will allow</span>
<span class="cm">	 * the BIOS and warm boot to work without a SCSI bus hang on</span>
<span class="cm">	 * the Inquiry caused by host and target mismatched DTR values.</span>
<span class="cm">	 * Without the SCSI Bus Reset, before an Inquiry a device can&#39;t</span>
<span class="cm">	 * be assumed to be in Asynchronous, Narrow mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span> <span class="o">&amp;</span> <span class="n">BIOS_CTRL_RESET_SCSI_BUS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_ABLE</span><span class="p">,</span>
				 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">wdtr_able</span><span class="p">);</span>
		<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_ABLE</span><span class="p">,</span>
				 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_able</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set microcode operating variables for DISC and SDTR_SPEED1,</span>
<span class="cm">	 * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM</span>
<span class="cm">	 * configuration values.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,</span>
<span class="cm">	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them</span>
<span class="cm">	 * without determining here whether the device supports SDTR.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DISC_ENABLE</span><span class="p">,</span>
			 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">);</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_SPEED1</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed1</span><span class="p">);</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_SPEED2</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed2</span><span class="p">);</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_SPEED3</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed3</span><span class="p">);</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_SPEED4</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed4</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set SCSI_CFG0 Microcode Default Value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the SCSI_CFG0 register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DEFAULT_SCSI_CFG0</span><span class="p">,</span>
			 <span class="n">PARITY_EN</span> <span class="o">|</span> <span class="n">QUEUE_128</span> <span class="o">|</span> <span class="n">SEL_TMO_LONG</span> <span class="o">|</span> <span class="n">OUR_ID_EN</span> <span class="o">|</span>
			 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine SCSI_CFG1 Microcode Default Value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the SCSI_CFG1 register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Read current SCSI_CFG1 Register value. */</span>
	<span class="n">scsi_cfg1</span> <span class="o">=</span> <span class="n">AdvReadWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_SCSI_CFG1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the internal narrow cable is reversed all of the SCSI_CTRL</span>
<span class="cm">	 * register signals will be set. Check for and return an error if</span>
<span class="cm">	 * this condition is found.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">AdvReadWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_SCSI_CTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3F07</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x3F07</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_REVERSED_CABLE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * All kind of combinations of devices attached to one of four</span>
<span class="cm">	 * connectors are acceptable except HVD device attached. For example,</span>
<span class="cm">	 * LVD device can be attached to SE connector while SE device attached</span>
<span class="cm">	 * to LVD connector.  If LVD device attached to SE connector, it only</span>
<span class="cm">	 * runs up to Ultra speed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If an HVD device is attached to one of LVD connectors, return an</span>
<span class="cm">	 * error.  However, there is no way to detect HVD device attached to</span>
<span class="cm">	 * SE connectors.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_cfg1</span> <span class="o">&amp;</span> <span class="n">HVD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_HVD_DEVICE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If either SE or LVD automatic termination control is enabled, then</span>
<span class="cm">	 * set the termination value based on a table listed in a_condor.h.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If manual termination was specified with an EEPROM setting then</span>
<span class="cm">	 * &#39;termination&#39; was set-up in AdvInitFrom38C0800EEPROM() and is ready</span>
<span class="cm">	 * to be &#39;ored&#39; into SCSI_CFG1.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">&amp;</span> <span class="n">TERM_SE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* SE automatic termination control is enabled. */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">scsi_cfg1</span> <span class="o">&amp;</span> <span class="n">C_DET_SE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* TERM_SE_HI: on, TERM_SE_LO: on */</span>
		<span class="k">case</span> <span class="mh">0x1</span>:
		<span class="k">case</span> <span class="mh">0x2</span>:
		<span class="k">case</span> <span class="mh">0x3</span>:
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">|=</span> <span class="n">TERM_SE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* TERM_SE_HI: on, TERM_SE_LO: off */</span>
		<span class="k">case</span> <span class="mh">0x0</span>:
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">|=</span> <span class="n">TERM_SE_HI</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">&amp;</span> <span class="n">TERM_LVD</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* LVD automatic termination control is enabled. */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">scsi_cfg1</span> <span class="o">&amp;</span> <span class="n">C_DET_LVD</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* TERM_LVD_HI: on, TERM_LVD_LO: on */</span>
		<span class="k">case</span> <span class="mh">0x4</span>:
		<span class="k">case</span> <span class="mh">0x8</span>:
		<span class="k">case</span> <span class="mh">0xC</span>:
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">|=</span> <span class="n">TERM_LVD</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* TERM_LVD_HI: off, TERM_LVD_LO: off */</span>
		<span class="k">case</span> <span class="mh">0x0</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear any set TERM_SE and TERM_LVD bits.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_cfg1</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">TERM_SE</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">TERM_LVD</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Invert the TERM_SE and TERM_LVD bits and then set &#39;scsi_cfg1&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_cfg1</span> <span class="o">|=</span> <span class="p">(</span><span class="o">~</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE</span>
<span class="cm">	 * bits and set possibly modified termination control bits in the</span>
<span class="cm">	 * Microcode SCSI_CFG1 Register Value.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_cfg1</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">BIG_ENDIAN</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DIS_TERM_DRV</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">TERM_POL</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HVD_LVD_SE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set SCSI_CFG1 Microcode Default Value</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set possibly modified termination control and reset DIS_TERM_DRV</span>
<span class="cm">	 * bits in the Microcode SCSI_CFG1 Register Value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the SCSI_CFG1 register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DEFAULT_SCSI_CFG1</span><span class="p">,</span> <span class="n">scsi_cfg1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set MEM_CFG Microcode Default Value</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the MEM_CFG register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 *</span>
<span class="cm">	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7</span>
<span class="cm">	 * are defined.</span>
<span class="cm">	 *</span>
<span class="cm">	 * ASC-38C0800 has 16KB internal memory.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DEFAULT_MEM_CFG</span><span class="p">,</span>
			 <span class="n">BIOS_EN</span> <span class="o">|</span> <span class="n">RAM_SZ_16KB</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set SEL_MASK Microcode Default Value</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the SEL_MASK register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DEFAULT_SEL_MASK</span><span class="p">,</span>
			 <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">));</span>

	<span class="n">AdvBuildCarrierFreelist</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set-up the Host-&gt;RISC Initiator Command Queue (ICQ).</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_NO_CARRIER</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="p">)</span>
	    <span class="n">ADV_U32_TO_VADDR</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="o">-&gt;</span><span class="n">next_vpa</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * The first command issued will be placed in the stopper carrier.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="o">-&gt;</span><span class="n">next_vpa</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ASC_CQ_STOPPER</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set RISC ICQ physical address start value.</span>
<span class="cm">	 * carr_pa is LE, must be native before write</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteDWordLramNoSwap</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_ICQ</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="o">-&gt;</span><span class="n">carr_pa</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set-up the RISC-&gt;Host Initiator Response Queue (IRQ).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_NO_CARRIER</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="p">)</span>
	    <span class="n">ADV_U32_TO_VADDR</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span><span class="o">-&gt;</span><span class="n">next_vpa</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * The first command completed by the RISC will be placed in</span>
<span class="cm">	 * the stopper.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: Set &#39;next_vpa&#39; to ASC_CQ_STOPPER. When the request is</span>
<span class="cm">	 * completed the RISC will set the ASC_RQ_STOPPER bit.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span><span class="o">-&gt;</span><span class="n">next_vpa</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ASC_CQ_STOPPER</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set RISC IRQ physical address start value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * carr_pa is LE, must be native before write *</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteDWordLramNoSwap</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_IRQ</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span><span class="o">-&gt;</span><span class="n">carr_pa</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_pending_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_INTR_ENABLES</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">ADV_INTR_ENABLE_HOST_INTR</span> <span class="o">|</span>
			      <span class="n">ADV_INTR_ENABLE_GLOBAL_INTR</span><span class="p">));</span>

	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CODE_BEGIN_ADDR</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_PC</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>

	<span class="cm">/* finally, finally, gentlemen, start your engine */</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_RISC_CSR</span><span class="p">,</span> <span class="n">ADV_RISC_CSR_RUN</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus</span>
<span class="cm">	 * Resets should be performed. The RISC has to be running</span>
<span class="cm">	 * to issue a SCSI Bus Reset.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span> <span class="o">&amp;</span> <span class="n">BIOS_CTRL_RESET_SCSI_BUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the BIOS Signature is present in memory, restore the</span>
<span class="cm">		 * BIOS Handshake Configuration Table and do not perform</span>
<span class="cm">		 * a SCSI Bus Reset.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bios_mem</span><span class="p">[(</span><span class="n">ASC_MC_BIOS_SIGNATURE</span> <span class="o">-</span> <span class="n">ASC_MC_BIOSMEM</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span>
		    <span class="mh">0x55AA</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Restore per TID negotiated values.</span>
<span class="cm">			 */</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_ABLE</span><span class="p">,</span> <span class="n">wdtr_able</span><span class="p">);</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_ABLE</span><span class="p">,</span> <span class="n">sdtr_able</span><span class="p">);</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_TAGQNG_ABLE</span><span class="p">,</span>
					 <span class="n">tagqng_able</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tid</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">tid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">AdvWriteByteLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						 <span class="n">ASC_MC_NUMBER_OF_MAX_CMD</span> <span class="o">+</span> <span class="n">tid</span><span class="p">,</span>
						 <span class="n">max_cmd</span><span class="p">[</span><span class="n">tid</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">AdvResetSB</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ADV_TRUE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">warn_code</span> <span class="o">=</span> <span class="n">ASC_WARN_BUSRESET_ERROR</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">warn_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the ASC-38C1600.</span>
<span class="cm"> *</span>
<span class="cm"> * On failure set the ASC_DVC_VAR field &#39;err_code&#39; and return ADV_ERROR.</span>
<span class="cm"> *</span>
<span class="cm"> * For a non-fatal error return a warning code. If there are no warnings</span>
<span class="cm"> * then 0 is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Needed after initialization for error recovery.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">AdvInitAsc38C1600Driver</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">fwname</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;advansys/38C1600.bin&quot;</span><span class="p">;</span>
	<span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">warn_code</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">begin_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end_addr</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">code_sum</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">word</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">chksum</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">scsi_cfg1</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">byte</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">tid</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">bios_mem</span><span class="p">[</span><span class="n">ASC_MC_BIOSLEN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>	<span class="cm">/* BIOS RISC Memory 0x40-0x8F. */</span>
	<span class="n">ushort</span> <span class="n">wdtr_able</span><span class="p">,</span> <span class="n">sdtr_able</span><span class="p">,</span> <span class="n">ppr_able</span><span class="p">,</span> <span class="n">tagqng_able</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">max_cmd</span><span class="p">[</span><span class="n">ASC_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* If there is already an error, don&#39;t continue. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The caller must set &#39;chip_type&#39; to ADV_CHIP_ASC38C1600.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">!=</span> <span class="n">ADV_CHIP_ASC38C1600</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_BAD_CHIPTYPE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">warn_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save the RISC memory BIOS region before writing the microcode.</span>
<span class="cm">	 * The BIOS may already be loaded and using its RISC LRAM region</span>
<span class="cm">	 * so its region must be saved and restored.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: This code makes the assumption, which is currently true,</span>
<span class="cm">	 * that a chip reset does not clear RISC LRAM.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ASC_MC_BIOSLEN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_BIOSMEM</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span>
				<span class="n">bios_mem</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save current per TID negotiated values.</span>
<span class="cm">	 */</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_ABLE</span><span class="p">,</span> <span class="n">wdtr_able</span><span class="p">);</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_ABLE</span><span class="p">,</span> <span class="n">sdtr_able</span><span class="p">);</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_PPR_ABLE</span><span class="p">,</span> <span class="n">ppr_able</span><span class="p">);</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_TAGQNG_ABLE</span><span class="p">,</span> <span class="n">tagqng_able</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tid</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">tid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvReadByteLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_NUMBER_OF_MAX_CMD</span> <span class="o">+</span> <span class="n">tid</span><span class="p">,</span>
				<span class="n">max_cmd</span><span class="p">[</span><span class="n">tid</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * RAM BIST (Built-In Self Test)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Address : I/O base + offset 0x38h register (byte).</span>
<span class="cm">	 * Function: Bit 7-6(RW) : RAM mode</span>
<span class="cm">	 *                          Normal Mode   : 0x00</span>
<span class="cm">	 *                          Pre-test Mode : 0x40</span>
<span class="cm">	 *                          RAM Test Mode : 0x80</span>
<span class="cm">	 *           Bit 5       : unused</span>
<span class="cm">	 *           Bit 4(RO)   : Done bit</span>
<span class="cm">	 *           Bit 3-0(RO) : Status</span>
<span class="cm">	 *                          Host Error    : 0x08</span>
<span class="cm">	 *                          Int_RAM Error : 0x04</span>
<span class="cm">	 *                          RISC Error    : 0x02</span>
<span class="cm">	 *                          SCSI Error    : 0x01</span>
<span class="cm">	 *                          No Error      : 0x00</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: RAM BIST code should be put right here, before loading the</span>
<span class="cm">	 * microcode and after saving the RISC memory BIOS region.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * LRAM Pre-test</span>
<span class="cm">	 *</span>
<span class="cm">	 * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.</span>
<span class="cm">	 * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return</span>
<span class="cm">	 * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset</span>
<span class="cm">	 * to NORMAL_MODE, return an error too.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_RAM_BIST</span><span class="p">,</span> <span class="n">PRE_TEST_MODE</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>	<span class="cm">/* Wait for 10ms before reading back. */</span>
		<span class="n">byte</span> <span class="o">=</span> <span class="n">AdvReadByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_RAM_BIST</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="n">RAM_TEST_DONE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PRE_TEST_VALUE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_BIST_PRE_TEST</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_RAM_BIST</span><span class="p">,</span> <span class="n">NORMAL_MODE</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>	<span class="cm">/* Wait for 10ms before reading back. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AdvReadByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_RAM_BIST</span><span class="p">)</span>
		    <span class="o">!=</span> <span class="n">NORMAL_VALUE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_BIST_PRE_TEST</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * LRAM Test - It takes about 1.5 ms to run through the test.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.</span>
<span class="cm">	 * If Done bit not set or Status not 0, save register byte, set the</span>
<span class="cm">	 * err_code, and return an error.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_RAM_BIST</span><span class="p">,</span> <span class="n">RAM_TEST_MODE</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>	<span class="cm">/* Wait for 10ms before checking status. */</span>

	<span class="n">byte</span> <span class="o">=</span> <span class="n">AdvReadByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_RAM_BIST</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="n">RAM_TEST_DONE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="n">RAM_TEST_STATUS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get here if Done bit not set or Status not 0. */</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bist_err_code</span> <span class="o">=</span> <span class="n">byte</span><span class="p">;</span>	<span class="cm">/* for BIOS display message */</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_BIST_RAM_TEST</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We need to reset back to normal mode after LRAM test passes. */</span>
	<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_RAM_BIST</span><span class="p">,</span> <span class="n">NORMAL_MODE</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">fwname</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">drv_ptr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to load image </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">fwname</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_MCODE_CHKSUM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Bogus length %zu in image </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">fwname</span><span class="p">);</span>
		<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_MCODE_CHKSUM</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chksum</span> <span class="o">=</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		 <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">AdvLoadMicrocode</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
					     <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="n">ADV_38C1600_MEMSIZE</span><span class="p">,</span>
					     <span class="n">chksum</span><span class="p">);</span>
	<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore the RISC memory BIOS region.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ASC_MC_BIOSLEN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_BIOSMEM</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span>
				 <span class="n">bios_mem</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate and write the microcode code checksum to the microcode</span>
<span class="cm">	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).</span>
<span class="cm">	 */</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CODE_BEGIN_ADDR</span><span class="p">,</span> <span class="n">begin_addr</span><span class="p">);</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CODE_END_ADDR</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">);</span>
	<span class="n">code_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_RAM_ADDR</span><span class="p">,</span> <span class="n">begin_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">word</span> <span class="o">=</span> <span class="n">begin_addr</span><span class="p">;</span> <span class="n">word</span> <span class="o">&lt;</span> <span class="n">end_addr</span><span class="p">;</span> <span class="n">word</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">code_sum</span> <span class="o">+=</span> <span class="n">AdvReadWordAutoIncLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CODE_CHK_SUM</span><span class="p">,</span> <span class="n">code_sum</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read microcode version and date.</span>
<span class="cm">	 */</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_VERSION_DATE</span><span class="p">,</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">mcode_date</span><span class="p">);</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_VERSION_NUM</span><span class="p">,</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">mcode_version</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the chip type to indicate the ASC38C1600.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CHIP_TYPE</span><span class="p">,</span> <span class="n">ADV_CHIP_ASC38C1600</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write 1 to bit 14 &#39;DIS_TERM_DRV&#39; in the SCSI_CFG1 register.</span>
<span class="cm">	 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current</span>
<span class="cm">	 * cable detection and then we are able to read C_DET[3:0].</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: We will reset DIS_TERM_DRV to 0 in the &#39;Set SCSI_CFG1</span>
<span class="cm">	 * Microcode Default Value&#39; section below.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_cfg1</span> <span class="o">=</span> <span class="n">AdvReadWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_SCSI_CFG1</span><span class="p">);</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_SCSI_CFG1</span><span class="p">,</span>
			     <span class="n">scsi_cfg1</span> <span class="o">|</span> <span class="n">DIS_TERM_DRV</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the PCI Configuration Command Register &quot;Parity Error Response</span>
<span class="cm">	 * Control&quot; Bit was clear (0), then set the microcode variable</span>
<span class="cm">	 * &#39;control_flag&#39; CONTROL_FLAG_IGNORE_PERR flag to tell the microcode</span>
<span class="cm">	 * to ignore DMA parity errors.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">control_flag</span> <span class="o">&amp;</span> <span class="n">CONTROL_FLAG_IGNORE_PERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CONTROL_FLAG</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
		<span class="n">word</span> <span class="o">|=</span> <span class="n">CONTROL_FLAG_IGNORE_PERR</span><span class="p">;</span>
		<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CONTROL_FLAG</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the BIOS control flag AIPP (Asynchronous Information</span>
<span class="cm">	 * Phase Protection) disable bit is not set, then set the firmware</span>
<span class="cm">	 * &#39;control_flag&#39; CONTROL_FLAG_ENABLE_AIPP bit to enable</span>
<span class="cm">	 * AIPP checking and encoding.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span> <span class="o">&amp;</span> <span class="n">BIOS_CTRL_AIPP_DIS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CONTROL_FLAG</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
		<span class="n">word</span> <span class="o">|=</span> <span class="n">CONTROL_FLAG_ENABLE_AIPP</span><span class="p">;</span>
		<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CONTROL_FLAG</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For ASC-38C1600 use DMA_CFG0 default values: FIFO_THRESH_80B [6:4],</span>
<span class="cm">	 * and START_CTL_TH [3:2].</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_DMA_CFG0</span><span class="p">,</span>
			     <span class="n">FIFO_THRESH_80B</span> <span class="o">|</span> <span class="n">START_CTL_TH</span> <span class="o">|</span> <span class="n">READ_CMD_MRM</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Microcode operating variables for WDTR, SDTR, and command tag</span>
<span class="cm">	 * queuing will be set in slave_configure() based on what a</span>
<span class="cm">	 * device reports it is capable of in Inquiry byte 7.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If SCSI Bus Resets have been disabled, then directly set</span>
<span class="cm">	 * SDTR and WDTR from the EEPROM configuration. This will allow</span>
<span class="cm">	 * the BIOS and warm boot to work without a SCSI bus hang on</span>
<span class="cm">	 * the Inquiry caused by host and target mismatched DTR values.</span>
<span class="cm">	 * Without the SCSI Bus Reset, before an Inquiry a device can&#39;t</span>
<span class="cm">	 * be assumed to be in Asynchronous, Narrow mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span> <span class="o">&amp;</span> <span class="n">BIOS_CTRL_RESET_SCSI_BUS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_ABLE</span><span class="p">,</span>
				 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">wdtr_able</span><span class="p">);</span>
		<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_ABLE</span><span class="p">,</span>
				 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_able</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set microcode operating variables for DISC and SDTR_SPEED1,</span>
<span class="cm">	 * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM</span>
<span class="cm">	 * configuration values.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,</span>
<span class="cm">	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them</span>
<span class="cm">	 * without determining here whether the device supports SDTR.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DISC_ENABLE</span><span class="p">,</span>
			 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">);</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_SPEED1</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed1</span><span class="p">);</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_SPEED2</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed2</span><span class="p">);</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_SPEED3</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed3</span><span class="p">);</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_SPEED4</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed4</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set SCSI_CFG0 Microcode Default Value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the SCSI_CFG0 register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DEFAULT_SCSI_CFG0</span><span class="p">,</span>
			 <span class="n">PARITY_EN</span> <span class="o">|</span> <span class="n">QUEUE_128</span> <span class="o">|</span> <span class="n">SEL_TMO_LONG</span> <span class="o">|</span> <span class="n">OUR_ID_EN</span> <span class="o">|</span>
			 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate SCSI_CFG1 Microcode Default Value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the SCSI_CFG1 register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Each ASC-38C1600 function has only two cable detect bits.</span>
<span class="cm">	 * The bus mode override bits are in IOPB_SOFT_OVER_WR.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_cfg1</span> <span class="o">=</span> <span class="n">AdvReadWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_SCSI_CFG1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the cable is reversed all of the SCSI_CTRL register signals</span>
<span class="cm">	 * will be set. Check for and return an error if this condition is</span>
<span class="cm">	 * found.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">AdvReadWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_SCSI_CTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3F07</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x3F07</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_REVERSED_CABLE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Each ASC-38C1600 function has two connectors. Only an HVD device</span>
<span class="cm">	 * can not be connected to either connector. An LVD device or SE device</span>
<span class="cm">	 * may be connected to either connecor. If an SE device is connected,</span>
<span class="cm">	 * then at most Ultra speed (20 Mhz) can be used on both connectors.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If an HVD device is attached, return an error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_cfg1</span> <span class="o">&amp;</span> <span class="n">HVD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_HVD_DEVICE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Each function in the ASC-38C1600 uses only the SE cable detect and</span>
<span class="cm">	 * termination because there are two connectors for each function. Each</span>
<span class="cm">	 * function may use either LVD or SE mode. Corresponding the SE automatic</span>
<span class="cm">	 * termination control EEPROM bits are used for each function. Each</span>
<span class="cm">	 * function has its own EEPROM. If SE automatic control is enabled for</span>
<span class="cm">	 * the function, then set the termination value based on a table listed</span>
<span class="cm">	 * in a_condor.h.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If manual termination is specified in the EEPROM for the function,</span>
<span class="cm">	 * then &#39;termination&#39; was set-up in AscInitFrom38C1600EEPROM() and is</span>
<span class="cm">	 * ready to be &#39;ored&#39; into SCSI_CFG1.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">&amp;</span> <span class="n">TERM_SE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adv_dvc_to_pdev</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
		<span class="cm">/* SE automatic termination control is enabled. */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">scsi_cfg1</span> <span class="o">&amp;</span> <span class="n">C_DET_SE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* TERM_SE_HI: on, TERM_SE_LO: on */</span>
		<span class="k">case</span> <span class="mh">0x1</span>:
		<span class="k">case</span> <span class="mh">0x2</span>:
		<span class="k">case</span> <span class="mh">0x3</span>:
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">|=</span> <span class="n">TERM_SE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x0</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Function 0 - TERM_SE_HI: off, TERM_SE_LO: off */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Function 1 - TERM_SE_HI: on, TERM_SE_LO: off */</span>
				<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">|=</span> <span class="n">TERM_SE_HI</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear any set TERM_SE bits.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_cfg1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TERM_SE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Invert the TERM_SE bits and then set &#39;scsi_cfg1&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_cfg1</span> <span class="o">|=</span> <span class="p">(</span><span class="o">~</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">&amp;</span> <span class="n">TERM_SE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear Big Endian and Terminator Polarity bits and set possibly</span>
<span class="cm">	 * modified termination control bits in the Microcode SCSI_CFG1</span>
<span class="cm">	 * Register Value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Big Endian bit is not used even on big endian machines.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_cfg1</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">BIG_ENDIAN</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DIS_TERM_DRV</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">TERM_POL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set SCSI_CFG1 Microcode Default Value</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set possibly modified termination control bits in the Microcode</span>
<span class="cm">	 * SCSI_CFG1 Register Value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the SCSI_CFG1 register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DEFAULT_SCSI_CFG1</span><span class="p">,</span> <span class="n">scsi_cfg1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set MEM_CFG Microcode Default Value</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the MEM_CFG register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 *</span>
<span class="cm">	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7</span>
<span class="cm">	 * are defined.</span>
<span class="cm">	 *</span>
<span class="cm">	 * ASC-38C1600 has 32KB internal memory.</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX - Since ASC38C1600 Rev.3 has a Local RAM failure issue, we come</span>
<span class="cm">	 * out a special 16K Adv Library and Microcode version. After the issue</span>
<span class="cm">	 * resolved, we should turn back to the 32K support. Both a_condor.h and</span>
<span class="cm">	 * mcode.sas files also need to be updated.</span>
<span class="cm">	 *</span>
<span class="cm">	 * AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,</span>
<span class="cm">	 *  BIOS_EN | RAM_SZ_32KB);</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DEFAULT_MEM_CFG</span><span class="p">,</span>
			 <span class="n">BIOS_EN</span> <span class="o">|</span> <span class="n">RAM_SZ_16KB</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set SEL_MASK Microcode Default Value</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode will set the SEL_MASK register using this value</span>
<span class="cm">	 * after it is started below.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_DEFAULT_SEL_MASK</span><span class="p">,</span>
			 <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">));</span>

	<span class="n">AdvBuildCarrierFreelist</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set-up the Host-&gt;RISC Initiator Command Queue (ICQ).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_NO_CARRIER</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="p">)</span>
	    <span class="n">ADV_U32_TO_VADDR</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="o">-&gt;</span><span class="n">next_vpa</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * The first command issued will be placed in the stopper carrier.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="o">-&gt;</span><span class="n">next_vpa</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ASC_CQ_STOPPER</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set RISC ICQ physical address start value. Initialize the</span>
<span class="cm">	 * COMMA register to the same value otherwise the RISC will</span>
<span class="cm">	 * prematurely detect a command is available.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteDWordLramNoSwap</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_ICQ</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="o">-&gt;</span><span class="n">carr_pa</span><span class="p">);</span>
	<span class="n">AdvWriteDWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPDW_COMMA</span><span class="p">,</span>
			      <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="o">-&gt;</span><span class="n">carr_pa</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set-up the RISC-&gt;Host Initiator Response Queue (IRQ).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_NO_CARRIER</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="p">)</span>
	    <span class="n">ADV_U32_TO_VADDR</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span><span class="o">-&gt;</span><span class="n">next_vpa</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * The first command completed by the RISC will be placed in</span>
<span class="cm">	 * the stopper.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: Set &#39;next_vpa&#39; to ASC_CQ_STOPPER. When the request is</span>
<span class="cm">	 * completed the RISC will set the ASC_RQ_STOPPER bit.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span><span class="o">-&gt;</span><span class="n">next_vpa</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ASC_CQ_STOPPER</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set RISC IRQ physical address start value.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteDWordLramNoSwap</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_IRQ</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span><span class="o">-&gt;</span><span class="n">carr_pa</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_pending_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_INTR_ENABLES</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">ADV_INTR_ENABLE_HOST_INTR</span> <span class="o">|</span>
			      <span class="n">ADV_INTR_ENABLE_GLOBAL_INTR</span><span class="p">));</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_CODE_BEGIN_ADDR</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_PC</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>

	<span class="cm">/* finally, finally, gentlemen, start your engine */</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_RISC_CSR</span><span class="p">,</span> <span class="n">ADV_RISC_CSR_RUN</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus</span>
<span class="cm">	 * Resets should be performed. The RISC has to be running</span>
<span class="cm">	 * to issue a SCSI Bus Reset.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span> <span class="o">&amp;</span> <span class="n">BIOS_CTRL_RESET_SCSI_BUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the BIOS Signature is present in memory, restore the</span>
<span class="cm">		 * per TID microcode operating variables.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bios_mem</span><span class="p">[(</span><span class="n">ASC_MC_BIOS_SIGNATURE</span> <span class="o">-</span> <span class="n">ASC_MC_BIOSMEM</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span>
		    <span class="mh">0x55AA</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Restore per TID negotiated values.</span>
<span class="cm">			 */</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_ABLE</span><span class="p">,</span> <span class="n">wdtr_able</span><span class="p">);</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_ABLE</span><span class="p">,</span> <span class="n">sdtr_able</span><span class="p">);</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_PPR_ABLE</span><span class="p">,</span> <span class="n">ppr_able</span><span class="p">);</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_TAGQNG_ABLE</span><span class="p">,</span>
					 <span class="n">tagqng_able</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tid</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">tid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">AdvWriteByteLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						 <span class="n">ASC_MC_NUMBER_OF_MAX_CMD</span> <span class="o">+</span> <span class="n">tid</span><span class="p">,</span>
						 <span class="n">max_cmd</span><span class="p">[</span><span class="n">tid</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">AdvResetSB</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ADV_TRUE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">warn_code</span> <span class="o">=</span> <span class="n">ASC_WARN_BUSRESET_ERROR</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">warn_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reset chip and SCSI Bus.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *      ADV_TRUE(1) -   Chip re-initialization and SCSI Bus Reset successful.</span>
<span class="cm"> *      ADV_FALSE(0) -  Chip re-initialization and SCSI Bus Reset failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">AdvResetChipAndSB</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">wdtr_able</span><span class="p">,</span> <span class="n">sdtr_able</span><span class="p">,</span> <span class="n">tagqng_able</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">ppr_able</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">tid</span><span class="p">,</span> <span class="n">max_cmd</span><span class="p">[</span><span class="n">ADV_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">bios_sig</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save current per TID negotiated values.</span>
<span class="cm">	 */</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_ABLE</span><span class="p">,</span> <span class="n">wdtr_able</span><span class="p">);</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_ABLE</span><span class="p">,</span> <span class="n">sdtr_able</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C1600</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_PPR_ABLE</span><span class="p">,</span> <span class="n">ppr_able</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_TAGQNG_ABLE</span><span class="p">,</span> <span class="n">tagqng_able</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tid</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">tid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvReadByteLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_NUMBER_OF_MAX_CMD</span> <span class="o">+</span> <span class="n">tid</span><span class="p">,</span>
				<span class="n">max_cmd</span><span class="p">[</span><span class="n">tid</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Force the AdvInitAsc3550/38C0800Driver() function to</span>
<span class="cm">	 * perform a SCSI Bus Reset by clearing the BIOS signature word.</span>
<span class="cm">	 * The initialization functions assumes a SCSI Bus Reset is not</span>
<span class="cm">	 * needed if the BIOS signature word is present.</span>
<span class="cm">	 */</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_BIOS_SIGNATURE</span><span class="p">,</span> <span class="n">bios_sig</span><span class="p">);</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_BIOS_SIGNATURE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stop chip and reset it.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_RISC_CSR</span><span class="p">,</span> <span class="n">ADV_RISC_CSR_STOP</span><span class="p">);</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_CTRL_REG</span><span class="p">,</span> <span class="n">ADV_CTRL_REG_CMD_RESET</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_CTRL_REG</span><span class="p">,</span>
			     <span class="n">ADV_CTRL_REG_CMD_WR_IO_REG</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset Adv Library error code, if any, and try</span>
<span class="cm">	 * re-initializing the chip.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C1600</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">AdvInitAsc38C1600Driver</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">AdvInitAsc38C0800Driver</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">AdvInitAsc3550Driver</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Translate initialization return value to status value. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ADV_TRUE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ADV_FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore the BIOS signature word.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_BIOS_SIGNATURE</span><span class="p">,</span> <span class="n">bios_sig</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore per TID negotiated values.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_ABLE</span><span class="p">,</span> <span class="n">wdtr_able</span><span class="p">);</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_ABLE</span><span class="p">,</span> <span class="n">sdtr_able</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C1600</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_PPR_ABLE</span><span class="p">,</span> <span class="n">ppr_able</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_TAGQNG_ABLE</span><span class="p">,</span> <span class="n">tagqng_able</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tid</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">tid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AdvWriteByteLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_NUMBER_OF_MAX_CMD</span> <span class="o">+</span> <span class="n">tid</span><span class="p">,</span>
				 <span class="n">max_cmd</span><span class="p">[</span><span class="n">tid</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * adv_async_callback() - Adv Library asynchronous event callback function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">adv_async_callback</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">adv_dvc_varp</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ADV_ASYNC_SCSI_BUS_RESET_DET</span>:
		<span class="cm">/*</span>
<span class="cm">		 * The firmware detected a SCSI Bus reset.</span>
<span class="cm">		 */</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;ADV_ASYNC_SCSI_BUS_RESET_DET</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ADV_ASYNC_RDMA_FAILURE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Handle RDMA failure by resetting the SCSI Bus and</span>
<span class="cm">		 * possibly the chip if it is unresponsive. Log the error</span>
<span class="cm">		 * with a unique code.</span>
<span class="cm">		 */</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;ADV_ASYNC_RDMA_FAILURE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">AdvResetChipAndSB</span><span class="p">(</span><span class="n">adv_dvc_varp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ADV_HOST_SCSI_BUS_RESET</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Host generated SCSI bus reset occurred.</span>
<span class="cm">		 */</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;ADV_HOST_SCSI_BUS_RESET</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;unknown code 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * adv_isr_callback() - Second Level Interrupt Handler called by AdvISR().</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function for the Wide SCSI Adv Library.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">adv_isr_callback</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">adv_dvc_varp</span><span class="p">,</span> <span class="n">ADV_SCSI_REQ_Q</span> <span class="o">*</span><span class="n">scsiqp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span><span class="p">;</span>
	<span class="n">adv_req_t</span> <span class="o">*</span><span class="n">reqp</span><span class="p">;</span>
	<span class="n">adv_sgblk_t</span> <span class="o">*</span><span class="n">sgblkp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="n">ADV_DCNT</span> <span class="n">resid_cnt</span><span class="p">;</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;adv_dvc_varp 0x%lx, scsiqp 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">adv_dvc_varp</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">scsiqp</span><span class="p">);</span>
	<span class="n">ASC_DBG_PRT_ADV_SCSI_REQ_Q</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">scsiqp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the adv_req_t structure for the command that has been</span>
<span class="cm">	 * completed. The adv_req_t structure actually contains the</span>
<span class="cm">	 * completed ADV_SCSI_REQ_Q structure.</span>
<span class="cm">	 */</span>
	<span class="n">reqp</span> <span class="o">=</span> <span class="p">(</span><span class="n">adv_req_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ADV_U32_TO_VADDR</span><span class="p">(</span><span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">srb_ptr</span><span class="p">);</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;reqp 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">reqp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reqp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASC_PRINT</span><span class="p">(</span><span class="s">&quot;adv_isr_callback: reqp is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the struct scsi_cmnd structure and Scsi_Host structure for the</span>
<span class="cm">	 * command that has been completed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: The adv_req_t request structure and adv_sgblk_t structure,</span>
<span class="cm">	 * if any, are dropped, because a board structure pointer can not be</span>
<span class="cm">	 * determined.</span>
<span class="cm">	 */</span>
	<span class="n">scp</span> <span class="o">=</span> <span class="n">reqp</span><span class="o">-&gt;</span><span class="n">cmndp</span><span class="p">;</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;scp 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">scp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASC_PRINT</span>
		    <span class="p">(</span><span class="s">&quot;adv_isr_callback: scp is NULL; adv_req_t dropped.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASC_DBG_PRT_CDB</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">callback</span><span class="p">);</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;shost 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>

	<span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">adv_dvc_varp</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * &#39;done_status&#39; contains the command&#39;s ending status.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">done_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">QD_NO_ERROR</span>:
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;QD_NO_ERROR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check for an underrun condition.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If there was no error and an underrun condition, then</span>
<span class="cm">		 * then return the number of underrun bytes.</span>
<span class="cm">		 */</span>
		<span class="n">resid_cnt</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">data_cnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">resid_cnt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">resid_cnt</span> <span class="o">&lt;=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;underrun condition %lu bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">resid_cnt</span><span class="p">);</span>
			<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">scp</span><span class="p">,</span> <span class="n">resid_cnt</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">QD_WITH_ERROR</span>:
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;QD_WITH_ERROR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">QHSTA_NO_ERROR</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">==</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;SAM_STAT_CHECK_CONDITION</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">ASC_DBG_PRT_SENSE</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
						  <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * Note: The &#39;status_byte()&#39; macro used by</span>
<span class="cm">				 * target drivers defined in scsi.h shifts the</span>
<span class="cm">				 * status byte returned by host drivers right</span>
<span class="cm">				 * by 1 bit.  This is why target drivers also</span>
<span class="cm">				 * use right shifted status byte definitions.</span>
<span class="cm">				 * For instance target drivers use</span>
<span class="cm">				 * CHECK_CONDITION, defined to 0x1, instead of</span>
<span class="cm">				 * the SCSI defined check condition value of</span>
<span class="cm">				 * 0x2. Host drivers are supposed to return</span>
<span class="cm">				 * the status byte as it is defined by SCSI.</span>
<span class="cm">				 */</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DRIVER_BYTE</span><span class="p">(</span><span class="n">DRIVER_SENSE</span><span class="p">)</span> <span class="o">|</span>
				    <span class="n">STATUS_BYTE</span><span class="p">(</span><span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">STATUS_BYTE</span><span class="p">(</span><span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="cm">/* Some other QHSTA error occurred. */</span>
			<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;host_status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="p">);</span>
			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">HOST_BYTE</span><span class="p">(</span><span class="n">DID_BAD_TARGET</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">QD_ABORTED_BY_HOST</span>:
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;QD_ABORTED_BY_HOST</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span>
		    <span class="n">HOST_BYTE</span><span class="p">(</span><span class="n">DID_ABORT</span><span class="p">)</span> <span class="o">|</span> <span class="n">STATUS_BYTE</span><span class="p">(</span><span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;done_status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">done_status</span><span class="p">);</span>
		<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span>
		    <span class="n">HOST_BYTE</span><span class="p">(</span><span class="n">DID_ERROR</span><span class="p">)</span> <span class="o">|</span> <span class="n">STATUS_BYTE</span><span class="p">(</span><span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the &#39;init_tidmask&#39; bit isn&#39;t already set for the target and the</span>
<span class="cm">	 * current request finished normally, then set the bit for the target</span>
<span class="cm">	 * to indicate that a device is present.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">done_status</span> <span class="o">==</span> <span class="n">QD_NO_ERROR</span> <span class="o">&amp;&amp;</span>
	    <span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">QHSTA_NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">|=</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">asc_scsi_done</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Free all &#39;adv_sgblk_t&#39; structures allocated for the request.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">sgblkp</span> <span class="o">=</span> <span class="n">reqp</span><span class="o">-&gt;</span><span class="n">sgblkp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Remove &#39;sgblkp&#39; from the request list. */</span>
		<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">sgblkp</span> <span class="o">=</span> <span class="n">sgblkp</span><span class="o">-&gt;</span><span class="n">next_sgblkp</span><span class="p">;</span>

		<span class="cm">/* Add &#39;sgblkp&#39; to the board free list. */</span>
		<span class="n">sgblkp</span><span class="o">-&gt;</span><span class="n">next_sgblkp</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_sgblkp</span><span class="p">;</span>
		<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_sgblkp</span> <span class="o">=</span> <span class="n">sgblkp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Free the adv_req_t structure used with the command by adding</span>
<span class="cm">	 * it back to the board free list.</span>
<span class="cm">	 */</span>
	<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">next_reqp</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_reqp</span><span class="p">;</span>
	<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_reqp</span> <span class="o">=</span> <span class="n">reqp</span><span class="p">;</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Adv Library Interrupt Service Routine</span>
<span class="cm"> *</span>
<span class="cm"> *  This function is called by a driver&#39;s interrupt service routine.</span>
<span class="cm"> *  The function disables and re-enables interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> *  When a microcode idle command is completed, the ADV_DVC_VAR</span>
<span class="cm"> *  &#39;idle_cmd_done&#39; field is set to ADV_TRUE.</span>
<span class="cm"> *</span>
<span class="cm"> *  Note: AdvISR() can be called when interrupts are disabled or even</span>
<span class="cm"> *  when there is no hardware interrupt condition present. It will</span>
<span class="cm"> *  always check for completed idle commands and microcode requests.</span>
<span class="cm"> *  This is an important feature that shouldn&#39;t be changed because it</span>
<span class="cm"> *  allows commands to be completed from polling mode loops.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *   ADV_TRUE(1) - interrupt was pending</span>
<span class="cm"> *   ADV_FALSE(0) - no interrupt was pending</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">AdvISR</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">int_stat</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">target_bit</span><span class="p">;</span>
	<span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="n">free_carrp</span><span class="p">;</span>
	<span class="n">ADV_VADDR</span> <span class="n">irq_next_vpa</span><span class="p">;</span>
	<span class="n">ADV_SCSI_REQ_Q</span> <span class="o">*</span><span class="n">scsiq</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>

	<span class="cm">/* Reading the register clears the interrupt. */</span>
	<span class="n">int_stat</span> <span class="o">=</span> <span class="n">AdvReadByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_INTR_STATUS_REG</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">int_stat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ADV_INTR_STATUS_INTRA</span> <span class="o">|</span> <span class="n">ADV_INTR_STATUS_INTRB</span> <span class="o">|</span>
			 <span class="n">ADV_INTR_STATUS_INTRC</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ADV_FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Notify the driver of an asynchronous microcode condition by</span>
<span class="cm">	 * calling the adv_async_callback function. The function</span>
<span class="cm">	 * is passed the microcode ASC_MC_INTRB_CODE byte value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">int_stat</span> <span class="o">&amp;</span> <span class="n">ADV_INTR_STATUS_INTRB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uchar</span> <span class="n">intrb_code</span><span class="p">;</span>

		<span class="n">AdvReadByteLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_INTRB_CODE</span><span class="p">,</span> <span class="n">intrb_code</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span> <span class="o">||</span>
		    <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">intrb_code</span> <span class="o">==</span> <span class="n">ADV_ASYNC_CARRIER_READY_FAILURE</span> <span class="o">&amp;&amp;</span>
			    <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_pending_cnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_TICKLE</span><span class="p">,</span>
						     <span class="n">ADV_TICKLE_A</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
							     <span class="n">IOPB_TICKLE</span><span class="p">,</span>
							     <span class="n">ADV_TICKLE_NOP</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">adv_async_callback</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">intrb_code</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the IRQ stopper carrier contains a completed request.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(((</span><span class="n">irq_next_vpa</span> <span class="o">=</span>
		 <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span><span class="o">-&gt;</span><span class="n">next_vpa</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">ASC_RQ_DONE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get a pointer to the newly completed ADV_SCSI_REQ_Q structure.</span>
<span class="cm">		 * The RISC will have set &#39;areq_vpa&#39; to a virtual address.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The firmware will have copied the ASC_SCSI_REQ_Q.scsiq_ptr</span>
<span class="cm">		 * field to the carrier ADV_CARR_T.areq_vpa field. The conversion</span>
<span class="cm">		 * below complements the conversion of ASC_SCSI_REQ_Q.scsiq_ptr&#39;</span>
<span class="cm">		 * in AdvExeScsiQueue().</span>
<span class="cm">		 */</span>
		<span class="n">scsiq</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADV_SCSI_REQ_Q</span> <span class="o">*</span><span class="p">)</span>
		    <span class="n">ADV_U32_TO_VADDR</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span><span class="o">-&gt;</span><span class="n">areq_vpa</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Request finished with good status and the queue was not</span>
<span class="cm">		 * DMAed to host memory by the firmware. Set all status fields</span>
<span class="cm">		 * to indicate good status.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">irq_next_vpa</span> <span class="o">&amp;</span> <span class="n">ASC_RQ_GOOD</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">done_status</span> <span class="o">=</span> <span class="n">QD_NO_ERROR</span><span class="p">;</span>
			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">=</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">data_cnt</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Advance the stopper pointer to the next carrier</span>
<span class="cm">		 * ignoring the lower four bits. Free the previous</span>
<span class="cm">		 * stopper carrier.</span>
<span class="cm">		 */</span>
		<span class="n">free_carrp</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span><span class="p">;</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">irq_sp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="p">)</span>
		    <span class="n">ADV_U32_TO_VADDR</span><span class="p">(</span><span class="n">ASC_GET_CARRP</span><span class="p">(</span><span class="n">irq_next_vpa</span><span class="p">));</span>

		<span class="n">free_carrp</span><span class="o">-&gt;</span><span class="n">next_vpa</span> <span class="o">=</span>
		    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ADV_VADDR_TO_U32</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span><span class="p">));</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span> <span class="o">=</span> <span class="n">free_carrp</span><span class="p">;</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_pending_cnt</span><span class="o">--</span><span class="p">;</span>

		<span class="n">target_bit</span> <span class="o">=</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">target_id</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Clear request microcode control flag.</span>
<span class="cm">		 */</span>
		<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">cntl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Notify the driver of the completed request by passing</span>
<span class="cm">		 * the ADV_SCSI_REQ_Q pointer to its callback function.</span>
<span class="cm">		 */</span>
		<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">a_flag</span> <span class="o">|=</span> <span class="n">ADV_SCSIQ_DONE</span><span class="p">;</span>
		<span class="n">adv_isr_callback</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">scsiq</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note: After the driver callback function is called, &#39;scsiq&#39;</span>
<span class="cm">		 * can no longer be referenced.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Fall through and continue processing other completed</span>
<span class="cm">		 * requests...</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ADV_TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscSetLibErrorCode</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">err_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">err_code</span><span class="p">;</span>
		<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_ASCDVC_ERR_CODE_W</span><span class="p">,</span>
				 <span class="n">err_code</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">AscAckInterrupt</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uchar</span> <span class="n">host_flag</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">risc_flag</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">loop</span><span class="p">;</span>

	<span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">risc_flag</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_RISC_FLAG_B</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mh">0x7FFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">risc_flag</span> <span class="o">&amp;</span> <span class="n">ASC_RISC_FLAG_GEN_INT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">host_flag</span> <span class="o">=</span>
	    <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
			    <span class="n">ASCV_HOST_FLAG_B</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">ASC_HOST_FLAG_ACK_INT</span><span class="p">);</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HOST_FLAG_B</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">host_flag</span> <span class="o">|</span> <span class="n">ASC_HOST_FLAG_ACK_INT</span><span class="p">));</span>
	<span class="n">AscSetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">CIW_INT_ACK</span><span class="p">);</span>
	<span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">AscGetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CSW_INT_PENDING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscSetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">CIW_INT_ACK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HOST_FLAG_B</span><span class="p">,</span> <span class="n">host_flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">uchar</span> <span class="nf">AscGetSynPeriodIndex</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">syn_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">period_table</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">period_table</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_period_tbl</span><span class="p">;</span>
	<span class="n">max_index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_sdtr_index</span><span class="p">;</span>
	<span class="n">min_index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">min_sdtr_index</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">syn_time</span> <span class="o">&lt;=</span> <span class="n">period_table</span><span class="p">[</span><span class="n">max_index</span><span class="p">]))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">min_index</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">max_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">syn_time</span> <span class="o">&lt;=</span> <span class="n">period_table</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">max_index</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">max_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">uchar</span>
<span class="nf">AscMsgOutSDTR</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">sdtr_period</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">sdtr_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EXT_MSG</span> <span class="n">sdtr_buf</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sdtr_period_index</span><span class="p">;</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">sdtr_buf</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">EXTENDED_MESSAGE</span><span class="p">;</span>
	<span class="n">sdtr_buf</span><span class="p">.</span><span class="n">msg_len</span> <span class="o">=</span> <span class="n">MS_SDTR_LEN</span><span class="p">;</span>
	<span class="n">sdtr_buf</span><span class="p">.</span><span class="n">msg_req</span> <span class="o">=</span> <span class="n">EXTENDED_SDTR</span><span class="p">;</span>
	<span class="n">sdtr_buf</span><span class="p">.</span><span class="n">xfer_period</span> <span class="o">=</span> <span class="n">sdtr_period</span><span class="p">;</span>
	<span class="n">sdtr_offset</span> <span class="o">&amp;=</span> <span class="n">ASC_SYN_MAX_OFFSET</span><span class="p">;</span>
	<span class="n">sdtr_buf</span><span class="p">.</span><span class="n">req_ack_offset</span> <span class="o">=</span> <span class="n">sdtr_offset</span><span class="p">;</span>
	<span class="n">sdtr_period_index</span> <span class="o">=</span> <span class="n">AscGetSynPeriodIndex</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">sdtr_period</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdtr_period_index</span> <span class="o">&lt;=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_sdtr_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscMemWordCopyPtrToLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_MSGOUT_BEG</span><span class="p">,</span>
					<span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sdtr_buf</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">EXT_MSG</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">sdtr_period_index</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">sdtr_offset</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sdtr_buf</span><span class="p">.</span><span class="n">req_ack_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">AscMemWordCopyPtrToLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_MSGOUT_BEG</span><span class="p">,</span>
					<span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sdtr_buf</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">EXT_MSG</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">uchar</span>
<span class="nf">AscCalSDTRData</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">sdtr_period</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">syn_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uchar</span> <span class="n">byte</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sdtr_period_ix</span><span class="p">;</span>

	<span class="n">sdtr_period_ix</span> <span class="o">=</span> <span class="n">AscGetSynPeriodIndex</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">sdtr_period</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdtr_period_ix</span> <span class="o">&gt;</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_sdtr_index</span><span class="p">)</span>
		<span class="k">return</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdtr_period_ix</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">syn_offset</span> <span class="o">&amp;</span> <span class="n">ASC_SYN_MAX_OFFSET</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">byte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscSetChipSynRegAtID</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">id</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">sdtr_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">org_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sta</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

	<span class="n">AscSetBank</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">org_id</span> <span class="o">=</span> <span class="n">AscReadChipDvcID</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">org_id</span> <span class="o">==</span> <span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">org_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">ASC_SCSI_BIT_ID_TYPE</span><span class="p">)</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">AscWriteChipDvcID</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AscReadChipDvcID</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">AscSetBank</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">AscSetChipSyn</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">sdtr_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AscGetChipSyn</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sdtr_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sta</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sta</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">AscSetBank</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">AscWriteChipDvcID</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">org_id</span><span class="p">);</span>
	<span class="n">AscSetBank</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sta</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">AscSetChipSDTR</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">sdtr_data</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">tid_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AscSetChipSynRegAtID</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">tid_no</span><span class="p">,</span> <span class="n">sdtr_data</span><span class="p">);</span>
	<span class="n">AscPutMCodeSDTRDoneAtID</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">tid_no</span><span class="p">,</span> <span class="n">sdtr_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscIsrChipHalted</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EXT_MSG</span> <span class="n">ext_msg</span><span class="p">;</span>
	<span class="n">EXT_MSG</span> <span class="n">out_msg</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">halt_q_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sdtr_accept</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">int_halt_code</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">scsi_busy</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">target_id</span><span class="p">;</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">tag_code</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">q_status</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">halt_qp</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sdtr_data</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">target_ix</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">q_cntl</span><span class="p">,</span> <span class="n">tid_no</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">cur_dvc_qng</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">asyn_sdtr</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">scsi_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">drv_ptr</span><span class="p">);</span>
	<span class="n">boardp</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">drv_ptr</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">int_halt_code</span> <span class="o">=</span> <span class="n">AscReadLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HALTCODE_W</span><span class="p">);</span>

	<span class="n">halt_qp</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_CURCDB_B</span><span class="p">);</span>
	<span class="n">halt_q_addr</span> <span class="o">=</span> <span class="n">ASC_QNO_TO_QADDR</span><span class="p">(</span><span class="n">halt_qp</span><span class="p">);</span>
	<span class="n">target_ix</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">halt_q_addr</span> <span class="o">+</span>
					     <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_TARGET_IX</span><span class="p">));</span>
	<span class="n">q_cntl</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">halt_q_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_CNTL</span><span class="p">));</span>
	<span class="n">tid_no</span> <span class="o">=</span> <span class="n">ASC_TIX_TO_TID</span><span class="p">(</span><span class="n">target_ix</span><span class="p">);</span>
	<span class="n">target_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">ASC_TID_TO_TARGET_ID</span><span class="p">(</span><span class="n">tid_no</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer</span> <span class="o">&amp;</span> <span class="n">target_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asyn_sdtr</span> <span class="o">=</span> <span class="n">ASYN_SDTR_DATA_FIX_PCI_REV_AB</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">asyn_sdtr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">int_halt_code</span> <span class="o">==</span> <span class="n">ASC_HALT_DISABLE_ASYN_USE_SYN_FIX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer</span> <span class="o">&amp;</span> <span class="n">target_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">AscSetChipSDTR</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tid_no</span><span class="p">);</span>
			<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">sdtr_data</span><span class="p">[</span><span class="n">tid_no</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HALTCODE_W</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">int_halt_code</span> <span class="o">==</span> <span class="n">ASC_HALT_ENABLE_ASYN_USE_SYN_FIX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer</span> <span class="o">&amp;</span> <span class="n">target_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">AscSetChipSDTR</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">asyn_sdtr</span><span class="p">,</span> <span class="n">tid_no</span><span class="p">);</span>
			<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">sdtr_data</span><span class="p">[</span><span class="n">tid_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">asyn_sdtr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HALTCODE_W</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">int_halt_code</span> <span class="o">==</span> <span class="n">ASC_HALT_EXTMSG_IN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscMemWordCopyPtrFromLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					  <span class="n">ASCV_MSGIN_BEG</span><span class="p">,</span>
					  <span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ext_msg</span><span class="p">,</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="n">EXT_MSG</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ext_msg</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">==</span> <span class="n">EXTENDED_MESSAGE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ext_msg</span><span class="p">.</span><span class="n">msg_req</span> <span class="o">==</span> <span class="n">EXTENDED_SDTR</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ext_msg</span><span class="p">.</span><span class="n">msg_len</span> <span class="o">==</span> <span class="n">MS_SDTR_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdtr_accept</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ext_msg</span><span class="p">.</span><span class="n">req_ack_offset</span> <span class="o">&gt;</span> <span class="n">ASC_SYN_MAX_OFFSET</span><span class="p">))</span> <span class="p">{</span>

				<span class="n">sdtr_accept</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
				<span class="n">ext_msg</span><span class="p">.</span><span class="n">req_ack_offset</span> <span class="o">=</span> <span class="n">ASC_SYN_MAX_OFFSET</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ext_msg</span><span class="p">.</span><span class="n">xfer_period</span> <span class="o">&lt;</span>
			     <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_period_tbl</span><span class="p">[</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">min_sdtr_index</span><span class="p">])</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">ext_msg</span><span class="p">.</span><span class="n">xfer_period</span> <span class="o">&gt;</span>
				<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_period_tbl</span><span class="p">[</span><span class="n">asc_dvc</span><span class="o">-&gt;</span>
							 <span class="n">max_sdtr_index</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">sdtr_accept</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
				<span class="n">ext_msg</span><span class="p">.</span><span class="n">xfer_period</span> <span class="o">=</span>
				    <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_period_tbl</span><span class="p">[</span><span class="n">asc_dvc</span><span class="o">-&gt;</span>
							     <span class="n">min_sdtr_index</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sdtr_accept</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sdtr_data</span> <span class="o">=</span>
				    <span class="n">AscCalSDTRData</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">ext_msg</span><span class="p">.</span><span class="n">xfer_period</span><span class="p">,</span>
						   <span class="n">ext_msg</span><span class="p">.</span><span class="n">req_ack_offset</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">sdtr_data</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">))</span> <span class="p">{</span>

					<span class="n">q_cntl</span> <span class="o">|=</span> <span class="n">QC_MSG_OUT</span><span class="p">;</span>
					<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_id</span><span class="p">;</span>
					<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_done</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_id</span><span class="p">;</span>
					<span class="n">AscSetChipSDTR</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">asyn_sdtr</span><span class="p">,</span>
						       <span class="n">tid_no</span><span class="p">);</span>
					<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">sdtr_data</span><span class="p">[</span><span class="n">tid_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">asyn_sdtr</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ext_msg</span><span class="p">.</span><span class="n">req_ack_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

				<span class="n">q_cntl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">QC_MSG_OUT</span><span class="p">;</span>
				<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_id</span><span class="p">;</span>
				<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_done</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_id</span><span class="p">;</span>
				<span class="n">AscSetChipSDTR</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">asyn_sdtr</span><span class="p">,</span> <span class="n">tid_no</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sdtr_accept</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">q_cntl</span> <span class="o">&amp;</span> <span class="n">QC_MSG_OUT</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">q_cntl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">QC_MSG_OUT</span><span class="p">;</span>
					<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_done</span> <span class="o">|=</span> <span class="n">target_id</span><span class="p">;</span>
					<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">|=</span> <span class="n">target_id</span><span class="p">;</span>
					<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer</span> <span class="o">&amp;=</span>
					    <span class="o">~</span><span class="n">target_id</span><span class="p">;</span>
					<span class="n">sdtr_data</span> <span class="o">=</span>
					    <span class="n">AscCalSDTRData</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span>
							   <span class="n">ext_msg</span><span class="p">.</span><span class="n">xfer_period</span><span class="p">,</span>
							   <span class="n">ext_msg</span><span class="p">.</span>
							   <span class="n">req_ack_offset</span><span class="p">);</span>
					<span class="n">AscSetChipSDTR</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">sdtr_data</span><span class="p">,</span>
						       <span class="n">tid_no</span><span class="p">);</span>
					<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">sdtr_data</span><span class="p">[</span><span class="n">tid_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">sdtr_data</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">q_cntl</span> <span class="o">|=</span> <span class="n">QC_MSG_OUT</span><span class="p">;</span>
					<span class="n">AscMsgOutSDTR</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span>
						      <span class="n">ext_msg</span><span class="p">.</span><span class="n">xfer_period</span><span class="p">,</span>
						      <span class="n">ext_msg</span><span class="p">.</span><span class="n">req_ack_offset</span><span class="p">);</span>
					<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer</span> <span class="o">&amp;=</span>
					    <span class="o">~</span><span class="n">target_id</span><span class="p">;</span>
					<span class="n">sdtr_data</span> <span class="o">=</span>
					    <span class="n">AscCalSDTRData</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span>
							   <span class="n">ext_msg</span><span class="p">.</span><span class="n">xfer_period</span><span class="p">,</span>
							   <span class="n">ext_msg</span><span class="p">.</span>
							   <span class="n">req_ack_offset</span><span class="p">);</span>
					<span class="n">AscSetChipSDTR</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">sdtr_data</span><span class="p">,</span>
						       <span class="n">tid_no</span><span class="p">);</span>
					<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">sdtr_data</span><span class="p">[</span><span class="n">tid_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">sdtr_data</span><span class="p">;</span>
					<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_done</span> <span class="o">|=</span> <span class="n">target_id</span><span class="p">;</span>
					<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">|=</span> <span class="n">target_id</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">halt_q_addr</span> <span class="o">+</span>
						  <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_CNTL</span><span class="p">),</span>
					 <span class="n">q_cntl</span><span class="p">);</span>
			<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HALTCODE_W</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ext_msg</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">==</span> <span class="n">EXTENDED_MESSAGE</span> <span class="o">&amp;&amp;</span>
			   <span class="n">ext_msg</span><span class="p">.</span><span class="n">msg_req</span> <span class="o">==</span> <span class="n">EXTENDED_WDTR</span> <span class="o">&amp;&amp;</span>
			   <span class="n">ext_msg</span><span class="p">.</span><span class="n">msg_len</span> <span class="o">==</span> <span class="n">MS_WDTR_LEN</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">ext_msg</span><span class="p">.</span><span class="n">wdtr_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">AscMemWordCopyPtrToLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						<span class="n">ASCV_MSGOUT_BEG</span><span class="p">,</span>
						<span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ext_msg</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">EXT_MSG</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">q_cntl</span> <span class="o">|=</span> <span class="n">QC_MSG_OUT</span><span class="p">;</span>
			<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">halt_q_addr</span> <span class="o">+</span>
						  <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_CNTL</span><span class="p">),</span>
					 <span class="n">q_cntl</span><span class="p">);</span>
			<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HALTCODE_W</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

			<span class="n">ext_msg</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MESSAGE_REJECT</span><span class="p">;</span>
			<span class="n">AscMemWordCopyPtrToLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						<span class="n">ASCV_MSGOUT_BEG</span><span class="p">,</span>
						<span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ext_msg</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">EXT_MSG</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">q_cntl</span> <span class="o">|=</span> <span class="n">QC_MSG_OUT</span><span class="p">;</span>
			<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">halt_q_addr</span> <span class="o">+</span>
						  <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_CNTL</span><span class="p">),</span>
					 <span class="n">q_cntl</span><span class="p">);</span>
			<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HALTCODE_W</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">int_halt_code</span> <span class="o">==</span> <span class="n">ASC_HALT_CHK_CONDITION</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">q_cntl</span> <span class="o">|=</span> <span class="n">QC_REQ_SENSE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">&amp;</span> <span class="n">target_id</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_done</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_id</span><span class="p">;</span>

			<span class="n">sdtr_data</span> <span class="o">=</span> <span class="n">AscGetMCodeInitSDTRAtID</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">tid_no</span><span class="p">);</span>
			<span class="n">q_cntl</span> <span class="o">|=</span> <span class="n">QC_MSG_OUT</span><span class="p">;</span>
			<span class="n">AscMsgOutSDTR</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span>
				      <span class="n">asc_dvc</span><span class="o">-&gt;</span>
				      <span class="n">sdtr_period_tbl</span><span class="p">[(</span><span class="n">sdtr_data</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span>
						      <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span>
							      <span class="n">max_sdtr_index</span> <span class="o">-</span>
							      <span class="mi">1</span><span class="p">)],</span>
				      <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">sdtr_data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span>
					      <span class="n">ASC_SYN_MAX_OFFSET</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">halt_q_addr</span> <span class="o">+</span>
					  <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_CNTL</span><span class="p">),</span> <span class="n">q_cntl</span><span class="p">);</span>

		<span class="n">tag_code</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">halt_q_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span>
						    <span class="n">ASC_SCSIQ_B_TAG_CODE</span><span class="p">));</span>
		<span class="n">tag_code</span> <span class="o">&amp;=</span> <span class="mh">0xDC</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer</span> <span class="o">&amp;</span> <span class="n">target_id</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer_always</span> <span class="o">&amp;</span> <span class="n">target_id</span><span class="p">)</span>
		    <span class="p">)</span> <span class="p">{</span>

			<span class="n">tag_code</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ASC_TAG_FLAG_DISABLE_DISCONNECT</span>
				     <span class="o">|</span> <span class="n">ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX</span><span class="p">);</span>

		<span class="p">}</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">halt_q_addr</span> <span class="o">+</span>
					  <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_TAG_CODE</span><span class="p">),</span>
				 <span class="n">tag_code</span><span class="p">);</span>

		<span class="n">q_status</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">halt_q_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span>
						    <span class="n">ASC_SCSIQ_B_STATUS</span><span class="p">));</span>
		<span class="n">q_status</span> <span class="o">|=</span> <span class="p">(</span><span class="n">QS_READY</span> <span class="o">|</span> <span class="n">QS_BUSY</span><span class="p">);</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">halt_q_addr</span> <span class="o">+</span>
					  <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_STATUS</span><span class="p">),</span>
				 <span class="n">q_status</span><span class="p">);</span>

		<span class="n">scsi_busy</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASCV_SCSIBUSY_B</span><span class="p">);</span>
		<span class="n">scsi_busy</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_id</span><span class="p">;</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASCV_SCSIBUSY_B</span><span class="p">,</span> <span class="n">scsi_busy</span><span class="p">);</span>

		<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HALTCODE_W</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">int_halt_code</span> <span class="o">==</span> <span class="n">ASC_HALT_SDTR_REJECTED</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">AscMemWordCopyPtrFromLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					  <span class="n">ASCV_MSGOUT_BEG</span><span class="p">,</span>
					  <span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">out_msg</span><span class="p">,</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="n">EXT_MSG</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">out_msg</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">==</span> <span class="n">EXTENDED_MESSAGE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">out_msg</span><span class="p">.</span><span class="n">msg_len</span> <span class="o">==</span> <span class="n">MS_SDTR_LEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">out_msg</span><span class="p">.</span><span class="n">msg_req</span> <span class="o">==</span> <span class="n">EXTENDED_SDTR</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_id</span><span class="p">;</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_done</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_id</span><span class="p">;</span>
			<span class="n">AscSetChipSDTR</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">asyn_sdtr</span><span class="p">,</span> <span class="n">tid_no</span><span class="p">);</span>
			<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">sdtr_data</span><span class="p">[</span><span class="n">tid_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">asyn_sdtr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">q_cntl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">QC_MSG_OUT</span><span class="p">;</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">halt_q_addr</span> <span class="o">+</span>
					  <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_CNTL</span><span class="p">),</span> <span class="n">q_cntl</span><span class="p">);</span>
		<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HALTCODE_W</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">int_halt_code</span> <span class="o">==</span> <span class="n">ASC_HALT_SS_QUEUE_FULL</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">scsi_status</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					      <span class="p">(</span><span class="n">ushort</span><span class="p">)((</span><span class="n">ushort</span><span class="p">)</span><span class="n">halt_q_addr</span> <span class="o">+</span>
						       <span class="p">(</span><span class="n">ushort</span><span class="p">)</span>
						       <span class="n">ASC_SCSIQ_SCSI_STATUS</span><span class="p">));</span>
		<span class="n">cur_dvc_qng</span> <span class="o">=</span>
		    <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">ushort</span><span class="p">)((</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_QADR_BEG</span> <span class="o">+</span>
					     <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">target_ix</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cur_dvc_qng</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cur_dvc_qng</span><span class="p">[</span><span class="n">tid_no</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">scsi_busy</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						    <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASCV_SCSIBUSY_B</span><span class="p">);</span>
			<span class="n">scsi_busy</span> <span class="o">|=</span> <span class="n">target_id</span><span class="p">;</span>
			<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASCV_SCSIBUSY_B</span><span class="p">,</span> <span class="n">scsi_busy</span><span class="p">);</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">queue_full_or_busy</span> <span class="o">|=</span> <span class="n">target_id</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">scsi_status</span> <span class="o">==</span> <span class="n">SAM_STAT_TASK_SET_FULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cur_dvc_qng</span> <span class="o">&gt;</span> <span class="n">ASC_MIN_TAGGED_CMD</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">cur_dvc_qng</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">[</span><span class="n">tid_no</span><span class="p">]</span> <span class="o">=</span>
					    <span class="n">cur_dvc_qng</span><span class="p">;</span>

					<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
							 <span class="p">(</span><span class="n">ushort</span><span class="p">)((</span><span class="n">ushort</span><span class="p">)</span>
								  <span class="n">ASCV_MAX_DVC_QNG_BEG</span>
								  <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span>
								  <span class="n">tid_no</span><span class="p">),</span>
							 <span class="n">cur_dvc_qng</span><span class="p">);</span>

					<span class="cm">/*</span>
<span class="cm">					 * Set the device queue depth to the</span>
<span class="cm">					 * number of active requests when the</span>
<span class="cm">					 * QUEUE FULL condition was encountered.</span>
<span class="cm">					 */</span>
					<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">queue_full</span> <span class="o">|=</span> <span class="n">target_id</span><span class="p">;</span>
					<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">queue_full_cnt</span><span class="p">[</span><span class="n">tid_no</span><span class="p">]</span> <span class="o">=</span>
					    <span class="n">cur_dvc_qng</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HALTCODE_W</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#if CC_VERY_LONG_SG_LIST</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">int_halt_code</span> <span class="o">==</span> <span class="n">ASC_HALT_HOST_COPY_SG_LIST_TO_RISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uchar</span> <span class="n">q_no</span><span class="p">;</span>
		<span class="n">ushort</span> <span class="n">q_addr</span><span class="p">;</span>
		<span class="n">uchar</span> <span class="n">sg_wk_q_no</span><span class="p">;</span>
		<span class="n">uchar</span> <span class="n">first_sg_wk_q_no</span><span class="p">;</span>
		<span class="n">ASC_SCSI_Q</span> <span class="o">*</span><span class="n">scsiq</span><span class="p">;</span>	<span class="cm">/* Ptr to driver request. */</span>
		<span class="n">ASC_SG_HEAD</span> <span class="o">*</span><span class="n">sg_head</span><span class="p">;</span>	<span class="cm">/* Ptr to driver SG request. */</span>
		<span class="n">ASC_SG_LIST_Q</span> <span class="n">scsi_sg_q</span><span class="p">;</span>	<span class="cm">/* Structure written to queue. */</span>
		<span class="n">ushort</span> <span class="n">sg_list_dwords</span><span class="p">;</span>
		<span class="n">ushort</span> <span class="n">sg_entry_cnt</span><span class="p">;</span>
		<span class="n">uchar</span> <span class="n">next_qp</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">q_no</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASCV_REQ_SG_LIST_QP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q_no</span> <span class="o">==</span> <span class="n">ASC_QLINK_END</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">q_addr</span> <span class="o">=</span> <span class="n">ASC_QNO_TO_QADDR</span><span class="p">(</span><span class="n">q_no</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Convert the request&#39;s SRB pointer to a host ASC_SCSI_REQ</span>
<span class="cm">		 * structure pointer using a macro provided by the driver.</span>
<span class="cm">		 * The ASC_SCSI_REQ pointer provides a pointer to the</span>
<span class="cm">		 * host ASC_SG_HEAD structure.</span>
<span class="cm">		 */</span>
		<span class="cm">/* Read request&#39;s SRB pointer. */</span>
		<span class="n">scsiq</span> <span class="o">=</span> <span class="p">(</span><span class="n">ASC_SCSI_Q</span> <span class="o">*</span><span class="p">)</span>
		    <span class="n">ASC_SRB2SCSIQ</span><span class="p">(</span><span class="n">ASC_U32_TO_VADDR</span><span class="p">(</span><span class="n">AscReadLramDWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
								    <span class="p">(</span><span class="n">ushort</span><span class="p">)</span>
								    <span class="p">(</span><span class="n">q_addr</span> <span class="o">+</span>
								     <span class="n">ASC_SCSIQ_D_SRBPTR</span><span class="p">))));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get request&#39;s first and working SG queue.</span>
<span class="cm">		 */</span>
		<span class="n">sg_wk_q_no</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					     <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span>
						      <span class="n">ASC_SCSIQ_B_SG_WK_QP</span><span class="p">));</span>

		<span class="n">first_sg_wk_q_no</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						   <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span>
							    <span class="n">ASC_SCSIQ_B_FIRST_SG_WK_QP</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Reset request&#39;s working SG queue back to the</span>
<span class="cm">		 * first SG queue.</span>
<span class="cm">		 */</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span>
					  <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_SG_WK_QP</span><span class="p">),</span>
				 <span class="n">first_sg_wk_q_no</span><span class="p">);</span>

		<span class="n">sg_head</span> <span class="o">=</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">sg_head</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set sg_entry_cnt to the number of SG elements</span>
<span class="cm">		 * that will be completed on this interrupt.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note: The allocated SG queues contain ASC_MAX_SG_LIST - 1</span>
<span class="cm">		 * SG elements. The data_cnt and data_addr fields which</span>
<span class="cm">		 * add 1 to the SG element capacity are not used when</span>
<span class="cm">		 * restarting SG handling after a halt.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">remain_sg_entry_cnt</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ASC_MAX_SG_LIST</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sg_entry_cnt</span> <span class="o">=</span> <span class="n">ASC_MAX_SG_LIST</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Keep track of remaining number of SG elements that</span>
<span class="cm">			 * will need to be handled on the next interrupt.</span>
<span class="cm">			 */</span>
			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">remain_sg_entry_cnt</span> <span class="o">-=</span> <span class="p">(</span><span class="n">ASC_MAX_SG_LIST</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sg_entry_cnt</span> <span class="o">=</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">remain_sg_entry_cnt</span><span class="p">;</span>
			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">remain_sg_entry_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Copy SG elements into the list of allocated SG queues.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Last index completed is saved in scsiq-&gt;next_sg_index.</span>
<span class="cm">		 */</span>
		<span class="n">next_qp</span> <span class="o">=</span> <span class="n">first_sg_wk_q_no</span><span class="p">;</span>
		<span class="n">q_addr</span> <span class="o">=</span> <span class="n">ASC_QNO_TO_QADDR</span><span class="p">(</span><span class="n">next_qp</span><span class="p">);</span>
		<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">sg_head_qp</span> <span class="o">=</span> <span class="n">q_no</span><span class="p">;</span>
		<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">cntl</span> <span class="o">=</span> <span class="n">QCSG_SG_XFER_LIST</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">queue_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">seq_no</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sg_entry_cnt</span> <span class="o">&gt;</span> <span class="n">ASC_SG_LIST_PER_Q</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sg_list_dwords</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">ASC_SG_LIST_PER_Q</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
				<span class="n">sg_entry_cnt</span> <span class="o">-=</span> <span class="n">ASC_SG_LIST_PER_Q</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * After very first SG queue RISC FW uses next</span>
<span class="cm">				 * SG queue first element then checks sg_list_cnt</span>
<span class="cm">				 * against zero and then decrements, so set</span>
<span class="cm">				 * sg_list_cnt 1 less than number of SG elements</span>
<span class="cm">				 * in each SG queue.</span>
<span class="cm">				 */</span>
				<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">sg_list_cnt</span> <span class="o">=</span> <span class="n">ASC_SG_LIST_PER_Q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">sg_cur_list_cnt</span> <span class="o">=</span>
				    <span class="n">ASC_SG_LIST_PER_Q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * This is the last SG queue in the list of</span>
<span class="cm">				 * allocated SG queues. If there are more</span>
<span class="cm">				 * SG elements than will fit in the allocated</span>
<span class="cm">				 * queues, then set the QCSG_SG_XFER_MORE flag.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">remain_sg_entry_cnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">cntl</span> <span class="o">|=</span> <span class="n">QCSG_SG_XFER_MORE</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">cntl</span> <span class="o">|=</span> <span class="n">QCSG_SG_XFER_END</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* equals sg_entry_cnt * 2 */</span>
				<span class="n">sg_list_dwords</span> <span class="o">=</span> <span class="n">sg_entry_cnt</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">sg_list_cnt</span> <span class="o">=</span> <span class="n">sg_entry_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">sg_cur_list_cnt</span> <span class="o">=</span> <span class="n">sg_entry_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">sg_entry_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">q_no</span> <span class="o">=</span> <span class="n">next_qp</span><span class="p">;</span>
			<span class="n">AscMemWordCopyPtrToLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						<span class="n">q_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_SGHD_CPY_BEG</span><span class="p">,</span>
						<span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">scsi_sg_q</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">ASC_SG_LIST_Q</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

			<span class="n">AscMemDWordCopyPtrToLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						 <span class="n">q_addr</span> <span class="o">+</span> <span class="n">ASC_SGQ_LIST_BEG</span><span class="p">,</span>
						 <span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sg_head</span><span class="o">-&gt;</span>
						 <span class="n">sg_list</span><span class="p">[</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">next_sg_index</span><span class="p">],</span>
						 <span class="n">sg_list_dwords</span><span class="p">);</span>

			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">next_sg_index</span> <span class="o">+=</span> <span class="n">ASC_SG_LIST_PER_Q</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the just completed SG queue contained the</span>
<span class="cm">			 * last SG element, then no more SG queues need</span>
<span class="cm">			 * to be written.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">cntl</span> <span class="o">&amp;</span> <span class="n">QCSG_SG_XFER_END</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">next_qp</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						  <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span>
							   <span class="n">ASC_SCSIQ_B_FWD</span><span class="p">));</span>
			<span class="n">q_addr</span> <span class="o">=</span> <span class="n">ASC_QNO_TO_QADDR</span><span class="p">(</span><span class="n">next_qp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Clear the halt condition so the RISC will be restarted</span>
<span class="cm">		 * after the return.</span>
<span class="cm">		 */</span>
		<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HALTCODE_W</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CC_VERY_LONG_SG_LIST */</span><span class="cp"></span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * void</span>
<span class="cm"> * DvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)</span>
<span class="cm"> *</span>
<span class="cm"> * Calling/Exit State:</span>
<span class="cm"> *    none</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Input an ASC_QDONE_INFO structure from the chip</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">DvcGetQinfo</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">s_addr</span><span class="p">,</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">inbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">words</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">word</span><span class="p">;</span>

	<span class="n">AscSetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">s_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">inpw</span><span class="p">(</span><span class="n">iop_base</span> <span class="o">+</span> <span class="n">IOP_RAM_DATA</span><span class="p">);</span>
		<span class="n">inbuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">word</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">inbuf</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">word</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASC_DBG_PRT_HEX</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;DvcGetQinfo&quot;</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">words</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">uchar</span>
<span class="nf">_AscCopyLramScsiDoneQ</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span>
		      <span class="n">ushort</span> <span class="n">q_addr</span><span class="p">,</span>
		      <span class="n">ASC_QDONE_INFO</span> <span class="o">*</span><span class="n">scsiq</span><span class="p">,</span> <span class="n">ASC_DCNT</span> <span class="n">max_dma_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">_val</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sg_queue_cnt</span><span class="p">;</span>

	<span class="n">DvcGetQinfo</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
		    <span class="n">q_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_DONE_INFO_BEG</span><span class="p">,</span>
		    <span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="n">scsiq</span><span class="p">,</span>
		    <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ASC_SCSIQ_2</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ASC_SCSIQ_3</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">_val</span> <span class="o">=</span> <span class="n">AscReadLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_STATUS</span><span class="p">));</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q_status</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">_val</span><span class="p">;</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q_no</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">_val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">_val</span> <span class="o">=</span> <span class="n">AscReadLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_CNTL</span><span class="p">));</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">cntl</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">_val</span><span class="p">;</span>
	<span class="n">sg_queue_cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">_val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">_val</span> <span class="o">=</span> <span class="n">AscReadLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span>
					<span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_SENSE_LEN</span><span class="p">));</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">sense_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">_val</span><span class="p">;</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">extra_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">_val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read high word of remain bytes from alternate location.</span>
<span class="cm">	 */</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">remain_bytes</span> <span class="o">=</span> <span class="p">(((</span><span class="n">ADV_DCNT</span><span class="p">)</span><span class="n">AscReadLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
							  <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span>
								   <span class="p">(</span><span class="n">ushort</span><span class="p">)</span>
								   <span class="n">ASC_SCSIQ_W_ALT_DC1</span><span class="p">)))</span>
			       <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read low word of remain bytes from original location.</span>
<span class="cm">	 */</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">remain_bytes</span> <span class="o">+=</span> <span class="n">AscReadLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					       <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span>
							<span class="n">ASC_SCSIQ_DW_REMAIN_XFER_CNT</span><span class="p">));</span>

	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">remain_bytes</span> <span class="o">&amp;=</span> <span class="n">max_dma_count</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sg_queue_cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * asc_isr_callback() - Second Level Interrupt Handler called by AscISR().</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupt callback function for the Narrow SCSI Asc Library.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">asc_isr_callback</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc_varp</span><span class="p">,</span> <span class="n">ASC_QDONE_INFO</span> <span class="o">*</span><span class="n">qdonep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;asc_dvc_varp 0x%p, qdonep 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asc_dvc_varp</span><span class="p">,</span> <span class="n">qdonep</span><span class="p">);</span>
	<span class="n">ASC_DBG_PRT_ASC_QDONE_INFO</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">qdonep</span><span class="p">);</span>

	<span class="n">scp</span> <span class="o">=</span> <span class="n">advansys_srb_to_ptr</span><span class="p">(</span><span class="n">asc_dvc_varp</span><span class="p">,</span> <span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">d2</span><span class="p">.</span><span class="n">srb_ptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ASC_DBG_PRT_CDB</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">callback</span><span class="p">);</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;shost 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>

	<span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">asc_dvc_varp</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">);</span>

	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">dma_handle</span><span class="p">,</span>
			 <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * &#39;qdonep&#39; contains the command&#39;s ending status.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">done_stat</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">QD_NO_ERROR</span>:
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;QD_NO_ERROR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check for an underrun condition.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If there was no error and an underrun condition, then</span>
<span class="cm">		 * return the number of underrun bytes.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">remain_bytes</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">remain_bytes</span> <span class="o">&lt;=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;underrun condition %u bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">remain_bytes</span><span class="p">);</span>
			<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">scp</span><span class="p">,</span> <span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">remain_bytes</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">QD_WITH_ERROR</span>:
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;QD_WITH_ERROR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">host_stat</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">QHSTA_NO_ERROR</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">scsi_stat</span> <span class="o">==</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;SAM_STAT_CHECK_CONDITION</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">ASC_DBG_PRT_SENSE</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
						  <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * Note: The &#39;status_byte()&#39; macro used by</span>
<span class="cm">				 * target drivers defined in scsi.h shifts the</span>
<span class="cm">				 * status byte returned by host drivers right</span>
<span class="cm">				 * by 1 bit.  This is why target drivers also</span>
<span class="cm">				 * use right shifted status byte definitions.</span>
<span class="cm">				 * For instance target drivers use</span>
<span class="cm">				 * CHECK_CONDITION, defined to 0x1, instead of</span>
<span class="cm">				 * the SCSI defined check condition value of</span>
<span class="cm">				 * 0x2. Host drivers are supposed to return</span>
<span class="cm">				 * the status byte as it is defined by SCSI.</span>
<span class="cm">				 */</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DRIVER_BYTE</span><span class="p">(</span><span class="n">DRIVER_SENSE</span><span class="p">)</span> <span class="o">|</span>
				    <span class="n">STATUS_BYTE</span><span class="p">(</span><span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">scsi_stat</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">STATUS_BYTE</span><span class="p">(</span><span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">scsi_stat</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="cm">/* QHSTA error occurred */</span>
			<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;host_stat 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">host_stat</span><span class="p">);</span>
			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">HOST_BYTE</span><span class="p">(</span><span class="n">DID_BAD_TARGET</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">QD_ABORTED_BY_HOST</span>:
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;QD_ABORTED_BY_HOST</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span>
		    <span class="n">HOST_BYTE</span><span class="p">(</span><span class="n">DID_ABORT</span><span class="p">)</span> <span class="o">|</span> <span class="n">MSG_BYTE</span><span class="p">(</span><span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span>
						    <span class="n">scsi_msg</span><span class="p">)</span> <span class="o">|</span>
		    <span class="n">STATUS_BYTE</span><span class="p">(</span><span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">scsi_stat</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;done_stat 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">done_stat</span><span class="p">);</span>
		<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span>
		    <span class="n">HOST_BYTE</span><span class="p">(</span><span class="n">DID_ERROR</span><span class="p">)</span> <span class="o">|</span> <span class="n">MSG_BYTE</span><span class="p">(</span><span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span>
						    <span class="n">scsi_msg</span><span class="p">)</span> <span class="o">|</span>
		    <span class="n">STATUS_BYTE</span><span class="p">(</span><span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">scsi_stat</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the &#39;init_tidmask&#39; bit isn&#39;t already set for the target and the</span>
<span class="cm">	 * current request finished normally, then set the bit for the target</span>
<span class="cm">	 * to indicate that a device is present.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">&amp;</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">done_stat</span> <span class="o">==</span> <span class="n">QD_NO_ERROR</span> <span class="o">&amp;&amp;</span>
	    <span class="n">qdonep</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">host_stat</span> <span class="o">==</span> <span class="n">QHSTA_NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">|=</span> <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">asc_scsi_done</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscIsrQDone</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uchar</span> <span class="n">next_qp</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">n_q_used</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sg_list_qp</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sg_queue_cnt</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">q_cnt</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">done_q_tail</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">tid_no</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">scsi_busy</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">target_id</span><span class="p">;</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">q_addr</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">sg_q_addr</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">cur_target_qng</span><span class="p">;</span>
	<span class="n">ASC_QDONE_INFO</span> <span class="n">scsiq_buf</span><span class="p">;</span>
	<span class="n">ASC_QDONE_INFO</span> <span class="o">*</span><span class="n">scsiq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">false_overrun</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">n_q_used</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">scsiq</span> <span class="o">=</span> <span class="p">(</span><span class="n">ASC_QDONE_INFO</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">scsiq_buf</span><span class="p">;</span>
	<span class="n">done_q_tail</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">AscGetVarDoneQTail</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">q_addr</span> <span class="o">=</span> <span class="n">ASC_QNO_TO_QADDR</span><span class="p">(</span><span class="n">done_q_tail</span><span class="p">);</span>
	<span class="n">next_qp</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_FWD</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_qp</span> <span class="o">!=</span> <span class="n">ASC_QLINK_END</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscPutVarDoneQTail</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">next_qp</span><span class="p">);</span>
		<span class="n">q_addr</span> <span class="o">=</span> <span class="n">ASC_QNO_TO_QADDR</span><span class="p">(</span><span class="n">next_qp</span><span class="p">);</span>
		<span class="n">sg_queue_cnt</span> <span class="o">=</span> <span class="n">_AscCopyLramScsiDoneQ</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">q_addr</span><span class="p">,</span> <span class="n">scsiq</span><span class="p">,</span>
						     <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dma_count</span><span class="p">);</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span>
					  <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_STATUS</span><span class="p">),</span>
				 <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">scsiq</span><span class="o">-&gt;</span>
					 <span class="n">q_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="o">~</span><span class="p">(</span><span class="n">QS_READY</span> <span class="o">|</span>
							     <span class="n">QS_ABORTED</span><span class="p">)));</span>
		<span class="n">tid_no</span> <span class="o">=</span> <span class="n">ASC_TIX_TO_TID</span><span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d2</span><span class="p">.</span><span class="n">target_ix</span><span class="p">);</span>
		<span class="n">target_id</span> <span class="o">=</span> <span class="n">ASC_TIX_TO_TARGET_ID</span><span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d2</span><span class="p">.</span><span class="n">target_ix</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">cntl</span> <span class="o">&amp;</span> <span class="n">QC_SG_HEAD</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg_q_addr</span> <span class="o">=</span> <span class="n">q_addr</span><span class="p">;</span>
			<span class="n">sg_list_qp</span> <span class="o">=</span> <span class="n">next_qp</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">q_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">q_cnt</span> <span class="o">&lt;</span> <span class="n">sg_queue_cnt</span><span class="p">;</span> <span class="n">q_cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sg_list_qp</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
							     <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">sg_q_addr</span>
								      <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span>
								      <span class="n">ASC_SCSIQ_B_FWD</span><span class="p">));</span>
				<span class="n">sg_q_addr</span> <span class="o">=</span> <span class="n">ASC_QNO_TO_QADDR</span><span class="p">(</span><span class="n">sg_list_qp</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sg_list_qp</span> <span class="o">==</span> <span class="n">ASC_QLINK_END</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">AscSetLibErrorCode</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span>
							   <span class="n">ASCQ_ERR_SG_Q_LINKS</span><span class="p">);</span>
					<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">done_stat</span> <span class="o">=</span> <span class="n">QD_WITH_ERROR</span><span class="p">;</span>
					<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">host_stat</span> <span class="o">=</span>
					    <span class="n">QHSTA_D_QDONE_SG_LIST_CORRUPTED</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">FATAL_ERR_QDONE</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">sg_q_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span>
							  <span class="n">ASC_SCSIQ_B_STATUS</span><span class="p">),</span>
						 <span class="n">QS_FREE</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">n_q_used</span> <span class="o">=</span> <span class="n">sg_queue_cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">AscPutVarDoneQTail</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">sg_list_qp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">queue_full_or_busy</span> <span class="o">&amp;</span> <span class="n">target_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cur_target_qng</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
							 <span class="p">(</span><span class="n">ushort</span><span class="p">)((</span><span class="n">ushort</span><span class="p">)</span>
								  <span class="n">ASC_QADR_BEG</span>
								  <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span>
								  <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d2</span><span class="p">.</span>
								  <span class="n">target_ix</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur_target_qng</span> <span class="o">&lt;</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">[</span><span class="n">tid_no</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">scsi_busy</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span>
							    <span class="n">ASCV_SCSIBUSY_B</span><span class="p">);</span>
				<span class="n">scsi_busy</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_id</span><span class="p">;</span>
				<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						 <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASCV_SCSIBUSY_B</span><span class="p">,</span>
						 <span class="n">scsi_busy</span><span class="p">);</span>
				<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">queue_full_or_busy</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_id</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cur_total_qng</span> <span class="o">&gt;=</span> <span class="n">n_q_used</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cur_total_qng</span> <span class="o">-=</span> <span class="n">n_q_used</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cur_dvc_qng</span><span class="p">[</span><span class="n">tid_no</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cur_dvc_qng</span><span class="p">[</span><span class="n">tid_no</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">AscSetLibErrorCode</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">ASCQ_ERR_CUR_QNG</span><span class="p">);</span>
			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">done_stat</span> <span class="o">=</span> <span class="n">QD_WITH_ERROR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">FATAL_ERR_QDONE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d2</span><span class="p">.</span><span class="n">srb_ptr</span> <span class="o">==</span> <span class="mi">0UL</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q_status</span> <span class="o">&amp;</span> <span class="n">QS_ABORTED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="p">(</span><span class="mh">0x11</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q_status</span> <span class="o">==</span> <span class="n">QS_DONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">false_overrun</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">extra_bytes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">remain_bytes</span> <span class="o">+=</span>
				    <span class="p">(</span><span class="n">ADV_DCNT</span><span class="p">)</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">extra_bytes</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">done_stat</span> <span class="o">==</span> <span class="n">QD_WITH_ERROR</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">host_stat</span> <span class="o">==</span>
				    <span class="n">QHSTA_M_DATA_OVER_RUN</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">scsiq</span><span class="o">-&gt;</span>
					     <span class="n">cntl</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">QC_DATA_IN</span> <span class="o">|</span> <span class="n">QC_DATA_OUT</span><span class="p">))</span>
					    <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">done_stat</span> <span class="o">=</span>
						    <span class="n">QD_NO_ERROR</span><span class="p">;</span>
						<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">host_stat</span> <span class="o">=</span>
						    <span class="n">QHSTA_NO_ERROR</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">false_overrun</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">done_stat</span> <span class="o">=</span>
						    <span class="n">QD_NO_ERROR</span><span class="p">;</span>
						<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">host_stat</span> <span class="o">=</span>
						    <span class="n">QHSTA_NO_ERROR</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">host_stat</span> <span class="o">==</span>
					   <span class="n">QHSTA_M_HUNG_REQ_SCSI_BUS_RESET</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">AscStopChip</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
					<span class="n">AscSetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
							  <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">CC_SCSI_RESET</span>
								  <span class="o">|</span> <span class="n">CC_HALT</span><span class="p">));</span>
					<span class="n">udelay</span><span class="p">(</span><span class="mi">60</span><span class="p">);</span>
					<span class="n">AscSetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">CC_HALT</span><span class="p">);</span>
					<span class="n">AscSetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
							 <span class="n">CIW_CLR_SCSI_RESET_INT</span><span class="p">);</span>
					<span class="n">AscSetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="n">AscSetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">cntl</span> <span class="o">&amp;</span> <span class="n">QC_NO_CALLBACK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">asc_isr_callback</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">scsiq</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						     <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span>
							      <span class="n">ASC_SCSIQ_CDB_BEG</span><span class="p">))</span>
				     <span class="o">==</span> <span class="n">START_STOP</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">unit_not_ready</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_id</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">d3</span><span class="p">.</span><span class="n">done_stat</span> <span class="o">!=</span> <span class="n">QD_NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">start_motor</span> <span class="o">&amp;=</span>
						    <span class="o">~</span><span class="n">target_id</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">AscSetLibErrorCode</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">ASCQ_ERR_Q_STATUS</span><span class="p">);</span>
 <span class="nl">FATAL_ERR_QDONE:</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">cntl</span> <span class="o">&amp;</span> <span class="n">QC_NO_CALLBACK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">asc_isr_callback</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">scsiq</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscISR</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASC_CS_TYPE</span> <span class="n">chipstat</span><span class="p">;</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">saved_ram_addr</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">ctrl_reg</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">saved_ctrl_reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">int_pending</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">host_flag</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">int_pending</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">AscIsIntPending</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">int_pending</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_state</span> <span class="o">&amp;</span> <span class="n">ASC_INIT_STATE_END_LOAD_MC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ERR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">in_critical_cnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscSetLibErrorCode</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">ASCQ_ERR_ISR_ON_CRITICAL</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">is_in_int</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscSetLibErrorCode</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">ASCQ_ERR_ISR_RE_ENTRY</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">is_in_int</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="n">ctrl_reg</span> <span class="o">=</span> <span class="n">AscGetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">saved_ctrl_reg</span> <span class="o">=</span> <span class="n">ctrl_reg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">CC_SCSI_RESET</span> <span class="o">|</span> <span class="n">CC_CHIP_RESET</span> <span class="o">|</span>
				       <span class="n">CC_SINGLE_STEP</span> <span class="o">|</span> <span class="n">CC_DIAG</span> <span class="o">|</span> <span class="n">CC_TEST</span><span class="p">));</span>
	<span class="n">chipstat</span> <span class="o">=</span> <span class="n">AscGetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chipstat</span> <span class="o">&amp;</span> <span class="n">CSW_SCSI_RESET_LATCH</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ASC_IS_VL</span> <span class="o">|</span> <span class="n">ASC_IS_EISA</span><span class="p">)))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
			<span class="n">int_pending</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">saved_ctrl_reg</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="o">~</span><span class="n">CC_HALT</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">((</span><span class="n">AscGetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">CSW_SCSI_RESET_ACTIVE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">AscSetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">CC_CHIP_RESET</span> <span class="o">|</span> <span class="n">CC_HALT</span><span class="p">));</span>
			<span class="n">AscSetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">CC_HALT</span><span class="p">);</span>
			<span class="n">AscSetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">CIW_CLR_SCSI_RESET_INT</span><span class="p">);</span>
			<span class="n">AscSetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">chipstat</span> <span class="o">=</span> <span class="n">AscGetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">saved_ram_addr</span> <span class="o">=</span> <span class="n">AscGetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">host_flag</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				    <span class="n">ASCV_HOST_FLAG_B</span><span class="p">)</span> <span class="o">&amp;</span>
	    <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="o">~</span><span class="n">ASC_HOST_FLAG_IN_ISR</span><span class="p">);</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HOST_FLAG_B</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">host_flag</span> <span class="o">|</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">ASC_HOST_FLAG_IN_ISR</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">chipstat</span> <span class="o">&amp;</span> <span class="n">CSW_INT_PENDING</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">int_pending</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">AscAckInterrupt</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
		<span class="n">int_pending</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chipstat</span> <span class="o">&amp;</span> <span class="n">CSW_HALTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ctrl_reg</span> <span class="o">&amp;</span> <span class="n">CC_SINGLE_STEP</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">AscIsrChipHalted</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">)</span> <span class="o">==</span> <span class="n">ERR</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">ISR_REPORT_QDONE_FATAL_ERROR</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">saved_ctrl_reg</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="o">~</span><span class="n">CC_HALT</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="nl">ISR_REPORT_QDONE_FATAL_ERROR:</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">dvc_cntl</span> <span class="o">&amp;</span> <span class="n">ASC_CNTL_INT_MULTI_Q</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">while</span> <span class="p">(((</span><span class="n">status</span> <span class="o">=</span>
					 <span class="n">AscIsrQDone</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">do</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">=</span>
					     <span class="n">AscIsrQDone</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mh">0x11</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">int_pending</span> <span class="o">=</span> <span class="n">ERR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HOST_FLAG_B</span><span class="p">,</span> <span class="n">host_flag</span><span class="p">);</span>
	<span class="n">AscSetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">saved_ram_addr</span><span class="p">);</span>
	<span class="n">AscSetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">saved_ctrl_reg</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">is_in_int</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">int_pending</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * advansys_reset()</span>
<span class="cm"> *</span>
<span class="cm"> * Reset the bus associated with the command &#39;scp&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * This function runs its own thread. Interrupts must be blocked but</span>
<span class="cm"> * sleeping is allowed and no locking other than for host structures is</span>
<span class="cm"> * required. Returns SUCCESS or FAILED.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">advansys_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">scp</span><span class="p">);</span>

	<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">reset</span><span class="p">);</span>

	<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="s">&quot;SCSI bus reset started...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">;</span>

		<span class="cm">/* Reset the chip and SCSI bus. */</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;before AscInitAsc1000Driver()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">AscInitAsc1000Driver</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>

		<span class="cm">/* Refer to ASC_IERR_* definitions for meaning of &#39;err_code&#39;. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">||</span> <span class="o">!</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">overrun_dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="s">&quot;SCSI bus reset error: &quot;</span>
				    <span class="s">&quot;0x%x, status: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">,</span>
				    <span class="n">status</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="s">&quot;SCSI bus reset warning: &quot;</span>
				    <span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="s">&quot;SCSI bus reset &quot;</span>
				    <span class="s">&quot;successful</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;after AscInitAsc1000Driver()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the suggest reset bus flags are set, then reset the bus.</span>
<span class="cm">		 * Otherwise only reset the device.</span>
<span class="cm">		 */</span>
		<span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">adv_dvc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Reset the target&#39;s SCSI bus.</span>
<span class="cm">		 */</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;before AdvResetChipAndSB()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">AdvResetChipAndSB</span><span class="p">(</span><span class="n">adv_dvc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ASC_TRUE</span>:
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="s">&quot;SCSI bus reset &quot;</span>
				    <span class="s">&quot;successful</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ASC_FALSE</span>:
		<span class="nl">default:</span>
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="s">&quot;SCSI bus reset error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">AdvISR</span><span class="p">(</span><span class="n">adv_dvc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Save the time of the most recently completed reset. */</span>
	<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">last_reset</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;ret %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * advansys_biosparam()</span>
<span class="cm"> *</span>
<span class="cm"> * Translate disk drive geometry if the &quot;BIOS greater than 1 GB&quot;</span>
<span class="cm"> * support is enabled for a drive.</span>
<span class="cm"> *</span>
<span class="cm"> * ip (information pointer) is an int array with the following definition:</span>
<span class="cm"> * ip[0]: heads</span>
<span class="cm"> * ip[1]: sectors</span>
<span class="cm"> * ip[2]: cylinders</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">advansys_biosparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
		   <span class="n">sector_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ip</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;begin</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">biosparam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">.</span><span class="n">dvc_cntl</span> <span class="o">&amp;</span>
		     <span class="n">ASC_CNTL_BIOS_GT_1GB</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">capacity</span> <span class="o">&gt;</span> <span class="mh">0x200000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
			<span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
			<span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">.</span><span class="n">bios_ctrl</span> <span class="o">&amp;</span>
		     <span class="n">BIOS_CTRL_EXTENDED_XLAT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">capacity</span> <span class="o">&gt;</span> <span class="mh">0x200000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
			<span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
			<span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ip</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">capacity</span> <span class="o">/</span> <span class="p">(</span><span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * First-level interrupt handler.</span>
<span class="cm"> *</span>
<span class="cm"> * &#39;dev_id&#39; is a pointer to the interrupting adapter&#39;s Scsi_Host.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">advansys_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">irqreturn_t</span> <span class="n">result</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;boardp 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">boardp</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AscIsIntPending</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">io_port</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
			<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">);</span>
			<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;before AscISR()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">AscISR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;before AdvISR()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AdvISR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
			<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscHostReqRiscHalt</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">saved_stop_code</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">AscIsChipHalted</span><span class="p">(</span><span class="n">iop_base</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">saved_stop_code</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_STOP_CODE_B</span><span class="p">);</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_STOP_CODE_B</span><span class="p">,</span>
			 <span class="n">ASC_STOP_HOST_REQ_RISC_HALT</span> <span class="o">|</span> <span class="n">ASC_STOP_REQ_RISC_STOP</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AscIsChipHalted</span><span class="p">(</span><span class="n">iop_base</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_STOP_CODE_B</span><span class="p">,</span> <span class="n">saved_stop_code</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sta</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">AscSetRunChipSynRegAtID</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">tid_no</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">sdtr_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sta</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">AscHostReqRiscHalt</span><span class="p">(</span><span class="n">iop_base</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sta</span> <span class="o">=</span> <span class="n">AscSetChipSynRegAtID</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">tid_no</span><span class="p">,</span> <span class="n">sdtr_data</span><span class="p">);</span>
		<span class="n">AscStartChip</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sta</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">AscAsyncFix</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">type</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">tid_bits</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bug_fix_cntl</span> <span class="o">&amp;</span> <span class="n">ASC_BUG_FIX_ASYN_USE_SYN</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">&amp;</span> <span class="n">tid_bits</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_ROM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="s">&quot;HP &quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer_always</span> <span class="o">|=</span> <span class="n">tid_bits</span><span class="p">;</span>

	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer</span> <span class="o">|=</span> <span class="n">tid_bits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_PROCESSOR</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_SCANNER</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_ROM</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TAPE</span><span class="p">))</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">tid_bits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer</span> <span class="o">&amp;</span> <span class="n">tid_bits</span><span class="p">)</span>
		<span class="n">AscSetRunChipSynRegAtID</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
					<span class="n">ASYN_SDTR_DATA_FIX_PCI_REV_AB</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">advansys_narrow_slave_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">tid_bit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">orig_use_tagged_qng</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">use_tagged_qng</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">orig_init_sdtr</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_sdtr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">sdtr_enable</span> <span class="o">&amp;</span> <span class="n">tid_bit</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdtr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">|=</span> <span class="n">tid_bit</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">tid_bit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">orig_init_sdtr</span> <span class="o">!=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_sdtr</span><span class="p">)</span>
			<span class="n">AscAsyncFix</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">sdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">cmd_qng_enabled</span> <span class="o">&amp;</span> <span class="n">tid_bit</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">can_tagged_qng</span> <span class="o">|=</span> <span class="n">tid_bit</span><span class="p">;</span>
				<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">use_tagged_qng</span> <span class="o">|=</span> <span class="n">tid_bit</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">MSG_ORDERED_TAG</span><span class="p">,</span>
						<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">can_tagged_qng</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">tid_bit</span><span class="p">;</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">use_tagged_qng</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">tid_bit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">orig_use_tagged_qng</span> <span class="o">!=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">use_tagged_qng</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_DISC_ENABLE_B</span><span class="p">,</span>
				 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">);</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_USE_TAGGED_QNG_B</span><span class="p">,</span>
				 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">use_tagged_qng</span><span class="p">);</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_CAN_TAGGED_QNG_B</span><span class="p">,</span>
				 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">can_tagged_qng</span><span class="p">);</span>

		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">max_tag_qng</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">ASCV_MAX_DVC_QNG_BEG</span> <span class="o">+</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">),</span>
				 <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wide Transfers</span>
<span class="cm"> *</span>
<span class="cm"> * If the EEPROM enabled WDTR for the device and the device supports wide</span>
<span class="cm"> * bus (16 bit) transfers, then turn on the device&#39;s &#39;wdtr_able&#39; bit and</span>
<span class="cm"> * write the new value to the microcode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">advansys_wide_enable_wdtr</span><span class="p">(</span><span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">tidmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_word</span><span class="p">;</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_ABLE</span><span class="p">,</span> <span class="n">cfg_word</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cfg_word</span> <span class="o">&amp;</span> <span class="n">tidmask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cfg_word</span> <span class="o">|=</span> <span class="n">tidmask</span><span class="p">;</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_ABLE</span><span class="p">,</span> <span class="n">cfg_word</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the microcode SDTR and WDTR negotiation done indicators for</span>
<span class="cm">	 * the target to cause it to negotiate with the new setting set above.</span>
<span class="cm">	 * WDTR when accepted causes the target to enter asynchronous mode, so</span>
<span class="cm">	 * SDTR must be negotiated.</span>
<span class="cm">	 */</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_DONE</span><span class="p">,</span> <span class="n">cfg_word</span><span class="p">);</span>
	<span class="n">cfg_word</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">tidmask</span><span class="p">;</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_DONE</span><span class="p">,</span> <span class="n">cfg_word</span><span class="p">);</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_DONE</span><span class="p">,</span> <span class="n">cfg_word</span><span class="p">);</span>
	<span class="n">cfg_word</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">tidmask</span><span class="p">;</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_WDTR_DONE</span><span class="p">,</span> <span class="n">cfg_word</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Synchronous Transfers</span>
<span class="cm"> *</span>
<span class="cm"> * If the EEPROM enabled SDTR for the device and the device</span>
<span class="cm"> * supports synchronous transfers, then turn on the device&#39;s</span>
<span class="cm"> * &#39;sdtr_able&#39; bit. Write the new value to the microcode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">advansys_wide_enable_sdtr</span><span class="p">(</span><span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">tidmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_word</span><span class="p">;</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_ABLE</span><span class="p">,</span> <span class="n">cfg_word</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cfg_word</span> <span class="o">&amp;</span> <span class="n">tidmask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cfg_word</span> <span class="o">|=</span> <span class="n">tidmask</span><span class="p">;</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_ABLE</span><span class="p">,</span> <span class="n">cfg_word</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the microcode &quot;SDTR negotiation&quot; done indicator for the</span>
<span class="cm">	 * target to cause it to negotiate with the new setting set above.</span>
<span class="cm">	 */</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_DONE</span><span class="p">,</span> <span class="n">cfg_word</span><span class="p">);</span>
	<span class="n">cfg_word</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">tidmask</span><span class="p">;</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_SDTR_DONE</span><span class="p">,</span> <span class="n">cfg_word</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * PPR (Parallel Protocol Request) Capable</span>
<span class="cm"> *</span>
<span class="cm"> * If the device supports DT mode, then it must be PPR capable.</span>
<span class="cm"> * The PPR message will be used in place of the SDTR and WDTR</span>
<span class="cm"> * messages to negotiate synchronous speed and offset, transfer</span>
<span class="cm"> * width, and protocol options.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">advansys_wide_enable_ppr</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">adv_dvc</span><span class="p">,</span>
				<span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">tidmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_PPR_ABLE</span><span class="p">,</span> <span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">ppr_able</span><span class="p">);</span>
	<span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">ppr_able</span> <span class="o">|=</span> <span class="n">tidmask</span><span class="p">;</span>
	<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_PPR_ABLE</span><span class="p">,</span> <span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">ppr_able</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">advansys_wide_slave_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">adv_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AdvPortAddr</span> <span class="n">iop_base</span> <span class="o">=</span> <span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">tidmask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Handle WDTR, SDTR, and Tag Queuing. If the feature</span>
<span class="cm">		 * is enabled in the EEPROM and the device supports the</span>
<span class="cm">		 * feature, then enable it in the microcode.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">wdtr_able</span> <span class="o">&amp;</span> <span class="n">tidmask</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">wdtr</span><span class="p">)</span>
			<span class="n">advansys_wide_enable_wdtr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">tidmask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_able</span> <span class="o">&amp;</span> <span class="n">tidmask</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdtr</span><span class="p">)</span>
			<span class="n">advansys_wide_enable_sdtr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">tidmask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C1600</span> <span class="o">&amp;&amp;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ppr</span><span class="p">)</span>
			<span class="n">advansys_wide_enable_ppr</span><span class="p">(</span><span class="n">adv_dvc</span><span class="p">,</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">tidmask</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Tag Queuing is disabled for the BIOS which runs in polled</span>
<span class="cm">		 * mode and would see no benefit from Tag Queuing. Also by</span>
<span class="cm">		 * disabling Tag Queuing in the BIOS devices with Tag Queuing</span>
<span class="cm">		 * bugs will at least work with the BIOS.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">tagqng_able</span> <span class="o">&amp;</span> <span class="n">tidmask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_word</span><span class="p">;</span>
			<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_TAGQNG_ABLE</span><span class="p">,</span> <span class="n">cfg_word</span><span class="p">);</span>
			<span class="n">cfg_word</span> <span class="o">|=</span> <span class="n">tidmask</span><span class="p">;</span>
			<span class="n">AdvWriteWordLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MC_TAGQNG_ABLE</span><span class="p">,</span>
					 <span class="n">cfg_word</span><span class="p">);</span>
			<span class="n">AdvWriteByteLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					 <span class="n">ASC_MC_NUMBER_OF_MAX_CMD</span> <span class="o">+</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
					 <span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">tagqng_able</span> <span class="o">&amp;</span> <span class="n">tidmask</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">MSG_ORDERED_TAG</span><span class="p">,</span>
					<span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the number of commands to queue per device for the</span>
<span class="cm"> * specified host adapter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">advansys_slave_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span>
		<span class="n">advansys_narrow_slave_configure</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">advansys_wide_slave_configure</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__le32</span> <span class="nf">advansys_get_sense_buffer_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">board</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="n">scp</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
					     <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="n">dma_cache_sync</span><span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
		       <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">dma_handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asc_build_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">asc_scsi_q</span> <span class="o">*</span><span class="n">asc_scsi_q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_dvc_var</span> <span class="o">*</span><span class="n">asc_dvc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_sg</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">asc_scsi_q</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">asc_scsi_q</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Point the ASC_SCSI_Q to the &#39;struct scsi_cmnd&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">srb_ptr</span> <span class="o">=</span> <span class="n">advansys_ptr_to_srb</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">scp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">srb_ptr</span> <span class="o">==</span> <span class="n">BAD_SRB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">HOST_BYTE</span><span class="p">(</span><span class="n">DID_SOFT_ERROR</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ASC_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build the ASC_SCSI_Q request.</span>
<span class="cm">	 */</span>
	<span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">cdbptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
	<span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">target_id</span> <span class="o">=</span> <span class="n">ASC_TID_TO_TARGET_ID</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">target_lun</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">target_ix</span> <span class="o">=</span>
	    <span class="n">ASC_TIDLUN_TO_IX</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">sense_addr</span> <span class="o">=</span> <span class="n">advansys_get_sense_buffer_dma</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">sense_len</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are any outstanding requests for the current target,</span>
<span class="cm">	 * then every 255th request send an ORDERED request. This heuristic</span>
<span class="cm">	 * tries to retain the benefit of request sorting while preventing</span>
<span class="cm">	 * request starvation. 255 is the max number of tags or pending commands</span>
<span class="cm">	 * a device may have outstanding.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The request count is incremented below for every successfully</span>
<span class="cm">	 * started request.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cur_dvc_qng</span><span class="p">[</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">reqcnt</span><span class="p">[</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">%</span> <span class="mi">255</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">tag_code</span> <span class="o">=</span> <span class="n">MSG_ORDERED_TAG</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">tag_code</span> <span class="o">=</span> <span class="n">MSG_SIMPLE_TAG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Build ASC_SCSI_Q */</span>
	<span class="n">use_sg</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_sg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">sgcnt</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">slp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">asc_sg_head</span> <span class="o">*</span><span class="n">asc_sg_head</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">use_sg</span> <span class="o">&gt;</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="s">&quot;use_sg %d &gt; &quot;</span>
				<span class="s">&quot;sg_tablesize %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">,</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span><span class="p">);</span>
			<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">HOST_BYTE</span><span class="p">(</span><span class="n">DID_ERROR</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ASC_ERROR</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">asc_sg_head</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">sg_head</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">use_sg</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">asc_sg_list</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asc_sg_head</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">HOST_BYTE</span><span class="p">(</span><span class="n">DID_SOFT_ERROR</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ASC_ERROR</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">cntl</span> <span class="o">|=</span> <span class="n">QC_SG_HEAD</span><span class="p">;</span>
		<span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">sg_head</span> <span class="o">=</span> <span class="n">asc_sg_head</span><span class="p">;</span>
		<span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* This is a byte value, otherwise it would need to be swapped. */</span>
		<span class="n">asc_sg_head</span><span class="o">-&gt;</span><span class="n">entry_cnt</span> <span class="o">=</span> <span class="n">asc_scsi_q</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">sg_queue_cnt</span> <span class="o">=</span> <span class="n">use_sg</span><span class="p">;</span>
		<span class="n">ASC_STATS_ADD</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">xfer_elem</span><span class="p">,</span>
			      <span class="n">asc_sg_head</span><span class="o">-&gt;</span><span class="n">entry_cnt</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Convert scatter-gather list into ASC_SG_HEAD list.</span>
<span class="cm">		 */</span>
		<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">scp</span><span class="p">,</span> <span class="n">slp</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">,</span> <span class="n">sgcnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_sg_head</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">[</span><span class="n">sgcnt</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span>
			    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sg_dma_address</span><span class="p">(</span><span class="n">slp</span><span class="p">));</span>
			<span class="n">asc_sg_head</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">[</span><span class="n">sgcnt</span><span class="p">].</span><span class="n">bytes</span> <span class="o">=</span>
			    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sg_dma_len</span><span class="p">(</span><span class="n">slp</span><span class="p">));</span>
			<span class="n">ASC_STATS_ADD</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">xfer_sect</span><span class="p">,</span>
				      <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">sg_dma_len</span><span class="p">(</span><span class="n">slp</span><span class="p">),</span> <span class="mi">512</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">xfer_cnt</span><span class="p">);</span>

	<span class="n">ASC_DBG_PRT_ASC_SCSI_Q</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">asc_scsi_q</span><span class="p">);</span>
	<span class="n">ASC_DBG_PRT_CDB</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ASC_NOERROR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Build scatter-gather list for Adv Library (Wide Board).</span>
<span class="cm"> *</span>
<span class="cm"> * Additional ADV_SG_BLOCK structures will need to be allocated</span>
<span class="cm"> * if the total number of scatter-gather elements exceeds</span>
<span class="cm"> * NO_OF_SG_PER_BLOCK (15). The ADV_SG_BLOCK structures are</span>
<span class="cm"> * assumed to be physically contiguous.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *      ADV_SUCCESS(1) - SG List successfully created</span>
<span class="cm"> *      ADV_ERROR(-1) - SG List creation failed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">adv_get_sglist</span><span class="p">(</span><span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span><span class="p">,</span> <span class="n">adv_req_t</span> <span class="o">*</span><span class="n">reqp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">,</span>
	       <span class="kt">int</span> <span class="n">use_sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adv_sgblk_t</span> <span class="o">*</span><span class="n">sgblkp</span><span class="p">;</span>
	<span class="n">ADV_SCSI_REQ_Q</span> <span class="o">*</span><span class="n">scsiqp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">slp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sg_elem_cnt</span><span class="p">;</span>
	<span class="n">ADV_SG_BLOCK</span> <span class="o">*</span><span class="n">sg_block</span><span class="p">,</span> <span class="o">*</span><span class="n">prev_sg_block</span><span class="p">;</span>
	<span class="n">ADV_PADDR</span> <span class="n">sg_block_paddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">scsiqp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADV_SCSI_REQ_Q</span> <span class="o">*</span><span class="p">)</span><span class="n">ADV_32BALIGN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reqp</span><span class="o">-&gt;</span><span class="n">scsi_req_q</span><span class="p">);</span>
	<span class="n">slp</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="n">sg_elem_cnt</span> <span class="o">=</span> <span class="n">use_sg</span><span class="p">;</span>
	<span class="n">prev_sg_block</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">sgblkp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allocate a &#39;adv_sgblk_t&#39; structure from the board free</span>
<span class="cm">		 * list. One &#39;adv_sgblk_t&#39; structure holds NO_OF_SG_PER_BLOCK</span>
<span class="cm">		 * (15) scatter-gather elements.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sgblkp</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_sgblkp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;no free adv_sgblk_t</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">adv_build_nosg</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Allocation failed. Free &#39;adv_sgblk_t&#39; structures</span>
<span class="cm">			 * already allocated for the request.</span>
<span class="cm">			 */</span>
			<span class="k">while</span> <span class="p">((</span><span class="n">sgblkp</span> <span class="o">=</span> <span class="n">reqp</span><span class="o">-&gt;</span><span class="n">sgblkp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Remove &#39;sgblkp&#39; from the request list. */</span>
				<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">sgblkp</span> <span class="o">=</span> <span class="n">sgblkp</span><span class="o">-&gt;</span><span class="n">next_sgblkp</span><span class="p">;</span>

				<span class="cm">/* Add &#39;sgblkp&#39; to the board free list. */</span>
				<span class="n">sgblkp</span><span class="o">-&gt;</span><span class="n">next_sgblkp</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_sgblkp</span><span class="p">;</span>
				<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_sgblkp</span> <span class="o">=</span> <span class="n">sgblkp</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">ASC_BUSY</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Complete &#39;adv_sgblk_t&#39; board allocation. */</span>
		<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_sgblkp</span> <span class="o">=</span> <span class="n">sgblkp</span><span class="o">-&gt;</span><span class="n">next_sgblkp</span><span class="p">;</span>
		<span class="n">sgblkp</span><span class="o">-&gt;</span><span class="n">next_sgblkp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get 8 byte aligned virtual and physical addresses</span>
<span class="cm">		 * for the allocated ADV_SG_BLOCK structure.</span>
<span class="cm">		 */</span>
		<span class="n">sg_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADV_SG_BLOCK</span> <span class="o">*</span><span class="p">)</span><span class="n">ADV_8BALIGN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgblkp</span><span class="o">-&gt;</span><span class="n">sg_block</span><span class="p">);</span>
		<span class="n">sg_block_paddr</span> <span class="o">=</span> <span class="n">virt_to_bus</span><span class="p">(</span><span class="n">sg_block</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if this is the first &#39;adv_sgblk_t&#39; for the</span>
<span class="cm">		 * request.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reqp</span><span class="o">-&gt;</span><span class="n">sgblkp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Request&#39;s first scatter-gather block. */</span>
			<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">sgblkp</span> <span class="o">=</span> <span class="n">sgblkp</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Set ADV_SCSI_REQ_T ADV_SG_BLOCK virtual and physical</span>
<span class="cm">			 * address pointers.</span>
<span class="cm">			 */</span>
			<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">sg_list_ptr</span> <span class="o">=</span> <span class="n">sg_block</span><span class="p">;</span>
			<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">sg_real_addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sg_block_paddr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Request&#39;s second or later scatter-gather block. */</span>
			<span class="n">sgblkp</span><span class="o">-&gt;</span><span class="n">next_sgblkp</span> <span class="o">=</span> <span class="n">reqp</span><span class="o">-&gt;</span><span class="n">sgblkp</span><span class="p">;</span>
			<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">sgblkp</span> <span class="o">=</span> <span class="n">sgblkp</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Point the previous ADV_SG_BLOCK structure to</span>
<span class="cm">			 * the newly allocated ADV_SG_BLOCK structure.</span>
<span class="cm">			 */</span>
			<span class="n">prev_sg_block</span><span class="o">-&gt;</span><span class="n">sg_ptr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sg_block_paddr</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NO_OF_SG_PER_BLOCK</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg_block</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg_addr</span> <span class="o">=</span>
					<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sg_dma_address</span><span class="p">(</span><span class="n">slp</span><span class="p">));</span>
			<span class="n">sg_block</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg_count</span> <span class="o">=</span>
					<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sg_dma_len</span><span class="p">(</span><span class="n">slp</span><span class="p">));</span>
			<span class="n">ASC_STATS_ADD</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">xfer_sect</span><span class="p">,</span>
				      <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">sg_dma_len</span><span class="p">(</span><span class="n">slp</span><span class="p">),</span> <span class="mi">512</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">sg_elem_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Last ADV_SG_BLOCK and scatter-gather entry. */</span>
				<span class="n">sg_block</span><span class="o">-&gt;</span><span class="n">sg_cnt</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">sg_block</span><span class="o">-&gt;</span><span class="n">sg_ptr</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>	<span class="cm">/* Last ADV_SG_BLOCK in list. */</span>
				<span class="k">return</span> <span class="n">ADV_SUCCESS</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">slp</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sg_block</span><span class="o">-&gt;</span><span class="n">sg_cnt</span> <span class="o">=</span> <span class="n">NO_OF_SG_PER_BLOCK</span><span class="p">;</span>
		<span class="n">prev_sg_block</span> <span class="o">=</span> <span class="n">sg_block</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Build a request structure for the Adv Library (Wide Board).</span>
<span class="cm"> *</span>
<span class="cm"> * If an adv_req_t can not be allocated to issue the request,</span>
<span class="cm"> * then return ASC_BUSY. If an error occurs, then return ASC_ERROR.</span>
<span class="cm"> *</span>
<span class="cm"> * Multi-byte fields in the ASC_SCSI_REQ_Q that are used by the</span>
<span class="cm"> * microcode for DMA addresses or math operations are byte swapped</span>
<span class="cm"> * to little-endian order.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">adv_build_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">,</span>
	      <span class="n">ADV_SCSI_REQ_Q</span> <span class="o">**</span><span class="n">adv_scsiqpp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adv_req_t</span> <span class="o">*</span><span class="n">reqp</span><span class="p">;</span>
	<span class="n">ADV_SCSI_REQ_Q</span> <span class="o">*</span><span class="n">scsiqp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_sg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate an adv_req_t structure from the board to execute</span>
<span class="cm">	 * the command.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_reqp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;no free adv_req_t</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">adv_build_noreq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ASC_BUSY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">reqp</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_reqp</span><span class="p">;</span>
		<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_reqp</span> <span class="o">=</span> <span class="n">reqp</span><span class="o">-&gt;</span><span class="n">next_reqp</span><span class="p">;</span>
		<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">next_reqp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get 32-byte aligned ADV_SCSI_REQ_Q and ADV_SG_BLOCK pointers.</span>
<span class="cm">	 */</span>
	<span class="n">scsiqp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADV_SCSI_REQ_Q</span> <span class="o">*</span><span class="p">)</span><span class="n">ADV_32BALIGN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reqp</span><span class="o">-&gt;</span><span class="n">scsi_req_q</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the structure.</span>
<span class="cm">	 */</span>
	<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">cntl</span> <span class="o">=</span> <span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">scsi_cntl</span> <span class="o">=</span> <span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">done_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the ADV_SCSI_REQ_Q &#39;srb_ptr&#39; to point to the adv_req_t structure.</span>
<span class="cm">	 */</span>
	<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">srb_ptr</span> <span class="o">=</span> <span class="n">ADV_VADDR_TO_U32</span><span class="p">(</span><span class="n">reqp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the adv_req_t &#39;cmndp&#39; to point to the struct scsi_cmnd structure.</span>
<span class="cm">	 */</span>
	<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">cmndp</span> <span class="o">=</span> <span class="n">scp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build the ADV_SCSI_REQ_Q request.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Set CDB length and copy it to the request structure.  */</span>
	<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
	<span class="cm">/* Copy first 12 CDB bytes to cdb[]. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="cm">/* Copy last 4 CDB bytes, if present, to cdb16[]. */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">cdb16</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">target_id</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">target_lun</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>

	<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">sense_addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">virt_to_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">sense_len</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>

	<span class="cm">/* Build ADV_SCSI_REQ_Q */</span>

	<span class="n">use_sg</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_sg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Zero-length transfer */</span>
		<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">sgblkp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">data_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">vdata_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">data_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">sg_list_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">sg_real_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use_sg</span> <span class="o">&gt;</span> <span class="n">ADV_MAX_SG_LIST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="s">&quot;use_sg %d &gt; &quot;</span>
				   <span class="s">&quot;ADV_MAX_SG_LIST %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">,</span>
				   <span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span><span class="p">);</span>
			<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">HOST_BYTE</span><span class="p">(</span><span class="n">DID_ERROR</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Free the &#39;adv_req_t&#39; structure by adding it back</span>
<span class="cm">			 * to the board free list.</span>
<span class="cm">			 */</span>
			<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">next_reqp</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_reqp</span><span class="p">;</span>
			<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_reqp</span> <span class="o">=</span> <span class="n">reqp</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">ASC_ERROR</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">scsiqp</span><span class="o">-&gt;</span><span class="n">data_cnt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scp</span><span class="p">));</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">adv_get_sglist</span><span class="p">(</span><span class="n">boardp</span><span class="p">,</span> <span class="n">reqp</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">ADV_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Free the adv_req_t structure by adding it back to</span>
<span class="cm">			 * the board free list.</span>
<span class="cm">			 */</span>
			<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">next_reqp</span> <span class="o">=</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_reqp</span><span class="p">;</span>
			<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">adv_reqp</span> <span class="o">=</span> <span class="n">reqp</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ASC_STATS_ADD</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">xfer_elem</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">xfer_cnt</span><span class="p">);</span>

	<span class="n">ASC_DBG_PRT_ADV_SCSI_REQ_Q</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">scsiqp</span><span class="p">);</span>
	<span class="n">ASC_DBG_PRT_CDB</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="o">*</span><span class="n">adv_scsiqpp</span> <span class="o">=</span> <span class="n">scsiqp</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ASC_NOERROR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscSgListToQueue</span><span class="p">(</span><span class="kt">int</span> <span class="n">sg_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n_sg_list_qs</span><span class="p">;</span>

	<span class="n">n_sg_list_qs</span> <span class="o">=</span> <span class="p">((</span><span class="n">sg_list</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">ASC_SG_LIST_PER_Q</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">sg_list</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ASC_SG_LIST_PER_Q</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">n_sg_list_qs</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">n_sg_list_qs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">uint</span>
<span class="nf">AscGetNumOfFreeQueue</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">target_ix</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">n_qs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uint</span> <span class="n">cur_used_qs</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">cur_free_qs</span><span class="p">;</span>
	<span class="n">ASC_SCSI_BIT_ID_TYPE</span> <span class="n">target_id</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">tid_no</span><span class="p">;</span>

	<span class="n">target_id</span> <span class="o">=</span> <span class="n">ASC_TIX_TO_TARGET_ID</span><span class="p">(</span><span class="n">target_ix</span><span class="p">);</span>
	<span class="n">tid_no</span> <span class="o">=</span> <span class="n">ASC_TIX_TO_TID</span><span class="p">(</span><span class="n">target_ix</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">unit_not_ready</span> <span class="o">&amp;</span> <span class="n">target_id</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">queue_full_or_busy</span> <span class="o">&amp;</span> <span class="n">target_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_qs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur_used_qs</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cur_total_qng</span> <span class="o">+</span>
		    <span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">last_q_shortage</span> <span class="o">+</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">ASC_MIN_FREE_Q</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cur_used_qs</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cur_total_qng</span> <span class="o">+</span>
		    <span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">ASC_MIN_FREE_Q</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">uint</span><span class="p">)</span> <span class="p">(</span><span class="n">cur_used_qs</span> <span class="o">+</span> <span class="n">n_qs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur_free_qs</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">-</span> <span class="n">cur_used_qs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cur_dvc_qng</span><span class="p">[</span><span class="n">tid_no</span><span class="p">]</span> <span class="o">&gt;=</span>
		    <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">[</span><span class="n">tid_no</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">cur_free_qs</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_qs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">n_qs</span> <span class="o">&gt;</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">last_q_shortage</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">n_qs</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">-</span> <span class="n">ASC_MIN_FREE_Q</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">last_q_shortage</span> <span class="o">=</span> <span class="n">n_qs</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">uchar</span> <span class="nf">AscAllocFreeQueue</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">free_q_head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">q_addr</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">next_qp</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">q_status</span><span class="p">;</span>

	<span class="n">q_addr</span> <span class="o">=</span> <span class="n">ASC_QNO_TO_QADDR</span><span class="p">(</span><span class="n">free_q_head</span><span class="p">);</span>
	<span class="n">q_status</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					  <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span>
						   <span class="n">ASC_SCSIQ_B_STATUS</span><span class="p">));</span>
	<span class="n">next_qp</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_B_FWD</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">q_status</span> <span class="o">&amp;</span> <span class="n">QS_READY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">next_qp</span> <span class="o">!=</span> <span class="n">ASC_QLINK_END</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">next_qp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ASC_QLINK_END</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">uchar</span>
<span class="nf">AscAllocMultipleFreeQueue</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">free_q_head</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">n_free_q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uchar</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_free_q</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_q_head</span> <span class="o">=</span> <span class="n">AscAllocFreeQueue</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">free_q_head</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">free_q_head</span> <span class="o">==</span> <span class="n">ASC_QLINK_END</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">free_q_head</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * void</span>
<span class="cm"> * DvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)</span>
<span class="cm"> *</span>
<span class="cm"> * Calling/Exit State:</span>
<span class="cm"> *    none</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Output an ASC_SCSI_Q structure to the chip</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">DvcPutScsiQ</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">s_addr</span><span class="p">,</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">outbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">words</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ASC_DBG_PRT_HEX</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;DvcPutScsiQ&quot;</span><span class="p">,</span> <span class="n">outbuf</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">words</span><span class="p">);</span>
	<span class="n">AscSetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">s_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">outpw</span><span class="p">(</span><span class="n">iop_base</span> <span class="o">+</span> <span class="n">IOP_RAM_DATA</span><span class="p">,</span>
		      <span class="p">((</span><span class="n">ushort</span><span class="p">)</span><span class="n">outbuf</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">outbuf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscPutReadyQueue</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">ASC_SCSI_Q</span> <span class="o">*</span><span class="n">scsiq</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">q_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">q_addr</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">tid_no</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sdtr_data</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">syn_period_ix</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">syn_offset</span><span class="p">;</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">&amp;</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">target_id</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_done</span> <span class="o">&amp;</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">target_id</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tid_no</span> <span class="o">=</span> <span class="n">ASC_TIX_TO_TID</span><span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">target_ix</span><span class="p">);</span>
		<span class="n">sdtr_data</span> <span class="o">=</span> <span class="n">AscGetMCodeInitSDTRAtID</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">tid_no</span><span class="p">);</span>
		<span class="n">syn_period_ix</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">sdtr_data</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_sdtr_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">syn_offset</span> <span class="o">=</span> <span class="n">sdtr_data</span> <span class="o">&amp;</span> <span class="n">ASC_SYN_MAX_OFFSET</span><span class="p">;</span>
		<span class="n">AscMsgOutSDTR</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span>
			      <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_period_tbl</span><span class="p">[</span><span class="n">syn_period_ix</span><span class="p">],</span>
			      <span class="n">syn_offset</span><span class="p">);</span>
		<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">cntl</span> <span class="o">|=</span> <span class="n">QC_MSG_OUT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">q_addr</span> <span class="o">=</span> <span class="n">ASC_QNO_TO_QADDR</span><span class="p">(</span><span class="n">q_no</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">target_id</span> <span class="o">&amp;</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">use_tagged_qng</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">tag_code</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSG_SIMPLE_TAG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">QS_FREE</span><span class="p">;</span>
	<span class="n">AscMemWordCopyPtrToLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				<span class="n">q_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_CDB_BEG</span><span class="p">,</span>
				<span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">cdbptr</span><span class="p">,</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">cdb_len</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">DvcPutScsiQ</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
		    <span class="n">q_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_CPY_BEG</span><span class="p">,</span>
		    <span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">cntl</span><span class="p">,</span>
		    <span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ASC_SCSIQ_1</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ASC_SCSIQ_2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ASC_SCSIQ_B_STATUS</span><span class="p">),</span>
			 <span class="p">(</span><span class="n">ushort</span><span class="p">)(((</span><span class="n">ushort</span><span class="p">)</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span>
				   <span class="n">q_no</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">QS_READY</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">AscPutReadySgListQueue</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">ASC_SCSI_Q</span> <span class="o">*</span><span class="n">scsiq</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">q_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">ASC_SG_HEAD</span> <span class="o">*</span><span class="n">sg_head</span><span class="p">;</span>
	<span class="n">ASC_SG_LIST_Q</span> <span class="n">scsi_sg_q</span><span class="p">;</span>
	<span class="n">ASC_DCNT</span> <span class="n">saved_data_addr</span><span class="p">;</span>
	<span class="n">ASC_DCNT</span> <span class="n">saved_data_cnt</span><span class="p">;</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">sg_list_dwords</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">sg_index</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">sg_entry_cnt</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">q_addr</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">next_qp</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">sg_head</span> <span class="o">=</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">sg_head</span><span class="p">;</span>
	<span class="n">saved_data_addr</span> <span class="o">=</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_addr</span><span class="p">;</span>
	<span class="n">saved_data_cnt</span> <span class="o">=</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_cnt</span><span class="p">;</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ASC_PADDR</span><span class="p">)</span> <span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">ASC_DCNT</span><span class="p">)</span> <span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bytes</span><span class="p">;</span>
<span class="cp">#if CC_VERY_LONG_SG_LIST</span>
	<span class="cm">/*</span>
<span class="cm">	 * If sg_head-&gt;entry_cnt is greater than ASC_MAX_SG_LIST</span>
<span class="cm">	 * then not all SG elements will fit in the allocated queues.</span>
<span class="cm">	 * The rest of the SG elements will be copied when the RISC</span>
<span class="cm">	 * completes the SG elements that fit and halts.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">entry_cnt</span> <span class="o">&gt;</span> <span class="n">ASC_MAX_SG_LIST</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set sg_entry_cnt to be the number of SG elements that</span>
<span class="cm">		 * will fit in the allocated SG queues. It is minus 1, because</span>
<span class="cm">		 * the first SG element is handled above. ASC_MAX_SG_LIST is</span>
<span class="cm">		 * already inflated by 1 to account for this. For example it</span>
<span class="cm">		 * may be 50 which is 1 + 7 queues * 7 SG elements.</span>
<span class="cm">		 */</span>
		<span class="n">sg_entry_cnt</span> <span class="o">=</span> <span class="n">ASC_MAX_SG_LIST</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Keep track of remaining number of SG elements that will</span>
<span class="cm">		 * need to be handled from a_isr.c.</span>
<span class="cm">		 */</span>
		<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">remain_sg_entry_cnt</span> <span class="o">=</span>
		    <span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">entry_cnt</span> <span class="o">-</span> <span class="n">ASC_MAX_SG_LIST</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#endif </span><span class="cm">/* CC_VERY_LONG_SG_LIST */</span><span class="cp"></span>
		<span class="cm">/*</span>
<span class="cm">		 * Set sg_entry_cnt to be the number of SG elements that</span>
<span class="cm">		 * will fit in the allocated SG queues. It is minus 1, because</span>
<span class="cm">		 * the first SG element is handled above.</span>
<span class="cm">		 */</span>
		<span class="n">sg_entry_cnt</span> <span class="o">=</span> <span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">entry_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#if CC_VERY_LONG_SG_LIST</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CC_VERY_LONG_SG_LIST */</span><span class="cp"></span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sg_entry_cnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">cntl</span> <span class="o">|=</span> <span class="n">QC_SG_HEAD</span><span class="p">;</span>
		<span class="n">q_addr</span> <span class="o">=</span> <span class="n">ASC_QNO_TO_QADDR</span><span class="p">(</span><span class="n">q_no</span><span class="p">);</span>
		<span class="n">sg_index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">sg_queue_cnt</span> <span class="o">=</span> <span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">queue_cnt</span><span class="p">;</span>
		<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">sg_head_qp</span> <span class="o">=</span> <span class="n">q_no</span><span class="p">;</span>
		<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">cntl</span> <span class="o">=</span> <span class="n">QCSG_SG_XFER_LIST</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">queue_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">seq_no</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sg_entry_cnt</span> <span class="o">&gt;</span> <span class="n">ASC_SG_LIST_PER_Q</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sg_list_dwords</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">ASC_SG_LIST_PER_Q</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
				<span class="n">sg_entry_cnt</span> <span class="o">-=</span> <span class="n">ASC_SG_LIST_PER_Q</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">sg_list_cnt</span> <span class="o">=</span>
					    <span class="n">ASC_SG_LIST_PER_Q</span><span class="p">;</span>
					<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">sg_cur_list_cnt</span> <span class="o">=</span>
					    <span class="n">ASC_SG_LIST_PER_Q</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">sg_list_cnt</span> <span class="o">=</span>
					    <span class="n">ASC_SG_LIST_PER_Q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">sg_cur_list_cnt</span> <span class="o">=</span>
					    <span class="n">ASC_SG_LIST_PER_Q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#if CC_VERY_LONG_SG_LIST</span>
				<span class="cm">/*</span>
<span class="cm">				 * This is the last SG queue in the list of</span>
<span class="cm">				 * allocated SG queues. If there are more</span>
<span class="cm">				 * SG elements than will fit in the allocated</span>
<span class="cm">				 * queues, then set the QCSG_SG_XFER_MORE flag.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">entry_cnt</span> <span class="o">&gt;</span> <span class="n">ASC_MAX_SG_LIST</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">cntl</span> <span class="o">|=</span> <span class="n">QCSG_SG_XFER_MORE</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#endif </span><span class="cm">/* CC_VERY_LONG_SG_LIST */</span><span class="cp"></span>
					<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">cntl</span> <span class="o">|=</span> <span class="n">QCSG_SG_XFER_END</span><span class="p">;</span>
<span class="cp">#if CC_VERY_LONG_SG_LIST</span>
				<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CC_VERY_LONG_SG_LIST */</span><span class="cp"></span>
				<span class="n">sg_list_dwords</span> <span class="o">=</span> <span class="n">sg_entry_cnt</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">sg_list_cnt</span> <span class="o">=</span> <span class="n">sg_entry_cnt</span><span class="p">;</span>
					<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">sg_cur_list_cnt</span> <span class="o">=</span>
					    <span class="n">sg_entry_cnt</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">sg_list_cnt</span> <span class="o">=</span>
					    <span class="n">sg_entry_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">sg_cur_list_cnt</span> <span class="o">=</span>
					    <span class="n">sg_entry_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">sg_entry_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">next_qp</span> <span class="o">=</span> <span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						  <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">q_addr</span> <span class="o">+</span>
							   <span class="n">ASC_SCSIQ_B_FWD</span><span class="p">));</span>
			<span class="n">scsi_sg_q</span><span class="p">.</span><span class="n">q_no</span> <span class="o">=</span> <span class="n">next_qp</span><span class="p">;</span>
			<span class="n">q_addr</span> <span class="o">=</span> <span class="n">ASC_QNO_TO_QADDR</span><span class="p">(</span><span class="n">next_qp</span><span class="p">);</span>
			<span class="n">AscMemWordCopyPtrToLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						<span class="n">q_addr</span> <span class="o">+</span> <span class="n">ASC_SCSIQ_SGHD_CPY_BEG</span><span class="p">,</span>
						<span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">scsi_sg_q</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">ASC_SG_LIST_Q</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">AscMemDWordCopyPtrToLram</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
						 <span class="n">q_addr</span> <span class="o">+</span> <span class="n">ASC_SGQ_LIST_BEG</span><span class="p">,</span>
						 <span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sg_head</span><span class="o">-&gt;</span>
						 <span class="n">sg_list</span><span class="p">[</span><span class="n">sg_index</span><span class="p">],</span>
						 <span class="n">sg_list_dwords</span><span class="p">);</span>
			<span class="n">sg_index</span> <span class="o">+=</span> <span class="n">ASC_SG_LIST_PER_Q</span><span class="p">;</span>
			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">next_sg_index</span> <span class="o">=</span> <span class="n">sg_index</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">cntl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">QC_SG_HEAD</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sta</span> <span class="o">=</span> <span class="n">AscPutReadyQueue</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">scsiq</span><span class="p">,</span> <span class="n">q_no</span><span class="p">);</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_addr</span> <span class="o">=</span> <span class="n">saved_data_addr</span><span class="p">;</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_cnt</span> <span class="o">=</span> <span class="n">saved_data_cnt</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sta</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">AscSendScsiQueue</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">ASC_SCSI_Q</span> <span class="o">*</span><span class="n">scsiq</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">n_q_required</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">free_q_head</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">next_qp</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">tid_no</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">target_ix</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sta</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">target_ix</span> <span class="o">=</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">target_ix</span><span class="p">;</span>
	<span class="n">tid_no</span> <span class="o">=</span> <span class="n">ASC_TIX_TO_TID</span><span class="p">(</span><span class="n">target_ix</span><span class="p">);</span>
	<span class="n">sta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">free_q_head</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">AscGetVarFreeQHead</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_q_required</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next_qp</span> <span class="o">=</span> <span class="n">AscAllocMultipleFreeQueue</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">free_q_head</span><span class="p">,</span>
						    <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">n_q_required</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_qp</span> <span class="o">!=</span> <span class="n">ASC_QLINK_END</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">last_q_shortage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">queue_cnt</span> <span class="o">=</span> <span class="n">n_q_required</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">q_no</span> <span class="o">=</span> <span class="n">free_q_head</span><span class="p">;</span>
			<span class="n">sta</span> <span class="o">=</span> <span class="n">AscPutReadySgListQueue</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">scsiq</span><span class="p">,</span>
						     <span class="n">free_q_head</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n_q_required</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next_qp</span> <span class="o">=</span> <span class="n">AscAllocFreeQueue</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">free_q_head</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_qp</span> <span class="o">!=</span> <span class="n">ASC_QLINK_END</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">q_no</span> <span class="o">=</span> <span class="n">free_q_head</span><span class="p">;</span>
			<span class="n">sta</span> <span class="o">=</span> <span class="n">AscPutReadyQueue</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">scsiq</span><span class="p">,</span> <span class="n">free_q_head</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sta</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscPutVarFreeQHead</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">next_qp</span><span class="p">);</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cur_total_qng</span> <span class="o">+=</span> <span class="n">n_q_required</span><span class="p">;</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cur_dvc_qng</span><span class="p">[</span><span class="n">tid_no</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sta</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define ASC_SYN_OFFSET_ONE_DISABLE_LIST  16</span>
<span class="k">static</span> <span class="n">uchar</span> <span class="n">_syn_offset_one_disable_cmd</span><span class="p">[</span><span class="n">ASC_SYN_OFFSET_ONE_DISABLE_LIST</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">INQUIRY</span><span class="p">,</span>
	<span class="n">REQUEST_SENSE</span><span class="p">,</span>
	<span class="n">READ_CAPACITY</span><span class="p">,</span>
	<span class="n">READ_TOC</span><span class="p">,</span>
	<span class="n">MODE_SELECT</span><span class="p">,</span>
	<span class="n">MODE_SENSE</span><span class="p">,</span>
	<span class="n">MODE_SELECT_10</span><span class="p">,</span>
	<span class="n">MODE_SENSE_10</span><span class="p">,</span>
	<span class="mh">0xFF</span><span class="p">,</span>
	<span class="mh">0xFF</span><span class="p">,</span>
	<span class="mh">0xFF</span><span class="p">,</span>
	<span class="mh">0xFF</span><span class="p">,</span>
	<span class="mh">0xFF</span><span class="p">,</span>
	<span class="mh">0xFF</span><span class="p">,</span>
	<span class="mh">0xFF</span><span class="p">,</span>
	<span class="mh">0xFF</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscExeScsiQueue</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">ASC_SCSI_Q</span> <span class="o">*</span><span class="n">scsiq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_q_required</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">disable_syn_offset_one_fix</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">ASC_PADDR</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">sg_entry_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">sg_entry_cnt_minus_one</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">target_ix</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">tid_no</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">sdtr_data</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">extra_bytes</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">scsi_cmd</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">disable_cmd</span><span class="p">;</span>
	<span class="n">ASC_SG_HEAD</span> <span class="o">*</span><span class="n">sg_head</span><span class="p">;</span>
	<span class="n">ASC_DCNT</span> <span class="n">data_cnt</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">sg_head</span> <span class="o">=</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">sg_head</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ERR</span><span class="p">);</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">q_no</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">tag_code</span> <span class="o">&amp;</span> <span class="n">ASC_TAG_FLAG_EXTRA_BYTES</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">extra_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">target_ix</span> <span class="o">=</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">target_ix</span><span class="p">;</span>
	<span class="n">tid_no</span> <span class="o">=</span> <span class="n">ASC_TIX_TO_TID</span><span class="p">(</span><span class="n">target_ix</span><span class="p">);</span>
	<span class="n">n_q_required</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">cdbptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">&amp;</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">target_id</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_done</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">target_id</span><span class="p">;</span>
			<span class="n">sdtr_data</span> <span class="o">=</span> <span class="n">AscGetMCodeInitSDTRAtID</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">tid_no</span><span class="p">);</span>
			<span class="n">AscMsgOutSDTR</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span>
				      <span class="n">asc_dvc</span><span class="o">-&gt;</span>
				      <span class="n">sdtr_period_tbl</span><span class="p">[(</span><span class="n">sdtr_data</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span>
						      <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span>
							      <span class="n">max_sdtr_index</span> <span class="o">-</span>
							      <span class="mi">1</span><span class="p">)],</span>
				      <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">sdtr_data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span>
					      <span class="n">ASC_SYN_MAX_OFFSET</span><span class="p">));</span>
			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">cntl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">QC_MSG_OUT</span> <span class="o">|</span> <span class="n">QC_URGENT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">in_critical_cnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscSetLibErrorCode</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">ASCQ_ERR_CRITICAL_RE_ENTRY</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ERR</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">in_critical_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">cntl</span> <span class="o">&amp;</span> <span class="n">QC_SG_HEAD</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sg_entry_cnt</span> <span class="o">=</span> <span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">entry_cnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">in_critical_cnt</span><span class="o">--</span><span class="p">;</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">ERR</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#if !CC_VERY_LONG_SG_LIST</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sg_entry_cnt</span> <span class="o">&gt;</span> <span class="n">ASC_MAX_SG_LIST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">in_critical_cnt</span><span class="o">--</span><span class="p">;</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">ERR</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !CC_VERY_LONG_SG_LIST */</span><span class="cp"></span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sg_entry_cnt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_addr</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">ADV_PADDR</span><span class="p">)</span><span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">addr</span><span class="p">;</span>
			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_cnt</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">ADV_DCNT</span><span class="p">)</span><span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bytes</span><span class="p">;</span>
			<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">cntl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">QC_SG_HEAD</span> <span class="o">|</span> <span class="n">QC_SG_SWAP_QUEUE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">sg_entry_cnt_minus_one</span> <span class="o">=</span> <span class="n">sg_entry_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">scsi_cmd</span> <span class="o">=</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">cdbptr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">disable_syn_offset_one_fix</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer</span> <span class="o">&amp;</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">target_id</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer_always</span> <span class="o">&amp;</span> <span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">target_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">cntl</span> <span class="o">&amp;</span> <span class="n">QC_SG_HEAD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sg_entry_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">data_cnt</span> <span class="o">+=</span>
				    <span class="p">(</span><span class="n">ADV_DCNT</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span>
							  <span class="n">bytes</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">data_cnt</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_cnt</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data_cnt</span> <span class="o">!=</span> <span class="mi">0UL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data_cnt</span> <span class="o">&lt;</span> <span class="mi">512UL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">disable_syn_offset_one_fix</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ASC_SYN_OFFSET_ONE_DISABLE_LIST</span><span class="p">;</span>
				     <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">disable_cmd</span> <span class="o">=</span>
					    <span class="n">_syn_offset_one_disable_cmd</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">disable_cmd</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">scsi_cmd</span> <span class="o">==</span> <span class="n">disable_cmd</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">disable_syn_offset_one_fix</span> <span class="o">=</span>
						    <span class="n">TRUE</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disable_syn_offset_one_fix</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">tag_code</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSG_SIMPLE_TAG</span><span class="p">;</span>
		<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">tag_code</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX</span> <span class="o">|</span>
				       <span class="n">ASC_TAG_FLAG_DISABLE_DISCONNECT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">tag_code</span> <span class="o">&amp;=</span> <span class="mh">0x27</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">cntl</span> <span class="o">&amp;</span> <span class="n">QC_SG_HEAD</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bug_fix_cntl</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bug_fix_cntl</span> <span class="o">&amp;</span> <span class="n">ASC_BUG_FIX_IF_NOT_DWB</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">scsi_cmd</span> <span class="o">==</span> <span class="n">READ_6</span><span class="p">)</span> <span class="o">||</span>
				    <span class="p">(</span><span class="n">scsi_cmd</span> <span class="o">==</span> <span class="n">READ_10</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">addr</span> <span class="o">=</span>
					    <span class="p">(</span><span class="n">ADV_PADDR</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sg_head</span><span class="o">-&gt;</span>
								   <span class="n">sg_list</span>
								   <span class="p">[</span><span class="n">sg_entry_cnt_minus_one</span><span class="p">].</span>
								   <span class="n">addr</span><span class="p">)</span> <span class="o">+</span>
					    <span class="p">(</span><span class="n">ADV_DCNT</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sg_head</span><span class="o">-&gt;</span>
								  <span class="n">sg_list</span>
								  <span class="p">[</span><span class="n">sg_entry_cnt_minus_one</span><span class="p">].</span>
								  <span class="n">bytes</span><span class="p">);</span>
					<span class="n">extra_bytes</span> <span class="o">=</span>
					    <span class="p">(</span><span class="n">uchar</span><span class="p">)((</span><span class="n">ushort</span><span class="p">)</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x0003</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">extra_bytes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					    <span class="o">&amp;&amp;</span>
					    <span class="p">((</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span>
					      <span class="n">tag_code</span> <span class="o">&amp;</span>
					      <span class="n">ASC_TAG_FLAG_EXTRA_BYTES</span><span class="p">)</span>
					     <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">tag_code</span> <span class="o">|=</span>
						    <span class="n">ASC_TAG_FLAG_EXTRA_BYTES</span><span class="p">;</span>
						<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">extra_bytes</span> <span class="o">=</span>
						    <span class="n">extra_bytes</span><span class="p">;</span>
						<span class="n">data_cnt</span> <span class="o">=</span>
						    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sg_head</span><span class="o">-&gt;</span>
								<span class="n">sg_list</span>
								<span class="p">[</span><span class="n">sg_entry_cnt_minus_one</span><span class="p">].</span>
								<span class="n">bytes</span><span class="p">);</span>
						<span class="n">data_cnt</span> <span class="o">-=</span>
						    <span class="p">(</span><span class="n">ASC_DCNT</span><span class="p">)</span> <span class="n">extra_bytes</span><span class="p">;</span>
						<span class="n">sg_head</span><span class="o">-&gt;</span>
						    <span class="n">sg_list</span>
						    <span class="p">[</span><span class="n">sg_entry_cnt_minus_one</span><span class="p">].</span>
						    <span class="n">bytes</span> <span class="o">=</span>
						    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">data_cnt</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">entry_to_copy</span> <span class="o">=</span> <span class="n">sg_head</span><span class="o">-&gt;</span><span class="n">entry_cnt</span><span class="p">;</span>
<span class="cp">#if CC_VERY_LONG_SG_LIST</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set the sg_entry_cnt to the maximum possible. The rest of</span>
<span class="cm">		 * the SG elements will be copied when the RISC completes the</span>
<span class="cm">		 * SG elements that fit and halts.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sg_entry_cnt</span> <span class="o">&gt;</span> <span class="n">ASC_MAX_SG_LIST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg_entry_cnt</span> <span class="o">=</span> <span class="n">ASC_MAX_SG_LIST</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CC_VERY_LONG_SG_LIST */</span><span class="cp"></span>
		<span class="n">n_q_required</span> <span class="o">=</span> <span class="n">AscSgListToQueue</span><span class="p">(</span><span class="n">sg_entry_cnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">AscGetNumOfFreeQueue</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">target_ix</span><span class="p">,</span> <span class="n">n_q_required</span><span class="p">)</span> <span class="o">&gt;=</span>
		     <span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">n_q_required</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">((</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">cntl</span> <span class="o">&amp;</span> <span class="n">QC_URGENT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">sta</span> <span class="o">=</span>
			     <span class="n">AscSendScsiQueue</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">scsiq</span><span class="p">,</span>
					      <span class="n">n_q_required</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">in_critical_cnt</span><span class="o">--</span><span class="p">;</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">sta</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bug_fix_cntl</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bug_fix_cntl</span> <span class="o">&amp;</span> <span class="n">ASC_BUG_FIX_IF_NOT_DWB</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">scsi_cmd</span> <span class="o">==</span> <span class="n">READ_6</span><span class="p">)</span> <span class="o">||</span>
				    <span class="p">(</span><span class="n">scsi_cmd</span> <span class="o">==</span> <span class="n">READ_10</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">addr</span> <span class="o">=</span>
					    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_addr</span><span class="p">)</span> <span class="o">+</span>
					    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_cnt</span><span class="p">);</span>
					<span class="n">extra_bytes</span> <span class="o">=</span>
					    <span class="p">(</span><span class="n">uchar</span><span class="p">)((</span><span class="n">ushort</span><span class="p">)</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x0003</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">extra_bytes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					    <span class="o">&amp;&amp;</span>
					    <span class="p">((</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span>
					      <span class="n">tag_code</span> <span class="o">&amp;</span>
					      <span class="n">ASC_TAG_FLAG_EXTRA_BYTES</span><span class="p">)</span>
					     <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">data_cnt</span> <span class="o">=</span>
						    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span>
								<span class="n">data_cnt</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(((</span><span class="n">ushort</span><span class="p">)</span><span class="n">data_cnt</span> <span class="o">&amp;</span> <span class="mh">0x01FF</span><span class="p">)</span>
						    <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q2</span><span class="p">.</span><span class="n">tag_code</span> <span class="o">|=</span>
							    <span class="n">ASC_TAG_FLAG_EXTRA_BYTES</span><span class="p">;</span>
							<span class="n">data_cnt</span> <span class="o">-=</span> <span class="p">(</span><span class="n">ASC_DCNT</span><span class="p">)</span>
							    <span class="n">extra_bytes</span><span class="p">;</span>
							<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">data_cnt</span> <span class="o">=</span>
							    <span class="n">cpu_to_le32</span>
							    <span class="p">(</span><span class="n">data_cnt</span><span class="p">);</span>
							<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">extra_bytes</span> <span class="o">=</span>
							    <span class="n">extra_bytes</span><span class="p">;</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">n_q_required</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">AscGetNumOfFreeQueue</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">target_ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">q1</span><span class="p">.</span><span class="n">cntl</span> <span class="o">&amp;</span> <span class="n">QC_URGENT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">sta</span> <span class="o">=</span> <span class="n">AscSendScsiQueue</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">scsiq</span><span class="p">,</span>
						    <span class="n">n_q_required</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">in_critical_cnt</span><span class="o">--</span><span class="p">;</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">sta</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">in_critical_cnt</span><span class="o">--</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sta</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * AdvExeScsiQueue() - Send a request to the RISC microcode program.</span>
<span class="cm"> *</span>
<span class="cm"> *   Allocate a carrier structure, point the carrier to the ADV_SCSI_REQ_Q,</span>
<span class="cm"> *   add the carrier to the ICQ (Initiator Command Queue), and tickle the</span>
<span class="cm"> *   RISC to notify it a new command is ready to be executed.</span>
<span class="cm"> *</span>
<span class="cm"> * If &#39;done_status&#39; is not set to QD_DO_RETRY, then &#39;error_retry&#39; will be</span>
<span class="cm"> * set to SCSI_MAX_RETRY.</span>
<span class="cm"> *</span>
<span class="cm"> * Multi-byte fields in the ASC_SCSI_REQ_Q that are used by the microcode</span>
<span class="cm"> * for DMA addresses or math operations are byte swapped to little-endian</span>
<span class="cm"> * order.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *      ADV_SUCCESS(1) - The request was successfully queued.</span>
<span class="cm"> *      ADV_BUSY(0) -    Resource unavailable; Retry again after pending</span>
<span class="cm"> *                       request completes.</span>
<span class="cm"> *      ADV_ERROR(-1) -  Invalid ADV_SCSI_REQ_Q request structure</span>
<span class="cm"> *                       host IC error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">AdvExeScsiQueue</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="n">ADV_SCSI_REQ_Q</span> <span class="o">*</span><span class="n">scsiq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ADV_PADDR</span> <span class="n">req_paddr</span><span class="p">;</span>
	<span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="n">new_carrp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The ADV_SCSI_REQ_Q &#39;target_id&#39; field should never exceed ADV_MAX_TID.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">target_id</span> <span class="o">&gt;</span> <span class="n">ADV_MAX_TID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">=</span> <span class="n">QHSTA_M_INVALID_DEVICE</span><span class="p">;</span>
		<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">done_status</span> <span class="o">=</span> <span class="n">QD_WITH_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate a carrier ensuring at least one carrier always</span>
<span class="cm">	 * remains on the freelist and initialize fields.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">new_carrp</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ADV_BUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_freelist</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADV_CARR_T</span> <span class="o">*</span><span class="p">)</span>
	    <span class="n">ADV_U32_TO_VADDR</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">new_carrp</span><span class="o">-&gt;</span><span class="n">next_vpa</span><span class="p">));</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">carr_pending_cnt</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the carrier to be a stopper by setting &#39;next_vpa&#39;</span>
<span class="cm">	 * to the stopper value. The current stopper will be changed</span>
<span class="cm">	 * below to point to the new stopper.</span>
<span class="cm">	 */</span>
	<span class="n">new_carrp</span><span class="o">-&gt;</span><span class="n">next_vpa</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ASC_CQ_STOPPER</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the ADV_SCSI_REQ_Q done flag.</span>
<span class="cm">	 */</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">a_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ADV_SCSIQ_DONE</span><span class="p">;</span>

	<span class="n">req_paddr</span> <span class="o">=</span> <span class="n">virt_to_bus</span><span class="p">(</span><span class="n">scsiq</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">req_paddr</span> <span class="o">&amp;</span> <span class="mi">31</span><span class="p">);</span>
	<span class="cm">/* Wait for assertion before making little-endian */</span>
	<span class="n">req_paddr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">req_paddr</span><span class="p">);</span>

	<span class="cm">/* Save virtual and physical address of ADV_SCSI_REQ_Q and carrier. */</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">scsiq_ptr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ADV_VADDR_TO_U32</span><span class="p">(</span><span class="n">scsiq</span><span class="p">));</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">scsiq_rptr</span> <span class="o">=</span> <span class="n">req_paddr</span><span class="p">;</span>

	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">carr_va</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ADV_VADDR_TO_U32</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Every ADV_CARR_T.carr_pa is byte swapped to little-endian</span>
<span class="cm">	 * order during initialization.</span>
<span class="cm">	 */</span>
	<span class="n">scsiq</span><span class="o">-&gt;</span><span class="n">carr_pa</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="o">-&gt;</span><span class="n">carr_pa</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use the current stopper to send the ADV_SCSI_REQ_Q command to</span>
<span class="cm">	 * the microcode. The newly allocated stopper will become the new</span>
<span class="cm">	 * stopper.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="o">-&gt;</span><span class="n">areq_vpa</span> <span class="o">=</span> <span class="n">req_paddr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the &#39;next_vpa&#39; pointer for the old stopper to be the</span>
<span class="cm">	 * physical address of the new stopper. The RISC can only</span>
<span class="cm">	 * follow physical addresses.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span><span class="o">-&gt;</span><span class="n">next_vpa</span> <span class="o">=</span> <span class="n">new_carrp</span><span class="o">-&gt;</span><span class="n">carr_pa</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the host adapter stopper pointer to point to the new carrier.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">icq_sp</span> <span class="o">=</span> <span class="n">new_carrp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span> <span class="o">||</span>
	    <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Tickle the RISC to tell it to read its Command Queue Head pointer.</span>
<span class="cm">		 */</span>
		<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_TICKLE</span><span class="p">,</span> <span class="n">ADV_TICKLE_A</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Clear the tickle value. In the ASC-3550 the RISC flag</span>
<span class="cm">			 * command &#39;clr_tickle_a&#39; does not work unless the host</span>
<span class="cm">			 * value is cleared.</span>
<span class="cm">			 */</span>
			<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_TICKLE</span><span class="p">,</span>
					     <span class="n">ADV_TICKLE_NOP</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C1600</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Notify the RISC a carrier is ready by writing the physical</span>
<span class="cm">		 * address of the new carrier stopper to the COMMA register.</span>
<span class="cm">		 */</span>
		<span class="n">AdvWriteDWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPDW_COMMA</span><span class="p">,</span>
				      <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">new_carrp</span><span class="o">-&gt;</span><span class="n">carr_pa</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ADV_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Execute a single &#39;Scsi_Cmnd&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asc_execute_scsi_cmnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">err_code</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;scp 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">scp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">asc_scsi_q</span> <span class="n">asc_scsi_q</span><span class="p">;</span>

		<span class="cm">/* asc_build_req() can not return ASC_BUSY. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">asc_build_req</span><span class="p">(</span><span class="n">boardp</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asc_scsi_q</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">ASC_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">build_error</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ASC_ERROR</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">AscExeScsiQueue</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asc_scsi_q</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">asc_scsi_q</span><span class="p">.</span><span class="n">sg_head</span><span class="p">);</span>
		<span class="n">err_code</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">adv_dvc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">;</span>
		<span class="n">ADV_SCSI_REQ_Q</span> <span class="o">*</span><span class="n">adv_scsiqp</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">adv_build_req</span><span class="p">(</span><span class="n">boardp</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adv_scsiqp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ASC_NOERROR</span>:
			<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;adv_build_req ASC_NOERROR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ASC_BUSY</span>:
			<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;adv_build_req ASC_BUSY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * The asc_stats fields &#39;adv_build_noreq&#39; and</span>
<span class="cm">			 * &#39;adv_build_nosg&#39; count wide board busy conditions.</span>
<span class="cm">			 * They are updated in adv_build_req and</span>
<span class="cm">			 * adv_get_sglist, respectively.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="n">ASC_BUSY</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ASC_ERROR</span>:
		<span class="nl">default:</span>
			<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;adv_build_req ASC_ERROR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">build_error</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ASC_ERROR</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">AdvExeScsiQueue</span><span class="p">(</span><span class="n">adv_dvc</span><span class="p">,</span> <span class="n">adv_scsiqp</span><span class="p">);</span>
		<span class="n">err_code</span> <span class="o">=</span> <span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ASC_NOERROR</span>:
		<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">exe_noerror</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Increment monotonically increasing per device</span>
<span class="cm">		 * successful request counter. Wrapping doesn&#39;t matter.</span>
<span class="cm">		 */</span>
		<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">reqcnt</span><span class="p">[</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;ExeScsiQueue() ASC_NOERROR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASC_BUSY</span>:
		<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">exe_busy</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASC_ERROR</span>:
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="s">&quot;ExeScsiQueue() ASC_ERROR, &quot;</span>
			<span class="s">&quot;err_code 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err_code</span><span class="p">);</span>
		<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">exe_error</span><span class="p">);</span>
		<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">HOST_BYTE</span><span class="p">(</span><span class="n">DID_ERROR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="s">&quot;ExeScsiQueue() unknown, &quot;</span>
			<span class="s">&quot;err_code 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err_code</span><span class="p">);</span>
		<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">exe_unknown</span><span class="p">);</span>
		<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">HOST_BYTE</span><span class="p">(</span><span class="n">DID_ERROR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * advansys_queuecommand() - interrupt-driven I/O entrypoint.</span>
<span class="cm"> *</span>
<span class="cm"> * This function always returns 0. Command return status is saved</span>
<span class="cm"> * in the &#39;scp&#39; result field.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">advansys_queuecommand_lck</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">asc_res</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ASC_STATS</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">queuecommand</span><span class="p">);</span>
	<span class="n">scp</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">asc_res</span> <span class="o">=</span> <span class="n">asc_execute_scsi_cmnd</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">asc_res</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ASC_NOERROR</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASC_BUSY</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASC_ERROR</span>:
	<span class="nl">default:</span>
		<span class="n">asc_scsi_done</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">advansys_queuecommand</span><span class="p">)</span>

<span class="k">static</span> <span class="n">ushort</span> <span class="n">__devinit</span> <span class="n">AscGetEisaChipCfg</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PortAddr</span> <span class="n">eisa_cfg_iop</span> <span class="o">=</span> <span class="p">(</span><span class="n">PortAddr</span><span class="p">)</span> <span class="n">ASC_GET_EISA_SLOT</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">|</span>
	    <span class="p">(</span><span class="n">PortAddr</span><span class="p">)</span> <span class="p">(</span><span class="n">ASC_EISA_CFG_IOP_MASK</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inpw</span><span class="p">(</span><span class="n">eisa_cfg_iop</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the BIOS address of the adapter at the specified</span>
<span class="cm"> * I/O port and with the specified bus type.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">__devinit</span>
<span class="nf">AscGetChipBiosAddress</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">bus_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_lsw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">bios_addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The PCI BIOS is re-located by the motherboard BIOS. Because</span>
<span class="cm">	 * of this the driver can not determine where a PCI BIOS is</span>
<span class="cm">	 * loaded and executes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_PCI</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_EISA</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfg_lsw</span> <span class="o">=</span> <span class="n">AscGetEisaChipCfg</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
		<span class="n">cfg_lsw</span> <span class="o">&amp;=</span> <span class="mh">0x000F</span><span class="p">;</span>
		<span class="n">bios_addr</span> <span class="o">=</span> <span class="n">ASC_BIOS_MIN_ADDR</span> <span class="o">+</span> <span class="n">cfg_lsw</span> <span class="o">*</span> <span class="n">ASC_BIOS_BANK_SIZE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">bios_addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cfg_lsw</span> <span class="o">=</span> <span class="n">AscGetChipCfgLsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  ISA PnP uses the top bit as the 32K BIOS flag</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">ASC_IS_ISAPNP</span><span class="p">)</span>
		<span class="n">cfg_lsw</span> <span class="o">&amp;=</span> <span class="mh">0x7FFF</span><span class="p">;</span>
	<span class="n">bios_addr</span> <span class="o">=</span> <span class="n">ASC_BIOS_MIN_ADDR</span> <span class="o">+</span> <span class="p">(</span><span class="n">cfg_lsw</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">*</span> <span class="n">ASC_BIOS_BANK_SIZE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bios_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">uchar</span> <span class="n">__devinit</span> <span class="nf">AscSetChipScsiID</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">new_host_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">cfg_lsw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">AscGetChipScsiID</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">==</span> <span class="n">new_host_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">new_host_id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cfg_lsw</span> <span class="o">=</span> <span class="n">AscGetChipCfgLsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">cfg_lsw</span> <span class="o">&amp;=</span> <span class="mh">0xF8FF</span><span class="p">;</span>
	<span class="n">cfg_lsw</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)((</span><span class="n">new_host_id</span> <span class="o">&amp;</span> <span class="n">ASC_MAX_TID</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">AscSetChipCfgLsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">cfg_lsw</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">AscGetChipScsiID</span><span class="p">(</span><span class="n">iop_base</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__devinit</span> <span class="nf">AscGetChipScsiCtrl</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sc</span><span class="p">;</span>

	<span class="n">AscSetBank</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sc</span> <span class="o">=</span> <span class="n">inp</span><span class="p">(</span><span class="n">iop_base</span> <span class="o">+</span> <span class="n">IOP_REG_SC</span><span class="p">);</span>
	<span class="n">AscSetBank</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__devinit</span>
<span class="nf">AscGetChipVersion</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">bus_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_EISA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PortAddr</span> <span class="n">eisa_iop</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">revision</span><span class="p">;</span>
		<span class="n">eisa_iop</span> <span class="o">=</span> <span class="p">(</span><span class="n">PortAddr</span><span class="p">)</span> <span class="n">ASC_GET_EISA_SLOT</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">(</span><span class="n">PortAddr</span><span class="p">)</span> <span class="n">ASC_EISA_REV_IOP_MASK</span><span class="p">;</span>
		<span class="n">revision</span> <span class="o">=</span> <span class="n">inp</span><span class="p">(</span><span class="n">eisa_iop</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ASC_CHIP_MIN_VER_EISA</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">revision</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">AscGetChipVerNo</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_ISA</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">AscEnableIsaDma</span><span class="p">(</span><span class="n">uchar</span> <span class="n">dma_channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_channel</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outp</span><span class="p">(</span><span class="mh">0x000B</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="mh">0xC0</span> <span class="o">|</span> <span class="n">dma_channel</span><span class="p">));</span>
		<span class="n">outp</span><span class="p">(</span><span class="mh">0x000A</span><span class="p">,</span> <span class="n">dma_channel</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dma_channel</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outp</span><span class="p">(</span><span class="mh">0x00D6</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="mh">0xC0</span> <span class="o">|</span> <span class="p">(</span><span class="n">dma_channel</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)));</span>
		<span class="n">outp</span><span class="p">(</span><span class="mh">0x00D4</span><span class="p">,</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">dma_channel</span> <span class="o">-</span> <span class="mi">4</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ISA */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">AscStopQueueExe</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_STOP_CODE_B</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscWriteLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_STOP_CODE_B</span><span class="p">,</span>
				 <span class="n">ASC_STOP_REQ_RISC_STOP</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">AscReadLramByte</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_STOP_CODE_B</span><span class="p">)</span> <span class="o">&amp;</span>
			    <span class="n">ASC_STOP_ACK_RISC_STOP</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ASC_DCNT</span> <span class="n">__devinit</span> <span class="nf">AscGetMaxDmaCount</span><span class="p">(</span><span class="n">ushort</span> <span class="n">bus_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_ISA</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ASC_MAX_ISA_DMA_COUNT</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ASC_IS_EISA</span> <span class="o">|</span> <span class="n">ASC_IS_VL</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ASC_MAX_VL_DMA_COUNT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ASC_MAX_PCI_DMA_COUNT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_ISA</span>
<span class="k">static</span> <span class="n">ushort</span> <span class="n">__devinit</span> <span class="nf">AscGetIsaDmaChannel</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">channel</span><span class="p">;</span>

	<span class="n">channel</span> <span class="o">=</span> <span class="n">AscGetChipCfgLsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0003</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="mh">0x03</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">7</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">channel</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ushort</span> <span class="n">__devinit</span> <span class="nf">AscSetIsaDmaChannel</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">dma_channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">cfg_lsw</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">dma_channel</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dma_channel</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_channel</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
			<span class="n">value</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">dma_channel</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">cfg_lsw</span> <span class="o">=</span> <span class="n">AscGetChipCfgLsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFC</span><span class="p">;</span>
		<span class="n">cfg_lsw</span> <span class="o">|=</span> <span class="n">value</span><span class="p">;</span>
		<span class="n">AscSetChipCfgLsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">cfg_lsw</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">AscGetIsaDmaChannel</span><span class="p">(</span><span class="n">iop_base</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">uchar</span> <span class="n">__devinit</span> <span class="nf">AscGetIsaDmaSpeed</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uchar</span> <span class="n">speed_value</span><span class="p">;</span>

	<span class="n">AscSetBank</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">speed_value</span> <span class="o">=</span> <span class="n">AscReadChipDmaSpeed</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">speed_value</span> <span class="o">&amp;=</span> <span class="mh">0x07</span><span class="p">;</span>
	<span class="n">AscSetBank</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">speed_value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">uchar</span> <span class="n">__devinit</span> <span class="nf">AscSetIsaDmaSpeed</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">speed_value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">speed_value</span> <span class="o">&amp;=</span> <span class="mh">0x07</span><span class="p">;</span>
	<span class="n">AscSetBank</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">AscWriteChipDmaSpeed</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">speed_value</span><span class="p">);</span>
	<span class="n">AscSetBank</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">AscGetIsaDmaSpeed</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ISA */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">ushort</span> <span class="n">__devinit</span> <span class="nf">AscInitAscDvcVar</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">warn_code</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">chip_version</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">warn_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span>
	     <span class="p">(</span><span class="n">ASC_IS_ISA</span> <span class="o">|</span> <span class="n">ASC_IS_PCI</span> <span class="o">|</span> <span class="n">ASC_IS_EISA</span> <span class="o">|</span> <span class="n">ASC_IS_VL</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_NO_BUS_TYPE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">AscSetChipControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">CC_HALT</span><span class="p">);</span>
	<span class="n">AscSetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bug_fix_cntl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">pci_fix_asyn_xfer_always</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* asc_dvc-&gt;init_state initialized in AscInitGetConfig(). */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cur_total_qng</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">is_in_int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">in_critical_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">last_q_shortage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">use_tagged_qng</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">no_scam</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">unit_not_ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">queue_full_or_busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">redo_scam</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">res2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">min_sdtr_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">can_tagged_qng</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">cmd_qng_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">dvc_cntl</span> <span class="o">=</span> <span class="n">ASC_DEF_DVC_CNTL</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MAX_TOTAL_QNG</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">scsi_reset_wait</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">start_motor</span> <span class="o">=</span> <span class="n">ASC_SCSI_WIDTH_BIT_SET</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dma_count</span> <span class="o">=</span> <span class="n">AscGetMaxDmaCount</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">sdtr_enable</span> <span class="o">=</span> <span class="n">ASC_SCSI_WIDTH_BIT_SET</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span> <span class="o">=</span> <span class="n">ASC_SCSI_WIDTH_BIT_SET</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span> <span class="o">=</span> <span class="n">ASC_DEF_CHIP_SCSI_ID</span><span class="p">;</span>
	<span class="n">chip_version</span> <span class="o">=</span> <span class="n">AscGetChipVersion</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chip_version</span> <span class="o">=</span> <span class="n">chip_version</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_period_tbl</span> <span class="o">=</span> <span class="n">asc_syn_xfer_period</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_sdtr_index</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_PCI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">chip_version</span> <span class="o">&gt;=</span> <span class="n">ASC_CHIP_VER_PCI_ULTRA_3150</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">=</span> <span class="n">ASC_IS_PCI_ULTRA</span><span class="p">;</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_period_tbl</span> <span class="o">=</span> <span class="n">asc_syn_ultra_xfer_period</span><span class="p">;</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_sdtr_index</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip_version</span> <span class="o">==</span> <span class="n">ASC_CHIP_VER_PCI_ULTRA_3150</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">AscSetExtraControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">SEC_ACTIVE_NEGATE</span> <span class="o">|</span> <span class="n">SEC_SLEW_RATE</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chip_version</span> <span class="o">&gt;=</span> <span class="n">ASC_CHIP_VER_PCI_ULTRA_3050</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">AscSetExtraControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">SEC_ACTIVE_NEGATE</span> <span class="o">|</span>
					    <span class="n">SEC_ENABLE_FILTER</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">ASC_IS_PCI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscSetExtraControl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">SEC_ACTIVE_NEGATE</span> <span class="o">|</span> <span class="n">SEC_SLEW_RATE</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">isa_dma_speed</span> <span class="o">=</span> <span class="n">ASC_DEF_ISA_DMA_SPEED</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ISA</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_ISA</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip_version</span> <span class="o">&gt;=</span> <span class="n">ASC_CHIP_MIN_VER_ISA_PNP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">AscSetChipIFC</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IFC_INIT_DEFAULT</span><span class="p">);</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">=</span> <span class="n">ASC_IS_ISAPNP</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">isa_dma_channel</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">AscGetIsaDmaChannel</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ISA */</span><span class="cp"></span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cur_dvc_qng</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ASC_MAX_SCSI1_QNG</span><span class="p">;</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">scsiq_busy_head</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ASC_SCSI_Q</span> <span class="o">*</span><span class="p">)</span><span class="mi">0L</span><span class="p">;</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">scsiq_busy_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ASC_SCSI_Q</span> <span class="o">*</span><span class="p">)</span><span class="mi">0L</span><span class="p">;</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">max_tag_qng</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ASC_MAX_INRAM_TAG_QNG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">warn_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">AscWriteEEPCmdReg</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">cmd_reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retry</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">retry</span> <span class="o">&lt;</span> <span class="n">ASC_EEP_MAX_RETRY</span><span class="p">;</span> <span class="n">retry</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">read_back</span><span class="p">;</span>
		<span class="n">AscSetChipEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">cmd_reg</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">read_back</span> <span class="o">=</span> <span class="n">AscGetChipEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_back</span> <span class="o">==</span> <span class="n">cmd_reg</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">AscWaitEEPRead</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ushort</span> <span class="n">__devinit</span> <span class="nf">AscReadEEPWord</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">read_wval</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">cmd_reg</span><span class="p">;</span>

	<span class="n">AscWriteEEPCmdReg</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_EEP_CMD_WRITE_DISABLE</span><span class="p">);</span>
	<span class="n">AscWaitEEPRead</span><span class="p">();</span>
	<span class="n">cmd_reg</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">|</span> <span class="n">ASC_EEP_CMD_READ</span><span class="p">;</span>
	<span class="n">AscWriteEEPCmdReg</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">cmd_reg</span><span class="p">);</span>
	<span class="n">AscWaitEEPRead</span><span class="p">();</span>
	<span class="n">read_wval</span> <span class="o">=</span> <span class="n">AscGetChipEEPData</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">AscWaitEEPRead</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">read_wval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ushort</span> <span class="n">__devinit</span>
<span class="nf">AscGetEEPConfig</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCEEP_CONFIG</span> <span class="o">*</span><span class="n">cfg_buf</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">bus_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">wval</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">sum</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cfg_beg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cfg_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uchar_end_in_config</span> <span class="o">=</span> <span class="n">ASC_EEP_MAX_DVC_ADDR</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_addr</span><span class="p">;</span>

	<span class="n">wbuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="n">cfg_buf</span><span class="p">;</span>
	<span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Read two config words; Byte-swapping done by AscReadEEPWord(). */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">s_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s_addr</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">s_addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">AscReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">s_addr</span><span class="p">);</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_VL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfg_beg</span> <span class="o">=</span> <span class="n">ASC_EEP_DVC_CFG_BEG_VL</span><span class="p">;</span>
		<span class="n">cfg_end</span> <span class="o">=</span> <span class="n">ASC_EEP_MAX_DVC_ADDR_VL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cfg_beg</span> <span class="o">=</span> <span class="n">ASC_EEP_DVC_CFG_BEG</span><span class="p">;</span>
		<span class="n">cfg_end</span> <span class="o">=</span> <span class="n">ASC_EEP_MAX_DVC_ADDR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">cfg_beg</span><span class="p">;</span> <span class="n">s_addr</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">cfg_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">s_addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wval</span> <span class="o">=</span> <span class="n">AscReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">s_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s_addr</span> <span class="o">&lt;=</span> <span class="n">uchar_end_in_config</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Swap all char fields - must unswap bytes already swapped</span>
<span class="cm">			 * by AscReadEEPWord().</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">wval</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Don&#39;t swap word field at the end - cntl field. */</span>
			<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">wval</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">wval</span><span class="p">;</span>	<span class="cm">/* Checksum treats all EEPROM data as words. */</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read the checksum word which will be compared against &#39;sum&#39;</span>
<span class="cm">	 * by the caller. Word field already swapped.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">AscReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">s_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">AscTestExternalLram</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">q_addr</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">saved_word</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sta</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">sta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">q_addr</span> <span class="o">=</span> <span class="n">ASC_QNO_TO_QADDR</span><span class="p">(</span><span class="mi">241</span><span class="p">);</span>
	<span class="n">saved_word</span> <span class="o">=</span> <span class="n">AscReadLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">q_addr</span><span class="p">);</span>
	<span class="n">AscSetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">q_addr</span><span class="p">);</span>
	<span class="n">AscSetChipLramData</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="mh">0x55AA</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">AscSetChipLramAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">q_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AscGetChipLramData</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x55AA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">q_addr</span><span class="p">,</span> <span class="n">saved_word</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sta</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">AscWaitEEPWrite</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">AscWriteEEPDataReg</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">data_reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">read_back</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retry</span><span class="p">;</span>

	<span class="n">retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscSetChipEEPData</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">data_reg</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">read_back</span> <span class="o">=</span> <span class="n">AscGetChipEEPData</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_back</span> <span class="o">==</span> <span class="n">data_reg</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retry</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">ASC_EEP_MAX_RETRY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ushort</span> <span class="n">__devinit</span>
<span class="nf">AscWriteEEPWord</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">word_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">read_wval</span><span class="p">;</span>

	<span class="n">read_wval</span> <span class="o">=</span> <span class="n">AscReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_wval</span> <span class="o">!=</span> <span class="n">word_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscWriteEEPCmdReg</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_EEP_CMD_WRITE_ABLE</span><span class="p">);</span>
		<span class="n">AscWaitEEPRead</span><span class="p">();</span>
		<span class="n">AscWriteEEPDataReg</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">word_val</span><span class="p">);</span>
		<span class="n">AscWaitEEPRead</span><span class="p">();</span>
		<span class="n">AscWriteEEPCmdReg</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">uchar</span><span class="p">)((</span><span class="n">uchar</span><span class="p">)</span><span class="n">ASC_EEP_CMD_WRITE</span> <span class="o">|</span> <span class="n">addr</span><span class="p">));</span>
		<span class="n">AscWaitEEPWrite</span><span class="p">();</span>
		<span class="n">AscWriteEEPCmdReg</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_EEP_CMD_WRITE_DISABLE</span><span class="p">);</span>
		<span class="n">AscWaitEEPRead</span><span class="p">();</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">AscReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">addr</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">read_wval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">AscSetEEPConfigOnce</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCEEP_CONFIG</span> <span class="o">*</span><span class="n">cfg_buf</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">bus_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n_error</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">word</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">sum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cfg_beg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cfg_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uchar_end_in_config</span> <span class="o">=</span> <span class="n">ASC_EEP_MAX_DVC_ADDR</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">wbuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="n">cfg_buf</span><span class="p">;</span>
	<span class="n">n_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Write two config words; AscWriteEEPWord() will swap bytes. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">s_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s_addr</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">s_addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">wbuf</span> <span class="o">!=</span> <span class="n">AscWriteEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">s_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">n_error</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_VL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfg_beg</span> <span class="o">=</span> <span class="n">ASC_EEP_DVC_CFG_BEG_VL</span><span class="p">;</span>
		<span class="n">cfg_end</span> <span class="o">=</span> <span class="n">ASC_EEP_MAX_DVC_ADDR_VL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cfg_beg</span> <span class="o">=</span> <span class="n">ASC_EEP_DVC_CFG_BEG</span><span class="p">;</span>
		<span class="n">cfg_end</span> <span class="o">=</span> <span class="n">ASC_EEP_MAX_DVC_ADDR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">cfg_beg</span><span class="p">;</span> <span class="n">s_addr</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">cfg_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">s_addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s_addr</span> <span class="o">&lt;=</span> <span class="n">uchar_end_in_config</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is a char field. Swap char fields before they are</span>
<span class="cm">			 * swapped again by AscWriteEEPWord().</span>
<span class="cm">			 */</span>
			<span class="n">word</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="o">*</span><span class="n">wbuf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">word</span> <span class="o">!=</span>
			    <span class="n">AscWriteEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">s_addr</span><span class="p">,</span> <span class="n">word</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">n_error</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Don&#39;t swap word field at the end - cntl field. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">wbuf</span> <span class="o">!=</span>
			    <span class="n">AscWriteEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">s_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">n_error</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>	<span class="cm">/* Checksum calculated from word values. */</span>
	<span class="p">}</span>
	<span class="cm">/* Write checksum word. It will be swapped by AscWriteEEPWord(). */</span>
	<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">!=</span> <span class="n">AscWriteEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">s_addr</span><span class="p">,</span> <span class="n">sum</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">n_error</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Read EEPROM back again. */</span>
	<span class="n">wbuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="n">cfg_buf</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read two config words; Byte-swapping done by AscReadEEPWord().</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">s_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s_addr</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">s_addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">wbuf</span> <span class="o">!=</span> <span class="n">AscReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">s_addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">n_error</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_VL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfg_beg</span> <span class="o">=</span> <span class="n">ASC_EEP_DVC_CFG_BEG_VL</span><span class="p">;</span>
		<span class="n">cfg_end</span> <span class="o">=</span> <span class="n">ASC_EEP_MAX_DVC_ADDR_VL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cfg_beg</span> <span class="o">=</span> <span class="n">ASC_EEP_DVC_CFG_BEG</span><span class="p">;</span>
		<span class="n">cfg_end</span> <span class="o">=</span> <span class="n">ASC_EEP_MAX_DVC_ADDR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">cfg_beg</span><span class="p">;</span> <span class="n">s_addr</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">cfg_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">s_addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s_addr</span> <span class="o">&lt;=</span> <span class="n">uchar_end_in_config</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Swap all char fields. Must unswap bytes already swapped</span>
<span class="cm">			 * by AscReadEEPWord().</span>
<span class="cm">			 */</span>
			<span class="n">word</span> <span class="o">=</span>
			    <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">AscReadEEPWord</span>
					<span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">s_addr</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Don&#39;t swap word field at the end - cntl field. */</span>
			<span class="n">word</span> <span class="o">=</span> <span class="n">AscReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">s_addr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">wbuf</span> <span class="o">!=</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n_error</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Read checksum; Byte swapping not needed. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AscReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)</span><span class="n">s_addr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n_error</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n_error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">AscSetEEPConfig</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCEEP_CONFIG</span> <span class="o">*</span><span class="n">cfg_buf</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">bus_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_error</span><span class="p">;</span>

	<span class="n">retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">n_error</span> <span class="o">=</span> <span class="n">AscSetEEPConfigOnce</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">cfg_buf</span><span class="p">,</span>
						   <span class="n">bus_type</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">retry</span> <span class="o">&gt;</span> <span class="n">ASC_EEP_MAX_RETRY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n_error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ushort</span> <span class="n">__devinit</span> <span class="nf">AscInitFromEEP</span><span class="p">(</span><span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASCEEP_CONFIG</span> <span class="n">eep_config_buf</span><span class="p">;</span>
	<span class="n">ASCEEP_CONFIG</span> <span class="o">*</span><span class="n">eep_config</span><span class="p">;</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">chksum</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">warn_code</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">cfg_msw</span><span class="p">,</span> <span class="n">cfg_lsw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write_eep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">warn_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">AscWriteLramWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASCV_HALTCODE_W</span><span class="p">,</span> <span class="mh">0x00FE</span><span class="p">);</span>
	<span class="n">AscStopQueueExe</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">AscStopChip</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">AscGetChipScsiCtrl</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_state</span> <span class="o">|=</span> <span class="n">ASC_INIT_RESET_SCSI_DONE</span><span class="p">;</span>
		<span class="n">AscResetChipAndScsiBus</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">scsi_reset_wait</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span> <span class="cm">/* XXX: msleep? */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AscIsChipHalted</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_START_STOP_CHIP</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">warn_code</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">AscSetPCAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_MCODE_START_ADDR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AscGetPCAddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ASC_MCODE_START_ADDR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_SET_PC_ADDR</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">warn_code</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">eep_config</span> <span class="o">=</span> <span class="p">(</span><span class="n">ASCEEP_CONFIG</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">eep_config_buf</span><span class="p">;</span>
	<span class="n">cfg_msw</span> <span class="o">=</span> <span class="n">AscGetChipCfgMsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">cfg_lsw</span> <span class="o">=</span> <span class="n">AscGetChipCfgLsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cfg_msw</span> <span class="o">&amp;</span> <span class="n">ASC_CFG_MSW_CLR_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfg_msw</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ASC_CFG_MSW_CLR_MASK</span><span class="p">;</span>
		<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_CFG_MSW_RECOVER</span><span class="p">;</span>
		<span class="n">AscSetChipCfgMsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">cfg_msw</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">chksum</span> <span class="o">=</span> <span class="n">AscGetEEPConfig</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">eep_config</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span><span class="p">);</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;chksum 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chksum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chksum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chksum</span> <span class="o">=</span> <span class="mh">0xaa55</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AscGetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CSW_AUTO_CONFIG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_AUTO_CONFIG</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chip_version</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">cfg_lsw</span> <span class="o">!=</span> <span class="n">cfg_lsw</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_EEPROM_RECOVER</span><span class="p">;</span>
				<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">cfg_lsw</span> <span class="o">=</span>
				    <span class="n">AscGetChipCfgLsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">cfg_msw</span> <span class="o">!=</span> <span class="n">cfg_msw</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_EEPROM_RECOVER</span><span class="p">;</span>
				<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">cfg_msw</span> <span class="o">=</span>
				    <span class="n">AscGetChipCfgMsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">cfg_msw</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ASC_CFG_MSW_CLR_MASK</span><span class="p">;</span>
	<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">cfg_lsw</span> <span class="o">|=</span> <span class="n">ASC_CFG0_HOST_INT_ON</span><span class="p">;</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;eep_config-&gt;chksum 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">chksum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chksum</span> <span class="o">!=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">chksum</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AscGetChipVersion</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">ASC_CHIP_VER_PCI_ULTRA_3050</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;chksum error ignored; EEPROM-less board</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">disc_enable</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">start_motor</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">use_cmd_qng</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">=</span> <span class="mh">0xF0</span><span class="p">;</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_tag_qng</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">cntl</span> <span class="o">=</span> <span class="mh">0xBFFF</span><span class="p">;</span>
			<span class="n">ASC_EEP_SET_CHIP_ID</span><span class="p">(</span><span class="n">eep_config</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">no_scam</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* Indicate EEPROM-less board. */</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xBB</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ASC_PRINT</span>
			    <span class="p">(</span><span class="s">&quot;AscInitFromEEP: EEPROM checksum error; Will try to re-write EEPROM.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">write_eep</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_EEPROM_CHKSUM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">sdtr_enable</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">init_sdtr</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">cmd_qng_enabled</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">use_cmd_qng</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">isa_dma_speed</span> <span class="o">=</span> <span class="n">ASC_EEP_GET_DMA_SPD</span><span class="p">(</span><span class="n">eep_config</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">start_motor</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">start_motor</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">dvc_cntl</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">cntl</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">no_scam</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">no_scam</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AscTestExternalLram</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_PCI_ULTRA</span><span class="p">)</span> <span class="o">==</span>
		     <span class="n">ASC_IS_PCI_ULTRA</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">=</span>
			    <span class="n">ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG</span><span class="p">;</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_tag_qng</span> <span class="o">=</span>
			    <span class="n">ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">cfg_msw</span> <span class="o">|=</span> <span class="mh">0x0800</span><span class="p">;</span>
			<span class="n">cfg_msw</span> <span class="o">|=</span> <span class="mh">0x0800</span><span class="p">;</span>
			<span class="n">AscSetChipCfgMsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">cfg_msw</span><span class="p">);</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">=</span> <span class="n">ASC_MAX_PCI_INRAM_TOTAL_QNG</span><span class="p">;</span>
			<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_tag_qng</span> <span class="o">=</span> <span class="n">ASC_MAX_INRAM_TAG_QNG</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">&lt;</span> <span class="n">ASC_MIN_TOTAL_QNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">=</span> <span class="n">ASC_MIN_TOTAL_QNG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">&gt;</span> <span class="n">ASC_MAX_TOTAL_QNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">=</span> <span class="n">ASC_MAX_TOTAL_QNG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_tag_qng</span> <span class="o">&gt;</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_total_qng</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_tag_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_total_qng</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_tag_qng</span> <span class="o">&lt;</span> <span class="n">ASC_MIN_TAG_Q_PER_DVC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_tag_qng</span> <span class="o">=</span> <span class="n">ASC_MIN_TAG_Q_PER_DVC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_total_qng</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">use_cmd_qng</span> <span class="o">&amp;</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">use_cmd_qng</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">disc_enable</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">use_cmd_qng</span><span class="p">;</span>
		<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_CMD_QNG_CONFLICT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASC_EEP_SET_CHIP_ID</span><span class="p">(</span><span class="n">eep_config</span><span class="p">,</span>
			    <span class="n">ASC_EEP_GET_CHIP_ID</span><span class="p">(</span><span class="n">eep_config</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ASC_MAX_TID</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span> <span class="o">=</span> <span class="n">ASC_EEP_GET_CHIP_ID</span><span class="p">(</span><span class="n">eep_config</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_PCI_ULTRA</span><span class="p">)</span> <span class="o">==</span> <span class="n">ASC_IS_PCI_ULTRA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">dvc_cntl</span> <span class="o">&amp;</span> <span class="n">ASC_CNTL_SDTR_ENABLE_ULTRA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">min_sdtr_index</span> <span class="o">=</span> <span class="n">ASC_SDTR_ULTRA_PCI_10MB_INDEX</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">dos_int13_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">dos_int13_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">max_tag_qng</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">max_tag_qng</span><span class="p">;</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">sdtr_period_offset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">ASC_DEF_SDTR_OFFSET</span> <span class="o">|</span>
			    <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">min_sdtr_index</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">eep_config</span><span class="o">-&gt;</span><span class="n">cfg_msw</span> <span class="o">=</span> <span class="n">AscGetChipCfgMsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write_eep</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">AscSetEEPConfig</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">eep_config</span><span class="p">,</span>
				     <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASC_PRINT1</span>
			    <span class="p">(</span><span class="s">&quot;AscInitFromEEP: Failed to re-write EEPROM with %d errors.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ASC_PRINT</span>
			    <span class="p">(</span><span class="s">&quot;AscInitFromEEP: Successfully re-wrote EEPROM.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">warn_code</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">AscInitGetConfig</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">board</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">warn_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_state</span> <span class="o">=</span> <span class="n">ASC_INIT_STATE_BEG_GET_CFG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">AscFindSignature</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">AscInitAscDvcVar</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
		<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">AscInitFromEEP</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_state</span> <span class="o">|=</span> <span class="n">ASC_INIT_STATE_END_GET_CFG</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">scsi_reset_wait</span> <span class="o">&gt;</span> <span class="n">ASC_MAX_SCSI_RESET_WAIT</span><span class="p">)</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">scsi_reset_wait</span> <span class="o">=</span> <span class="n">ASC_MAX_SCSI_RESET_WAIT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_BAD_SIGNATURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">warn_code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:	<span class="cm">/* No error */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASC_WARN_IO_PORT_ROTATE</span>:
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;I/O port address &quot;</span>
				<span class="s">&quot;modified</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASC_WARN_AUTO_CONFIG</span>:
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;I/O port increment switch &quot;</span>
				<span class="s">&quot;enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASC_WARN_EEPROM_CHKSUM</span>:
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;EEPROM checksum error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASC_WARN_IRQ_MODIFIED</span>:
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;IRQ modified</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASC_WARN_CMD_QNG_CONFLICT</span>:
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;tag queuing enabled w/o &quot;</span>
				<span class="s">&quot;disconnects</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;unknown warning: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">warn_code</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;error 0x%x at init_state &quot;</span>
			<span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_state</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">AscInitSetConfig</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">board</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">;</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_msw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">warn_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_state</span> <span class="o">|=</span> <span class="n">ASC_INIT_STATE_BEG_SET_CFG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AscFindSignature</span><span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_BAD_SIGNATURE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cfg_msw</span> <span class="o">=</span> <span class="n">AscGetChipCfgMsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cfg_msw</span> <span class="o">&amp;</span> <span class="n">ASC_CFG_MSW_CLR_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfg_msw</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ASC_CFG_MSW_CLR_MASK</span><span class="p">;</span>
		<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_CFG_MSW_RECOVER</span><span class="p">;</span>
		<span class="n">AscSetChipCfgMsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">cfg_msw</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">cmd_qng_enabled</span> <span class="o">&amp;</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">cmd_qng_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">cmd_qng_enabled</span><span class="p">;</span>
		<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_CMD_QNG_CONFLICT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AscGetChipStatus</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CSW_AUTO_CONFIG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_AUTO_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_PCI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfg_msw</span> <span class="o">&amp;=</span> <span class="mh">0xFFC0</span><span class="p">;</span>
		<span class="n">AscSetChipCfgMsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">cfg_msw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_PCI_ULTRA</span><span class="p">)</span> <span class="o">==</span> <span class="n">ASC_IS_PCI_ULTRA</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_ASP_1200A</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_ASP_ABP940</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bug_fix_cntl</span> <span class="o">|=</span> <span class="n">ASC_BUG_FIX_IF_NOT_DWB</span><span class="p">;</span>
				<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bug_fix_cntl</span> <span class="o">|=</span>
				    <span class="n">ASC_BUG_FIX_ASYN_USE_SYN</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">ASC_IS_ISAPNP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AscGetChipVersion</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span><span class="p">)</span>
		    <span class="o">==</span> <span class="n">ASC_CHIP_VER_ASYN_BUG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bug_fix_cntl</span> <span class="o">|=</span> <span class="n">ASC_BUG_FIX_ASYN_USE_SYN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AscSetChipScsiID</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_SET_SCSI_ID</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_ISA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_ISA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AscSetIsaDmaChannel</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">isa_dma_channel</span><span class="p">);</span>
		<span class="n">AscSetIsaDmaSpeed</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">isa_dma_speed</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ISA */</span><span class="cp"></span>

	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_state</span> <span class="o">|=</span> <span class="n">ASC_INIT_STATE_END_SET_CFG</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">warn_code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:	<span class="cm">/* No error. */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASC_WARN_IO_PORT_ROTATE</span>:
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;I/O port address &quot;</span>
				<span class="s">&quot;modified</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASC_WARN_AUTO_CONFIG</span>:
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;I/O port increment switch &quot;</span>
				<span class="s">&quot;enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASC_WARN_EEPROM_CHKSUM</span>:
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;EEPROM checksum error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASC_WARN_IRQ_MODIFIED</span>:
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;IRQ modified</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASC_WARN_CMD_QNG_CONFLICT</span>:
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;tag queuing w/o &quot;</span>
				<span class="s">&quot;disconnects</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;unknown warning: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">warn_code</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;error 0x%x at init_state &quot;</span>
			<span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">init_state</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * EEPROM Configuration.</span>
<span class="cm"> *</span>
<span class="cm"> * All drivers should use this structure to set the default EEPROM</span>
<span class="cm"> * configuration. The BIOS now uses this structure when it is built.</span>
<span class="cm"> * Additional structure information can be found in a_condor.h where</span>
<span class="cm"> * the structure is defined.</span>
<span class="cm"> *</span>
<span class="cm"> * The *_Field_IsChar structs are needed to correct for endianness.</span>
<span class="cm"> * These values are read from the board 16 bits at a time directly</span>
<span class="cm"> * into the structs. Because some fields are char, the values will be</span>
<span class="cm"> * in the wrong order. The *_Field_IsChar tells when to flip the</span>
<span class="cm"> * bytes. Data read and written to PCI memory is automatically swapped</span>
<span class="cm"> * on big-endian platforms so char fields read as words are actually being</span>
<span class="cm"> * unswapped on big-endian platforms.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ADVEEP_3550_CONFIG</span> <span class="n">Default_3550_EEPROM_Config</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">ADV_EEPROM_BIOS_ENABLE</span><span class="p">,</span>	<span class="cm">/* cfg_lsw */</span>
	<span class="mh">0x0000</span><span class="p">,</span>			<span class="cm">/* cfg_msw */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* disc_enable */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* wdtr_able */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* sdtr_able */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* start_motor */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* tagqng_able */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* bios_scan */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* scam_tolerant */</span>
	<span class="mi">7</span><span class="p">,</span>			<span class="cm">/* adapter_scsi_id */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* bios_boot_delay */</span>
	<span class="mi">3</span><span class="p">,</span>			<span class="cm">/* scsi_reset_delay */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* bios_id_lun */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* termination */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* reserved1 */</span>
	<span class="mh">0xFFE7</span><span class="p">,</span>			<span class="cm">/* bios_ctrl */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* ultra_able */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* reserved2 */</span>
	<span class="n">ASC_DEF_MAX_HOST_QNG</span><span class="p">,</span>	<span class="cm">/* max_host_qng */</span>
	<span class="n">ASC_DEF_MAX_DVC_QNG</span><span class="p">,</span>	<span class="cm">/* max_dvc_qng */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* dvc_cntl */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* bug_fix */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* serial_number_word1 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* serial_number_word2 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* serial_number_word3 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* check_sum */</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
	<span class="p">,</span>			<span class="cm">/* oem_name[16] */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* dvc_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* adv_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* adv_err_addr */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* saved_dvc_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* saved_adv_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* saved_adv_err_addr */</span>
	<span class="mi">0</span>			<span class="cm">/* num_of_err */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">ADVEEP_3550_CONFIG</span> <span class="n">ADVEEP_3550_Config_Field_IsChar</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* cfg_lsw */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* cfg_msw */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* -disc_enable */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* wdtr_able */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* sdtr_able */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* start_motor */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* tagqng_able */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* bios_scan */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* scam_tolerant */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* adapter_scsi_id */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* bios_boot_delay */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* scsi_reset_delay */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* bios_id_lun */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* termination */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* reserved1 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* bios_ctrl */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* ultra_able */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* reserved2 */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* max_host_qng */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* max_dvc_qng */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* dvc_cntl */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* bug_fix */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* serial_number_word1 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* serial_number_word2 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* serial_number_word3 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* check_sum */</span>
	<span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
	<span class="p">,</span>			<span class="cm">/* oem_name[16] */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* dvc_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* adv_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* adv_err_addr */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* saved_dvc_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* saved_adv_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* saved_adv_err_addr */</span>
	<span class="mi">0</span>			<span class="cm">/* num_of_err */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">ADVEEP_38C0800_CONFIG</span> <span class="n">Default_38C0800_EEPROM_Config</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">ADV_EEPROM_BIOS_ENABLE</span><span class="p">,</span>	<span class="cm">/* 00 cfg_lsw */</span>
	<span class="mh">0x0000</span><span class="p">,</span>			<span class="cm">/* 01 cfg_msw */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* 02 disc_enable */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* 03 wdtr_able */</span>
	<span class="mh">0x4444</span><span class="p">,</span>			<span class="cm">/* 04 sdtr_speed1 */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* 05 start_motor */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* 06 tagqng_able */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* 07 bios_scan */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 08 scam_tolerant */</span>
	<span class="mi">7</span><span class="p">,</span>			<span class="cm">/* 09 adapter_scsi_id */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/*    bios_boot_delay */</span>
	<span class="mi">3</span><span class="p">,</span>			<span class="cm">/* 10 scsi_reset_delay */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/*    bios_id_lun */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 11 termination_se */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/*    termination_lvd */</span>
	<span class="mh">0xFFE7</span><span class="p">,</span>			<span class="cm">/* 12 bios_ctrl */</span>
	<span class="mh">0x4444</span><span class="p">,</span>			<span class="cm">/* 13 sdtr_speed2 */</span>
	<span class="mh">0x4444</span><span class="p">,</span>			<span class="cm">/* 14 sdtr_speed3 */</span>
	<span class="n">ASC_DEF_MAX_HOST_QNG</span><span class="p">,</span>	<span class="cm">/* 15 max_host_qng */</span>
	<span class="n">ASC_DEF_MAX_DVC_QNG</span><span class="p">,</span>	<span class="cm">/*    max_dvc_qng */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 16 dvc_cntl */</span>
	<span class="mh">0x4444</span><span class="p">,</span>			<span class="cm">/* 17 sdtr_speed4 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 18 serial_number_word1 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 19 serial_number_word2 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 20 serial_number_word3 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 21 check_sum */</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
	<span class="p">,</span>			<span class="cm">/* 22-29 oem_name[16] */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 30 dvc_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 31 adv_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 32 adv_err_addr */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 33 saved_dvc_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 34 saved_adv_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 35 saved_adv_err_addr */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 36 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 37 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 38 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 39 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 40 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 41 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 42 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 43 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 44 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 45 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 46 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 47 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 48 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 49 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 50 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 51 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 52 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 53 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 54 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 55 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 56 cisptr_lsw */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 57 cisprt_msw */</span>
	<span class="n">PCI_VENDOR_ID_ASP</span><span class="p">,</span>	<span class="cm">/* 58 subsysvid */</span>
	<span class="n">PCI_DEVICE_ID_38C0800_REV1</span><span class="p">,</span>	<span class="cm">/* 59 subsysid */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 60 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 61 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 62 reserved */</span>
	<span class="mi">0</span>			<span class="cm">/* 63 reserved */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">ADVEEP_38C0800_CONFIG</span> <span class="n">ADVEEP_38C0800_Config_Field_IsChar</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 00 cfg_lsw */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 01 cfg_msw */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 02 disc_enable */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 03 wdtr_able */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 04 sdtr_speed1 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 05 start_motor */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 06 tagqng_able */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 07 bios_scan */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 08 scam_tolerant */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 09 adapter_scsi_id */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/*    bios_boot_delay */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 10 scsi_reset_delay */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/*    bios_id_lun */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 11 termination_se */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/*    termination_lvd */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 12 bios_ctrl */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 13 sdtr_speed2 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 14 sdtr_speed3 */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 15 max_host_qng */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/*    max_dvc_qng */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 16 dvc_cntl */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 17 sdtr_speed4 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 18 serial_number_word1 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 19 serial_number_word2 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 20 serial_number_word3 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 21 check_sum */</span>
	<span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
	<span class="p">,</span>			<span class="cm">/* 22-29 oem_name[16] */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 30 dvc_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 31 adv_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 32 adv_err_addr */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 33 saved_dvc_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 34 saved_adv_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 35 saved_adv_err_addr */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 36 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 37 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 38 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 39 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 40 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 41 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 42 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 43 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 44 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 45 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 46 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 47 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 48 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 49 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 50 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 51 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 52 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 53 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 54 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 55 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 56 cisptr_lsw */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 57 cisprt_msw */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 58 subsysvid */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 59 subsysid */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 60 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 61 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 62 reserved */</span>
	<span class="mi">0</span>			<span class="cm">/* 63 reserved */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">ADVEEP_38C1600_CONFIG</span> <span class="n">Default_38C1600_EEPROM_Config</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">ADV_EEPROM_BIOS_ENABLE</span><span class="p">,</span>	<span class="cm">/* 00 cfg_lsw */</span>
	<span class="mh">0x0000</span><span class="p">,</span>			<span class="cm">/* 01 cfg_msw */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* 02 disc_enable */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* 03 wdtr_able */</span>
	<span class="mh">0x5555</span><span class="p">,</span>			<span class="cm">/* 04 sdtr_speed1 */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* 05 start_motor */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* 06 tagqng_able */</span>
	<span class="mh">0xFFFF</span><span class="p">,</span>			<span class="cm">/* 07 bios_scan */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 08 scam_tolerant */</span>
	<span class="mi">7</span><span class="p">,</span>			<span class="cm">/* 09 adapter_scsi_id */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/*    bios_boot_delay */</span>
	<span class="mi">3</span><span class="p">,</span>			<span class="cm">/* 10 scsi_reset_delay */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/*    bios_id_lun */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 11 termination_se */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/*    termination_lvd */</span>
	<span class="mh">0xFFE7</span><span class="p">,</span>			<span class="cm">/* 12 bios_ctrl */</span>
	<span class="mh">0x5555</span><span class="p">,</span>			<span class="cm">/* 13 sdtr_speed2 */</span>
	<span class="mh">0x5555</span><span class="p">,</span>			<span class="cm">/* 14 sdtr_speed3 */</span>
	<span class="n">ASC_DEF_MAX_HOST_QNG</span><span class="p">,</span>	<span class="cm">/* 15 max_host_qng */</span>
	<span class="n">ASC_DEF_MAX_DVC_QNG</span><span class="p">,</span>	<span class="cm">/*    max_dvc_qng */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 16 dvc_cntl */</span>
	<span class="mh">0x5555</span><span class="p">,</span>			<span class="cm">/* 17 sdtr_speed4 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 18 serial_number_word1 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 19 serial_number_word2 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 20 serial_number_word3 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 21 check_sum */</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
	<span class="p">,</span>			<span class="cm">/* 22-29 oem_name[16] */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 30 dvc_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 31 adv_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 32 adv_err_addr */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 33 saved_dvc_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 34 saved_adv_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 35 saved_adv_err_addr */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 36 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 37 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 38 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 39 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 40 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 41 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 42 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 43 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 44 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 45 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 46 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 47 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 48 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 49 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 50 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 51 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 52 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 53 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 54 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 55 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 56 cisptr_lsw */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 57 cisprt_msw */</span>
	<span class="n">PCI_VENDOR_ID_ASP</span><span class="p">,</span>	<span class="cm">/* 58 subsysvid */</span>
	<span class="n">PCI_DEVICE_ID_38C1600_REV1</span><span class="p">,</span>	<span class="cm">/* 59 subsysid */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 60 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 61 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 62 reserved */</span>
	<span class="mi">0</span>			<span class="cm">/* 63 reserved */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">ADVEEP_38C1600_CONFIG</span> <span class="n">ADVEEP_38C1600_Config_Field_IsChar</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 00 cfg_lsw */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 01 cfg_msw */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 02 disc_enable */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 03 wdtr_able */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 04 sdtr_speed1 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 05 start_motor */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 06 tagqng_able */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 07 bios_scan */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 08 scam_tolerant */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 09 adapter_scsi_id */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/*    bios_boot_delay */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 10 scsi_reset_delay */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/*    bios_id_lun */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 11 termination_se */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/*    termination_lvd */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 12 bios_ctrl */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 13 sdtr_speed2 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 14 sdtr_speed3 */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/* 15 max_host_qng */</span>
	<span class="mi">1</span><span class="p">,</span>			<span class="cm">/*    max_dvc_qng */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 16 dvc_cntl */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 17 sdtr_speed4 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 18 serial_number_word1 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 19 serial_number_word2 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 20 serial_number_word3 */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 21 check_sum */</span>
	<span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
	<span class="p">,</span>			<span class="cm">/* 22-29 oem_name[16] */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 30 dvc_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 31 adv_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 32 adv_err_addr */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 33 saved_dvc_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 34 saved_adv_err_code */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 35 saved_adv_err_addr */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 36 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 37 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 38 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 39 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 40 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 41 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 42 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 43 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 44 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 45 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 46 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 47 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 48 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 49 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 50 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 51 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 52 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 53 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 54 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 55 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 56 cisptr_lsw */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 57 cisprt_msw */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 58 subsysvid */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 59 subsysid */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 60 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 61 reserved */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* 62 reserved */</span>
	<span class="mi">0</span>			<span class="cm">/* 63 reserved */</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="cm">/*</span>
<span class="cm"> * Wait for EEPROM command to complete</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">eep_delay_ms</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">eep_delay_ms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">eep_delay_ms</span> <span class="o">&lt;</span> <span class="n">ADV_EEP_DELAY_MS</span><span class="p">;</span> <span class="n">eep_delay_ms</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AdvReadWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">)</span> <span class="o">&amp;</span>
		    <span class="n">ASC_EEP_CMD_DONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">AdvReadWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ASC_EEP_CMD_DONE</span><span class="p">)</span> <span class="o">==</span>
	    <span class="mi">0</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read the EEPROM from specified location</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ushort</span> <span class="n">__devinit</span> <span class="nf">AdvReadEEPWord</span><span class="p">(</span><span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eep_word_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span>
			     <span class="n">ASC_EEP_CMD_READ</span> <span class="o">|</span> <span class="n">eep_word_addr</span><span class="p">);</span>
	<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">AdvReadWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_DATA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write the EEPROM from &#39;cfg_buf&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span>
<span class="nf">AdvSet3550EEPConfig</span><span class="p">(</span><span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ADVEEP_3550_CONFIG</span> <span class="o">*</span><span class="n">cfg_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">addr</span><span class="p">,</span> <span class="n">chksum</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">charfields</span><span class="p">;</span>

	<span class="n">wbuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="n">cfg_buf</span><span class="p">;</span>
	<span class="n">charfields</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ADVEEP_3550_Config_Field_IsChar</span><span class="p">;</span>
	<span class="n">chksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span> <span class="n">ASC_EEP_CMD_WRITE_ABLE</span><span class="p">);</span>
	<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write EEPROM from word 0 to word 20.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ADV_EEP_DVC_CFG_BEGIN</span><span class="p">;</span>
	     <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">ADV_EEP_DVC_CFG_END</span><span class="p">;</span> <span class="n">addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ushort</span> <span class="n">word</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">charfields</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">word</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="o">*</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">word</span> <span class="o">=</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">chksum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>	<span class="cm">/* Checksum is calculated from word values. */</span>
		<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_DATA</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
		<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span>
				     <span class="n">ASC_EEP_CMD_WRITE</span> <span class="o">|</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="n">ADV_EEP_DELAY_MS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write EEPROM checksum at word 21.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_DATA</span><span class="p">,</span> <span class="n">chksum</span><span class="p">);</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span> <span class="n">ASC_EEP_CMD_WRITE</span> <span class="o">|</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">wbuf</span><span class="o">++</span><span class="p">;</span>
	<span class="n">charfields</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write EEPROM OEM name at words 22 to 29.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ADV_EEP_DVC_CTL_BEGIN</span><span class="p">;</span>
	     <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">ADV_EEP_MAX_WORD_ADDR</span><span class="p">;</span> <span class="n">addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ushort</span> <span class="n">word</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">charfields</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">word</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="o">*</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">word</span> <span class="o">=</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_DATA</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
		<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span>
				     <span class="n">ASC_EEP_CMD_WRITE</span> <span class="o">|</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span> <span class="n">ASC_EEP_CMD_WRITE_DISABLE</span><span class="p">);</span>
	<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write the EEPROM from &#39;cfg_buf&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span>
<span class="nf">AdvSet38C0800EEPConfig</span><span class="p">(</span><span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ADVEEP_38C0800_CONFIG</span> <span class="o">*</span><span class="n">cfg_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">charfields</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">addr</span><span class="p">,</span> <span class="n">chksum</span><span class="p">;</span>

	<span class="n">wbuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="n">cfg_buf</span><span class="p">;</span>
	<span class="n">charfields</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ADVEEP_38C0800_Config_Field_IsChar</span><span class="p">;</span>
	<span class="n">chksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span> <span class="n">ASC_EEP_CMD_WRITE_ABLE</span><span class="p">);</span>
	<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write EEPROM from word 0 to word 20.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ADV_EEP_DVC_CFG_BEGIN</span><span class="p">;</span>
	     <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">ADV_EEP_DVC_CFG_END</span><span class="p">;</span> <span class="n">addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ushort</span> <span class="n">word</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">charfields</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">word</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="o">*</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">word</span> <span class="o">=</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">chksum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>	<span class="cm">/* Checksum is calculated from word values. */</span>
		<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_DATA</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
		<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span>
				     <span class="n">ASC_EEP_CMD_WRITE</span> <span class="o">|</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="n">ADV_EEP_DELAY_MS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write EEPROM checksum at word 21.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_DATA</span><span class="p">,</span> <span class="n">chksum</span><span class="p">);</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span> <span class="n">ASC_EEP_CMD_WRITE</span> <span class="o">|</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">wbuf</span><span class="o">++</span><span class="p">;</span>
	<span class="n">charfields</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write EEPROM OEM name at words 22 to 29.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ADV_EEP_DVC_CTL_BEGIN</span><span class="p">;</span>
	     <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">ADV_EEP_MAX_WORD_ADDR</span><span class="p">;</span> <span class="n">addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ushort</span> <span class="n">word</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">charfields</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">word</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="o">*</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">word</span> <span class="o">=</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_DATA</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
		<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span>
				     <span class="n">ASC_EEP_CMD_WRITE</span> <span class="o">|</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span> <span class="n">ASC_EEP_CMD_WRITE_DISABLE</span><span class="p">);</span>
	<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write the EEPROM from &#39;cfg_buf&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span>
<span class="nf">AdvSet38C1600EEPConfig</span><span class="p">(</span><span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ADVEEP_38C1600_CONFIG</span> <span class="o">*</span><span class="n">cfg_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">charfields</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">addr</span><span class="p">,</span> <span class="n">chksum</span><span class="p">;</span>

	<span class="n">wbuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="n">cfg_buf</span><span class="p">;</span>
	<span class="n">charfields</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ADVEEP_38C1600_Config_Field_IsChar</span><span class="p">;</span>
	<span class="n">chksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span> <span class="n">ASC_EEP_CMD_WRITE_ABLE</span><span class="p">);</span>
	<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write EEPROM from word 0 to word 20.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ADV_EEP_DVC_CFG_BEGIN</span><span class="p">;</span>
	     <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">ADV_EEP_DVC_CFG_END</span><span class="p">;</span> <span class="n">addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ushort</span> <span class="n">word</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">charfields</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">word</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="o">*</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">word</span> <span class="o">=</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">chksum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>	<span class="cm">/* Checksum is calculated from word values. */</span>
		<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_DATA</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
		<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span>
				     <span class="n">ASC_EEP_CMD_WRITE</span> <span class="o">|</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="n">ADV_EEP_DELAY_MS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write EEPROM checksum at word 21.</span>
<span class="cm">	 */</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_DATA</span><span class="p">,</span> <span class="n">chksum</span><span class="p">);</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span> <span class="n">ASC_EEP_CMD_WRITE</span> <span class="o">|</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">wbuf</span><span class="o">++</span><span class="p">;</span>
	<span class="n">charfields</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write EEPROM OEM name at words 22 to 29.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ADV_EEP_DVC_CTL_BEGIN</span><span class="p">;</span>
	     <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">ADV_EEP_MAX_WORD_ADDR</span><span class="p">;</span> <span class="n">addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ushort</span> <span class="n">word</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">charfields</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">word</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="o">*</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">word</span> <span class="o">=</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_DATA</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
		<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span>
				     <span class="n">ASC_EEP_CMD_WRITE</span> <span class="o">|</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_EE_CMD</span><span class="p">,</span> <span class="n">ASC_EEP_CMD_WRITE_DISABLE</span><span class="p">);</span>
	<span class="n">AdvWaitEEPCmd</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read EEPROM configuration into the specified buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return a checksum based on the EEPROM configuration read.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ushort</span> <span class="n">__devinit</span>
<span class="nf">AdvGet3550EEPConfig</span><span class="p">(</span><span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ADVEEP_3550_CONFIG</span> <span class="o">*</span><span class="n">cfg_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">wval</span><span class="p">,</span> <span class="n">chksum</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">eep_addr</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">charfields</span><span class="p">;</span>

	<span class="n">charfields</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ADVEEP_3550_Config_Field_IsChar</span><span class="p">;</span>
	<span class="n">wbuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="n">cfg_buf</span><span class="p">;</span>
	<span class="n">chksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">eep_addr</span> <span class="o">=</span> <span class="n">ADV_EEP_DVC_CFG_BEGIN</span><span class="p">;</span>
	     <span class="n">eep_addr</span> <span class="o">&lt;</span> <span class="n">ADV_EEP_DVC_CFG_END</span><span class="p">;</span> <span class="n">eep_addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wval</span> <span class="o">=</span> <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">eep_addr</span><span class="p">);</span>
		<span class="n">chksum</span> <span class="o">+=</span> <span class="n">wval</span><span class="p">;</span>	<span class="cm">/* Checksum is calculated from word values. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">charfields</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">wval</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">wval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Read checksum word. */</span>
	<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">eep_addr</span><span class="p">);</span>
	<span class="n">wbuf</span><span class="o">++</span><span class="p">;</span>
	<span class="n">charfields</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Read rest of EEPROM not covered by the checksum. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">eep_addr</span> <span class="o">=</span> <span class="n">ADV_EEP_DVC_CTL_BEGIN</span><span class="p">;</span>
	     <span class="n">eep_addr</span> <span class="o">&lt;</span> <span class="n">ADV_EEP_MAX_WORD_ADDR</span><span class="p">;</span> <span class="n">eep_addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">eep_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">charfields</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">chksum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read EEPROM configuration into the specified buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return a checksum based on the EEPROM configuration read.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ushort</span> <span class="n">__devinit</span>
<span class="nf">AdvGet38C0800EEPConfig</span><span class="p">(</span><span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ADVEEP_38C0800_CONFIG</span> <span class="o">*</span><span class="n">cfg_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">wval</span><span class="p">,</span> <span class="n">chksum</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">eep_addr</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">charfields</span><span class="p">;</span>

	<span class="n">charfields</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ADVEEP_38C0800_Config_Field_IsChar</span><span class="p">;</span>
	<span class="n">wbuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="n">cfg_buf</span><span class="p">;</span>
	<span class="n">chksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">eep_addr</span> <span class="o">=</span> <span class="n">ADV_EEP_DVC_CFG_BEGIN</span><span class="p">;</span>
	     <span class="n">eep_addr</span> <span class="o">&lt;</span> <span class="n">ADV_EEP_DVC_CFG_END</span><span class="p">;</span> <span class="n">eep_addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wval</span> <span class="o">=</span> <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">eep_addr</span><span class="p">);</span>
		<span class="n">chksum</span> <span class="o">+=</span> <span class="n">wval</span><span class="p">;</span>	<span class="cm">/* Checksum is calculated from word values. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">charfields</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">wval</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">wval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Read checksum word. */</span>
	<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">eep_addr</span><span class="p">);</span>
	<span class="n">wbuf</span><span class="o">++</span><span class="p">;</span>
	<span class="n">charfields</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Read rest of EEPROM not covered by the checksum. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">eep_addr</span> <span class="o">=</span> <span class="n">ADV_EEP_DVC_CTL_BEGIN</span><span class="p">;</span>
	     <span class="n">eep_addr</span> <span class="o">&lt;</span> <span class="n">ADV_EEP_MAX_WORD_ADDR</span><span class="p">;</span> <span class="n">eep_addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">eep_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">charfields</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">chksum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read EEPROM configuration into the specified buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return a checksum based on the EEPROM configuration read.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ushort</span> <span class="n">__devinit</span>
<span class="nf">AdvGet38C1600EEPConfig</span><span class="p">(</span><span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ADVEEP_38C1600_CONFIG</span> <span class="o">*</span><span class="n">cfg_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ushort</span> <span class="n">wval</span><span class="p">,</span> <span class="n">chksum</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">eep_addr</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="o">*</span><span class="n">charfields</span><span class="p">;</span>

	<span class="n">charfields</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ADVEEP_38C1600_Config_Field_IsChar</span><span class="p">;</span>
	<span class="n">wbuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)</span><span class="n">cfg_buf</span><span class="p">;</span>
	<span class="n">chksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">eep_addr</span> <span class="o">=</span> <span class="n">ADV_EEP_DVC_CFG_BEGIN</span><span class="p">;</span>
	     <span class="n">eep_addr</span> <span class="o">&lt;</span> <span class="n">ADV_EEP_DVC_CFG_END</span><span class="p">;</span> <span class="n">eep_addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wval</span> <span class="o">=</span> <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">eep_addr</span><span class="p">);</span>
		<span class="n">chksum</span> <span class="o">+=</span> <span class="n">wval</span><span class="p">;</span>	<span class="cm">/* Checksum is calculated from word values. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">charfields</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">wval</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">wval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Read checksum word. */</span>
	<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">eep_addr</span><span class="p">);</span>
	<span class="n">wbuf</span><span class="o">++</span><span class="p">;</span>
	<span class="n">charfields</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Read rest of EEPROM not covered by the checksum. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">eep_addr</span> <span class="o">=</span> <span class="n">ADV_EEP_DVC_CTL_BEGIN</span><span class="p">;</span>
	     <span class="n">eep_addr</span> <span class="o">&lt;</span> <span class="n">ADV_EEP_MAX_WORD_ADDR</span><span class="p">;</span> <span class="n">eep_addr</span><span class="o">++</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">eep_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">charfields</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">chksum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read the board&#39;s EEPROM configuration. Set fields in ADV_DVC_VAR and</span>
<span class="cm"> * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while</span>
<span class="cm"> * all of this is done.</span>
<span class="cm"> *</span>
<span class="cm"> * On failure set the ADV_DVC_VAR field &#39;err_code&#39; and return ADV_ERROR.</span>
<span class="cm"> *</span>
<span class="cm"> * For a non-fatal error return a warning code. If there are no warnings</span>
<span class="cm"> * then 0 is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Chip is stopped on entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">AdvInitFrom3550EEP</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">warn_code</span><span class="p">;</span>
	<span class="n">ADVEEP_3550_CONFIG</span> <span class="n">eep_config</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>

	<span class="n">warn_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the board&#39;s EEPROM configuration.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set default values if a bad checksum is found.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AdvGet3550EEPConfig</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eep_config</span><span class="p">)</span> <span class="o">!=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">check_sum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_EEPROM_CHKSUM</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set EEPROM default values.</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eep_config</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Default_3550_EEPROM_Config</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">ADVEEP_3550_CONFIG</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Assume the 6 byte board serial number that was read from</span>
<span class="cm">		 * EEPROM is correct even if the EEPROM checksum failed.</span>
<span class="cm">		 */</span>
		<span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word3</span> <span class="o">=</span>
		    <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ADV_EEP_DVC_CFG_END</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word2</span> <span class="o">=</span>
		    <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ADV_EEP_DVC_CFG_END</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

		<span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word1</span> <span class="o">=</span>
		    <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ADV_EEP_DVC_CFG_END</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>

		<span class="n">AdvSet3550EEPConfig</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eep_config</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the</span>
<span class="cm">	 * EEPROM configuration that was read.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is the mapping of EEPROM fields to Adv Library fields.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">wdtr_able</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">wdtr_able</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_able</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">sdtr_able</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ultra_able</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">ultra_able</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">tagqng_able</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">tagqng_able</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">disc_enable</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">adapter_scsi_id</span> <span class="o">&amp;</span> <span class="n">ADV_MAX_TID</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">start_motor</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">start_motor</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">scsi_reset_wait</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">scsi_reset_delay</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">bios_ctrl</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">no_scam</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">scam_tolerant</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial1</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word1</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial2</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word2</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial3</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word3</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the host maximum queuing (max. 253, min. 16) and the per device</span>
<span class="cm">	 * maximum queuing (max. 63, min. 4).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">&gt;</span> <span class="n">ASC_DEF_MAX_HOST_QNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MAX_HOST_QNG</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">&lt;</span> <span class="n">ASC_DEF_MIN_HOST_QNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the value is zero, assume it is uninitialized. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MAX_HOST_QNG</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MIN_HOST_QNG</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">&gt;</span> <span class="n">ASC_DEF_MAX_DVC_QNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MAX_DVC_QNG</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">&lt;</span> <span class="n">ASC_DEF_MIN_DVC_QNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the value is zero, assume it is uninitialized. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MAX_DVC_QNG</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MIN_DVC_QNG</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If &#39;max_dvc_qng&#39; is greater than &#39;max_host_qng&#39;, then</span>
<span class="cm">	 * set &#39;max_dvc_qng&#39; to &#39;max_host_qng&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">&gt;</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set ADV_DVC_VAR &#39;max_host_qng&#39; and ADV_DVC_VAR &#39;max_dvc_qng&#39;</span>
<span class="cm">	 * values based on possibly adjusted EEPROM values.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the EEPROM &#39;termination&#39; field is set to automatic (0), then set</span>
<span class="cm">	 * the ADV_DVC_CFG &#39;termination&#39; field to automatic also.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the termination is specified with a non-zero &#39;termination&#39;</span>
<span class="cm">	 * value check that a legal value is set and set the ADV_DVC_CFG</span>
<span class="cm">	 * &#39;termination&#39; field appropriately.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* auto termination */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Enable manual control with low off / high off. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="n">TERM_CTL_SEL</span><span class="p">;</span>

			<span class="cm">/* Enable manual control with low off / high on. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="n">TERM_CTL_SEL</span> <span class="o">|</span> <span class="n">TERM_CTL_H</span><span class="p">;</span>

			<span class="cm">/* Enable manual control with low on / high on. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span>
			    <span class="n">TERM_CTL_SEL</span> <span class="o">|</span> <span class="n">TERM_CTL_H</span> <span class="o">|</span> <span class="n">TERM_CTL_L</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The EEPROM &#39;termination&#39; field contains a bad value. Use</span>
<span class="cm">			 * automatic termination instead.</span>
<span class="cm">			 */</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_EEPROM_TERMINATION</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">warn_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read the board&#39;s EEPROM configuration. Set fields in ADV_DVC_VAR and</span>
<span class="cm"> * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while</span>
<span class="cm"> * all of this is done.</span>
<span class="cm"> *</span>
<span class="cm"> * On failure set the ADV_DVC_VAR field &#39;err_code&#39; and return ADV_ERROR.</span>
<span class="cm"> *</span>
<span class="cm"> * For a non-fatal error return a warning code. If there are no warnings</span>
<span class="cm"> * then 0 is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Chip is stopped on entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">AdvInitFrom38C0800EEP</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">warn_code</span><span class="p">;</span>
	<span class="n">ADVEEP_38C0800_CONFIG</span> <span class="n">eep_config</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">tid</span><span class="p">,</span> <span class="n">termination</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>

	<span class="n">warn_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the board&#39;s EEPROM configuration.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set default values if a bad checksum is found.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AdvGet38C0800EEPConfig</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eep_config</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">eep_config</span><span class="p">.</span><span class="n">check_sum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_EEPROM_CHKSUM</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set EEPROM default values.</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eep_config</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Default_38C0800_EEPROM_Config</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">ADVEEP_38C0800_CONFIG</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Assume the 6 byte board serial number that was read from</span>
<span class="cm">		 * EEPROM is correct even if the EEPROM checksum failed.</span>
<span class="cm">		 */</span>
		<span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word3</span> <span class="o">=</span>
		    <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ADV_EEP_DVC_CFG_END</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word2</span> <span class="o">=</span>
		    <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ADV_EEP_DVC_CFG_END</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

		<span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word1</span> <span class="o">=</span>
		    <span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ADV_EEP_DVC_CFG_END</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>

		<span class="n">AdvSet38C0800EEPConfig</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eep_config</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set ADV_DVC_VAR and ADV_DVC_CFG variables from the</span>
<span class="cm">	 * EEPROM configuration that was read.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is the mapping of EEPROM fields to Adv Library fields.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">wdtr_able</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">wdtr_able</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed1</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">sdtr_speed1</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed2</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">sdtr_speed2</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed3</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">sdtr_speed3</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed4</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">sdtr_speed4</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">tagqng_able</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">tagqng_able</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">disc_enable</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">adapter_scsi_id</span> <span class="o">&amp;</span> <span class="n">ADV_MAX_TID</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">start_motor</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">start_motor</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">scsi_reset_wait</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">scsi_reset_delay</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">bios_ctrl</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">no_scam</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">scam_tolerant</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial1</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word1</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial2</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word2</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial3</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word3</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For every Target ID if any of its &#39;sdtr_speed[1234]&#39; bits</span>
<span class="cm">	 * are set, then set an &#39;sdtr_able&#39; bit for it.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_able</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tid</span> <span class="o">&lt;=</span> <span class="n">ADV_MAX_TID</span><span class="p">;</span> <span class="n">tid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdtr_speed</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdtr_speed</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdtr_speed</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed3</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdtr_speed</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed4</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdtr_speed</span> <span class="o">&amp;</span> <span class="n">ADV_MAX_TID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_able</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">tid</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">sdtr_speed</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the host maximum queuing (max. 253, min. 16) and the per device</span>
<span class="cm">	 * maximum queuing (max. 63, min. 4).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">&gt;</span> <span class="n">ASC_DEF_MAX_HOST_QNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MAX_HOST_QNG</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">&lt;</span> <span class="n">ASC_DEF_MIN_HOST_QNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the value is zero, assume it is uninitialized. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MAX_HOST_QNG</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MIN_HOST_QNG</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">&gt;</span> <span class="n">ASC_DEF_MAX_DVC_QNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MAX_DVC_QNG</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">&lt;</span> <span class="n">ASC_DEF_MIN_DVC_QNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the value is zero, assume it is uninitialized. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MAX_DVC_QNG</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MIN_DVC_QNG</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If &#39;max_dvc_qng&#39; is greater than &#39;max_host_qng&#39;, then</span>
<span class="cm">	 * set &#39;max_dvc_qng&#39; to &#39;max_host_qng&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">&gt;</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set ADV_DVC_VAR &#39;max_host_qng&#39; and ADV_DVC_VAR &#39;max_dvc_qng&#39;</span>
<span class="cm">	 * values based on possibly adjusted EEPROM values.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the EEPROM &#39;termination&#39; field is set to automatic (0), then set</span>
<span class="cm">	 * the ADV_DVC_CFG &#39;termination&#39; field to automatic also.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the termination is specified with a non-zero &#39;termination&#39;</span>
<span class="cm">	 * value check that a legal value is set and set the ADV_DVC_CFG</span>
<span class="cm">	 * &#39;termination&#39; field appropriately.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_se</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">termination</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* auto termination for SE */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Enable manual control with low off / high off. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_se</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">termination</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* Enable manual control with low off / high on. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_se</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">termination</span> <span class="o">=</span> <span class="n">TERM_SE_HI</span><span class="p">;</span>

			<span class="cm">/* Enable manual control with low on / high on. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_se</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">termination</span> <span class="o">=</span> <span class="n">TERM_SE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The EEPROM &#39;termination_se&#39; field contains a bad value.</span>
<span class="cm">			 * Use automatic termination instead.</span>
<span class="cm">			 */</span>
			<span class="n">termination</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_EEPROM_TERMINATION</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_lvd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="n">termination</span><span class="p">;</span>	<span class="cm">/* auto termination for LVD */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Enable manual control with low off / high off. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_lvd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="n">termination</span><span class="p">;</span>

			<span class="cm">/* Enable manual control with low off / high on. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_lvd</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="n">termination</span> <span class="o">|</span> <span class="n">TERM_LVD_HI</span><span class="p">;</span>

			<span class="cm">/* Enable manual control with low on / high on. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_lvd</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="n">termination</span> <span class="o">|</span> <span class="n">TERM_LVD</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The EEPROM &#39;termination_lvd&#39; field contains a bad value.</span>
<span class="cm">			 * Use automatic termination instead.</span>
<span class="cm">			 */</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="n">termination</span><span class="p">;</span>
			<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_EEPROM_TERMINATION</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">warn_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read the board&#39;s EEPROM configuration. Set fields in ASC_DVC_VAR and</span>
<span class="cm"> * ASC_DVC_CFG based on the EEPROM settings. The chip is stopped while</span>
<span class="cm"> * all of this is done.</span>
<span class="cm"> *</span>
<span class="cm"> * On failure set the ASC_DVC_VAR field &#39;err_code&#39; and return ADV_ERROR.</span>
<span class="cm"> *</span>
<span class="cm"> * For a non-fatal error return a warning code. If there are no warnings</span>
<span class="cm"> * then 0 is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Chip is stopped on entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">AdvInitFrom38C1600EEP</span><span class="p">(</span><span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AdvPortAddr</span> <span class="n">iop_base</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">warn_code</span><span class="p">;</span>
	<span class="n">ADVEEP_38C1600_CONFIG</span> <span class="n">eep_config</span><span class="p">;</span>
	<span class="n">uchar</span> <span class="n">tid</span><span class="p">,</span> <span class="n">termination</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">sdtr_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>

	<span class="n">warn_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the board&#39;s EEPROM configuration.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set default values if a bad checksum is found.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AdvGet38C1600EEPConfig</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eep_config</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">eep_config</span><span class="p">.</span><span class="n">check_sum</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adv_dvc_to_pdev</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
		<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_EEPROM_CHKSUM</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set EEPROM default values.</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eep_config</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Default_38C1600_EEPROM_Config</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">ADVEEP_38C1600_CONFIG</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">ints</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Disable Bit 14 (BIOS_ENABLE) to fix SPARC Ultra 60</span>
<span class="cm">			 * and old Mac system booting problem. The Expansion</span>
<span class="cm">			 * ROM must be disabled in Function 1 for these systems</span>
<span class="cm">			 */</span>
			<span class="n">eep_config</span><span class="p">.</span><span class="n">cfg_lsw</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ADV_EEPROM_BIOS_ENABLE</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Clear the INTAB (bit 11) if the GPIO 0 input</span>
<span class="cm">			 * indicates the Function 1 interrupt line is wired</span>
<span class="cm">			 * to INTB.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Set/Clear Bit 11 (INTAB) from the GPIO bit 0 input:</span>
<span class="cm">			 *   1 - Function 1 interrupt line wired to INT A.</span>
<span class="cm">			 *   0 - Function 1 interrupt line wired to INT B.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Note: Function 0 is always wired to INTA.</span>
<span class="cm">			 * Put all 5 GPIO bits in input mode and then read</span>
<span class="cm">			 * their input values.</span>
<span class="cm">			 */</span>
			<span class="n">AdvWriteByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_GPIO_CNTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ints</span> <span class="o">=</span> <span class="n">AdvReadByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_GPIO_DATA</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ints</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">eep_config</span><span class="p">.</span><span class="n">cfg_lsw</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ADV_EEPROM_INTAB</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Assume the 6 byte board serial number that was read from</span>
<span class="cm">		 * EEPROM is correct even if the EEPROM checksum failed.</span>
<span class="cm">		 */</span>
		<span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word3</span> <span class="o">=</span>
			<span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ADV_EEP_DVC_CFG_END</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word2</span> <span class="o">=</span>
			<span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ADV_EEP_DVC_CFG_END</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">eep_config</span><span class="p">.</span><span class="n">serial_number_word1</span> <span class="o">=</span>
			<span class="n">AdvReadEEPWord</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ADV_EEP_DVC_CFG_END</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>

		<span class="n">AdvSet38C1600EEPConfig</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eep_config</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the</span>
<span class="cm">	 * EEPROM configuration that was read.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is the mapping of EEPROM fields to Adv Library fields.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">wdtr_able</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">wdtr_able</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed1</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">sdtr_speed1</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed2</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">sdtr_speed2</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed3</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">sdtr_speed3</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed4</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">sdtr_speed4</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">ppr_able</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">tagqng_able</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">tagqng_able</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">disc_enable</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">adapter_scsi_id</span> <span class="o">&amp;</span> <span class="n">ASC_MAX_TID</span><span class="p">);</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">start_motor</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">start_motor</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">scsi_reset_wait</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">scsi_reset_delay</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">bios_ctrl</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">no_scam</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">scam_tolerant</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For every Target ID if any of its &#39;sdtr_speed[1234]&#39; bits</span>
<span class="cm">	 * are set, then set an &#39;sdtr_able&#39; bit for it.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_able</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tid</span> <span class="o">&lt;=</span> <span class="n">ASC_MAX_TID</span><span class="p">;</span> <span class="n">tid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdtr_speed</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdtr_speed</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdtr_speed</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed3</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdtr_speed</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_speed4</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdtr_speed</span> <span class="o">&amp;</span> <span class="n">ASC_MAX_TID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">sdtr_able</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">tid</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">sdtr_speed</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the host maximum queuing (max. 253, min. 16) and the per device</span>
<span class="cm">	 * maximum queuing (max. 63, min. 4).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">&gt;</span> <span class="n">ASC_DEF_MAX_HOST_QNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MAX_HOST_QNG</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">&lt;</span> <span class="n">ASC_DEF_MIN_HOST_QNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the value is zero, assume it is uninitialized. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MAX_HOST_QNG</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MIN_HOST_QNG</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">&gt;</span> <span class="n">ASC_DEF_MAX_DVC_QNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MAX_DVC_QNG</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">&lt;</span> <span class="n">ASC_DEF_MIN_DVC_QNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the value is zero, assume it is uninitialized. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MAX_DVC_QNG</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">ASC_DEF_MIN_DVC_QNG</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If &#39;max_dvc_qng&#39; is greater than &#39;max_host_qng&#39;, then</span>
<span class="cm">	 * set &#39;max_dvc_qng&#39; to &#39;max_host_qng&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">&gt;</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set ASC_DVC_VAR &#39;max_host_qng&#39; and ASC_DVC_VAR &#39;max_dvc_qng&#39;</span>
<span class="cm">	 * values based on possibly adjusted EEPROM values.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_host_qng</span><span class="p">;</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">eep_config</span><span class="p">.</span><span class="n">max_dvc_qng</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the EEPROM &#39;termination&#39; field is set to automatic (0), then set</span>
<span class="cm">	 * the ASC_DVC_CFG &#39;termination&#39; field to automatic also.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the termination is specified with a non-zero &#39;termination&#39;</span>
<span class="cm">	 * value check that a legal value is set and set the ASC_DVC_CFG</span>
<span class="cm">	 * &#39;termination&#39; field appropriately.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_se</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">termination</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* auto termination for SE */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Enable manual control with low off / high off. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_se</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">termination</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* Enable manual control with low off / high on. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_se</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">termination</span> <span class="o">=</span> <span class="n">TERM_SE_HI</span><span class="p">;</span>

			<span class="cm">/* Enable manual control with low on / high on. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_se</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">termination</span> <span class="o">=</span> <span class="n">TERM_SE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The EEPROM &#39;termination_se&#39; field contains a bad value.</span>
<span class="cm">			 * Use automatic termination instead.</span>
<span class="cm">			 */</span>
			<span class="n">termination</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_EEPROM_TERMINATION</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_lvd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="n">termination</span><span class="p">;</span>	<span class="cm">/* auto termination for LVD */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Enable manual control with low off / high off. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_lvd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="n">termination</span><span class="p">;</span>

			<span class="cm">/* Enable manual control with low off / high on. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_lvd</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="n">termination</span> <span class="o">|</span> <span class="n">TERM_LVD_HI</span><span class="p">;</span>

			<span class="cm">/* Enable manual control with low on / high on. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eep_config</span><span class="p">.</span><span class="n">termination_lvd</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="n">termination</span> <span class="o">|</span> <span class="n">TERM_LVD</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The EEPROM &#39;termination_lvd&#39; field contains a bad value.</span>
<span class="cm">			 * Use automatic termination instead.</span>
<span class="cm">			 */</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="n">termination</span><span class="p">;</span>
			<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">ASC_WARN_EEPROM_TERMINATION</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">warn_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the ADV_DVC_VAR structure.</span>
<span class="cm"> *</span>
<span class="cm"> * On failure set the ADV_DVC_VAR field &#39;err_code&#39; and return ADV_ERROR.</span>
<span class="cm"> *</span>
<span class="cm"> * For a non-fatal error return a warning code. If there are no warnings</span>
<span class="cm"> * then 0 is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">AdvInitGetConfig</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">board</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">warn_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">AdvPortAddr</span> <span class="n">iop_base</span> <span class="o">=</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save the state of the PCI Configuration Command Register</span>
<span class="cm">	 * &quot;Parity Error Response Control&quot; Bit. If the bit is clear (0),</span>
<span class="cm">	 * in AdvInitAsc3550/38C0800Driver() tell the microcode to ignore</span>
<span class="cm">	 * DMA parity errors.</span>
<span class="cm">	 */</span>
	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">control_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_PARITY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">control_flag</span> <span class="o">|=</span> <span class="n">CONTROL_FLAG_IGNORE_PERR</span><span class="p">;</span>

	<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chip_version</span> <span class="o">=</span>
	    <span class="n">AdvGetChipVersion</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">bus_type</span><span class="p">);</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;iopb_chip_id_1: 0x%x 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">AdvReadByteRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPB_CHIP_ID_1</span><span class="p">),</span>
		 <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ADV_CHIP_ID_BYTE</span><span class="p">);</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;iopw_chip_id_0: 0x%x 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">AdvReadWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_CHIP_ID_0</span><span class="p">),</span>
		 <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">ADV_CHIP_ID_WORD</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset the chip to start and allow register writes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AdvFindSignature</span><span class="p">(</span><span class="n">iop_base</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">=</span> <span class="n">ASC_IERR_BAD_SIGNATURE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The caller must set &#39;chip_type&#39; to a valid setting.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">!=</span> <span class="n">ADV_CHIP_ASC3550</span> <span class="o">&amp;&amp;</span>
		    <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">!=</span> <span class="n">ADV_CHIP_ASC38C0800</span> <span class="o">&amp;&amp;</span>
		    <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">!=</span> <span class="n">ADV_CHIP_ASC38C1600</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span> <span class="o">|=</span> <span class="n">ASC_IERR_BAD_CHIPTYPE</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Reset Chip.</span>
<span class="cm">		 */</span>
		<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_CTRL_REG</span><span class="p">,</span>
				     <span class="n">ADV_CTRL_REG_CMD_RESET</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="n">AdvWriteWordRegister</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">IOPW_CTRL_REG</span><span class="p">,</span>
				     <span class="n">ADV_CTRL_REG_CMD_WR_IO_REG</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C1600</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">AdvInitFrom38C1600EEP</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">AdvInitFrom38C0800EEP</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">AdvInitFrom3550EEP</span><span class="p">(</span><span class="n">asc_dvc</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">warn_code</span> <span class="o">|=</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">warn_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;warning: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">warn_code</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">)</span>
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;error code 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">asc_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">advansys_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">proc_name</span> <span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="p">.</span><span class="n">proc_info</span> <span class="o">=</span> <span class="n">advansys_proc_info</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">advansys_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span> <span class="o">=</span> <span class="n">advansys_queuecommand</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_bus_reset_handler</span> <span class="o">=</span> <span class="n">advansys_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bios_param</span> <span class="o">=</span> <span class="n">advansys_biosparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_configure</span> <span class="o">=</span> <span class="n">advansys_slave_configure</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Because the driver may control an ISA adapter &#39;unchecked_isa_dma&#39;</span>
<span class="cm">	 * must be set. The flag will be cleared in advansys_board_found</span>
<span class="cm">	 * for non-ISA adapters.</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">unchecked_isa_dma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * All adapters controlled by this driver are capable of large</span>
<span class="cm">	 * scatter-gather lists. According to the mid-level SCSI documentation</span>
<span class="cm">	 * this obviates any performance gain provided by setting</span>
<span class="cm">	 * &#39;use_clustering&#39;. But empirically while CPU utilization is increased</span>
<span class="cm">	 * by enabling clustering, I/O throughput increases as well.</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">use_clustering</span> <span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">advansys_wide_init_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">board</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">adv_dvc_var</span> <span class="o">*</span><span class="n">adv_dvc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">req_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adv_req_t</span> <span class="o">*</span><span class="n">reqp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sg_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adv_sgblk_t</span> <span class="o">*</span><span class="n">sgp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">warn_code</span><span class="p">,</span> <span class="n">err_code</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate buffer carrier structures. The total size</span>
<span class="cm">	 * is about 4 KB, so allocate all at once.</span>
<span class="cm">	 */</span>
	<span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">carrier_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">ADV_CARRIER_BUFSIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;carrier_buf 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">carrier_buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">carrier_buf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">kmalloc_failed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate up to &#39;max_host_qng&#39; request structures for the Wide</span>
<span class="cm">	 * board. The total size is about 16 KB, so allocate all at once.</span>
<span class="cm">	 * If the allocation fails decrement and try again.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">req_cnt</span> <span class="o">=</span> <span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">max_host_qng</span><span class="p">;</span> <span class="n">req_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">req_cnt</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reqp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">adv_req_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">req_cnt</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;reqp 0x%p, req_cnt %d, bytes %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reqp</span><span class="p">,</span> <span class="n">req_cnt</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">adv_req_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">req_cnt</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reqp</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reqp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">kmalloc_failed</span><span class="p">;</span>

	<span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">orig_reqp</span> <span class="o">=</span> <span class="n">reqp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate up to ADV_TOT_SG_BLOCK request structures for</span>
<span class="cm">	 * the Wide board. Each structure is about 136 bytes.</span>
<span class="cm">	 */</span>
	<span class="n">board</span><span class="o">-&gt;</span><span class="n">adv_sgblkp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sg_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sg_cnt</span> <span class="o">&lt;</span> <span class="n">ADV_TOT_SG_BLOCK</span><span class="p">;</span> <span class="n">sg_cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sgp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">adv_sgblk_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgp</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">sgp</span><span class="o">-&gt;</span><span class="n">next_sgblkp</span> <span class="o">=</span> <span class="n">board</span><span class="o">-&gt;</span><span class="n">adv_sgblkp</span><span class="p">;</span>
		<span class="n">board</span><span class="o">-&gt;</span><span class="n">adv_sgblkp</span> <span class="o">=</span> <span class="n">sgp</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;sg_cnt %d * %lu = %lu bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sg_cnt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">adv_sgblk_t</span><span class="p">),</span>
		 <span class="k">sizeof</span><span class="p">(</span><span class="n">adv_sgblk_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">sg_cnt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">adv_sgblkp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">kmalloc_failed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Point &#39;adv_reqp&#39; to the request structures and</span>
<span class="cm">	 * link them together.</span>
<span class="cm">	 */</span>
	<span class="n">req_cnt</span><span class="o">--</span><span class="p">;</span>
	<span class="n">reqp</span><span class="p">[</span><span class="n">req_cnt</span><span class="p">].</span><span class="n">next_reqp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">req_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">req_cnt</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reqp</span><span class="p">[</span><span class="n">req_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">next_reqp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reqp</span><span class="p">[</span><span class="n">req_cnt</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">board</span><span class="o">-&gt;</span><span class="n">adv_reqp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reqp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;AdvInitAsc3550Driver()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">warn_code</span> <span class="o">=</span> <span class="n">AdvInitAsc3550Driver</span><span class="p">(</span><span class="n">adv_dvc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;AdvInitAsc38C0800Driver()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">warn_code</span> <span class="o">=</span> <span class="n">AdvInitAsc38C0800Driver</span><span class="p">(</span><span class="n">adv_dvc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;AdvInitAsc38C1600Driver()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">warn_code</span> <span class="o">=</span> <span class="n">AdvInitAsc38C1600Driver</span><span class="p">(</span><span class="n">adv_dvc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">err_code</span> <span class="o">=</span> <span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">warn_code</span> <span class="o">||</span> <span class="n">err_code</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;error: warn 0x%x, error &quot;</span>
			<span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">warn_code</span><span class="p">,</span> <span class="n">err_code</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

 <span class="nl">kmalloc_failed:</span>
	<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;error: kmalloc() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">err_code</span> <span class="o">=</span> <span class="n">ADV_ERROR</span><span class="p">;</span>
 <span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">err_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">advansys_wide_free_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">board</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adv_dvc_var</span> <span class="o">*</span><span class="n">adv_dvc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">carrier_buf</span><span class="p">);</span>
	<span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">carrier_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">orig_reqp</span><span class="p">);</span>
	<span class="n">adv_dvc</span><span class="o">-&gt;</span><span class="n">orig_reqp</span> <span class="o">=</span> <span class="n">board</span><span class="o">-&gt;</span><span class="n">adv_reqp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">adv_sgblkp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adv_sgblk_t</span> <span class="o">*</span><span class="n">sgp</span> <span class="o">=</span> <span class="n">board</span><span class="o">-&gt;</span><span class="n">adv_sgblkp</span><span class="p">;</span>
		<span class="n">board</span><span class="o">-&gt;</span><span class="n">adv_sgblkp</span> <span class="o">=</span> <span class="n">sgp</span><span class="o">-&gt;</span><span class="n">next_sgblkp</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sgp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">advansys_board_found</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bus_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">boardp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">ASC_DVC_VAR</span> <span class="o">*</span><span class="n">asc_dvc_varp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ADV_DVC_VAR</span> <span class="o">*</span><span class="n">adv_dvc_varp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">share_irq</span><span class="p">,</span> <span class="n">warn_code</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pdev</span> <span class="o">=</span> <span class="p">(</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">ASC_IS_PCI</span><span class="p">)</span> <span class="o">?</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;narrow board</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">asc_dvc_varp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">;</span>
		<span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">=</span> <span class="n">bus_type</span><span class="p">;</span>
		<span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">drv_ptr</span> <span class="o">=</span> <span class="n">boardp</span><span class="p">;</span>
		<span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_cfg</span><span class="p">.</span><span class="n">asc_dvc_cfg</span><span class="p">;</span>
		<span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">iop_base</span> <span class="o">=</span> <span class="n">iop</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_PCI</span>
		<span class="n">adv_dvc_varp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">adv_dvc_var</span><span class="p">;</span>
		<span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">drv_ptr</span> <span class="o">=</span> <span class="n">boardp</span><span class="p">;</span>
		<span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dvc_cfg</span><span class="p">.</span><span class="n">adv_dvc_cfg</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_ASP_ABP940UW</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;wide board ASC-3550</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">=</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_38C0800_REV1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;wide board ASC-38C0800</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">=</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;wide board ASC-38C1600</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">=</span> <span class="n">ADV_CHIP_ASC38C1600</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">asc_n_io_port</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">ioremap_addr</span> <span class="o">=</span> <span class="n">pci_ioremap_bar</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">ioremap_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;ioremap(%lx, %d) &quot;</span>
					<span class="s">&quot;returned NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
					<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">asc_n_io_port</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_shost</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">iop_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">AdvPortAddr</span><span class="p">)</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">ioremap_addr</span><span class="p">;</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;iop_base: 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Even though it isn&#39;t used to access wide boards, other</span>
<span class="cm">		 * than for the debug line below, save I/O Port address so</span>
<span class="cm">		 * that it can be reported.</span>
<span class="cm">		 */</span>
		<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">ioport</span> <span class="o">=</span> <span class="n">iop</span><span class="p">;</span>

		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;iopb_chip_id_1 0x%x, iopw_chip_id_0 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">inp</span><span class="p">(</span><span class="n">iop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="n">inpw</span><span class="p">(</span><span class="n">iop</span><span class="p">));</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocate buffer for printing information from</span>
<span class="cm">	 * /proc/scsi/advansys/[0...].</span>
<span class="cm">	 */</span>
	<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">prtbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">ASC_PRTBUF_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">prtbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;kmalloc(%d) returned NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ASC_PRTBUF_SIZE</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_unmap</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set the board bus type and PCI IRQ before</span>
<span class="cm">		 * calling AscInitGetConfig().</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">bus_type</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_ISA</span>
		<span class="k">case</span> <span class="n">ASC_IS_ISA</span>:
			<span class="n">shost</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="n">share_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ASC_IS_VL</span>:
			<span class="n">shost</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
			<span class="n">share_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ASC_IS_EISA</span>:
			<span class="n">shost</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
			<span class="n">share_irq</span> <span class="o">=</span> <span class="n">IRQF_SHARED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ISA */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_PCI</span>
		<span class="k">case</span> <span class="n">ASC_IS_PCI</span>:
			<span class="n">shost</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
			<span class="n">share_irq</span> <span class="o">=</span> <span class="n">IRQF_SHARED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>
		<span class="nl">default:</span>
			<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;unknown adapter type: &quot;</span>
					<span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">bus_type</span><span class="p">);</span>
			<span class="n">shost</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="n">share_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * NOTE: AscInitGetConfig() may change the board&#39;s</span>
<span class="cm">		 * bus_type value. The bus_type value should no</span>
<span class="cm">		 * longer be used. If the bus_type field must be</span>
<span class="cm">		 * referenced only use the bit-wise AND operator &quot;&amp;&quot;.</span>
<span class="cm">		 */</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;AscInitGetConfig()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">AscInitGetConfig</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENODEV</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_PCI</span>
		<span class="cm">/*</span>
<span class="cm">		 * For Wide boards set PCI information before calling</span>
<span class="cm">		 * AdvInitGetConfig().</span>
<span class="cm">		 */</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="n">share_irq</span> <span class="o">=</span> <span class="n">IRQF_SHARED</span><span class="p">;</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;AdvInitGetConfig()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">AdvInitGetConfig</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">shost</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENODEV</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_proc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save the EEPROM configuration so that it can be displayed</span>
<span class="cm">	 * from /proc/scsi/advansys/[0...].</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">ASCEEP_CONFIG</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set the adapter&#39;s target id bit in the &#39;init_tidmask&#39; field.</span>
<span class="cm">		 */</span>
		<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">|=</span>
		    <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Save EEPROM settings for the board.</span>
<span class="cm">		 */</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">eep_config</span><span class="p">.</span><span class="n">asc_eep</span><span class="p">;</span>

		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">init_sdtr</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">sdtr_enable</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">disc_enable</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">use_cmd_qng</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">cmd_qng_enabled</span><span class="p">;</span>
		<span class="n">ASC_EEP_SET_DMA_SPD</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">isa_dma_speed</span><span class="p">);</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">start_motor</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">start_motor</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">cntl</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">dvc_cntl</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">no_scam</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">no_scam</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">max_total_qng</span><span class="p">;</span>
		<span class="n">ASC_EEP_SET_CHIP_ID</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">);</span>
		<span class="cm">/* &#39;max_tag_qng&#39; is set to the same value for every device. */</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">max_tag_qng</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">max_tag_qng</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * Modify board configuration.</span>
<span class="cm">		 */</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;AscInitSetConfig()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">AscInitSetConfig</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">shost</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENODEV</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_free_proc</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ADVEEP_3550_CONFIG</span> <span class="o">*</span><span class="n">ep_3550</span><span class="p">;</span>
		<span class="n">ADVEEP_38C0800_CONFIG</span> <span class="o">*</span><span class="n">ep_38C0800</span><span class="p">;</span>
		<span class="n">ADVEEP_38C1600_CONFIG</span> <span class="o">*</span><span class="n">ep_38C1600</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Save Wide EEP Configuration Information.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC3550</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ep_3550</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">eep_config</span><span class="p">.</span><span class="n">adv_3550_eep</span><span class="p">;</span>

			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">adapter_scsi_id</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">;</span>
			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">max_host_qng</span><span class="p">;</span>
			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">;</span>
			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">termination</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span><span class="p">;</span>
			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">disc_enable</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">;</span>
			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span><span class="p">;</span>
			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">wdtr_able</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">wdtr_able</span><span class="p">;</span>
			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">sdtr_able</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">sdtr_able</span><span class="p">;</span>
			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">ultra_able</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">ultra_able</span><span class="p">;</span>
			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">tagqng_able</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">tagqng_able</span><span class="p">;</span>
			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">start_motor</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">start_motor</span><span class="p">;</span>
			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">scsi_reset_delay</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">scsi_reset_wait</span><span class="p">;</span>
			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">serial_number_word1</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial1</span><span class="p">;</span>
			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">serial_number_word2</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial2</span><span class="p">;</span>
			<span class="n">ep_3550</span><span class="o">-&gt;</span><span class="n">serial_number_word3</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial3</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_type</span> <span class="o">==</span> <span class="n">ADV_CHIP_ASC38C0800</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ep_38C0800</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">eep_config</span><span class="p">.</span><span class="n">adv_38C0800_eep</span><span class="p">;</span>

			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">adapter_scsi_id</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">max_host_qng</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">termination_lvd</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">disc_enable</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">wdtr_able</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">wdtr_able</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">tagqng_able</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">tagqng_able</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">sdtr_speed1</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">sdtr_speed1</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">sdtr_speed2</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">sdtr_speed2</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">sdtr_speed3</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">sdtr_speed3</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">sdtr_speed4</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">sdtr_speed4</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">tagqng_able</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">tagqng_able</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">start_motor</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">start_motor</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">scsi_reset_delay</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">scsi_reset_wait</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">serial_number_word1</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial1</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">serial_number_word2</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial2</span><span class="p">;</span>
			<span class="n">ep_38C0800</span><span class="o">-&gt;</span><span class="n">serial_number_word3</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial3</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ep_38C1600</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">eep_config</span><span class="p">.</span><span class="n">adv_38C1600_eep</span><span class="p">;</span>

			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">adapter_scsi_id</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">max_host_qng</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">max_host_qng</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">max_dvc_qng</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">termination_lvd</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">termination</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">disc_enable</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">disc_enable</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">bios_ctrl</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">wdtr_able</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">wdtr_able</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">tagqng_able</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">tagqng_able</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">sdtr_speed1</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">sdtr_speed1</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">sdtr_speed2</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">sdtr_speed2</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">sdtr_speed3</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">sdtr_speed3</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">sdtr_speed4</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">sdtr_speed4</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">tagqng_able</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">tagqng_able</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">start_motor</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">start_motor</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">scsi_reset_delay</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">scsi_reset_wait</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">serial_number_word1</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial1</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">serial_number_word2</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial2</span><span class="p">;</span>
			<span class="n">ep_38C1600</span><span class="o">-&gt;</span><span class="n">serial_number_word3</span> <span class="o">=</span>
			    <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">serial3</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set the adapter&#39;s target id bit in the &#39;init_tidmask&#39; field.</span>
<span class="cm">		 */</span>
		<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">init_tidmask</span> <span class="o">|=</span>
		    <span class="n">ADV_TID_TO_TIDMASK</span><span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Channels are numbered beginning with 0. For AdvanSys one host</span>
<span class="cm">	 * structure supports one channel. Multi-channel boards have a</span>
<span class="cm">	 * separate host structure for each channel.</span>
<span class="cm">	 */</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="n">ASC_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="n">ASC_MAX_LUN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">=</span> <span class="n">ASC_MAX_CDB_LEN</span><span class="p">;</span>

		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">io_port</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">;</span>
		<span class="n">boardp</span><span class="o">-&gt;</span><span class="n">asc_n_io_port</span> <span class="o">=</span> <span class="n">ASC_IOADR_GAP</span><span class="p">;</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">;</span>

		<span class="cm">/* Set maximum number of queues the adapter can handle. */</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">max_total_qng</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="n">ADV_MAX_TID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="n">ADV_MAX_LUN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">=</span> <span class="n">ADV_MAX_CDB_LEN</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Save the I/O Port address and length even though</span>
<span class="cm">		 * I/O ports are not used to access Wide boards.</span>
<span class="cm">		 * Instead the Wide boards are accessed with</span>
<span class="cm">		 * PCI Memory Mapped I/O.</span>
<span class="cm">		 */</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">io_port</span> <span class="o">=</span> <span class="n">iop</span><span class="p">;</span>

		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">chip_scsi_id</span><span class="p">;</span>

		<span class="cm">/* Set maximum number of queues the adapter can handle. */</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">max_host_qng</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Following v1.3.89, &#39;cmd_per_lun&#39; is no longer needed</span>
<span class="cm">	 * and should be set to zero.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But because of a bug introduced in v1.3.89 if the driver is</span>
<span class="cm">	 * compiled as a module and &#39;cmd_per_lun&#39; is zero, the Mid-Level</span>
<span class="cm">	 * SCSI function &#39;allocate_device&#39; will panic. To allow the driver</span>
<span class="cm">	 * to work as a module in these kernels set &#39;cmd_per_lun&#39; to 1.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: This is wrong.  cmd_per_lun should be set to the depth</span>
<span class="cm">	 * you want on untagged devices always.</span>
<span class="cm">	 #ifdef MODULE</span>
<span class="cm">	 */</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cm">/* #else</span>
<span class="cm">            shost-&gt;cmd_per_lun = 0;</span>
<span class="cm">#endif */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the maximum number of scatter-gather elements the</span>
<span class="cm">	 * adapter can handle.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allow two commands with &#39;sg_tablesize&#39; scatter-gather</span>
<span class="cm">		 * elements to be executed simultaneously. This value is</span>
<span class="cm">		 * the theoretical hardware limit. It may be decreased</span>
<span class="cm">		 * below.</span>
<span class="cm">		 */</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">=</span>
		    <span class="p">(((</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">max_total_qng</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
		     <span class="n">ASC_SG_LIST_PER_Q</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">ADV_MAX_SG_LIST</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The value of &#39;sg_tablesize&#39; can not exceed the SCSI</span>
<span class="cm">	 * mid-level driver definition of SG_ALL. SG_ALL also</span>
<span class="cm">	 * must not be exceeded, because it is used to define the</span>
<span class="cm">	 * size of the scatter-gather table in &#39;struct asc_sg_head&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">&gt;</span> <span class="n">SG_ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">SG_ALL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;sg_tablesize: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span><span class="p">);</span>

	<span class="cm">/* BIOS start address. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">AscGetChipBiosAddress</span><span class="p">(</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span>
						    <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">bus_type</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Fill-in BIOS board variables. The Wide BIOS saves</span>
<span class="cm">		 * information in LRAM that is used by the driver.</span>
<span class="cm">		 */</span>
		<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span>
				<span class="n">BIOS_SIGNATURE</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">bios_signature</span><span class="p">);</span>
		<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span>
				<span class="n">BIOS_VERSION</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">bios_version</span><span class="p">);</span>
		<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span>
				<span class="n">BIOS_CODESEG</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">bios_codeseg</span><span class="p">);</span>
		<span class="n">AdvReadWordLram</span><span class="p">(</span><span class="n">adv_dvc_varp</span><span class="o">-&gt;</span><span class="n">iop_base</span><span class="p">,</span>
				<span class="n">BIOS_CODELEN</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">bios_codelen</span><span class="p">);</span>

		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;bios_signature 0x%x, bios_version 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">bios_signature</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">bios_version</span><span class="p">);</span>

		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;bios_codeseg 0x%x, bios_codelen 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">bios_codeseg</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">bios_codelen</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the BIOS saved a valid signature, then fill in</span>
<span class="cm">		 * the BIOS code segment base address.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">bios_signature</span> <span class="o">==</span> <span class="mh">0x55AA</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Convert x86 realmode code segment to a linear</span>
<span class="cm">			 * address by shifting left 4.</span>
<span class="cm">			 */</span>
			<span class="n">shost</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="p">((</span><span class="n">ulong</span><span class="p">)</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">bios_codeseg</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">shost</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register Board Resources - I/O Port, DMA, IRQ</span>
<span class="cm">	 */</span>

	<span class="cm">/* Register DMA Channel for Narrow boards. */</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_channel</span> <span class="o">=</span> <span class="n">NO_ISA_DMA</span><span class="p">;</span>	<span class="cm">/* Default to no ISA DMA. */</span>
<span class="cp">#ifdef CONFIG_ISA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Register DMA channel for ISA bus. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">&amp;</span> <span class="n">ASC_IS_ISA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_channel</span> <span class="o">=</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">isa_dma_channel</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">request_dma</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_channel</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;request_dma() &quot;</span>
						<span class="s">&quot;%d failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_channel</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err_free_proc</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">AscEnableIsaDma</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_channel</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ISA */</span><span class="cp"></span>

	<span class="cm">/* Register IRQ Number. */</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;request_irq(%d, %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">advansys_interrupt</span><span class="p">,</span> <span class="n">share_irq</span><span class="p">,</span>
			  <span class="n">DRV_NAME</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;request_irq(): IRQ 0x%x &quot;</span>
					<span class="s">&quot;already in use</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;request_irq(): IRQ 0x%x &quot;</span>
					<span class="s">&quot;not valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;request_irq(): IRQ 0x%x &quot;</span>
					<span class="s">&quot;failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">err_free_dma</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize board RISC chip and enable interrupts.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;AscInitAsc1000Driver()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">overrun_buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">ASC_OVERRUN_BSIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">overrun_buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_free_irq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">warn_code</span> <span class="o">=</span> <span class="n">AscInitAsc1000Driver</span><span class="p">(</span><span class="n">asc_dvc_varp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">warn_code</span> <span class="o">||</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span> <span class="s">&quot;error: init_state 0x%x, &quot;</span>
					<span class="s">&quot;warn 0x%x, error 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">init_state</span><span class="p">,</span> <span class="n">warn_code</span><span class="p">,</span>
					<span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">overrun_dma</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">err_free_mem</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">advansys_wide_init_chip</span><span class="p">(</span><span class="n">shost</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_free_mem</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ASC_DBG_PRT_SCSI_HOST</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_add_host</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_mem</span><span class="p">;</span>

	<span class="n">scsi_scan_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">err_free_mem:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">boardp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">overrun_dma</span><span class="p">)</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">overrun_dma</span><span class="p">,</span>
					 <span class="n">ASC_OVERRUN_BSIZE</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">asc_dvc_varp</span><span class="o">-&gt;</span><span class="n">overrun_buf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">advansys_wide_free_mem</span><span class="p">(</span><span class="n">boardp</span><span class="p">);</span>
 <span class="nl">err_free_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>
 <span class="nl">err_free_dma:</span>
<span class="cp">#ifdef CONFIG_ISA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_channel</span> <span class="o">!=</span> <span class="n">NO_ISA_DMA</span><span class="p">)</span>
		<span class="n">free_dma</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_channel</span><span class="p">);</span>
<span class="cp">#endif</span>
 <span class="nl">err_free_proc:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">prtbuf</span><span class="p">);</span>
 <span class="nl">err_unmap:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">ioremap_addr</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">boardp</span><span class="o">-&gt;</span><span class="n">ioremap_addr</span><span class="p">);</span>
 <span class="nl">err_shost:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * advansys_release()</span>
<span class="cm"> *</span>
<span class="cm"> * Release resources allocated for a single AdvanSys adapter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">advansys_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">board</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;begin</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_ISA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_channel</span> <span class="o">!=</span> <span class="n">NO_ISA_DMA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;free_dma()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">free_dma</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_channel</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ASC_NARROW_BOARD</span><span class="p">(</span><span class="n">board</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">board</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">.</span><span class="n">overrun_dma</span><span class="p">,</span>
					<span class="n">ASC_OVERRUN_BSIZE</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">dvc_var</span><span class="p">.</span><span class="n">asc_dvc_var</span><span class="p">.</span><span class="n">overrun_buf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">ioremap_addr</span><span class="p">);</span>
		<span class="n">advansys_wide_free_mem</span><span class="p">(</span><span class="n">board</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">prtbuf</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define ASC_IOADR_TABLE_MAX_IX  11</span>

<span class="k">static</span> <span class="n">PortAddr</span> <span class="n">_asc_def_iop_base</span><span class="p">[</span><span class="n">ASC_IOADR_TABLE_MAX_IX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x100</span><span class="p">,</span> <span class="mh">0x0110</span><span class="p">,</span> <span class="mh">0x120</span><span class="p">,</span> <span class="mh">0x0130</span><span class="p">,</span> <span class="mh">0x140</span><span class="p">,</span> <span class="mh">0x0150</span><span class="p">,</span> <span class="mh">0x0190</span><span class="p">,</span>
	<span class="mh">0x0210</span><span class="p">,</span> <span class="mh">0x0230</span><span class="p">,</span> <span class="mh">0x0250</span><span class="p">,</span> <span class="mh">0x0330</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The ISA IRQ number is found in bits 2 and 3 of the CfgLsw.  It decodes as:</span>
<span class="cm"> * 00: 10</span>
<span class="cm"> * 01: 11</span>
<span class="cm"> * 10: 12</span>
<span class="cm"> * 11: 15</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">advansys_isa_irq_no</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_lsw</span> <span class="o">=</span> <span class="n">AscGetChipCfgLsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chip_irq</span> <span class="o">=</span> <span class="p">((</span><span class="n">cfg_lsw</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip_irq</span> <span class="o">==</span> <span class="mi">13</span><span class="p">)</span>
		<span class="n">chip_irq</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">chip_irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">advansys_isa_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span> <span class="o">=</span> <span class="n">_asc_def_iop_base</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">board</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_IOADR_GAP</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;I/O port 0x%x busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iop_base</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;probing I/O port 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iop_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AscFindSignature</span><span class="p">(</span><span class="n">iop_base</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">release_region</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">AscGetChipVersion</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_IS_ISA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ASC_CHIP_VER_ISA_BIT</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">release_region</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_template</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">board</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">release_region</span><span class="p">;</span>

	<span class="n">board</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">board</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">advansys_isa_irq_no</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">board</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">advansys_board_found</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_IS_ISA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_host</span><span class="p">;</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">free_host:</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
 <span class="nl">release_region:</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_IOADR_GAP</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">advansys_isa_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ioport</span> <span class="o">=</span> <span class="n">_asc_def_iop_base</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
	<span class="n">advansys_release</span><span class="p">(</span><span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">ioport</span><span class="p">,</span> <span class="n">ASC_IOADR_GAP</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">isa_driver</span> <span class="n">advansys_isa_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">advansys_isa_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">advansys_isa_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The VLB IRQ number is found in bits 2 to 4 of the CfgLsw.  It decodes as:</span>
<span class="cm"> * 000: invalid</span>
<span class="cm"> * 001: 10</span>
<span class="cm"> * 010: 11</span>
<span class="cm"> * 011: 12</span>
<span class="cm"> * 100: invalid</span>
<span class="cm"> * 101: 14</span>
<span class="cm"> * 110: 15</span>
<span class="cm"> * 111: invalid</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">advansys_vlb_irq_no</span><span class="p">(</span><span class="n">PortAddr</span> <span class="n">iop_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_lsw</span> <span class="o">=</span> <span class="n">AscGetChipCfgLsw</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chip_irq</span> <span class="o">=</span> <span class="p">((</span><span class="n">cfg_lsw</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">)</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">chip_irq</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">chip_irq</span> <span class="o">==</span> <span class="mi">13</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">chip_irq</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">chip_irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">advansys_vlb_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">PortAddr</span> <span class="n">iop_base</span> <span class="o">=</span> <span class="n">_asc_def_iop_base</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">board</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_IOADR_GAP</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;I/O port 0x%x busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iop_base</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASC_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;probing I/O port 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iop_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AscFindSignature</span><span class="p">(</span><span class="n">iop_base</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">release_region</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * I don&#39;t think this condition can actually happen, but the old</span>
<span class="cm">	 * driver did it, and the chances of finding a VLB setup in 2007</span>
<span class="cm">	 * to do testing with is slight to none.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AscGetChipVersion</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_IS_VL</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ASC_CHIP_MAX_VER_VL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">release_region</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_template</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">board</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">release_region</span><span class="p">;</span>

	<span class="n">board</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">board</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">advansys_vlb_irq_no</span><span class="p">(</span><span class="n">iop_base</span><span class="p">);</span>
	<span class="n">board</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">advansys_board_found</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_IS_VL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_host</span><span class="p">;</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">free_host:</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
 <span class="nl">release_region:</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">iop_base</span><span class="p">,</span> <span class="n">ASC_IOADR_GAP</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">isa_driver</span> <span class="n">advansys_vlb_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">advansys_vlb_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">advansys_isa_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;advansys_vlb&quot;</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">eisa_device_id</span> <span class="n">advansys_eisa_table</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;ABP7401&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ABP7501&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;&quot;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">eisa</span><span class="p">,</span> <span class="n">advansys_eisa_table</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * EISA is a little more tricky than PCI; each EISA device may have two</span>
<span class="cm"> * channels, and this driver is written to make each channel its own Scsi_Host</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">eisa_scsi_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The EISA IRQ number is found in bits 8 to 10 of the CfgLsw.  It decodes as:</span>
<span class="cm"> * 000: 10</span>
<span class="cm"> * 001: 11</span>
<span class="cm"> * 010: 12</span>
<span class="cm"> * 011: invalid</span>
<span class="cm"> * 100: 14</span>
<span class="cm"> * 101: 15</span>
<span class="cm"> * 110: invalid</span>
<span class="cm"> * 111: invalid</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">advansys_eisa_irq_no</span><span class="p">(</span><span class="k">struct</span> <span class="n">eisa_device</span> <span class="o">*</span><span class="n">edev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_lsw</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="mh">0xc86</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chip_irq</span> <span class="o">=</span> <span class="p">((</span><span class="n">cfg_lsw</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">chip_irq</span> <span class="o">==</span> <span class="mi">13</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">chip_irq</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">chip_irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">advansys_eisa_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ioport</span><span class="p">,</span> <span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eisa_device</span> <span class="o">*</span><span class="n">edev</span> <span class="o">=</span> <span class="n">to_eisa_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">eisa_scsi_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">ioport</span> <span class="o">=</span> <span class="n">edev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="mh">0xc30</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">ioport</span> <span class="o">+=</span> <span class="mh">0x20</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">board</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">ioport</span><span class="p">,</span> <span class="n">ASC_IOADR_GAP</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Region %x-%x busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioport</span><span class="p">,</span>
			       <span class="n">ioport</span> <span class="o">+</span> <span class="n">ASC_IOADR_GAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AscFindSignature</span><span class="p">(</span><span class="n">ioport</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">release_region</span><span class="p">(</span><span class="n">ioport</span><span class="p">,</span> <span class="n">ASC_IOADR_GAP</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * I don&#39;t know why we need to do this for EISA chips, but</span>
<span class="cm">		 * not for any others.  It looks to be equivalent to</span>
<span class="cm">		 * AscGetChipCfgMsw, but I may have overlooked something,</span>
<span class="cm">		 * so I&#39;m not converting it until I get an EISA board to</span>
<span class="cm">		 * test with.</span>
<span class="cm">		 */</span>
		<span class="n">inw</span><span class="p">(</span><span class="n">ioport</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq</span><span class="p">)</span>
			<span class="n">irq</span> <span class="o">=</span> <span class="n">advansys_eisa_irq_no</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_template</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">board</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">release_region</span><span class="p">;</span>

		<span class="n">board</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
		<span class="n">board</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
		<span class="n">board</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">advansys_board_found</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">ioport</span><span class="p">,</span> <span class="n">ASC_IS_EISA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">shost</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
 <span class="nl">release_region:</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">ioport</span><span class="p">,</span> <span class="n">ASC_IOADR_GAP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_data</span><span class="p">;</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">free_data:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
 <span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__devexit</span> <span class="kt">int</span> <span class="nf">advansys_eisa_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eisa_scsi_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ioport</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ioport</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">io_port</span><span class="p">;</span>
		<span class="n">advansys_release</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">ioport</span><span class="p">,</span> <span class="n">ASC_IOADR_GAP</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">eisa_driver</span> <span class="n">advansys_eisa_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>		<span class="n">advansys_eisa_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="n">DRV_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">advansys_eisa_probe</span><span class="p">,</span>
		<span class="p">.</span><span class="n">remove</span> <span class="o">=</span>	<span class="n">__devexit_p</span><span class="p">(</span><span class="n">advansys_eisa_remove</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* PCI Devices supported by this driver */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">advansys_pci_tbl</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_ASP</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ASP_1200A</span><span class="p">,</span>
	 <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_ASP</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ASP_ABP940</span><span class="p">,</span>
	 <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_ASP</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ASP_ABP940U</span><span class="p">,</span>
	 <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_ASP</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ASP_ABP940UW</span><span class="p">,</span>
	 <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_ASP</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_38C0800_REV1</span><span class="p">,</span>
	 <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_ASP</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_38C1600_REV1</span><span class="p">,</span>
	 <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">advansys_pci_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">advansys_set_latency</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_ASP_1200A</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_ASP_ABP940</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">latency</span><span class="p">;</span>
		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">latency</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">latency</span> <span class="o">&lt;</span> <span class="mh">0x20</span><span class="p">)</span>
			<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">advansys_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">ioport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asc_board</span> <span class="o">*</span><span class="n">board</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">disable_device</span><span class="p">;</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">advansys_set_latency</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">release_region</span><span class="p">;</span>

	<span class="n">ioport</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_template</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">board</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">release_region</span><span class="p">;</span>

	<span class="n">board</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">board</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">board</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_ASP_ABP940UW</span> <span class="o">||</span>
	    <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_38C0800_REV1</span> <span class="o">||</span>
	    <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_38C1600_REV1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">board</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ASC_IS_WIDE_BOARD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">advansys_board_found</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">ioport</span><span class="p">,</span> <span class="n">ASC_IS_PCI</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_host</span><span class="p">;</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">free_host:</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
 <span class="nl">release_region:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
 <span class="nl">disable_device:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
 <span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">advansys_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">advansys_release</span><span class="p">(</span><span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">advansys_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="n">DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">advansys_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">advansys_pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span>	<span class="n">__devexit_p</span><span class="p">(</span><span class="n">advansys_pci_remove</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">advansys_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">isa_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_isa_driver</span><span class="p">,</span>
				    <span class="n">ASC_IOADR_TABLE_MAX_IX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">isa_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_vlb_driver</span><span class="p">,</span>
				    <span class="n">ASC_IOADR_TABLE_MAX_IX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unregister_isa</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">eisa_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_eisa_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unregister_vlb</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_pci_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unregister_eisa</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">unregister_eisa:</span>
	<span class="n">eisa_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_eisa_driver</span><span class="p">);</span>
 <span class="nl">unregister_vlb:</span>
	<span class="n">isa_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_vlb_driver</span><span class="p">);</span>
 <span class="nl">unregister_isa:</span>
	<span class="n">isa_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_isa_driver</span><span class="p">);</span>
 <span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">advansys_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_pci_driver</span><span class="p">);</span>
	<span class="n">eisa_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_eisa_driver</span><span class="p">);</span>
	<span class="n">isa_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_vlb_driver</span><span class="p">);</span>
	<span class="n">isa_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">advansys_isa_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">advansys_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">advansys_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_FIRMWARE</span><span class="p">(</span><span class="s">&quot;advansys/mcode.bin&quot;</span><span class="p">);</span>
<span class="n">MODULE_FIRMWARE</span><span class="p">(</span><span class="s">&quot;advansys/3550.bin&quot;</span><span class="p">);</span>
<span class="n">MODULE_FIRMWARE</span><span class="p">(</span><span class="s">&quot;advansys/38C0800.bin&quot;</span><span class="p">);</span>
<span class="n">MODULE_FIRMWARE</span><span class="p">(</span><span class="s">&quot;advansys/38C1600.bin&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
