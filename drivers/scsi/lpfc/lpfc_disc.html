<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › lpfc › lpfc_disc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>lpfc_disc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************</span>
<span class="cm"> * This file is part of the Emulex Linux Device Driver for         *</span>
<span class="cm"> * Fibre Channel Host Bus Adapters.                                *</span>
<span class="cm"> * Copyright (C) 2004-2008 Emulex.  All rights reserved.           *</span>
<span class="cm"> * EMULEX and SLI are trademarks of Emulex.                        *</span>
<span class="cm"> * www.emulex.com                                                  *</span>
<span class="cm"> *                                                                 *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or   *</span>
<span class="cm"> * modify it under the terms of version 2 of the GNU General       *</span>
<span class="cm"> * Public License as published by the Free Software Foundation.    *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful. *</span>
<span class="cm"> * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *</span>
<span class="cm"> * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *</span>
<span class="cm"> * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *</span>
<span class="cm"> * TO BE LEGALLY INVALID.  See the GNU General Public License for  *</span>
<span class="cm"> * more details, a copy of which can be found in the file COPYING  *</span>
<span class="cm"> * included with this package.                                     *</span>
<span class="cm"> *******************************************************************/</span>

<span class="cp">#define FC_MAX_HOLD_RSCN     32	      </span><span class="cm">/* max number of deferred RSCNs */</span><span class="cp"></span>
<span class="cp">#define FC_MAX_NS_RSP        64512    </span><span class="cm">/* max size NameServer rsp */</span><span class="cp"></span>
<span class="cp">#define FC_MAXLOOP           126      </span><span class="cm">/* max devices supported on a fc loop */</span><span class="cp"></span>
<span class="cp">#define LPFC_DISC_FLOGI_TMO  10	      </span><span class="cm">/* Discovery FLOGI ratov */</span><span class="cp"></span>


<span class="cm">/* This is the protocol dependent definition for a Node List Entry.</span>
<span class="cm"> * This is used by Fibre Channel protocol to support FCP.</span>
<span class="cm"> */</span>

<span class="cm">/* worker thread events */</span>
<span class="k">enum</span> <span class="n">lpfc_work_type</span> <span class="p">{</span>
	<span class="n">LPFC_EVT_ONLINE</span><span class="p">,</span>
	<span class="n">LPFC_EVT_OFFLINE_PREP</span><span class="p">,</span>
	<span class="n">LPFC_EVT_OFFLINE</span><span class="p">,</span>
	<span class="n">LPFC_EVT_WARM_START</span><span class="p">,</span>
	<span class="n">LPFC_EVT_KILL</span><span class="p">,</span>
	<span class="n">LPFC_EVT_ELS_RETRY</span><span class="p">,</span>
	<span class="n">LPFC_EVT_DEV_LOSS</span><span class="p">,</span>
	<span class="n">LPFC_EVT_FASTPATH_MGMT_EVT</span><span class="p">,</span>
	<span class="n">LPFC_EVT_RESET_HBA</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* structure used to queue event to the discovery tasklet */</span>
<span class="k">struct</span> <span class="n">lpfc_work_evt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>      <span class="n">evt_listp</span><span class="p">;</span>
	<span class="kt">void</span>                 <span class="o">*</span><span class="n">evt_arg1</span><span class="p">;</span>
	<span class="kt">void</span>                 <span class="o">*</span><span class="n">evt_arg2</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">lpfc_work_type</span>   <span class="n">evt</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lpfc_scsi_check_condition_event</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">lpfc_scsi_varqueuedepth_event</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">lpfc_scsi_event_header</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">lpfc_fabric_event_header</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">lpfc_fcprdchkerr_event</span><span class="p">;</span>

<span class="cm">/* structure used for sending events from fast path */</span>
<span class="k">struct</span> <span class="n">lpfc_fast_path_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_work_evt</span> <span class="n">work_evt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span>     <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">lpfc_scsi_check_condition_event</span> <span class="n">check_cond_evt</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">lpfc_scsi_varqueuedepth_event</span> <span class="n">queue_depth_evt</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">lpfc_scsi_event_header</span> <span class="n">scsi_evt</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">lpfc_fabric_event_header</span> <span class="n">fabric_evt</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">lpfc_fcprdchkerr_event</span> <span class="n">read_check_error</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">un</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define LPFC_SLI4_MAX_XRI	1024	</span><span class="cm">/* Used to make the ndlp&#39;s xri_bitmap */</span><span class="cp"></span>
<span class="cp">#define XRI_BITMAP_ULONGS (LPFC_SLI4_MAX_XRI / BITS_PER_LONG)</span>
<span class="k">struct</span> <span class="n">lpfc_node_rrqs</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xri_bitmap</span><span class="p">[</span><span class="n">XRI_BITMAP_ULONGS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">nlp_listp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_name</span> <span class="n">nlp_portname</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_name</span> <span class="n">nlp_nodename</span><span class="p">;</span>
	<span class="kt">uint32_t</span>         <span class="n">nlp_flag</span><span class="p">;</span>		<span class="cm">/* entry  flags */</span>
	<span class="kt">uint32_t</span>         <span class="n">nlp_DID</span><span class="p">;</span>		<span class="cm">/* FC D_ID of entry */</span>
	<span class="kt">uint32_t</span>         <span class="n">nlp_last_elscmd</span><span class="p">;</span>	<span class="cm">/* Last ELS cmd sent */</span>
	<span class="kt">uint16_t</span>         <span class="n">nlp_type</span><span class="p">;</span>
<span class="cp">#define NLP_FC_NODE        0x1			</span><span class="cm">/* entry is an FC node */</span><span class="cp"></span>
<span class="cp">#define NLP_FABRIC         0x4			</span><span class="cm">/* entry rep a Fabric entity */</span><span class="cp"></span>
<span class="cp">#define NLP_FCP_TARGET     0x8			</span><span class="cm">/* entry is an FCP target */</span><span class="cp"></span>
<span class="cp">#define NLP_FCP_INITIATOR  0x10			</span><span class="cm">/* entry is an FCP Initiator */</span><span class="cp"></span>

	<span class="kt">uint16_t</span>        <span class="n">nlp_rpi</span><span class="p">;</span>
	<span class="kt">uint16_t</span>        <span class="n">nlp_state</span><span class="p">;</span>		<span class="cm">/* state transition indicator */</span>
	<span class="kt">uint16_t</span>        <span class="n">nlp_prev_state</span><span class="p">;</span>		<span class="cm">/* state transition indicator */</span>
	<span class="kt">uint16_t</span>        <span class="n">nlp_xri</span><span class="p">;</span>		<span class="cm">/* output exchange id for RPI */</span>
	<span class="kt">uint16_t</span>        <span class="n">nlp_sid</span><span class="p">;</span>		<span class="cm">/* scsi id */</span>
<span class="cp">#define NLP_NO_SID		0xffff</span>
	<span class="kt">uint16_t</span>	<span class="n">nlp_maxframe</span><span class="p">;</span>		<span class="cm">/* Max RCV frame size */</span>
	<span class="kt">uint8_t</span>		<span class="n">nlp_class_sup</span><span class="p">;</span>		<span class="cm">/* Supported Classes */</span>
	<span class="kt">uint8_t</span>         <span class="n">nlp_retry</span><span class="p">;</span>		<span class="cm">/* used for ELS retries */</span>
	<span class="kt">uint8_t</span>         <span class="n">nlp_fcp_info</span><span class="p">;</span>	        <span class="cm">/* class info, bits 0-3 */</span>
<span class="cp">#define NLP_FCP_2_DEVICE   0x10			</span><span class="cm">/* FCP-2 device */</span><span class="cp"></span>

	<span class="kt">uint16_t</span>        <span class="n">nlp_usg_map</span><span class="p">;</span>	<span class="cm">/* ndlp management usage bitmap */</span>
<span class="cp">#define NLP_USG_NODE_ACT_BIT	0x1	</span><span class="cm">/* Indicate ndlp is actively used */</span><span class="cp"></span>
<span class="cp">#define NLP_USG_IACT_REQ_BIT	0x2	</span><span class="cm">/* Request to inactivate ndlp */</span><span class="cp"></span>
<span class="cp">#define NLP_USG_FREE_REQ_BIT	0x4	</span><span class="cm">/* Request to invoke ndlp memory free */</span><span class="cp"></span>
<span class="cp">#define NLP_USG_FREE_ACK_BIT	0x8	</span><span class="cm">/* Indicate ndlp memory free invoked */</span><span class="cp"></span>

	<span class="k">struct</span> <span class="n">timer_list</span>   <span class="n">nlp_delayfunc</span><span class="p">;</span>	<span class="cm">/* Used for delayed ELS cmds */</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>			<span class="cm">/* Corresponding FC transport</span>
<span class="cm">						   port structure */</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_work_evt</span> <span class="n">els_retry_evt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_work_evt</span> <span class="n">dev_loss_evt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span>     <span class="n">kref</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">cmd_pending</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cmd_qdepth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_change_time</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_node_rrqs</span> <span class="n">active_rrqs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_scsicmd_bkt</span> <span class="o">*</span><span class="n">lat_data</span><span class="p">;</span>	<span class="cm">/* Latency data */</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">xritag</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">send_rrq</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">rxid</span><span class="p">;</span>
	<span class="kt">uint32_t</span>         <span class="n">nlp_DID</span><span class="p">;</span>		<span class="cm">/* FC D_ID of entry */</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rrq_stop_time</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Defines for nlp_flag (uint32) */</span>
<span class="cp">#define NLP_IGNR_REG_CMPL  0x00000001 </span><span class="cm">/* Rcvd rscn before we cmpl reg login */</span><span class="cp"></span>
<span class="cp">#define NLP_REG_LOGIN_SEND 0x00000002   </span><span class="cm">/* sent reglogin to adapter */</span><span class="cp"></span>
<span class="cp">#define NLP_PLOGI_SND      0x00000020	</span><span class="cm">/* sent PLOGI request for this entry */</span><span class="cp"></span>
<span class="cp">#define NLP_PRLI_SND       0x00000040	</span><span class="cm">/* sent PRLI request for this entry */</span><span class="cp"></span>
<span class="cp">#define NLP_ADISC_SND      0x00000080	</span><span class="cm">/* sent ADISC request for this entry */</span><span class="cp"></span>
<span class="cp">#define NLP_LOGO_SND       0x00000100	</span><span class="cm">/* sent LOGO request for this entry */</span><span class="cp"></span>
<span class="cp">#define NLP_RNID_SND       0x00000400	</span><span class="cm">/* sent RNID request for this entry */</span><span class="cp"></span>
<span class="cp">#define NLP_ELS_SND_MASK   0x000007e0	</span><span class="cm">/* sent ELS request for this entry */</span><span class="cp"></span>
<span class="cp">#define NLP_DEFER_RM       0x00010000	</span><span class="cm">/* Remove this ndlp if no longer used */</span><span class="cp"></span>
<span class="cp">#define NLP_DELAY_TMO      0x00020000	</span><span class="cm">/* delay timeout is running for node */</span><span class="cp"></span>
<span class="cp">#define NLP_NPR_2B_DISC    0x00040000	</span><span class="cm">/* node is included in num_disc_nodes */</span><span class="cp"></span>
<span class="cp">#define NLP_RCV_PLOGI      0x00080000	</span><span class="cm">/* Rcv&#39;ed PLOGI from remote system */</span><span class="cp"></span>
<span class="cp">#define NLP_LOGO_ACC       0x00100000	</span><span class="cm">/* Process LOGO after ACC completes */</span><span class="cp"></span>
<span class="cp">#define NLP_TGT_NO_SCSIID  0x00200000	</span><span class="cm">/* good PRLI but no binding for scsid */</span><span class="cp"></span>
<span class="cp">#define NLP_ACC_REGLOGIN   0x01000000	</span><span class="cm">/* Issue Reg Login after successful</span>
<span class="cm">					   ACC */</span><span class="cp"></span>
<span class="cp">#define NLP_NPR_ADISC      0x02000000	</span><span class="cm">/* Issue ADISC when dq&#39;ed from</span>
<span class="cm">					   NPR list */</span><span class="cp"></span>
<span class="cp">#define NLP_RM_DFLT_RPI    0x04000000	</span><span class="cm">/* need to remove leftover dflt RPI */</span><span class="cp"></span>
<span class="cp">#define NLP_NODEV_REMOVE   0x08000000	</span><span class="cm">/* Defer removal till discovery ends */</span><span class="cp"></span>
<span class="cp">#define NLP_TARGET_REMOVE  0x10000000   </span><span class="cm">/* Target remove in process */</span><span class="cp"></span>
<span class="cp">#define NLP_SC_REQ         0x20000000	</span><span class="cm">/* Target requires authentication */</span><span class="cp"></span>
<span class="cp">#define NLP_RPI_REGISTERED 0x80000000	</span><span class="cm">/* nlp_rpi is valid */</span><span class="cp"></span>

<span class="cm">/* ndlp usage management macros */</span>
<span class="cp">#define NLP_CHK_NODE_ACT(ndlp)		(((ndlp)-&gt;nlp_usg_map \</span>
<span class="cp">						&amp; NLP_USG_NODE_ACT_BIT) \</span>
<span class="cp">					&amp;&amp; \</span>
<span class="cp">					!((ndlp)-&gt;nlp_usg_map \</span>
<span class="cp">						&amp; NLP_USG_FREE_ACK_BIT))</span>
<span class="cp">#define NLP_SET_NODE_ACT(ndlp)		((ndlp)-&gt;nlp_usg_map \</span>
<span class="cp">						|= NLP_USG_NODE_ACT_BIT)</span>
<span class="cp">#define NLP_INT_NODE_ACT(ndlp)		((ndlp)-&gt;nlp_usg_map \</span>
<span class="cp">						= NLP_USG_NODE_ACT_BIT)</span>
<span class="cp">#define NLP_CLR_NODE_ACT(ndlp)		((ndlp)-&gt;nlp_usg_map \</span>
<span class="cp">						&amp;= ~NLP_USG_NODE_ACT_BIT)</span>
<span class="cp">#define NLP_CHK_IACT_REQ(ndlp)          ((ndlp)-&gt;nlp_usg_map \</span>
<span class="cp">						&amp; NLP_USG_IACT_REQ_BIT)</span>
<span class="cp">#define NLP_SET_IACT_REQ(ndlp)          ((ndlp)-&gt;nlp_usg_map \</span>
<span class="cp">						|= NLP_USG_IACT_REQ_BIT)</span>
<span class="cp">#define NLP_CHK_FREE_REQ(ndlp)		((ndlp)-&gt;nlp_usg_map \</span>
<span class="cp">						&amp; NLP_USG_FREE_REQ_BIT)</span>
<span class="cp">#define NLP_SET_FREE_REQ(ndlp)		((ndlp)-&gt;nlp_usg_map \</span>
<span class="cp">						|= NLP_USG_FREE_REQ_BIT)</span>
<span class="cp">#define NLP_CHK_FREE_ACK(ndlp)		((ndlp)-&gt;nlp_usg_map \</span>
<span class="cp">						&amp; NLP_USG_FREE_ACK_BIT)</span>
<span class="cp">#define NLP_SET_FREE_ACK(ndlp)		((ndlp)-&gt;nlp_usg_map \</span>
<span class="cp">						|= NLP_USG_FREE_ACK_BIT)</span>

<span class="cm">/* There are 4 different double linked lists nodelist entries can reside on.</span>
<span class="cm"> * The Port Login (PLOGI) list and Address Discovery (ADISC) list are used</span>
<span class="cm"> * when Link Up discovery or Registered State Change Notification (RSCN)</span>
<span class="cm"> * processing is needed.  Each list holds the nodes that require a PLOGI or</span>
<span class="cm"> * ADISC Extended Link Service (ELS) request.  These lists keep track of the</span>
<span class="cm"> * nodes affected by an RSCN, or a Link Up (Typically, all nodes are effected</span>
<span class="cm"> * by Link Up) event.  The unmapped_list contains all nodes that have</span>
<span class="cm"> * successfully logged into at the Fibre Channel level.  The</span>
<span class="cm"> * mapped_list will contain all nodes that are mapped FCP targets.</span>
<span class="cm"> *</span>
<span class="cm"> * The bind list is a list of undiscovered (potentially non-existent) nodes</span>
<span class="cm"> * that we have saved binding information on. This information is used when</span>
<span class="cm"> * nodes transition from the unmapped to the mapped list.</span>
<span class="cm"> */</span>

<span class="cm">/* Defines for nlp_state */</span>
<span class="cp">#define NLP_STE_UNUSED_NODE       0x0	</span><span class="cm">/* node is just allocated */</span><span class="cp"></span>
<span class="cp">#define NLP_STE_PLOGI_ISSUE       0x1	</span><span class="cm">/* PLOGI was sent to NL_PORT */</span><span class="cp"></span>
<span class="cp">#define NLP_STE_ADISC_ISSUE       0x2	</span><span class="cm">/* ADISC was sent to NL_PORT */</span><span class="cp"></span>
<span class="cp">#define NLP_STE_REG_LOGIN_ISSUE   0x3	</span><span class="cm">/* REG_LOGIN was issued for NL_PORT */</span><span class="cp"></span>
<span class="cp">#define NLP_STE_PRLI_ISSUE        0x4	</span><span class="cm">/* PRLI was sent to NL_PORT */</span><span class="cp"></span>
<span class="cp">#define NLP_STE_UNMAPPED_NODE     0x5	</span><span class="cm">/* PRLI completed from NL_PORT */</span><span class="cp"></span>
<span class="cp">#define NLP_STE_MAPPED_NODE       0x6	</span><span class="cm">/* Identified as a FCP Target */</span><span class="cp"></span>
<span class="cp">#define NLP_STE_NPR_NODE          0x7	</span><span class="cm">/* NPort disappeared */</span><span class="cp"></span>
<span class="cp">#define NLP_STE_MAX_STATE         0x8</span>
<span class="cp">#define NLP_STE_FREED_NODE        0xff	</span><span class="cm">/* node entry was freed to MEM_NLP */</span><span class="cp"></span>

<span class="cm">/* For UNUSED_NODE state, the node has just been allocated.</span>
<span class="cm"> * For PLOGI_ISSUE and REG_LOGIN_ISSUE, the node is on</span>
<span class="cm"> * the PLOGI list. For REG_LOGIN_COMPL, the node is taken off the PLOGI list</span>
<span class="cm"> * and put on the unmapped list. For ADISC processing, the node is taken off</span>
<span class="cm"> * the ADISC list and placed on either the mapped or unmapped list (depending</span>
<span class="cm"> * on its previous state). Once on the unmapped list, a PRLI is issued and the</span>
<span class="cm"> * state changed to PRLI_ISSUE. When the PRLI completion occurs, the state is</span>
<span class="cm"> * changed to PRLI_COMPL. If the completion indicates a mapped</span>
<span class="cm"> * node, the node is taken off the unmapped list. The binding list is checked</span>
<span class="cm"> * for a valid binding, or a binding is automatically assigned. If binding</span>
<span class="cm"> * assignment is unsuccessful, the node is left on the unmapped list. If</span>
<span class="cm"> * binding assignment is successful, the associated binding list entry (if</span>
<span class="cm"> * any) is removed, and the node is placed on the mapped list.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * For a Link Down, all nodes on the ADISC, PLOGI, unmapped or mapped</span>
<span class="cm"> * lists will receive a DEVICE_RECOVERY event. If the linkdown or devloss timers</span>
<span class="cm"> * expire, all effected nodes will receive a DEVICE_RM event.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * For a Link Up or RSCN, all nodes will move from the mapped / unmapped lists</span>
<span class="cm"> * to either the ADISC or PLOGI list.  After a Nameserver query or ALPA loopmap</span>
<span class="cm"> * check, additional nodes may be added (DEVICE_ADD) or removed (DEVICE_RM) to /</span>
<span class="cm"> * from the PLOGI or ADISC lists. Once the PLOGI and ADISC lists are populated,</span>
<span class="cm"> * we will first process the ADISC list.  32 entries are processed initially and</span>
<span class="cm"> * ADISC is initited for each one.  Completions / Events for each node are</span>
<span class="cm"> * funnelled thru the state machine.  As each node finishes ADISC processing, it</span>
<span class="cm"> * starts ADISC for any nodes waiting for ADISC processing. If no nodes are</span>
<span class="cm"> * waiting, and the ADISC list count is identically 0, then we are done. For</span>
<span class="cm"> * Link Up discovery, since all nodes on the PLOGI list are UNREG_LOGIN&#39;ed, we</span>
<span class="cm"> * can issue a CLEAR_LA and reenable Link Events. Next we will process the PLOGI</span>
<span class="cm"> * list.  32 entries are processed initially and PLOGI is initited for each one.</span>
<span class="cm"> * Completions / Events for each node are funnelled thru the state machine.  As</span>
<span class="cm"> * each node finishes PLOGI processing, it starts PLOGI for any nodes waiting</span>
<span class="cm"> * for PLOGI processing. If no nodes are waiting, and the PLOGI list count is</span>
<span class="cm"> * identically 0, then we are done. We have now completed discovery / RSCN</span>
<span class="cm"> * handling. Upon completion, ALL nodes should be on either the mapped or</span>
<span class="cm"> * unmapped lists.</span>
<span class="cm"> */</span>

<span class="cm">/* Defines for Node List Entry Events that could happen */</span>
<span class="cp">#define NLP_EVT_RCV_PLOGI         0x0	</span><span class="cm">/* Rcv&#39;d an ELS PLOGI command */</span><span class="cp"></span>
<span class="cp">#define NLP_EVT_RCV_PRLI          0x1	</span><span class="cm">/* Rcv&#39;d an ELS PRLI  command */</span><span class="cp"></span>
<span class="cp">#define NLP_EVT_RCV_LOGO          0x2	</span><span class="cm">/* Rcv&#39;d an ELS LOGO  command */</span><span class="cp"></span>
<span class="cp">#define NLP_EVT_RCV_ADISC         0x3	</span><span class="cm">/* Rcv&#39;d an ELS ADISC command */</span><span class="cp"></span>
<span class="cp">#define NLP_EVT_RCV_PDISC         0x4	</span><span class="cm">/* Rcv&#39;d an ELS PDISC command */</span><span class="cp"></span>
<span class="cp">#define NLP_EVT_RCV_PRLO          0x5	</span><span class="cm">/* Rcv&#39;d an ELS PRLO  command */</span><span class="cp"></span>
<span class="cp">#define NLP_EVT_CMPL_PLOGI        0x6	</span><span class="cm">/* Sent an ELS PLOGI command */</span><span class="cp"></span>
<span class="cp">#define NLP_EVT_CMPL_PRLI         0x7	</span><span class="cm">/* Sent an ELS PRLI  command */</span><span class="cp"></span>
<span class="cp">#define NLP_EVT_CMPL_LOGO         0x8	</span><span class="cm">/* Sent an ELS LOGO  command */</span><span class="cp"></span>
<span class="cp">#define NLP_EVT_CMPL_ADISC        0x9	</span><span class="cm">/* Sent an ELS ADISC command */</span><span class="cp"></span>
<span class="cp">#define NLP_EVT_CMPL_REG_LOGIN    0xa	</span><span class="cm">/* REG_LOGIN mbox cmd completed */</span><span class="cp"></span>
<span class="cp">#define NLP_EVT_DEVICE_RM         0xb	</span><span class="cm">/* Device not found in NS / ALPAmap */</span><span class="cp"></span>
<span class="cp">#define NLP_EVT_DEVICE_RECOVERY   0xc	</span><span class="cm">/* Device existence unknown */</span><span class="cp"></span>
<span class="cp">#define NLP_EVT_MAX_EVENT         0xd</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
