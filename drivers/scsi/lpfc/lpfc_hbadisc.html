<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › lpfc › lpfc_hbadisc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>lpfc_hbadisc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************</span>
<span class="cm"> * This file is part of the Emulex Linux Device Driver for         *</span>
<span class="cm"> * Fibre Channel Host Bus Adapters.                                *</span>
<span class="cm"> * Copyright (C) 2004-2012 Emulex.  All rights reserved.           *</span>
<span class="cm"> * EMULEX and SLI are trademarks of Emulex.                        *</span>
<span class="cm"> * www.emulex.com                                                  *</span>
<span class="cm"> * Portions Copyright (C) 2004-2005 Christoph Hellwig              *</span>
<span class="cm"> *                                                                 *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or   *</span>
<span class="cm"> * modify it under the terms of version 2 of the GNU General       *</span>
<span class="cm"> * Public License as published by the Free Software Foundation.    *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful. *</span>
<span class="cm"> * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *</span>
<span class="cm"> * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *</span>
<span class="cm"> * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *</span>
<span class="cm"> * TO BE LEGALLY INVALID.  See the GNU General Public License for  *</span>
<span class="cm"> * more details, a copy of which can be found in the file COPYING  *</span>
<span class="cm"> * included with this package.                                     *</span>
<span class="cm"> *******************************************************************/</span>

<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_fc.h&gt;</span>

<span class="cp">#include &quot;lpfc_hw4.h&quot;</span>
<span class="cp">#include &quot;lpfc_hw.h&quot;</span>
<span class="cp">#include &quot;lpfc_nl.h&quot;</span>
<span class="cp">#include &quot;lpfc_disc.h&quot;</span>
<span class="cp">#include &quot;lpfc_sli.h&quot;</span>
<span class="cp">#include &quot;lpfc_sli4.h&quot;</span>
<span class="cp">#include &quot;lpfc_scsi.h&quot;</span>
<span class="cp">#include &quot;lpfc.h&quot;</span>
<span class="cp">#include &quot;lpfc_logmsg.h&quot;</span>
<span class="cp">#include &quot;lpfc_crtn.h&quot;</span>
<span class="cp">#include &quot;lpfc_vport.h&quot;</span>
<span class="cp">#include &quot;lpfc_debugfs.h&quot;</span>

<span class="cm">/* AlpaArray for assignment of scsid for scan-down and bind_method */</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">lpfcAlpaArray</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0xEF</span><span class="p">,</span> <span class="mh">0xE8</span><span class="p">,</span> <span class="mh">0xE4</span><span class="p">,</span> <span class="mh">0xE2</span><span class="p">,</span> <span class="mh">0xE1</span><span class="p">,</span> <span class="mh">0xE0</span><span class="p">,</span> <span class="mh">0xDC</span><span class="p">,</span> <span class="mh">0xDA</span><span class="p">,</span> <span class="mh">0xD9</span><span class="p">,</span> <span class="mh">0xD6</span><span class="p">,</span>
	<span class="mh">0xD5</span><span class="p">,</span> <span class="mh">0xD4</span><span class="p">,</span> <span class="mh">0xD3</span><span class="p">,</span> <span class="mh">0xD2</span><span class="p">,</span> <span class="mh">0xD1</span><span class="p">,</span> <span class="mh">0xCE</span><span class="p">,</span> <span class="mh">0xCD</span><span class="p">,</span> <span class="mh">0xCC</span><span class="p">,</span> <span class="mh">0xCB</span><span class="p">,</span> <span class="mh">0xCA</span><span class="p">,</span>
	<span class="mh">0xC9</span><span class="p">,</span> <span class="mh">0xC7</span><span class="p">,</span> <span class="mh">0xC6</span><span class="p">,</span> <span class="mh">0xC5</span><span class="p">,</span> <span class="mh">0xC3</span><span class="p">,</span> <span class="mh">0xBC</span><span class="p">,</span> <span class="mh">0xBA</span><span class="p">,</span> <span class="mh">0xB9</span><span class="p">,</span> <span class="mh">0xB6</span><span class="p">,</span> <span class="mh">0xB5</span><span class="p">,</span>
	<span class="mh">0xB4</span><span class="p">,</span> <span class="mh">0xB3</span><span class="p">,</span> <span class="mh">0xB2</span><span class="p">,</span> <span class="mh">0xB1</span><span class="p">,</span> <span class="mh">0xAE</span><span class="p">,</span> <span class="mh">0xAD</span><span class="p">,</span> <span class="mh">0xAC</span><span class="p">,</span> <span class="mh">0xAB</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xA9</span><span class="p">,</span>
	<span class="mh">0xA7</span><span class="p">,</span> <span class="mh">0xA6</span><span class="p">,</span> <span class="mh">0xA5</span><span class="p">,</span> <span class="mh">0xA3</span><span class="p">,</span> <span class="mh">0x9F</span><span class="p">,</span> <span class="mh">0x9E</span><span class="p">,</span> <span class="mh">0x9D</span><span class="p">,</span> <span class="mh">0x9B</span><span class="p">,</span> <span class="mh">0x98</span><span class="p">,</span> <span class="mh">0x97</span><span class="p">,</span>
	<span class="mh">0x90</span><span class="p">,</span> <span class="mh">0x8F</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="mh">0x82</span><span class="p">,</span> <span class="mh">0x81</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x7C</span><span class="p">,</span> <span class="mh">0x7A</span><span class="p">,</span> <span class="mh">0x79</span><span class="p">,</span>
	<span class="mh">0x76</span><span class="p">,</span> <span class="mh">0x75</span><span class="p">,</span> <span class="mh">0x74</span><span class="p">,</span> <span class="mh">0x73</span><span class="p">,</span> <span class="mh">0x72</span><span class="p">,</span> <span class="mh">0x71</span><span class="p">,</span> <span class="mh">0x6E</span><span class="p">,</span> <span class="mh">0x6D</span><span class="p">,</span> <span class="mh">0x6C</span><span class="p">,</span> <span class="mh">0x6B</span><span class="p">,</span>
	<span class="mh">0x6A</span><span class="p">,</span> <span class="mh">0x69</span><span class="p">,</span> <span class="mh">0x67</span><span class="p">,</span> <span class="mh">0x66</span><span class="p">,</span> <span class="mh">0x65</span><span class="p">,</span> <span class="mh">0x63</span><span class="p">,</span> <span class="mh">0x5C</span><span class="p">,</span> <span class="mh">0x5A</span><span class="p">,</span> <span class="mh">0x59</span><span class="p">,</span> <span class="mh">0x56</span><span class="p">,</span>
	<span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x54</span><span class="p">,</span> <span class="mh">0x53</span><span class="p">,</span> <span class="mh">0x52</span><span class="p">,</span> <span class="mh">0x51</span><span class="p">,</span> <span class="mh">0x4E</span><span class="p">,</span> <span class="mh">0x4D</span><span class="p">,</span> <span class="mh">0x4C</span><span class="p">,</span> <span class="mh">0x4B</span><span class="p">,</span> <span class="mh">0x4A</span><span class="p">,</span>
	<span class="mh">0x49</span><span class="p">,</span> <span class="mh">0x47</span><span class="p">,</span> <span class="mh">0x46</span><span class="p">,</span> <span class="mh">0x45</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">,</span> <span class="mh">0x3C</span><span class="p">,</span> <span class="mh">0x3A</span><span class="p">,</span> <span class="mh">0x39</span><span class="p">,</span> <span class="mh">0x36</span><span class="p">,</span> <span class="mh">0x35</span><span class="p">,</span>
	<span class="mh">0x34</span><span class="p">,</span> <span class="mh">0x33</span><span class="p">,</span> <span class="mh">0x32</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0x2E</span><span class="p">,</span> <span class="mh">0x2D</span><span class="p">,</span> <span class="mh">0x2C</span><span class="p">,</span> <span class="mh">0x2B</span><span class="p">,</span> <span class="mh">0x2A</span><span class="p">,</span> <span class="mh">0x29</span><span class="p">,</span>
	<span class="mh">0x27</span><span class="p">,</span> <span class="mh">0x26</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="mh">0x23</span><span class="p">,</span> <span class="mh">0x1F</span><span class="p">,</span> <span class="mh">0x1E</span><span class="p">,</span> <span class="mh">0x1D</span><span class="p">,</span> <span class="mh">0x1B</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span>
	<span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x0F</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x01</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">lpfc_disc_timeout_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lpfc_disc_flush_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lpfc_unregister_fcfi_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_fcf_inuse</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">lpfc_terminate_rport_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span> <span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>

	<span class="n">rdata</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">&amp;</span> <span class="n">FC_RPORT_ROLE_FCP_TARGET</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Cannot find remote node&quot;</span>
			<span class="s">&quot; to terminate I/O Data x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phba</span>  <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_RPORT</span><span class="p">,</span>
		<span class="s">&quot;rport terminate: sid:x%x did:x%x flg:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_sid</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_sid</span> <span class="o">!=</span> <span class="n">NLP_NO_SID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_sli_abort_iocb</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">fcp_ring</span><span class="p">],</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_sid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LPFC_CTX_TGT</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function will be called when dev_loss_tmo fire.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_dev_loss_tmo_callbk</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span> <span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_work_evt</span> <span class="o">*</span><span class="n">evtp</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">put_node</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">put_rport</span><span class="p">;</span>

	<span class="n">rdata</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="n">phba</span>  <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_RPORT</span><span class="p">,</span>
		<span class="s">&quot;rport devlosscb: sid:x%x did:x%x flg:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_sid</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t defer this if we are in the process of deleting the vport</span>
<span class="cm">	 * or unloading the driver. The unload will cleanup the node</span>
<span class="cm">	 * appropriately we just need to cleanup the ndlp rport info here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_node</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">put_rport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_node</span><span class="p">)</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_rport</span><span class="p">)</span>
			<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_MAPPED_NODE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">evtp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">dev_loss_evt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_listp</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/* We need to hold the node by incrementing the reference</span>
<span class="cm">	 * count until this queued work is done</span>
<span class="cm">	 */</span>
	<span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg1</span>  <span class="o">=</span> <span class="n">lpfc_nlp_get</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt</span> <span class="o">=</span> <span class="n">LPFC_EVT_DEV_LOSS</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_listp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
		<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_dev_loss_tmo_handler - Remote node devloss timeout handler</span>
<span class="cm"> * @ndlp: Pointer to remote node object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the worker thread when devloss timeout timer</span>
<span class="cm"> * expires. For SLI4 host, this routine shall return 1 when at lease one</span>
<span class="cm"> * remote node, including this @ndlp, is still in use of FCF; otherwise, this</span>
<span class="cm"> * routine shall return 0 when there is no remote node is still in use of FCF</span>
<span class="cm"> * when devloss timeout happened to this @ndlp.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_dev_loss_tmo_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span>   <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">put_node</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">put_rport</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">warn_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fcf_inuse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rport</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fcf_inuse</span><span class="p">;</span>

	<span class="n">rdata</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">;</span>
	<span class="n">vport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="n">phba</span>  <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">fcf_inuse</span> <span class="o">=</span> <span class="n">lpfc_fcf_inuse</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_RPORT</span><span class="p">,</span>
		<span class="s">&quot;rport devlosstmo:did:x%x type:x%x id:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span><span class="p">,</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t defer this if we are in the process of deleting the vport</span>
<span class="cm">	 * or unloading the driver. The unload will cleanup the node</span>
<span class="cm">	 * appropriately we just need to cleanup the ndlp rport info here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_sid</span> <span class="o">!=</span> <span class="n">NLP_NO_SID</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* flush the target */</span>
			<span class="n">lpfc_sli_abort_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">fcp_ring</span><span class="p">],</span>
					<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_sid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LPFC_CTX_TGT</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">put_node</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">put_rport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_node</span><span class="p">)</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_rport</span><span class="p">)</span>
			<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">fcf_inuse</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_MAPPED_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				 <span class="s">&quot;0284 Devloss timeout Ignored on &quot;</span>
				 <span class="s">&quot;WWPN %x:%x:%x:%x:%x:%x:%x:%x &quot;</span>
				 <span class="s">&quot;NPort x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span>
				 <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">4</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">5</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">6</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">7</span><span class="p">),</span>
				 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">fcf_inuse</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">&amp;</span> <span class="n">NLP_FABRIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We will clean up these Nodes in linkup */</span>
		<span class="n">put_node</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">put_rport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_node</span><span class="p">)</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_rport</span><span class="p">)</span>
			<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">fcf_inuse</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_sid</span> <span class="o">!=</span> <span class="n">NLP_NO_SID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">warn_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* flush the target */</span>
		<span class="n">lpfc_sli_abort_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">fcp_ring</span><span class="p">],</span>
				    <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_sid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LPFC_CTX_TGT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">warn_on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				 <span class="s">&quot;0203 Devloss timeout on &quot;</span>
				 <span class="s">&quot;WWPN %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x &quot;</span>
				 <span class="s">&quot;NPort x%06x Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span>
				 <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">4</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">5</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">6</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">7</span><span class="p">),</span>
				 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span>
				 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				 <span class="s">&quot;0204 Devloss timeout on &quot;</span>
				 <span class="s">&quot;WWPN %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x &quot;</span>
				 <span class="s">&quot;NPort x%06x Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span>
				 <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">4</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">5</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">6</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="mi">7</span><span class="p">),</span>
				 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span>
				 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">put_node</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">put_rport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_node</span><span class="p">)</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_rport</span><span class="p">)</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_DELAY_TMO</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_REG_LOGIN_ISSUE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_PRLI_ISSUE</span><span class="p">))</span>
		<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">NLP_EVT_DEVICE_RM</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fcf_inuse</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_post_dev_loss_tmo_handler - SLI4 post devloss timeout handler</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> * @fcf_inuse: SLI4 FCF in-use state reported from devloss timeout handler.</span>
<span class="cm"> * @nlp_did: remote node identifer with devloss timeout.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the worker thread after invoking devloss</span>
<span class="cm"> * timeout handler and releasing the reference count for the ndlp with</span>
<span class="cm"> * which the devloss timeout was handled for SLI4 host. For the devloss</span>
<span class="cm"> * timeout of the last remote node which had been in use of FCF, when this</span>
<span class="cm"> * routine is invoked, it shall be guaranteed that none of the remote are</span>
<span class="cm"> * in-use of FCF. When devloss timeout to the last remote using the FCF,</span>
<span class="cm"> * if the FIP engine is neither in FCF table scan process nor roundrobin</span>
<span class="cm"> * failover process, the in-use FCF shall be unregistered. If the FIP</span>
<span class="cm"> * engine is in FCF discovery process, the devloss timeout state shall</span>
<span class="cm"> * be set for either the FCF table scan process or roundrobin failover</span>
<span class="cm"> * process to unregister the in-use FCF.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_post_dev_loss_tmo_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fcf_inuse</span><span class="p">,</span>
				    <span class="kt">uint32_t</span> <span class="n">nlp_did</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If devloss timeout happened to a remote node when FCF had no</span>
<span class="cm">	 * longer been in-use, do nothing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcf_inuse</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FIP_SUPPORT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lpfc_fcf_inuse</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_DISCOVERY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_DEVLOSS_TMO</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_DEVLOSS_TMO</span><span class="p">;</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					<span class="s">&quot;2847 Last remote node (x%x) using &quot;</span>
					<span class="s">&quot;FCF devloss tmo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nlp_did</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REDISC_PROG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					<span class="s">&quot;2868 Devloss tmo to FCF rediscovery &quot;</span>
					<span class="s">&quot;in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FCF_TS_INPROG</span> <span class="o">|</span> <span class="n">FCF_RR_INPROG</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					<span class="s">&quot;2869 Devloss tmo to idle FIP engine, &quot;</span>
					<span class="s">&quot;unreg in-use FCF and rescan.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/* Unregister in-use FCF and rescan */</span>
			<span class="n">lpfc_unregister_fcf_rescan</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">FCF_TS_INPROG</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					<span class="s">&quot;2870 FCF table scan in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">FCF_RR_INPROG</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					<span class="s">&quot;2871 FLOGI roundrobin FCF failover &quot;</span>
					<span class="s">&quot;in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lpfc_unregister_unused_fcf</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_alloc_fast_evt - Allocates data structure for posting event</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the functions which need to post</span>
<span class="cm"> * events from interrupt context. This function allocates data</span>
<span class="cm"> * structure required for posting event. It also keeps track of</span>
<span class="cm"> * number of events pending and prevent event storm when there are</span>
<span class="cm"> * too many events.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_fast_path_event</span> <span class="o">*</span>
<span class="nf">lpfc_alloc_fast_evt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_fast_path_event</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* If there are lot of fast event do not exhaust memory due to this */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fast_event_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">LPFC_MAX_EVT_COUNT</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fast_path_event</span><span class="p">),</span>
			<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fast_event_count</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">work_evt</span><span class="p">.</span><span class="n">evt_listp</span><span class="p">);</span>
		<span class="n">ret</span><span class="o">-&gt;</span><span class="n">work_evt</span><span class="p">.</span><span class="n">evt</span> <span class="o">=</span> <span class="n">LPFC_EVT_FASTPATH_MGMT_EVT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_free_fast_evt - Frees event data structure</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> * @evt:  Event object which need to be freed.</span>
<span class="cm"> *</span>
<span class="cm"> * This function frees the data structure required for posting</span>
<span class="cm"> * events.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_free_fast_evt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lpfc_fast_path_event</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fast_event_count</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">evt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_send_fastpath_evt - Posts events generated from fast path</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> * @evtp: Event data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from worker thread, when the interrupt</span>
<span class="cm"> * context need to post an event. This function posts the event</span>
<span class="cm"> * to fc transport netlink interface.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_send_fastpath_evt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lpfc_work_evt</span> <span class="o">*</span><span class="n">evtp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">evt_category</span><span class="p">,</span> <span class="n">evt_sub_category</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fast_path_event</span> <span class="o">*</span><span class="n">fast_evt_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">evt_data</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">evt_data_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>

	<span class="n">fast_evt_data</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">evtp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_fast_path_event</span><span class="p">,</span>
		<span class="n">work_evt</span><span class="p">);</span>

	<span class="n">evt_category</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">fast_evt_data</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fabric_evt</span><span class="p">.</span><span class="n">event_type</span><span class="p">;</span>
	<span class="n">evt_sub_category</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">fast_evt_data</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span>
			<span class="n">fabric_evt</span><span class="p">.</span><span class="n">subcategory</span><span class="p">;</span>
	<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">fast_evt_data</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">evt_category</span> <span class="o">==</span> <span class="n">FC_REG_FABRIC_EVENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">evt_sub_category</span> <span class="o">==</span> <span class="n">LPFC_EVENT_FCPRDCHKERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">evt_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">fast_evt_data</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_check_error</span><span class="p">;</span>
			<span class="n">evt_data_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fast_evt_data</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span>
				<span class="n">read_check_error</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">evt_sub_category</span> <span class="o">==</span> <span class="n">LPFC_EVENT_FABRIC_BUSY</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">evt_sub_category</span> <span class="o">==</span> <span class="n">LPFC_EVENT_PORT_BUSY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">evt_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">fast_evt_data</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fabric_evt</span><span class="p">;</span>
			<span class="n">evt_data_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fast_evt_data</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fabric_evt</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lpfc_free_fast_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fast_evt_data</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">evt_category</span> <span class="o">==</span> <span class="n">FC_REG_SCSI_EVENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">evt_sub_category</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LPFC_EVENT_QFULL</span>:
		<span class="k">case</span> <span class="n">LPFC_EVENT_DEVBSY</span>:
			<span class="n">evt_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">fast_evt_data</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">scsi_evt</span><span class="p">;</span>
			<span class="n">evt_data_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fast_evt_data</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">scsi_evt</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_EVENT_CHECK_COND</span>:
			<span class="n">evt_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">fast_evt_data</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">check_cond_evt</span><span class="p">;</span>
			<span class="n">evt_data_size</span> <span class="o">=</span>  <span class="k">sizeof</span><span class="p">(</span><span class="n">fast_evt_data</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span>
				<span class="n">check_cond_evt</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_EVENT_VARQUEDEPTH</span>:
			<span class="n">evt_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">fast_evt_data</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">queue_depth_evt</span><span class="p">;</span>
			<span class="n">evt_data_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fast_evt_data</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span>
				<span class="n">queue_depth_evt</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">lpfc_free_fast_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fast_evt_data</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_free_fast_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fast_evt_data</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span>
		<span class="n">fc_get_event_number</span><span class="p">(),</span>
		<span class="n">evt_data_size</span><span class="p">,</span>
		<span class="n">evt_data</span><span class="p">,</span>
		<span class="n">LPFC_NL_VENDOR_ID</span><span class="p">);</span>

	<span class="n">lpfc_free_fast_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fast_evt_data</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_work_list_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_work_evt</span>  <span class="o">*</span><span class="n">evtp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span>  <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">free_evt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fcf_inuse</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">nlp_did</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_remove_head</span><span class="p">((</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">),</span> <span class="n">evtp</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">evtp</span><span class="p">),</span>
				 <span class="n">evt_listp</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">free_evt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LPFC_EVT_ELS_RETRY</span>:
			<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg1</span><span class="p">);</span>
			<span class="n">lpfc_els_retry_delay_handler</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="n">free_evt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* evt is part of ndlp */</span>
			<span class="cm">/* decrement the node reference count held</span>
<span class="cm">			 * for this queued work</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_EVT_DEV_LOSS</span>:
			<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg1</span><span class="p">);</span>
			<span class="n">fcf_inuse</span> <span class="o">=</span> <span class="n">lpfc_dev_loss_tmo_handler</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="n">free_evt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* decrement the node reference count held for</span>
<span class="cm">			 * this queued work</span>
<span class="cm">			 */</span>
			<span class="n">nlp_did</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">;</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
				<span class="n">lpfc_sli4_post_dev_loss_tmo_handler</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
								    <span class="n">fcf_inuse</span><span class="p">,</span>
								    <span class="n">nlp_did</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_EVT_ONLINE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&lt;</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">)</span>
				<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg1</span><span class="p">)</span> <span class="o">=</span> <span class="n">lpfc_online</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">complete</span><span class="p">((</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="p">)(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg2</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_EVT_OFFLINE_PREP</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&gt;=</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">)</span>
				<span class="n">lpfc_offline_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">complete</span><span class="p">((</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="p">)(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg2</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_EVT_OFFLINE</span>:
			<span class="n">lpfc_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg1</span><span class="p">)</span> <span class="o">=</span>
				<span class="n">lpfc_sli_brdready</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">HS_FFRDY</span> <span class="o">|</span> <span class="n">HS_MBRDY</span><span class="p">);</span>
			<span class="n">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">complete</span><span class="p">((</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="p">)(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg2</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_EVT_WARM_START</span>:
			<span class="n">lpfc_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">lpfc_reset_barrier</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">lpfc_sli_brdreset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">lpfc_hba_down_post</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg1</span><span class="p">)</span> <span class="o">=</span>
				<span class="n">lpfc_sli_brdready</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">HS_MBRDY</span><span class="p">);</span>
			<span class="n">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">complete</span><span class="p">((</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="p">)(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg2</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_EVT_KILL</span>:
			<span class="n">lpfc_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg1</span><span class="p">)</span>
				<span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">)</span>
				        <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">lpfc_sli_brdkill</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">complete</span><span class="p">((</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="p">)(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg2</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_EVT_FASTPATH_MGMT_EVT</span>:
			<span class="n">lpfc_send_fastpath_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">evtp</span><span class="p">);</span>
			<span class="n">free_evt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_EVT_RESET_HBA</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">))</span>
				<span class="n">lpfc_reset_hba</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">free_evt</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">evtp</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_work_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ha_copy</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">control</span><span class="p">,</span> <span class="n">work_port_events</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">ha_copy</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* First, try to post the next mailbox command to SLI4 device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span> <span class="o">==</span> <span class="n">LPFC_PCI_DEV_OC</span><span class="p">)</span>
		<span class="n">lpfc_sli4_post_async_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_ERATT</span><span class="p">)</span>
		<span class="cm">/* Handle the error attention event */</span>
		<span class="n">lpfc_handle_eratt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_MBATT</span><span class="p">)</span>
		<span class="n">lpfc_sli_handle_mb_event</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_LATT</span><span class="p">)</span>
		<span class="n">lpfc_handle_latt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Process SLI4 events */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span> <span class="o">==</span> <span class="n">LPFC_PCI_DEV_OC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_RRQ_ACTIVE</span><span class="p">)</span>
			<span class="n">lpfc_handle_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">FCP_XRI_ABORT_EVENT</span><span class="p">)</span>
			<span class="n">lpfc_sli4_fcp_xri_abort_event_proc</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">ELS_XRI_ABORT_EVENT</span><span class="p">)</span>
			<span class="n">lpfc_sli4_els_xri_abort_event_proc</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">ASYNC_EVENT</span><span class="p">)</span>
			<span class="n">lpfc_sli4_async_event_proc</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_POST_RECEIVE_BUFFER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HBA_POST_RECEIVE_BUFFER</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">lpfc_sli_hbqbuf_add_hbqs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_HBQ</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REDISC_EVT</span><span class="p">)</span>
			<span class="n">lpfc_sli4_fcf_redisc_event_proc</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We could have no vports in array if unloading, so if</span>
<span class="cm">			 * this happens then just use the pport</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">vport</span> <span class="o">=</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">);</span>
			<span class="n">work_port_events</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_events</span><span class="p">;</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">work_port_events</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_DISC_TMO</span><span class="p">)</span>
				<span class="n">lpfc_disc_timeout_handler</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_ELS_TMO</span><span class="p">)</span>
				<span class="n">lpfc_els_timeout_handler</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_HB_TMO</span><span class="p">)</span>
				<span class="n">lpfc_hb_timeout_handler</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_MBOX_TMO</span><span class="p">)</span>
				<span class="n">lpfc_mbox_timeout_handler</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_FABRIC_BLOCK_TMO</span><span class="p">)</span>
				<span class="n">lpfc_unblock_fabric_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_FDMI_TMO</span><span class="p">)</span>
				<span class="n">lpfc_fdmi_timeout_handler</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_RAMP_DOWN_QUEUE</span><span class="p">)</span>
				<span class="n">lpfc_ramp_down_queue_handler</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_RAMP_UP_QUEUE</span><span class="p">)</span>
				<span class="n">lpfc_ramp_up_queue_handler</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_DELAYED_DISC_TMO</span><span class="p">)</span>
				<span class="n">lpfc_delayed_disc_timeout_handler</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>

	<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>
	<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HA_RXMASK</span>  <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">LPFC_ELS_RING</span><span class="p">)));</span>
	<span class="n">status</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">LPFC_ELS_RING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">HA_RXMASK</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">LPFC_DEFERRED_RING_EVENT</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_SP_QUEUE_EVT</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">LPFC_DEFERRED_RING_EVENT</span><span class="p">;</span>
			<span class="cm">/* Set the lpfc data pending flag */</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">LPFC_DATA_READY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">data_flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_DEFERRED_RING_EVENT</span><span class="p">;</span>
			<span class="n">lpfc_sli_handle_slow_ring_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
							<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span>
							 <span class="n">HA_RXMASK</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="p">)</span>
			<span class="n">lpfc_drain_txq</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Turn on Ring interrupts</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;=</span> <span class="n">LPFC_SLI_REV3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">control</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HC_R0INT_ENA</span> <span class="o">&lt;&lt;</span> <span class="n">LPFC_ELS_RING</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">lpfc_debugfs_slow_ring_trc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
					<span class="s">&quot;WRK Enable ring: cntl:x%x hacopy:x%x&quot;</span><span class="p">,</span>
					<span class="n">control</span><span class="p">,</span> <span class="n">ha_copy</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

				<span class="n">control</span> <span class="o">|=</span> <span class="p">(</span><span class="n">HC_R0INT_ENA</span> <span class="o">&lt;&lt;</span> <span class="n">LPFC_ELS_RING</span><span class="p">);</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">lpfc_debugfs_slow_ring_trc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
					<span class="s">&quot;WRK Ring ok:     cntl:x%x hacopy:x%x&quot;</span><span class="p">,</span>
					<span class="n">control</span><span class="p">,</span> <span class="n">ha_copy</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">lpfc_work_list_done</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">lpfc_do_work</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_NOFREEZE</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">data_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* wait and check worker queue activities */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_waitq</span><span class="p">,</span>
					<span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">LPFC_DATA_READY</span><span class="p">,</span>
							    <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">data_flags</span><span class="p">)</span>
					 <span class="o">||</span> <span class="n">kthread_should_stop</span><span class="p">()));</span>
		<span class="cm">/* Signal wakeup shall terminate the worker thread */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
					<span class="s">&quot;0433 Wakeup on signal: rc=x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Attend pending lpfc data processing */</span>
		<span class="n">lpfc_work_done</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			<span class="s">&quot;0432 Worker thread stopped.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is only called to handle FC worker events. Since this a rare</span>
<span class="cm"> * occurrence, we allocate a struct lpfc_work_evt structure here instead of</span>
<span class="cm"> * embedding it in the IOCB.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">lpfc_workq_post_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg1</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg2</span><span class="p">,</span>
		      <span class="kt">uint32_t</span> <span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_work_evt</span>  <span class="o">*</span><span class="n">evtp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * All Mailbox completions and LPFC_ELS_RING rcv ring IOCB events will</span>
<span class="cm">	 * be queued to worker thread for processing</span>
<span class="cm">	 */</span>
	<span class="n">evtp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_work_evt</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">evtp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg1</span>  <span class="o">=</span> <span class="n">arg1</span><span class="p">;</span>
	<span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg2</span>  <span class="o">=</span> <span class="n">arg2</span><span class="p">;</span>
	<span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt</span>       <span class="o">=</span> <span class="n">evt</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_listp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">lpfc_cleanup_rpis</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">remove</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">*</span><span class="n">next_ndlp</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">rc</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">next_ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_VPORT_TEARDOWN</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_NPIV_PORT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span> <span class="o">==</span> <span class="n">NameServer_DID</span><span class="p">)))</span>
			<span class="n">lpfc_unreg_rpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>

		<span class="cm">/* Leave Fabric nodes alone on link down */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">remove</span> <span class="o">&amp;&amp;</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">&amp;</span> <span class="n">NLP_FABRIC</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					     <span class="n">remove</span>
					     <span class="o">?</span> <span class="n">NLP_EVT_DEVICE_RM</span>
					     <span class="o">:</span> <span class="n">NLP_EVT_DEVICE_RECOVERY</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_VPORT_TEARDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
			<span class="n">lpfc_sli4_unreg_all_rpis</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="n">lpfc_mbx_unreg_vpi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">lpfc_port_link_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_LINKDOWN</span><span class="p">);</span>

	<span class="cm">/* Cleanup any outstanding received buffers */</span>
	<span class="n">lpfc_cleanup_rcv_buffers</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/* Cleanup any outstanding RSCN activity */</span>
	<span class="n">lpfc_els_flush_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/* Cleanup any outstanding ELS commands */</span>
	<span class="n">lpfc_els_flush_cmd</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="n">lpfc_cleanup_rpis</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Turn off discovery timer if its running */</span>
	<span class="n">lpfc_can_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">lpfc_linkdown_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="n">fc_host_post_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_get_event_number</span><span class="p">(),</span> <span class="n">FCH_EVT_LINKDOWN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;Link Down:       state:x%x rtry:x%x flg:x%x&quot;</span><span class="p">,</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_ns_retry</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">);</span>

	<span class="n">lpfc_port_link_failure</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/* Stop delayed Nport discovery */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_DISC_DELAYED</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">delayed_disc_tmo</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">lpfc_linkdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span>          <span class="o">*</span><span class="n">mb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Block all SCSI stack I/Os */</span>
	<span class="n">lpfc_scsi_dev_block</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FCF_AVAILABLE</span> <span class="o">|</span> <span class="n">FCF_SCAN_DONE</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&gt;</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_LBIT</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Issue a LINK DOWN event to all nodes */</span>
			<span class="n">lpfc_linkdown_port</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
	<span class="cm">/* Clean up any firmware default rpi&#39;s */</span>
	<span class="n">mb</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_unreg_did</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="n">LPFC_UNREG_ALL_DFLT_RPIS</span><span class="p">,</span> <span class="n">mb</span><span class="p">);</span>
		<span class="n">mb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
		<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">)</span>
		    <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Setup myDID for link up if we are in pt2pt mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PT2PT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mb</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_config_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mb</span><span class="p">);</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">)</span>
			    <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mempool_free</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FC_PT2PT</span> <span class="o">|</span> <span class="n">FC_PT2PT_PLOGI</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_linkup_cleanup_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">&amp;</span> <span class="n">NLP_FABRIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* On Linkup its safe to clean up the ndlp</span>
<span class="cm">			 * from Fabric connections.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span> <span class="o">!=</span> <span class="n">Fabric_DID</span><span class="p">)</span>
				<span class="n">lpfc_unreg_rpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
			<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_NPR_ADISC</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Fail outstanding IO now since device is</span>
<span class="cm">			 * marked for PLOGI.</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_unreg_rpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_linkup_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;Link Up:         top:x%x speed:x%x flg:x%x&quot;</span><span class="p">,</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_linkspeed</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span><span class="p">);</span>

	<span class="cm">/* If NPIV is not enabled, only bring the physical port up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">vport</span> <span class="o">!=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">fc_host_post_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_get_event_number</span><span class="p">(),</span> <span class="n">FCH_EVT_LINKUP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FC_PT2PT</span> <span class="o">|</span> <span class="n">FC_PT2PT_PLOGI</span> <span class="o">|</span> <span class="n">FC_ABORT_DISCOVERY</span> <span class="o">|</span>
			    <span class="n">FC_RSCN_MODE</span> <span class="o">|</span> <span class="n">FC_NLP_MORE</span> <span class="o">|</span> <span class="n">FC_RSCN_DISCOVERY</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_NDISC_ACTIVE</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_ns_retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_LBIT</span><span class="p">)</span>
		<span class="n">lpfc_linkup_cleanup_nodes</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_linkup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">lpfc_cleanup_wt_rrqs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_LINK_UP</span><span class="p">;</span>

	<span class="cm">/* Unblock fabric iocbs if they are blocked */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">FABRIC_COMANDS_BLOCKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bit_flags</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_block_timer</span><span class="p">);</span>

	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">lpfc_linkup_port</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">))</span>
		<span class="n">lpfc_issue_clear_la</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine handles processing a CLEAR_LA mailbox</span>
<span class="cm"> * command upon completion. It is setup in the LPFC_MBOXQ</span>
<span class="cm"> * as the completion routine when the command is</span>
<span class="cm"> * handed off to the SLI layer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_clear_la</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span>   <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">control</span><span class="p">;</span>

	<span class="cm">/* Since we don&#39;t do discovery right now, turn these off here */</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">extra_ring</span><span class="p">].</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">fcp_ring</span><span class="p">].</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">next_ring</span><span class="p">].</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>

	<span class="cm">/* Check for error */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span> <span class="o">!=</span> <span class="mh">0x1601</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* CLEAR_LA mbox error &lt;mbxStatus&gt; state &lt;hba_state&gt; */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
				 <span class="s">&quot;0320 CLEAR_LA mbxStatus error x%x hba &quot;</span>
				 <span class="s">&quot;state x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_PHYSICAL_PORT</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_READY</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_PROCESS_LA</span><span class="p">;</span>
	<span class="n">control</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">control</span> <span class="o">|=</span> <span class="n">HC_LAINT_ENA</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="cm">/* Device Discovery completes */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			 <span class="s">&quot;0225 Device Discovery completes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_ABORT_DISCOVERY</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="n">lpfc_can_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/* turn on Link Attention interrupts */</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_PROCESS_LA</span><span class="p">;</span>
	<span class="n">control</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">control</span> <span class="o">|=</span> <span class="n">HC_LAINT_ENA</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_local_config_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="cm">/* don&#39;t perform discovery for SLI4 loopback diagnostic test */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FCOE_MODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;</span> <span class="n">LS_LOOPBACK_MODE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span> <span class="o">&amp;&amp;</span>
	    <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PUBLIC_LOOP</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_LBIT</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Need to wait for FAN - use discovery timer</span>
<span class="cm">			 * for timeout.  port_state is identically</span>
<span class="cm">			 * LPFC_LOCAL_CFG_LINK while waiting for FAN</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_set_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Start discovery by sending a FLOGI. port_state is identically</span>
<span class="cm">	 * LPFC_FLOGI while waiting for FLOGI cmpl</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">!=</span> <span class="n">LPFC_FLOGI</span> <span class="o">||</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PT2PT_PLOGI</span><span class="p">)</span>
		<span class="n">lpfc_initial_flogi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
			 <span class="s">&quot;0306 CONFIG_LINK mbxStatus error x%x &quot;</span>
			 <span class="s">&quot;HBA state x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="n">lpfc_linkdown</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			 <span class="s">&quot;0200 CONFIG_LINK bad hba state x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>

	<span class="n">lpfc_issue_clear_la</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_clear_fcf_rr_bmask</span>
<span class="cm"> * @phba pointer to the struct lpfc_hba for this port.</span>
<span class="cm"> * This fucnction resets the round robin bit mask and clears the</span>
<span class="cm"> * fcf priority list. The list deletions are done while holding the</span>
<span class="cm"> * hbalock. The ON_LIST flag and the FLOGI_FAILED flags are cleared</span>
<span class="cm"> * from the lpfc_fcf_pri record.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_clear_fcf_rr_bmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_pri</span> <span class="o">*</span><span class="n">fcf_pri</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_pri</span> <span class="o">*</span><span class="n">next_fcf_pri</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">));</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">fcf_pri</span><span class="p">,</span> <span class="n">next_fcf_pri</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_reg_fcfi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
			 <span class="s">&quot;2017 REG_FCFI mbxStatus error x%x &quot;</span>
			 <span class="s">&quot;HBA state x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Start FCoE discovery by sending a FLOGI. */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcfi</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_reg_fcfi_fcfi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">reg_fcfi</span><span class="p">);</span>
	<span class="cm">/* Set the FCFI registered flag */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">|=</span> <span class="n">FCF_REGISTERED</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* If there is a pending FCoE event, restart FCF table scan. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">FCF_RR_INPROG</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="n">lpfc_check_pending_fcoe_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_UNREG_FCF</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_out</span><span class="p">;</span>

	<span class="cm">/* Mark successful completion of FCF table scan */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">|=</span> <span class="p">(</span><span class="n">FCF_SCAN_DONE</span> <span class="o">|</span> <span class="n">FCF_IN_USE</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_TS_INPROG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">!=</span> <span class="n">LPFC_FLOGI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">FCF_RR_INPROG</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">lpfc_issue_init_vfi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">fail_out:</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_RR_INPROG</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fab_name_match - Check if the fcf fabric name match.</span>
<span class="cm"> * @fab_name: pointer to fabric name.</span>
<span class="cm"> * @new_fcf_record: pointer to fcf record.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine compare the fcf record&#39;s fabric name with provided</span>
<span class="cm"> * fabric name. If the fabric name are identical this function</span>
<span class="cm"> * returns 1 else return 0.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">lpfc_fab_name_match</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fab_name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">new_fcf_record</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fab_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_0</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fab_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_1</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fab_name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_2</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fab_name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_3</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fab_name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_4</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fab_name</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_5</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fab_name</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_6</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fab_name</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_7</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sw_name_match - Check if the fcf switch name match.</span>
<span class="cm"> * @fab_name: pointer to fabric name.</span>
<span class="cm"> * @new_fcf_record: pointer to fcf record.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine compare the fcf record&#39;s switch name with provided</span>
<span class="cm"> * switch name. If the switch name are identical this function</span>
<span class="cm"> * returns 1 else return 0.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">lpfc_sw_name_match</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">sw_name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">new_fcf_record</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sw_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_0</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sw_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_1</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sw_name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_2</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sw_name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_3</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sw_name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_4</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sw_name</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_5</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sw_name</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_6</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sw_name</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_7</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mac_addr_match - Check if the fcf mac address match.</span>
<span class="cm"> * @mac_addr: pointer to mac address.</span>
<span class="cm"> * @new_fcf_record: pointer to fcf record.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine compare the fcf record&#39;s mac address with HBA&#39;s</span>
<span class="cm"> * FCF mac address. If the mac addresses are identical this function</span>
<span class="cm"> * returns 1 else return 0.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">lpfc_mac_addr_match</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">new_fcf_record</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_0</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_1</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_2</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_3</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_4</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_5</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">lpfc_vlan_id_match</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">curr_vlan_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">new_vlan_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">curr_vlan_id</span> <span class="o">==</span> <span class="n">new_vlan_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_update_fcf_record - Update driver fcf record</span>
<span class="cm"> * __lpfc_update_fcf_record_pri - update the lpfc_fcf_pri record.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fcf_index: Index for the lpfc_fcf_record.</span>
<span class="cm"> * @new_fcf_record: pointer to hba fcf record.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine updates the driver FCF priority record from the new HBA FCF</span>
<span class="cm"> * record. This routine is called with the host lock held.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__lpfc_update_fcf_record_pri</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">fcf_index</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">new_fcf_record</span>
				 <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_pri</span> <span class="o">*</span><span class="n">fcf_pri</span><span class="p">;</span>

	<span class="n">fcf_pri</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri</span><span class="p">[</span><span class="n">fcf_index</span><span class="p">];</span>
	<span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">fcf_index</span> <span class="o">=</span> <span class="n">fcf_index</span><span class="p">;</span>
	<span class="cm">/* FCF record priority */</span>
	<span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">new_fcf_record</span><span class="o">-&gt;</span><span class="n">fip_priority</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_copy_fcf_record - Copy fcf information to lpfc_hba.</span>
<span class="cm"> * @fcf: pointer to driver fcf record.</span>
<span class="cm"> * @new_fcf_record: pointer to fcf record.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine copies the FCF information from the FCF</span>
<span class="cm"> * record to lpfc_hba data structure.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_copy_fcf_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fcf_rec</span> <span class="o">*</span><span class="n">fcf_rec</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">new_fcf_record</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Fabric name */</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_0</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_1</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_2</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_3</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_4</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_5</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_6</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_7</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="cm">/* Mac address */</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_0</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_1</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_2</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_3</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_4</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_5</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="cm">/* FCF record index */</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">fcf_indx</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="cm">/* FCF record priority */</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">new_fcf_record</span><span class="o">-&gt;</span><span class="n">fip_priority</span><span class="p">;</span>
	<span class="cm">/* Switch name */</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_0</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_1</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_2</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_3</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_4</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_5</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_6</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_7</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_update_fcf_record - Update driver fcf record</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fcf_rec: pointer to driver fcf record.</span>
<span class="cm"> * @new_fcf_record: pointer to hba fcf record.</span>
<span class="cm"> * @addr_mode: address mode to be set to the driver fcf record.</span>
<span class="cm"> * @vlan_id: vlan tag to be set to the driver fcf record.</span>
<span class="cm"> * @flag: flag bits to be set to the driver fcf record.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine updates the driver FCF record from the new HBA FCF record</span>
<span class="cm"> * together with the address mode, vlan_id, and other informations. This</span>
<span class="cm"> * routine is called with the host lock held.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__lpfc_update_fcf_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_fcf_rec</span> <span class="o">*</span><span class="n">fcf_rec</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">new_fcf_record</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">addr_mode</span><span class="p">,</span>
		       <span class="kt">uint16_t</span> <span class="n">vlan_id</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Copy the fields from the HBA&#39;s FCF record */</span>
	<span class="n">lpfc_copy_fcf_record</span><span class="p">(</span><span class="n">fcf_rec</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="cm">/* Update other fields of driver FCF record */</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">addr_mode</span> <span class="o">=</span> <span class="n">addr_mode</span><span class="p">;</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">vlan_id</span> <span class="o">=</span> <span class="n">vlan_id</span><span class="p">;</span>
	<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="p">(</span><span class="n">flag</span> <span class="o">|</span> <span class="n">RECORD_VALID</span><span class="p">);</span>
	<span class="n">__lpfc_update_fcf_record_pri</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">),</span>
				 <span class="n">new_fcf_record</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_register_fcf - Register the FCF with hba.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues a register fcfi mailbox command to register</span>
<span class="cm"> * the fcf with HBA.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_register_fcf</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">fcf_mbxq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/* If the FCF is not available do nothing. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_AVAILABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FCF_TS_INPROG</span> <span class="o">|</span> <span class="n">FCF_RR_INPROG</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The FCF is already registered, start discovery */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REGISTERED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">|=</span> <span class="p">(</span><span class="n">FCF_SCAN_DONE</span> <span class="o">|</span> <span class="n">FCF_IN_USE</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_TS_INPROG</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">!=</span> <span class="n">LPFC_FLOGI</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">FCF_RR_INPROG</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">lpfc_initial_flogi</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">fcf_mbxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcf_mbxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FCF_TS_INPROG</span> <span class="o">|</span> <span class="n">FCF_RR_INPROG</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_reg_fcfi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fcf_mbxq</span><span class="p">);</span>
	<span class="n">fcf_mbxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">fcf_mbxq</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_reg_fcfi</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fcf_mbxq</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FCF_TS_INPROG</span> <span class="o">|</span> <span class="n">FCF_RR_INPROG</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">fcf_mbxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_match_fcf_conn_list - Check if the FCF record can be used for discovery.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @new_fcf_record: pointer to fcf record.</span>
<span class="cm"> * @boot_flag: Indicates if this record used by boot bios.</span>
<span class="cm"> * @addr_mode: The address mode to be used by this FCF</span>
<span class="cm"> * @vlan_id: The vlan id to be used as vlan tagging by this FCF.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine compare the fcf record with connect list obtained from the</span>
<span class="cm"> * config region to decide if this FCF can be used for SAN discovery. It returns</span>
<span class="cm"> * 1 if this record can be used for SAN discovery else return zero. If this FCF</span>
<span class="cm"> * record can be used for SAN discovery, the boot_flag will indicate if this FCF</span>
<span class="cm"> * is used by boot bios and addr_mode will indicate the addressing mode to be</span>
<span class="cm"> * used for this FCF when the function returns.</span>
<span class="cm"> * If the FCF record need to be used with a particular vlan id, the vlan is</span>
<span class="cm"> * set in the vlan_id on return of the function. If not VLAN tagging need to</span>
<span class="cm"> * be used with the FCF vlan_id will be set to LPFC_FCOE_NULL_VID;</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_match_fcf_conn_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">new_fcf_record</span><span class="p">,</span>
			<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">boot_flag</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">addr_mode</span><span class="p">,</span>
			<span class="kt">uint16_t</span> <span class="o">*</span><span class="n">vlan_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_conn_entry</span> <span class="o">*</span><span class="n">conn_entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">fcf_vlan_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Find the lowest VLAN id in the FCF record */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_fcf_record</span><span class="o">-&gt;</span><span class="n">vlan_bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">fcf_vlan_id</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">new_fcf_record</span><span class="o">-&gt;</span><span class="n">vlan_bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">j</span><span class="o">++</span><span class="p">;</span>
				<span class="n">fcf_vlan_id</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If FCF not available return 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_avail</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">)</span> <span class="o">||</span>
		<span class="o">!</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_valid</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FIP_SUPPORT</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">boot_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">addr_mode</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_addr_prov</span><span class="p">,</span>
				<span class="n">new_fcf_record</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">valid_vlan</span><span class="p">)</span>
			<span class="o">*</span><span class="n">vlan_id</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">vlan_id</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">vlan_id</span> <span class="o">=</span> <span class="n">LPFC_FCOE_NULL_VID</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are no FCF connection table entry, driver connect to all</span>
<span class="cm">	 * FCFs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf_conn_rec_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">boot_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">addr_mode</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_addr_prov</span><span class="p">,</span>
			<span class="n">new_fcf_record</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * When there are no FCF connect entries, use driver&#39;s default</span>
<span class="cm">		 * addressing mode - FPMA.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">addr_mode</span> <span class="o">&amp;</span> <span class="n">LPFC_FCF_FPMA</span><span class="p">)</span>
			<span class="o">*</span><span class="n">addr_mode</span> <span class="o">=</span> <span class="n">LPFC_FCF_FPMA</span><span class="p">;</span>

		<span class="cm">/* If FCF record report a vlan id use that vlan id */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcf_vlan_id</span><span class="p">)</span>
			<span class="o">*</span><span class="n">vlan_id</span> <span class="o">=</span> <span class="n">fcf_vlan_id</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">vlan_id</span> <span class="o">=</span> <span class="n">LPFC_FCOE_NULL_VID</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">conn_entry</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf_conn_rec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_VALID</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_FBNM_VALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">lpfc_fab_name_match</span><span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">fabric_name</span><span class="p">,</span>
					     <span class="n">new_fcf_record</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_SWNM_VALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">lpfc_sw_name_match</span><span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">switch_name</span><span class="p">,</span>
					    <span class="n">new_fcf_record</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_VLAN_VALID</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the vlan bit map does not have the bit set for the</span>
<span class="cm">			 * vlan id to be used, then it is not a match.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">new_fcf_record</span><span class="o">-&gt;</span><span class="n">vlan_bitmap</span>
				<span class="p">[</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">vlan_tag</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&amp;</span>
				<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">vlan_tag</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))))</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If connection record does not support any addressing mode,</span>
<span class="cm">		 * skip the FCF record.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_addr_prov</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">)</span>
			<span class="o">&amp;</span> <span class="p">(</span><span class="n">LPFC_FCF_FPMA</span> <span class="o">|</span> <span class="n">LPFC_FCF_SPMA</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if the connection record specifies a required</span>
<span class="cm">		 * addressing mode.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_AM_VALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_AM_PREFERRED</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * If SPMA required but FCF not support this continue.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_AM_SPMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_addr_prov</span><span class="p">,</span>
					<span class="n">new_fcf_record</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LPFC_FCF_SPMA</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If FPMA required but FCF not support this continue.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_AM_SPMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_addr_prov</span><span class="p">,</span>
				<span class="n">new_fcf_record</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LPFC_FCF_FPMA</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * This fcf record matches filtering criteria.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_BOOT</span><span class="p">)</span>
			<span class="o">*</span><span class="n">boot_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">boot_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If user did not specify any addressing mode, or if the</span>
<span class="cm">		 * preferred addressing mode specified by user is not supported</span>
<span class="cm">		 * by FCF, allow fabric to pick the addressing mode.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">addr_mode</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_addr_prov</span><span class="p">,</span>
				<span class="n">new_fcf_record</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the user specified a required address mode, assign that</span>
<span class="cm">		 * address mode</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_AM_VALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_AM_PREFERRED</span><span class="p">)))</span>
			<span class="o">*</span><span class="n">addr_mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span>
				<span class="n">FCFCNCT_AM_SPMA</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">LPFC_FCF_SPMA</span> <span class="o">:</span> <span class="n">LPFC_FCF_FPMA</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the user specified a preferred address mode, use the</span>
<span class="cm">		 * addr mode only if FCF support the addr_mode.</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_AM_VALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_AM_PREFERRED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_AM_SPMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="o">*</span><span class="n">addr_mode</span> <span class="o">&amp;</span> <span class="n">LPFC_FCF_SPMA</span><span class="p">))</span>
				<span class="o">*</span><span class="n">addr_mode</span> <span class="o">=</span> <span class="n">LPFC_FCF_SPMA</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_AM_VALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_AM_PREFERRED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_AM_SPMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="o">*</span><span class="n">addr_mode</span> <span class="o">&amp;</span> <span class="n">LPFC_FCF_FPMA</span><span class="p">))</span>
				<span class="o">*</span><span class="n">addr_mode</span> <span class="o">=</span> <span class="n">LPFC_FCF_FPMA</span><span class="p">;</span>

		<span class="cm">/* If matching connect list has a vlan id, use it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_VLAN_VALID</span><span class="p">)</span>
			<span class="o">*</span><span class="n">vlan_id</span> <span class="o">=</span> <span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">vlan_tag</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If no vlan id is specified in connect list, use the vlan id</span>
<span class="cm">		 * in the FCF record</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fcf_vlan_id</span><span class="p">)</span>
			<span class="o">*</span><span class="n">vlan_id</span> <span class="o">=</span> <span class="n">fcf_vlan_id</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">vlan_id</span> <span class="o">=</span> <span class="n">LPFC_FCOE_NULL_VID</span><span class="p">;</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_check_pending_fcoe_event - Check if there is pending fcoe event.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @unreg_fcf: Unregister FCF if FCF table need to be re-scaned.</span>
<span class="cm"> *</span>
<span class="cm"> * This function check if there is any fcoe event pending while driver</span>
<span class="cm"> * scan FCF entries. If there is any pending event, it will restart the</span>
<span class="cm"> * FCF saning and return 1 else return 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">lpfc_check_pending_fcoe_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">unreg_fcf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the Link is up and no FCoE events while in the</span>
<span class="cm">	 * FCF discovery, no need to restart FCF discovery.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span>  <span class="o">&gt;=</span> <span class="n">LPFC_LINK_UP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_eventtag</span> <span class="o">==</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_eventtag_at_fcf_scan</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
			<span class="s">&quot;2768 Pending link or FCF event during current &quot;</span>
			<span class="s">&quot;handling of the previous event: link_state:x%x, &quot;</span>
			<span class="s">&quot;evt_tag_at_scan:x%x, evt_tag_current:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_eventtag_at_fcf_scan</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_eventtag</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_AVAILABLE</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&gt;=</span> <span class="n">LPFC_LINK_UP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				<span class="s">&quot;2780 Restart FCF table scan due to &quot;</span>
				<span class="s">&quot;pending FCF event:evt_tag_at_scan:x%x, &quot;</span>
				<span class="s">&quot;evt_tag_current:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_eventtag_at_fcf_scan</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_eventtag</span><span class="p">);</span>
		<span class="n">lpfc_sli4_fcf_scan_read_fcf_rec</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_FCOE_FCF_GET_FIRST</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not continue FCF discovery and clear FCF_TS_INPROG</span>
<span class="cm">		 * flag</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				<span class="s">&quot;2833 Stop FCF discovery process due to link &quot;</span>
				<span class="s">&quot;state change (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FCF_TS_INPROG</span> <span class="o">|</span> <span class="n">FCF_RR_INPROG</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FCF_REDISC_FOV</span> <span class="o">|</span> <span class="n">FCF_DISCOVERY</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Unregister the currently registered FCF if required */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unreg_fcf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_REGISTERED</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">lpfc_sli4_unregister_fcf</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_new_fcf_random_select - Randomly select an eligible new fcf record</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fcf_cnt: number of eligible fcf record seen so far.</span>
<span class="cm"> *</span>
<span class="cm"> * This function makes an running random selection decision on FCF record to</span>
<span class="cm"> * use through a sequence of @fcf_cnt eligible FCF records with equal</span>
<span class="cm"> * probability. To perform integer manunipulation of random numbers with</span>
<span class="cm"> * size unit32_t, the lower 16 bits of the 32-bit random number returned</span>
<span class="cm"> * from random32() are taken as the random random number generated.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true when outcome is for the newly read FCF record should be</span>
<span class="cm"> * chosen; otherwise, return false when outcome is for keeping the previously</span>
<span class="cm"> * chosen FCF record.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">lpfc_sli4_new_fcf_random_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">fcf_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">rand_num</span><span class="p">;</span>

	<span class="cm">/* Get 16-bit uniform random number */</span>
	<span class="n">rand_num</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0xFFFF</span> <span class="o">&amp;</span> <span class="n">random32</span><span class="p">());</span>

	<span class="cm">/* Decision with probability 1/fcf_cnt */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fcf_cnt</span> <span class="o">*</span> <span class="n">rand_num</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mh">0xFFFF</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fcf_rec_mbox_parse - Parse read_fcf mbox command.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @mboxq: pointer to mailbox object.</span>
<span class="cm"> * @next_fcf_index: pointer to holder of next fcf index.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine parses the non-embedded fcf mailbox command by performing the</span>
<span class="cm"> * necessarily error checking, non-embedded read FCF record mailbox command</span>
<span class="cm"> * SGE parsing, and endianness swapping.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the pointer to the new FCF record in the non-embedded mailbox</span>
<span class="cm"> * command DMA memory if successfully, other NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span>
<span class="nf">lpfc_sli4_fcf_rec_mbox_parse</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">,</span>
			     <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">next_fcf_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">virt_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">phys_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_sge</span> <span class="n">sge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_read_fcf_tbl</span> <span class="o">*</span><span class="n">read_fcf</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">new_fcf_record</span><span class="p">;</span>

	<span class="cm">/* Get the first SGE entry from the non-embedded DMA memory. This</span>
<span class="cm">	 * routine only uses a single SGE.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_sli4_mbx_sge_get</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sge</span><span class="p">);</span>
	<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">getPaddr</span><span class="p">(</span><span class="n">sge</span><span class="p">.</span><span class="n">pa_hi</span><span class="p">,</span> <span class="n">sge</span><span class="p">.</span><span class="n">pa_lo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">sge_array</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
				<span class="s">&quot;2524 Failed to get the non-embedded SGE &quot;</span>
				<span class="s">&quot;virtual address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">virt_addr</span> <span class="o">=</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">sge_array</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span><span class="n">virt_addr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">==</span> <span class="n">STATUS_FCF_TABLE_EMPTY</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					<span class="s">&quot;2726 READ_FCF_RECORD Indicates empty &quot;</span>
					<span class="s">&quot;FCF table.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					<span class="s">&quot;2521 READ_FCF_RECORD mailbox failed &quot;</span>
					<span class="s">&quot;with status x%x add_status x%x, &quot;</span>
					<span class="s">&quot;mbx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Interpreting the returned information of the FCF record */</span>
	<span class="n">read_fcf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_read_fcf_tbl</span> <span class="o">*</span><span class="p">)</span><span class="n">virt_addr</span><span class="p">;</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">read_fcf</span><span class="p">,</span> <span class="n">read_fcf</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_read_fcf_tbl</span><span class="p">));</span>
	<span class="o">*</span><span class="n">next_fcf_index</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_fcf_tbl_nxt_vindx</span><span class="p">,</span> <span class="n">read_fcf</span><span class="p">);</span>
	<span class="n">new_fcf_record</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="p">)(</span><span class="n">virt_addr</span> <span class="o">+</span>
			  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_read_fcf_tbl</span><span class="p">));</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">new_fcf_record</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">,</span>
				<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcf_record</span><span class="p">,</span> <span class="n">vlan_bitmap</span><span class="p">));</span>
	<span class="n">new_fcf_record</span><span class="o">-&gt;</span><span class="n">word137</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">new_fcf_record</span><span class="o">-&gt;</span><span class="n">word137</span><span class="p">);</span>
	<span class="n">new_fcf_record</span><span class="o">-&gt;</span><span class="n">word138</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">new_fcf_record</span><span class="o">-&gt;</span><span class="n">word138</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">new_fcf_record</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_log_fcf_record_info - Log the information of a fcf record</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fcf_record: pointer to the fcf record.</span>
<span class="cm"> * @vlan_id: the lowest vlan identifier associated to this fcf record.</span>
<span class="cm"> * @next_fcf_index: the index to the next fcf record in hba&#39;s fcf table.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine logs the detailed FCF record if the LOG_FIP loggin is</span>
<span class="cm"> * enabled.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_log_fcf_record_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">fcf_record</span><span class="p">,</span>
			      <span class="kt">uint16_t</span> <span class="n">vlan_id</span><span class="p">,</span>
			      <span class="kt">uint16_t</span> <span class="n">next_fcf_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
			<span class="s">&quot;2764 READ_FCF_RECORD:</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;</span><span class="se">\t</span><span class="s">FCF_Index     : x%x</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;</span><span class="se">\t</span><span class="s">FCF_Avail     : x%x</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;</span><span class="se">\t</span><span class="s">FCF_Valid     : x%x</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;</span><span class="se">\t</span><span class="s">FIP_Priority  : x%x</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;</span><span class="se">\t</span><span class="s">MAC_Provider  : x%x</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;</span><span class="se">\t</span><span class="s">Lowest VLANID : x%x</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;</span><span class="se">\t</span><span class="s">FCF_MAC Addr  : x%x:%x:%x:%x:%x:%x</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;</span><span class="se">\t</span><span class="s">Fabric_Name   : x%x:%x:%x:%x:%x:%x:%x:%x</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;</span><span class="se">\t</span><span class="s">Switch_Name   : x%x:%x:%x:%x:%x:%x:%x:%x</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;</span><span class="se">\t</span><span class="s">Next_FCF_Index: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_avail</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_valid</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">fcf_record</span><span class="o">-&gt;</span><span class="n">fip_priority</span><span class="p">,</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_addr_prov</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">vlan_id</span><span class="p">,</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_0</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_1</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_2</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_3</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_4</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_5</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_0</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_1</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_2</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_3</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_4</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_5</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_6</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fab_name_7</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_0</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_1</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_2</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_3</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_4</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_5</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_6</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_switch_name_7</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">),</span>
			<span class="n">next_fcf_index</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> lpfc_sli4_fcf_record_match - testing new FCF record for matching existing FCF</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fcf_rec: pointer to an existing FCF record.</span>
<span class="cm"> * @new_fcf_record: pointer to a new FCF record.</span>
<span class="cm"> * @new_vlan_id: vlan id from the new FCF record.</span>
<span class="cm"> *</span>
<span class="cm"> * This function performs matching test of a new FCF record against an existing</span>
<span class="cm"> * FCF record. If the new_vlan_id passed in is LPFC_FCOE_IGNORE_VID, vlan id</span>
<span class="cm"> * will not be used as part of the FCF record matching criteria.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if all the fields matching, otherwise returns false.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">lpfc_sli4_fcf_record_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">lpfc_fcf_rec</span> <span class="o">*</span><span class="n">fcf_rec</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">new_fcf_record</span><span class="p">,</span>
			   <span class="kt">uint16_t</span> <span class="n">new_vlan_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_vlan_id</span> <span class="o">!=</span> <span class="n">LPFC_FCOE_IGNORE_VID</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_vlan_id_match</span><span class="p">(</span><span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">vlan_id</span><span class="p">,</span> <span class="n">new_vlan_id</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_mac_addr_match</span><span class="p">(</span><span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_sw_name_match</span><span class="p">(</span><span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">switch_name</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_fab_name_match</span><span class="p">(</span><span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">fabric_name</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">!=</span> <span class="n">new_fcf_record</span><span class="o">-&gt;</span><span class="n">fip_priority</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fcf_rr_next_proc - processing next roundrobin fcf</span>
<span class="cm"> * @vport: Pointer to vport object.</span>
<span class="cm"> * @fcf_index: index to next fcf.</span>
<span class="cm"> *</span>
<span class="cm"> * This function processing the roundrobin fcf failover to next fcf index.</span>
<span class="cm"> * When this function is invoked, there will be a current fcf registered</span>
<span class="cm"> * for flogi.</span>
<span class="cm"> * Return: 0 for continue retrying flogi on currently registered fcf;</span>
<span class="cm"> *         1 for stop flogi on currently registered fcf;</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">lpfc_sli4_fcf_rr_next_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">fcf_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fcf_index</span> <span class="o">==</span> <span class="n">LPFC_FCOE_FCF_NEXT_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_DEVLOSS_TMO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					<span class="s">&quot;2872 Devloss tmo with no eligible &quot;</span>
					<span class="s">&quot;FCF, unregister in-use FCF (x%x) &quot;</span>
					<span class="s">&quot;and rescan FCF table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">);</span>
			<span class="n">lpfc_unregister_fcf_rescan</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">stop_flogi_current_fcf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Mark the end to FLOGI roundrobin failover */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_RR_INPROG</span><span class="p">;</span>
		<span class="cm">/* Allow action to new fcf asynchronous event */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FCF_AVAILABLE</span> <span class="o">|</span> <span class="n">FCF_SCAN_DONE</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
				<span class="s">&quot;2865 No FCF available, stop roundrobin FCF &quot;</span>
				<span class="s">&quot;failover and change port state:x%x/x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">LPFC_VPORT_UNKNOWN</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_VPORT_UNKNOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">stop_flogi_current_fcf</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				<span class="s">&quot;2794 Try FLOGI roundrobin FCF failover to &quot;</span>
				<span class="s">&quot;(x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_rr_read_fcf_rec</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_ELS</span><span class="p">,</span>
					<span class="s">&quot;2761 FLOGI roundrobin FCF failover &quot;</span>
					<span class="s">&quot;failed (rc:x%x) to read FCF (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">rc</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">stop_flogi_current_fcf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">stop_flogi_current_fcf:</span>
	<span class="n">lpfc_can_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fcf_pri_list_del</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fcf_index the index of the fcf record to delete</span>
<span class="cm"> * This routine checks the on list flag of the fcf_index to be deleted.</span>
<span class="cm"> * If it is one the list then it is removed from the list, and the flag</span>
<span class="cm"> * is cleared. This routine grab the hbalock before removing the fcf</span>
<span class="cm"> * record from the list.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lpfc_sli4_fcf_pri_list_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			<span class="kt">uint16_t</span> <span class="n">fcf_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_pri</span> <span class="o">*</span><span class="n">new_fcf_pri</span><span class="p">;</span>

	<span class="n">new_fcf_pri</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri</span><span class="p">[</span><span class="n">fcf_index</span><span class="p">];</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
		<span class="s">&quot;3058 deleting idx x%x pri x%x flg x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">fcf_index</span><span class="p">,</span> <span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span><span class="p">,</span>
		 <span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">flag</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">LPFC_FCF_ON_PRI_LIST</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">priority</span> <span class="o">==</span>
				<span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span><span class="p">)</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">eligible_fcf_cnt</span><span class="o">--</span><span class="p">;</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_FCF_ON_PRI_LIST</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_set_fcf_flogi_fail</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fcf_index the index of the fcf record to update</span>
<span class="cm"> * This routine acquires the hbalock and then set the LPFC_FCF_FLOGI_FAILED</span>
<span class="cm"> * flag so the the round robin slection for the particular priority level</span>
<span class="cm"> * will try a different fcf record that does not have this bit set.</span>
<span class="cm"> * If the fcf record is re-read for any reason this flag is cleared brfore</span>
<span class="cm"> * adding it to the priority list.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_set_fcf_flogi_fail</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">fcf_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_pri</span> <span class="o">*</span><span class="n">new_fcf_pri</span><span class="p">;</span>
	<span class="n">new_fcf_pri</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri</span><span class="p">[</span><span class="n">fcf_index</span><span class="p">];</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">LPFC_FCF_FLOGI_FAILED</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fcf_pri_list_add</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fcf_index the index of the fcf record to add</span>
<span class="cm"> * This routine checks the priority of the fcf_index to be added.</span>
<span class="cm"> * If it is a lower priority than the current head of the fcf_pri list</span>
<span class="cm"> * then it is added to the list in the right order.</span>
<span class="cm"> * If it is the same priority as the current head of the list then it</span>
<span class="cm"> * is added to the head of the list and its bit in the rr_bmask is set.</span>
<span class="cm"> * If the fcf_index to be added is of a higher priority than the current</span>
<span class="cm"> * head of the list then the rr_bmask is cleared, its bit is set in the</span>
<span class="cm"> * rr_bmask and it is added to the head of the list.</span>
<span class="cm"> * returns:</span>
<span class="cm"> * 0=success 1=failure</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">lpfc_sli4_fcf_pri_list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">fcf_index</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">new_fcf_record</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">current_fcf_pri</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">last_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_pri</span> <span class="o">*</span><span class="n">fcf_pri</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_pri</span> <span class="o">*</span><span class="n">next_fcf_pri</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_pri</span> <span class="o">*</span><span class="n">new_fcf_pri</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">new_fcf_pri</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri</span><span class="p">[</span><span class="n">fcf_index</span><span class="p">];</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
		<span class="s">&quot;3059 adding idx x%x pri x%x flg x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">fcf_index</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="o">-&gt;</span><span class="n">fip_priority</span><span class="p">,</span>
		 <span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">flag</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">LPFC_FCF_ON_PRI_LIST</span><span class="p">)</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">fcf_index</span> <span class="o">=</span> <span class="n">fcf_index</span><span class="p">;</span>
	<span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">new_fcf_record</span><span class="o">-&gt;</span><span class="n">fip_priority</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri_list</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_rr_index_set</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
				<span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">fcf_index</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">last_index</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">,</span>
				<span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_index</span> <span class="o">&gt;=</span> <span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Empty rr list */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">current_fcf_pri</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri</span><span class="p">[</span><span class="n">last_index</span><span class="p">].</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span> <span class="o">&lt;=</span>  <span class="n">current_fcf_pri</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span> <span class="o">&lt;</span>  <span class="n">current_fcf_pri</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">));</span>
			<span class="cm">/* fcfs_at_this_priority_level = 1; */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">eligible_fcf_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* fcfs_at_this_priority_level++; */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">eligible_fcf_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_rr_index_set</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
				<span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">fcf_index</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">fcf_pri</span><span class="p">,</span> <span class="n">next_fcf_pri</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span> <span class="o">&lt;=</span>
				<span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri_list</span><span class="p">)</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri_list</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_fcf_pri</span> <span class="o">*</span><span class="p">)</span>
					<span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri_list</span>
			<span class="o">||</span> <span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span> <span class="o">&lt;</span>
				<span class="n">next_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span> <span class="o">&gt;</span> <span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="cm">/* we use = instead of |= to clear the FLOGI_FAILED flag. */</span>
	<span class="n">new_fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span> <span class="n">LPFC_FCF_ON_PRI_LIST</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mbx_cmpl_fcf_scan_read_fcf_rec - fcf scan read_fcf mbox cmpl handler.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @mboxq: pointer to mailbox object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function iterates through all the fcf records available in</span>
<span class="cm"> * HBA and chooses the optimal FCF record for discovery. After finding</span>
<span class="cm"> * the FCF for discovery it registers the FCF record and kicks start</span>
<span class="cm"> * discovery.</span>
<span class="cm"> * If FCF_IN_USE flag is set in currently used FCF, the routine tries to</span>
<span class="cm"> * use an FCF record which matches fabric name and mac address of the</span>
<span class="cm"> * currently used FCF record.</span>
<span class="cm"> * If the driver supports only one FCF, it will try to use the FCF record</span>
<span class="cm"> * used by BOOT_BIOS.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_fcf_scan_read_fcf_rec</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">new_fcf_record</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">boot_flag</span><span class="p">,</span> <span class="n">addr_mode</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">fcf_index</span><span class="p">,</span> <span class="n">next_fcf_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_rec</span> <span class="o">*</span><span class="n">fcf_rec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">vlan_id</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">seed</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">select_new_fcf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* If there is pending FCoE event restart FCF table scan */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_check_pending_fcoe_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_SKIP_UNREG_FCF</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Parse the FCF record from the non-embedded mailbox command */</span>
	<span class="n">new_fcf_record</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_rec_mbox_parse</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">next_fcf_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_fcf_record</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
				<span class="s">&quot;2765 Mailbox command READ_FCF_RECORD &quot;</span>
				<span class="s">&quot;failed to retrieve a FCF record.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* Let next new FCF event trigger fast failover */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_TS_INPROG</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check the FCF record against the connection list */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_match_fcf_conn_list</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">boot_flag</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">addr_mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vlan_id</span><span class="p">);</span>

	<span class="cm">/* Log the FCF record information if turned on */</span>
	<span class="n">lpfc_sli4_log_fcf_record_info</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">,</span>
				      <span class="n">next_fcf_index</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the fcf record does not match with connect list entries</span>
<span class="cm">	 * read the next entry; otherwise, this is an eligible FCF</span>
<span class="cm">	 * record for roundrobin FCF failover.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_sli4_fcf_pri_list_del</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span>
					       <span class="n">new_fcf_record</span><span class="p">));</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
				<span class="s">&quot;2781 FCF (x%x) failed connection &quot;</span>
				<span class="s">&quot;list check: (x%x/x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span>
				       <span class="n">new_fcf_record</span><span class="p">),</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_avail</span><span class="p">,</span>
				       <span class="n">new_fcf_record</span><span class="p">),</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_valid</span><span class="p">,</span>
				       <span class="n">new_fcf_record</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_IN_USE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">lpfc_sli4_fcf_record_match</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">,</span>
		    <span class="n">new_fcf_record</span><span class="p">,</span> <span class="n">LPFC_FCOE_IGNORE_VID</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">)</span> <span class="o">!=</span>
			    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					<span class="s">&quot;2862 FCF (x%x) matches property &quot;</span>
					<span class="s">&quot;of in-use FCF (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span>
					       <span class="n">new_fcf_record</span><span class="p">),</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">read_next_fcf</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * In case the current in-use FCF record becomes</span>
<span class="cm">			 * invalid/unavailable during FCF discovery that</span>
<span class="cm">			 * was not triggered by fast FCF failover process,</span>
<span class="cm">			 * treat it as fast FCF failover.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REDISC_PEND</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REDISC_FOV</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
						<span class="s">&quot;2835 Invalid in-use FCF &quot;</span>
						<span class="s">&quot;(x%x), enter FCF failover &quot;</span>
						<span class="s">&quot;table scan.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">);</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">|=</span> <span class="n">FCF_REDISC_FOV</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
				<span class="n">lpfc_sli4_fcf_scan_read_fcf_rec</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="n">LPFC_FCOE_FCF_GET_FIRST</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">read_next_fcf</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fcf_index</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_pri_list_add</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">,</span>
							<span class="n">new_fcf_record</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">read_next_fcf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is not the first FCF discovery of the HBA, use last</span>
<span class="cm">	 * FCF record for the discovery. The condition that a rescan</span>
<span class="cm">	 * matches the in-use FCF record: fabric name, switch name, mac</span>
<span class="cm">	 * address, and vlan_id.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_IN_USE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcf_failover_policy</span> <span class="o">==</span> <span class="n">LPFC_FCF_FOV</span> <span class="o">&amp;&amp;</span>
			<span class="n">lpfc_sli4_fcf_record_match</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">,</span>
		    <span class="n">new_fcf_record</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">)</span> <span class="o">==</span>
			    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">|=</span> <span class="n">FCF_AVAILABLE</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REDISC_PEND</span><span class="p">)</span>
					<span class="cm">/* Stop FCF redisc wait timer */</span>
					<span class="n">__lpfc_sli4_stop_fcf_redisc_wait_timer</span><span class="p">(</span>
									<span class="n">phba</span><span class="p">);</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REDISC_FOV</span><span class="p">)</span>
					<span class="cm">/* Fast failover, mark completed */</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_REDISC_FOV</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
						<span class="s">&quot;2836 New FCF matches in-use &quot;</span>
						<span class="s">&quot;FCF (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					<span class="s">&quot;2863 New FCF (x%x) matches &quot;</span>
					<span class="s">&quot;property of in-use FCF (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span>
					       <span class="n">new_fcf_record</span><span class="p">),</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Read next FCF record from HBA searching for the matching</span>
<span class="cm">		 * with in-use record only if not during the fast failover</span>
<span class="cm">		 * period. In case of fast failover period, it shall try to</span>
<span class="cm">		 * determine whether the FCF record just read should be the</span>
<span class="cm">		 * next candidate.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REDISC_FOV</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">read_next_fcf</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Update on failover FCF record only if it&#39;s in FCF fast-failover</span>
<span class="cm">	 * period; otherwise, update on current FCF record.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REDISC_FOV</span><span class="p">)</span>
		<span class="n">fcf_rec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">failover_rec</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">fcf_rec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_AVAILABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the driver FCF record does not have boot flag</span>
<span class="cm">		 * set and new hba fcf record has boot flag set, use</span>
<span class="cm">		 * the new hba fcf record.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">boot_flag</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOOT_ENABLE</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Choose this FCF record */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					<span class="s">&quot;2837 Update current FCF record &quot;</span>
					<span class="s">&quot;(x%x) with new FCF record (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">fcf_indx</span><span class="p">,</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span>
					<span class="n">new_fcf_record</span><span class="p">));</span>
			<span class="n">__lpfc_update_fcf_record</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fcf_rec</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">,</span>
					<span class="n">addr_mode</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">,</span> <span class="n">BOOT_ENABLE</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">read_next_fcf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the driver FCF record has boot flag set and the</span>
<span class="cm">		 * new hba FCF record does not have boot flag, read</span>
<span class="cm">		 * the next FCF record.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">boot_flag</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOOT_ENABLE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">read_next_fcf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the new hba FCF record has lower priority value</span>
<span class="cm">		 * than the driver FCF record, use the new record.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_fcf_record</span><span class="o">-&gt;</span><span class="n">fip_priority</span> <span class="o">&lt;</span> <span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Choose the new FCF record with lower priority */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					<span class="s">&quot;2838 Update current FCF record &quot;</span>
					<span class="s">&quot;(x%x) with new FCF record (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">fcf_indx</span><span class="p">,</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span>
					       <span class="n">new_fcf_record</span><span class="p">));</span>
			<span class="n">__lpfc_update_fcf_record</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fcf_rec</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">,</span>
					<span class="n">addr_mode</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="cm">/* Reset running random FCF selection count */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">eligible_fcf_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_fcf_record</span><span class="o">-&gt;</span><span class="n">fip_priority</span> <span class="o">==</span> <span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Update running random FCF selection count */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">eligible_fcf_cnt</span><span class="o">++</span><span class="p">;</span>
			<span class="n">select_new_fcf</span> <span class="o">=</span> <span class="n">lpfc_sli4_new_fcf_random_select</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">eligible_fcf_cnt</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">select_new_fcf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					<span class="s">&quot;2839 Update current FCF record &quot;</span>
					<span class="s">&quot;(x%x) with new FCF record (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">fcf_rec</span><span class="o">-&gt;</span><span class="n">fcf_indx</span><span class="p">,</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span>
					       <span class="n">new_fcf_record</span><span class="p">));</span>
				<span class="cm">/* Choose the new FCF by random selection */</span>
				<span class="n">__lpfc_update_fcf_record</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fcf_rec</span><span class="p">,</span>
							 <span class="n">new_fcf_record</span><span class="p">,</span>
							 <span class="n">addr_mode</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">read_next_fcf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * This is the first suitable FCF record, choose this record for</span>
<span class="cm">	 * initial best-fit FCF.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fcf_rec</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
				<span class="s">&quot;2840 Update initial FCF candidate &quot;</span>
				<span class="s">&quot;with FCF (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span>
				       <span class="n">new_fcf_record</span><span class="p">));</span>
		<span class="n">__lpfc_update_fcf_record</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fcf_rec</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">,</span>
					 <span class="n">addr_mode</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">,</span> <span class="p">(</span><span class="n">boot_flag</span> <span class="o">?</span>
					 <span class="n">BOOT_ENABLE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">|=</span> <span class="n">FCF_AVAILABLE</span><span class="p">;</span>
		<span class="cm">/* Setup initial running random FCF selection count */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">eligible_fcf_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Seeding the random number generator for random selection */</span>
		<span class="n">seed</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="mh">0xFFFFFFFF</span> <span class="o">&amp;</span> <span class="n">jiffies</span><span class="p">);</span>
		<span class="n">srandom32</span><span class="p">(</span><span class="n">seed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">read_next_fcf</span><span class="p">;</span>

<span class="nl">read_next_fcf:</span>
	<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_fcf_index</span> <span class="o">==</span> <span class="n">LPFC_FCOE_FCF_NEXT_NONE</span> <span class="o">||</span> <span class="n">next_fcf_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REDISC_FOV</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Case of FCF fast failover scan</span>
<span class="cm">			 */</span>

			<span class="cm">/*</span>
<span class="cm">			 * It has not found any suitable FCF record, cancel</span>
<span class="cm">			 * FCF scan inprogress, and do nothing</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">failover_rec</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">RECORD_VALID</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					       <span class="s">&quot;2782 No suitable FCF found: &quot;</span>
					       <span class="s">&quot;(x%x/x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_eventtag_at_fcf_scan</span><span class="p">,</span>
					       <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span>
						      <span class="n">new_fcf_record</span><span class="p">));</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_DEVLOSS_TMO</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_TS_INPROG</span><span class="p">;</span>
					<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
					<span class="cm">/* Unregister in-use FCF and rescan */</span>
					<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span>
							<span class="n">LOG_FIP</span><span class="p">,</span>
							<span class="s">&quot;2864 On devloss tmo &quot;</span>
							<span class="s">&quot;unreg in-use FCF and &quot;</span>
							<span class="s">&quot;rescan FCF table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">lpfc_unregister_fcf_rescan</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/*</span>
<span class="cm">				 * Let next new FCF event trigger fast failover</span>
<span class="cm">				 */</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_TS_INPROG</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * It has found a suitable FCF record that is not</span>
<span class="cm">			 * the same as in-use FCF record, unregister the</span>
<span class="cm">			 * in-use FCF record, replace the in-use FCF record</span>
<span class="cm">			 * with the new FCF record, mark FCF fast failover</span>
<span class="cm">			 * completed, and then start register the new FCF</span>
<span class="cm">			 * record.</span>
<span class="cm">			 */</span>

			<span class="cm">/* Unregister the current in-use FCF record */</span>
			<span class="n">lpfc_unregister_fcf</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

			<span class="cm">/* Replace in-use record with the new record */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
					<span class="s">&quot;2842 Replace in-use FCF (x%x) &quot;</span>
					<span class="s">&quot;with failover FCF (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">failover_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">failover_rec</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fcf_rec</span><span class="p">));</span>
			<span class="cm">/*</span>
<span class="cm">			 * Mark the fast FCF failover rediscovery completed</span>
<span class="cm">			 * and the start of the first round of the roundrobin</span>
<span class="cm">			 * FCF failover.</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_REDISC_FOV</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="cm">/* Register to the new FCF record */</span>
			<span class="n">lpfc_register_fcf</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * In case of transaction period to fast FCF failover,</span>
<span class="cm">			 * do nothing when search to the end of the FCF table.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REDISC_EVT</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REDISC_PEND</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcf_failover_policy</span> <span class="o">==</span> <span class="n">LPFC_FCF_FOV</span> <span class="o">&amp;&amp;</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_IN_USE</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * In case the current in-use FCF record no</span>
<span class="cm">				 * longer existed during FCF discovery that</span>
<span class="cm">				 * was not triggered by fast FCF failover</span>
<span class="cm">				 * process, treat it as fast FCF failover.</span>
<span class="cm">				 */</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
						<span class="s">&quot;2841 In-use FCF record (x%x) &quot;</span>
						<span class="s">&quot;not reported, entering fast &quot;</span>
						<span class="s">&quot;FCF failover mode scanning.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">);</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">|=</span> <span class="n">FCF_REDISC_FOV</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="n">lpfc_sli4_fcf_scan_read_fcf_rec</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="n">LPFC_FCOE_FCF_GET_FIRST</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Register to the new FCF record */</span>
			<span class="n">lpfc_register_fcf</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">lpfc_sli4_fcf_scan_read_fcf_rec</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">next_fcf_index</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
	<span class="n">lpfc_register_fcf</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mbx_cmpl_fcf_rr_read_fcf_rec - fcf roundrobin read_fcf mbox cmpl hdler</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @mboxq: pointer to mailbox object.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the callback function for FLOGI failure roundrobin FCF failover</span>
<span class="cm"> * read FCF record mailbox command from the eligible FCF record bmask for</span>
<span class="cm"> * performing the failover. If the FCF read back is not valid/available, it</span>
<span class="cm"> * fails through to retrying FLOGI to the currently registered FCF again.</span>
<span class="cm"> * Otherwise, if the FCF read back is valid and available, it will set the</span>
<span class="cm"> * newly read FCF record to the failover FCF record, unregister currently</span>
<span class="cm"> * registered FCF record, copy the failover FCF record to the current</span>
<span class="cm"> * FCF record, and then register the current FCF record before proceeding</span>
<span class="cm"> * to trying FLOGI on the new failover FCF.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_fcf_rr_read_fcf_rec</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">new_fcf_record</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">boot_flag</span><span class="p">,</span> <span class="n">addr_mode</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">next_fcf_index</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">current_fcf_index</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">vlan_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* If link state is not up, stop the roundrobin failover process */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&lt;</span> <span class="n">LPFC_LINK_UP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_DISCOVERY</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_RR_INPROG</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Parse the FCF record from the non-embedded mailbox command */</span>
	<span class="n">new_fcf_record</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_rec_mbox_parse</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">next_fcf_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_fcf_record</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
				<span class="s">&quot;2766 Mailbox command READ_FCF_RECORD &quot;</span>
				<span class="s">&quot;failed to retrieve a FCF record.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the needed parameters from FCF record */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_match_fcf_conn_list</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">boot_flag</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">addr_mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vlan_id</span><span class="p">);</span>

	<span class="cm">/* Log the FCF record information if turned on */</span>
	<span class="n">lpfc_sli4_log_fcf_record_info</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">,</span>
				      <span class="n">next_fcf_index</span><span class="p">);</span>

	<span class="n">fcf_index</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
				<span class="s">&quot;2848 Remove ineligible FCF (x%x) from &quot;</span>
				<span class="s">&quot;from roundrobin bmask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>
		<span class="cm">/* Clear roundrobin bmask bit for ineligible FCF */</span>
		<span class="n">lpfc_sli4_fcf_rr_index_clear</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>
		<span class="cm">/* Perform next round of roundrobin FCF failover */</span>
		<span class="n">fcf_index</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_rr_next_index_get</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_rr_next_proc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fcf_index</span> <span class="o">==</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
				<span class="s">&quot;2760 Perform FLOGI roundrobin FCF failover: &quot;</span>
				<span class="s">&quot;FCF (x%x) back to FCF (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>
		<span class="cm">/* Wait 500 ms before retrying FLOGI to current FCF */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
		<span class="n">lpfc_issue_init_vfi</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Upload new FCF record to the failover FCF record */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
			<span class="s">&quot;2834 Update current FCF (x%x) with new FCF (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">failover_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">__lpfc_update_fcf_record</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">failover_rec</span><span class="p">,</span>
				 <span class="n">new_fcf_record</span><span class="p">,</span> <span class="n">addr_mode</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">boot_flag</span> <span class="o">?</span> <span class="n">BOOT_ENABLE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">current_fcf_index</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">;</span>

	<span class="cm">/* Unregister the current in-use FCF record */</span>
	<span class="n">lpfc_unregister_fcf</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Replace in-use record with the new record */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">failover_rec</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fcf_rec</span><span class="p">));</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
			<span class="s">&quot;2783 Perform FLOGI roundrobin FCF failover: FCF &quot;</span>
			<span class="s">&quot;(x%x) to FCF (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current_fcf_index</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>

<span class="nl">error_out:</span>
	<span class="n">lpfc_register_fcf</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mbx_cmpl_read_fcf_rec - read fcf completion handler.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @mboxq: pointer to mailbox object.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the callback function of read FCF record mailbox command for</span>
<span class="cm"> * updating the eligible FCF bmask for FLOGI failure roundrobin FCF</span>
<span class="cm"> * failover when a new FCF event happened. If the FCF read back is</span>
<span class="cm"> * valid/available and it passes the connection list check, it updates</span>
<span class="cm"> * the bmask for the eligible FCF record for roundrobin failover.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_read_fcf_rec</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">new_fcf_record</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">boot_flag</span><span class="p">,</span> <span class="n">addr_mode</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">fcf_index</span><span class="p">,</span> <span class="n">next_fcf_index</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">vlan_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* If link state is not up, no need to proceed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&lt;</span> <span class="n">LPFC_LINK_UP</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* If FCF discovery period is over, no need to proceed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_DISCOVERY</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Parse the FCF record from the non-embedded mailbox command */</span>
	<span class="n">new_fcf_record</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_rec_mbox_parse</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">next_fcf_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_fcf_record</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
				<span class="s">&quot;2767 Mailbox command READ_FCF_RECORD &quot;</span>
				<span class="s">&quot;failed to retrieve a FCF record.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check the connection list for eligibility */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_match_fcf_conn_list</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">boot_flag</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">addr_mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vlan_id</span><span class="p">);</span>

	<span class="cm">/* Log the FCF record information if turned on */</span>
	<span class="n">lpfc_sli4_log_fcf_record_info</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">,</span>
				      <span class="n">next_fcf_index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Update the eligible FCF record index bmask */</span>
	<span class="n">fcf_index</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_pri_list_add</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">,</span> <span class="n">new_fcf_record</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_init_vfi_cmpl - Completion handler for init_vfi mbox command.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @mboxq: pointer to mailbox data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function handles completion of init vfi mailbox command.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_init_vfi_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * VFI not supported on interface type 0, just do the flogi</span>
<span class="cm">	 * Also continue if the VFI is in use - just use the same one.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">)</span> <span class="o">!=</span>
			<span class="n">LPFC_SLI_INTF_IF_TYPE_0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span> <span class="o">!=</span> <span class="n">MBX_VFI_IN_USE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
				<span class="n">LOG_MBOX</span><span class="p">,</span>
				<span class="s">&quot;2891 Init VFI mailbox failed 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_initial_flogi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_init_vfi - Issue init_vfi mailbox command.</span>
<span class="cm"> * @vport: pointer to lpfc_vport data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function issue a init_vfi mailbox command to initialize the VFI and</span>
<span class="cm"> * VPI for the physical port.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_issue_init_vfi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="n">mboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
			<span class="n">LOG_MBOX</span><span class="p">,</span> <span class="s">&quot;2892 Failed to allocate &quot;</span>
			<span class="s">&quot;init_vfi mailbox</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_init_vfi</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_init_vfi_cmpl</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
			<span class="n">LOG_MBOX</span><span class="p">,</span> <span class="s">&quot;2893 Failed to issue init_vfi mailbox</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_init_vpi_cmpl - Completion handler for init_vpi mbox command.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @mboxq: pointer to mailbox data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function handles completion of init vpi mailbox command.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_init_vpi_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
				<span class="n">LOG_MBOX</span><span class="p">,</span>
				<span class="s">&quot;2609 Init VPI mailbox failed 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VPORT_NEEDS_INIT_VPI</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="cm">/* If this port is physical port or FDISC is done, do reg_vpi */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">==</span> <span class="n">vport</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">LPFC_FDISC</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">Fabric_DID</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
				<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
					<span class="n">LOG_DISCOVERY</span><span class="p">,</span>
					<span class="s">&quot;2731 Cannot find fabric &quot;</span>
					<span class="s">&quot;controller node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">lpfc_register_new_vport</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;</span> <span class="n">LS_NPIV_FAB_SUPPORTED</span><span class="p">)</span>
		<span class="n">lpfc_initial_fdisc</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_NO_FABRIC_SUPP</span><span class="p">);</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;2606 No NPIV Fabric support</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_init_vpi - Issue init_vpi mailbox command.</span>
<span class="cm"> * @vport: pointer to lpfc_vport data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function issue a init_vpi mailbox command to initialize</span>
<span class="cm"> * VPI for the vport.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_issue_init_vpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
			<span class="n">LOG_MBOX</span><span class="p">,</span> <span class="s">&quot;2607 Failed to allocate &quot;</span>
			<span class="s">&quot;init_vpi mailbox</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_init_vpi</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">);</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_init_vpi_cmpl</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
			<span class="n">LOG_MBOX</span><span class="p">,</span> <span class="s">&quot;2608 Failed to issue init_vpi mailbox</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_start_fdiscs - send fdiscs for each vports on this port.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function loops through the list of vports on the @phba and issues an</span>
<span class="cm"> * FDISC if possible.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_start_fdiscs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_PHYSICAL_PORT</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/* There are no vpi for this vport */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">&gt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						     <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						     <span class="n">FC_VPORT_LINKDOWN</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_VPORT_NEEDS_INIT_VPI</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_issue_init_vpi</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;</span> <span class="n">LS_NPIV_FAB_SUPPORTED</span><span class="p">)</span>
				<span class="n">lpfc_initial_fdisc</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						     <span class="n">FC_VPORT_NO_FABRIC_SUPP</span><span class="p">);</span>
				<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">KERN_ERR</span><span class="p">,</span>
						 <span class="n">LOG_ELS</span><span class="p">,</span>
						 <span class="s">&quot;0259 No NPIV &quot;</span>
						 <span class="s">&quot;Fabric support</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_reg_vfi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span> <span class="o">=</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * VFI not supported for interface type 0, so ignore any mailbox</span>
<span class="cm">	 * error (except VFI in use) and continue with the discovery.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">)</span> <span class="o">!=</span>
			<span class="n">LPFC_SLI_INTF_IF_TYPE_0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span> <span class="o">!=</span> <span class="n">MBX_VFI_IN_USE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
			 <span class="s">&quot;2018 REG_VFI mbxStatus error x%x &quot;</span>
			 <span class="s">&quot;HBA state x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* FLOGI failed, use loop map to make discovery list */</span>
			<span class="n">lpfc_disc_list_loopmap</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="cm">/* Start discovery */</span>
			<span class="n">lpfc_disc_start</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_mem</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_mem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* The VPI is implicitly registered when the VFI is registered */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi_state</span> <span class="o">|=</span> <span class="n">LPFC_VPI_REGISTERED</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VFI_REGISTERED</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VPORT_NEEDS_INIT_VPI</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="cm">/* In case SLI4 FC loopback test, we are ready */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;</span> <span class="n">LS_LOOPBACK_MODE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_READY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">LPFC_FABRIC_CFG_LINK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For private loop or for NPort pt2pt,</span>
<span class="cm">		 * just start discovery and we are done.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PT2PT</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PUBLIC_LOOP</span><span class="p">)))</span> <span class="p">{</span>

			<span class="cm">/* Use loop map to make discovery list */</span>
			<span class="n">lpfc_disc_list_loopmap</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="cm">/* Start discovery */</span>
			<span class="n">lpfc_disc_start</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lpfc_start_fdiscs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">lpfc_do_scr_ns_plogi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out_free_mem:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_read_sparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span>  <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>


	<span class="cm">/* Check for error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* READ_SPARAM mbox error &lt;mbxStatus&gt; state &lt;hba_state&gt; */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
				 <span class="s">&quot;0319 READ_SPARAM mbxStatus error x%x &quot;</span>
				 <span class="s">&quot;hba state x%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
		<span class="n">lpfc_linkdown</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span>
	       <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span><span class="p">));</span>
	<span class="n">lpfc_update_vport_wwn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_PHYSICAL_PORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">wwnn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">wwnn</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">wwpn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">wwnn</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">lpfc_issue_clear_la</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_mbx_process_link_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_mbx_read_top</span> <span class="o">*</span><span class="n">la</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">sparam_mbox</span><span class="p">,</span> <span class="o">*</span><span class="n">cfglink_mbox</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">fcf_record</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_link_spd</span><span class="p">,</span> <span class="n">la</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_LINK_SPEED_1GHZ</span>:
	<span class="k">case</span> <span class="n">LPFC_LINK_SPEED_2GHZ</span>:
	<span class="k">case</span> <span class="n">LPFC_LINK_SPEED_4GHZ</span>:
	<span class="k">case</span> <span class="n">LPFC_LINK_SPEED_8GHZ</span>:
	<span class="k">case</span> <span class="n">LPFC_LINK_SPEED_10GHZ</span>:
	<span class="k">case</span> <span class="n">LPFC_LINK_SPEED_16GHZ</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_linkspeed</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_link_spd</span><span class="p">,</span> <span class="n">la</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_linkspeed</span> <span class="o">=</span> <span class="n">LPFC_LINK_SPEED_UNKNOWN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_topology</span><span class="p">,</span> <span class="n">la</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LS_NPIV_FAB_SUPPORTED</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">;</span>

		<span class="cm">/* if npiv is enabled and this adapter supports npiv log</span>
<span class="cm">		 * a message that npiv is not supported in this topology</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_npiv</span> <span class="o">&amp;&amp;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_LINK_EVENT</span><span class="p">,</span>
				<span class="s">&quot;1309 Link Up Event npiv not supported in loop &quot;</span>
				<span class="s">&quot;topology</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="cm">/* Get Loop Map information */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_il</span><span class="p">,</span> <span class="n">la</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_LBIT</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_alpa_granted</span><span class="p">,</span> <span class="n">la</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">la</span><span class="o">-&gt;</span><span class="n">lilpBde64</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">alpa_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_log_verbose</span> <span class="o">&amp;</span> <span class="n">LOG_LINK_EVENT</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">numalpa</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
				<span class="k">union</span> <span class="p">{</span>
					<span class="kt">uint8_t</span> <span class="n">pamap</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
					<span class="k">struct</span> <span class="p">{</span>
						<span class="kt">uint32_t</span> <span class="n">wd1</span><span class="p">;</span>
						<span class="kt">uint32_t</span> <span class="n">wd2</span><span class="p">;</span>
						<span class="kt">uint32_t</span> <span class="n">wd3</span><span class="p">;</span>
						<span class="kt">uint32_t</span> <span class="n">wd4</span><span class="p">;</span>
					<span class="p">}</span> <span class="n">pa</span><span class="p">;</span>
				<span class="p">}</span> <span class="n">un</span><span class="p">;</span>
				<span class="n">numalpa</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">alpa_map</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
				<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">numalpa</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">memset</span><span class="p">(</span><span class="n">un</span><span class="p">.</span><span class="n">pamap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
					<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numalpa</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">un</span><span class="p">.</span><span class="n">pamap</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
							<span class="n">phba</span><span class="o">-&gt;</span><span class="n">alpa_map</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
						<span class="n">j</span><span class="o">++</span><span class="p">;</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span>
							<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="cm">/* Link Up Event ALPA map */</span>
					<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
							<span class="n">KERN_WARNING</span><span class="p">,</span>
							<span class="n">LOG_LINK_EVENT</span><span class="p">,</span>
							<span class="s">&quot;1304 Link Up Event &quot;</span>
							<span class="s">&quot;ALPA map Data: x%x &quot;</span>
							<span class="s">&quot;x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">un</span><span class="p">.</span><span class="n">pa</span><span class="p">.</span><span class="n">wd1</span><span class="p">,</span> <span class="n">un</span><span class="p">.</span><span class="n">pa</span><span class="p">.</span><span class="n">wd2</span><span class="p">,</span>
							<span class="n">un</span><span class="p">.</span><span class="n">pa</span><span class="p">.</span><span class="n">wd3</span><span class="p">,</span> <span class="n">un</span><span class="p">.</span><span class="n">pa</span><span class="p">.</span><span class="n">wd4</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span> <span class="o">&amp;&amp;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_npiv</span> <span class="o">&amp;&amp;</span>
			   <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&gt;=</span> <span class="n">LPFC_SLI_REV3</span><span class="p">))</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">|=</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_pref_DID</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_LBIT</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">lpfc_linkup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">sparam_mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sparam_mbox</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_read_sparam</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sparam_mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">sparam_mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sparam_mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="n">sparam_mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_read_sparam</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sparam_mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">sparam_mbox</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
		<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">sparam_mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FCOE_MODE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cfglink_mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfglink_mbox</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_LOCAL_CFG_LINK</span><span class="p">;</span>
		<span class="n">lpfc_config_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cfglink_mbox</span><span class="p">);</span>
		<span class="n">cfglink_mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
		<span class="n">cfglink_mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_local_config_link</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cfglink_mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">cfglink_mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_VPORT_UNKNOWN</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Add the driver&#39;s default FCF record at FCF index 0 now. This</span>
<span class="cm">		 * is phase 1 implementation that support FCF index 0 and driver</span>
<span class="cm">		 * defaults.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FIP_SUPPORT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fcf_record</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcf_record</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fcf_record</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
					<span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;2554 Could not allocate memory for &quot;</span>
					<span class="s">&quot;fcf record</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">lpfc_sli4_build_dflt_fcf_record</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">,</span>
						<span class="n">LPFC_FCOE_FCF_DEF_INDEX</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_add_fcf_record</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
					<span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;2013 Could not manually add FCF &quot;</span>
					<span class="s">&quot;record 0, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">fcf_record</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">fcf_record</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * The driver is expected to do FIP/FCF. Call the port</span>
<span class="cm">		 * and get the FCF Table.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">FCF_TS_INPROG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* This is the initial FCF discovery scan */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">|=</span> <span class="n">FCF_INIT_DISC</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				<span class="s">&quot;2778 Start FCF table scan at linkup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_scan_read_fcf_rec</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						     <span class="n">LPFC_FCOE_FCF_GET_FIRST</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_INIT_DISC</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Reset FCF roundrobin bmask for new discovery */</span>
		<span class="n">lpfc_sli4_clear_fcf_rr_bmask</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
			 <span class="s">&quot;0263 Discovery Mailbox error: state: 0x%x : %p %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">sparam_mbox</span><span class="p">,</span> <span class="n">cfglink_mbox</span><span class="p">);</span>
	<span class="n">lpfc_issue_clear_la</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_enable_la</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">control</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_PROCESS_LA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;=</span> <span class="n">LPFC_SLI_REV3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">control</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
		<span class="n">control</span> <span class="o">|=</span> <span class="n">HC_LAINT_ENA</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_mbx_issue_link_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_linkdown</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_enable_la</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_unregister_unused_fcf</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="cm">/* turn on Link Attention interrupts - no CLEAR_LA needed */</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This routine handles processing a READ_TOPOLOGY mailbox</span>
<span class="cm"> * command upon completion. It is setup in the LPFC_MBOXQ</span>
<span class="cm"> * as the completion routine when the command is</span>
<span class="cm"> * handed off to the SLI layer.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_read_topology</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_read_top</span> <span class="o">*</span><span class="n">la</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">);</span>

	<span class="cm">/* Unblock ELS traffic */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">].</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>
	<span class="cm">/* Check for error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_LINK_EVENT</span><span class="p">,</span>
				<span class="s">&quot;1307 READ_LA mbox error x%x state x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
		<span class="n">lpfc_mbx_issue_link_down</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">lpfc_mbx_cmpl_read_topology_free_mbuf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">la</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_read_top</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varReadTop</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">alpa_map</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_pb</span><span class="p">,</span> <span class="n">la</span><span class="p">))</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_BYPASSED_MODE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_BYPASSED_MODE</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span>  <span class="o">&lt;</span> <span class="n">la</span><span class="o">-&gt;</span><span class="n">eventTag</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span> <span class="o">==</span> <span class="n">la</span><span class="o">-&gt;</span><span class="n">eventTag</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">LinkMultiEvent</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_att_type</span><span class="p">,</span> <span class="n">la</span><span class="p">)</span> <span class="o">==</span> <span class="n">LPFC_ATT_LINK_UP</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">lpfc_linkdown</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span> <span class="o">=</span> <span class="n">la</span><span class="o">-&gt;</span><span class="n">eventTag</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_mm</span><span class="p">,</span> <span class="n">la</span><span class="p">))</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_MENLO_MAINT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_MENLO_MAINT</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_events</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_att_type</span><span class="p">,</span> <span class="n">la</span><span class="p">)</span> <span class="o">==</span> <span class="n">LPFC_ATT_LINK_UP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_mm</span><span class="p">,</span> <span class="n">la</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">LinkUp</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;</span> <span class="n">LS_LOOPBACK_MODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_LINK_EVENT</span><span class="p">,</span>
					<span class="s">&quot;1306 Link Up Event in loop back mode &quot;</span>
					<span class="s">&quot;x%x received Data: x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">la</span><span class="o">-&gt;</span><span class="n">eventTag</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span><span class="p">,</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_alpa_granted</span><span class="p">,</span>
					       <span class="n">la</span><span class="p">),</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_link_spd</span><span class="p">,</span> <span class="n">la</span><span class="p">),</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">alpa_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_LINK_EVENT</span><span class="p">,</span>
					<span class="s">&quot;1303 Link Up Event x%x received &quot;</span>
					<span class="s">&quot;Data: x%x x%x x%x x%x x%x x%x %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">la</span><span class="o">-&gt;</span><span class="n">eventTag</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span><span class="p">,</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_alpa_granted</span><span class="p">,</span>
					       <span class="n">la</span><span class="p">),</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_link_spd</span><span class="p">,</span> <span class="n">la</span><span class="p">),</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">alpa_map</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_mm</span><span class="p">,</span> <span class="n">la</span><span class="p">),</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_fa</span><span class="p">,</span> <span class="n">la</span><span class="p">),</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">wait_4_mlo_maint_flg</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lpfc_mbx_process_link_up</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">la</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_att_type</span><span class="p">,</span> <span class="n">la</span><span class="p">)</span> <span class="o">==</span>
		   <span class="n">LPFC_ATT_LINK_DOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">LinkDown</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;</span> <span class="n">LS_LOOPBACK_MODE</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_LINK_EVENT</span><span class="p">,</span>
				<span class="s">&quot;1308 Link Down Event in loop back mode &quot;</span>
				<span class="s">&quot;x%x received &quot;</span>
				<span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">la</span><span class="o">-&gt;</span><span class="n">eventTag</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_LINK_EVENT</span><span class="p">,</span>
				<span class="s">&quot;1305 Link Down Event x%x received &quot;</span>
				<span class="s">&quot;Data: x%x x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">la</span><span class="o">-&gt;</span><span class="n">eventTag</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_mm</span><span class="p">,</span> <span class="n">la</span><span class="p">),</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_fa</span><span class="p">,</span> <span class="n">la</span><span class="p">));</span>
		<span class="n">lpfc_mbx_issue_link_down</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_mm</span><span class="p">,</span> <span class="n">la</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_att_type</span><span class="p">,</span> <span class="n">la</span><span class="p">)</span> <span class="o">==</span> <span class="n">LPFC_ATT_LINK_UP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">!=</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">LinkDown</span><span class="o">++</span><span class="p">;</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_LINK_EVENT</span><span class="p">,</span>
				<span class="s">&quot;1312 Link Down Event x%x received &quot;</span>
				<span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">la</span><span class="o">-&gt;</span><span class="n">eventTag</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">);</span>
			<span class="n">lpfc_mbx_issue_link_down</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">lpfc_enable_la</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_LINK_EVENT</span><span class="p">,</span>
				<span class="s">&quot;1310 Menlo Maint Mode Link up Event x%x rcvd &quot;</span>
				<span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">la</span><span class="o">-&gt;</span><span class="n">eventTag</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The cmnd that triggered this will be waiting for this</span>
<span class="cm">		 * signal.</span>
<span class="cm">		 */</span>
		<span class="cm">/* WAKEUP for MENLO_SET_MODE or MENLO_RESET command. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">wait_4_mlo_maint_flg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">wait_4_mlo_maint_flg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">wait_4_mlo_m_q</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_fa</span><span class="p">,</span> <span class="n">la</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_mm</span><span class="p">,</span> <span class="n">la</span><span class="p">))</span>
			<span class="n">lpfc_issue_clear_la</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_LINK_EVENT</span><span class="p">,</span>
				<span class="s">&quot;1311 fa %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_fa</span><span class="p">,</span> <span class="n">la</span><span class="p">));</span>
	<span class="p">}</span>

<span class="nl">lpfc_mbx_cmpl_read_topology_free_mbuf:</span>
	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine handles processing a REG_LOGIN mailbox</span>
<span class="cm"> * command upon completion. It is setup in the LPFC_MBOXQ</span>
<span class="cm"> * as the completion routine when the command is</span>
<span class="cm"> * handed off to the SLI layer.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_reg_login</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span>  <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_REG_LOGIN_SEND</span><span class="p">)</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_REG_LOGIN_SEND</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_IGNR_REG_CMPL</span> <span class="o">||</span>
	    <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_REG_LOGIN_ISSUE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We rcvd a rscn after issuing this</span>
<span class="cm">		 * mbox reg login, we may have cycled</span>
<span class="cm">		 * back through the state and be</span>
<span class="cm">		 * back at reg login state so this</span>
<span class="cm">		 * mbox needs to be ignored becase</span>
<span class="cm">		 * there is another reg login in</span>
<span class="cm">		 * process.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_IGNR_REG_CMPL</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* Good status, call state machine */</span>
		<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span>
				<span class="n">NLP_EVT_CMPL_REG_LOGIN</span><span class="p">);</span>

	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="cm">/* decrement the node reference count held for this callback</span>
<span class="cm">	 * function.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_unreg_vpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x0011</span>:
	<span class="k">case</span> <span class="mh">0x0020</span>:
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
				 <span class="s">&quot;0911 cmpl_unreg_vpi, mb status = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/* If VPI is busy, reset the HBA */</span>
	<span class="k">case</span> <span class="mh">0x9700</span>:
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
			<span class="s">&quot;2798 Unreg_vpi failed vpi 0x%x, mb status = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">,</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">))</span>
			<span class="n">lpfc_workq_post_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="n">LPFC_EVT_RESET_HBA</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_VPI_REGISTERED</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">unreg_vpi_cmpl</span> <span class="o">=</span> <span class="n">VPORT_OK</span><span class="p">;</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="n">lpfc_cleanup_vports_rrqs</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This shost reference might have been taken at the beginning of</span>
<span class="cm">	 * lpfc_vport_delete()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vport</span> <span class="o">!=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">))</span>
		<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">lpfc_mbx_unreg_vpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">lpfc_unreg_vpi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_unreg_vpi</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_VPORT</span><span class="p">,</span>
				 <span class="s">&quot;1800 Could not issue unreg_vpi</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">unreg_vpi_cmpl</span> <span class="o">=</span> <span class="n">VPORT_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_reg_vpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x0011</span>:
	<span class="k">case</span> <span class="mh">0x9601</span>:
	<span class="k">case</span> <span class="mh">0x9602</span>:
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
				 <span class="s">&quot;0912 cmpl_reg_vpi, mb status = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">);</span>
		<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FC_FABRIC</span> <span class="o">|</span> <span class="n">FC_PUBLIC_LOOP</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi_state</span> <span class="o">|=</span> <span class="n">LPFC_VPI_REGISTERED</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* go thru NPR list and issue ELS PLOGIs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_npr_cnt</span><span class="p">)</span>
		<span class="n">lpfc_els_disc_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_NDISC_ACTIVE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">lpfc_can_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_VPORT_READY</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_create_static_vport - Read HBA config region to create static vports.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issue a DUMP mailbox command for config region 22 to get</span>
<span class="cm"> * the list of static vports to be created. The function create vports</span>
<span class="cm"> * based on the information returned from the HBA.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_create_static_vport</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">static_vport_info</span> <span class="o">*</span><span class="n">vport_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_vport_identifiers</span> <span class="n">vport_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">new_fc_vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">vport_buff</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">byte_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pmb</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0542 lpfc_create_static_vport failed to&quot;</span>
				<span class="s">&quot; allocate mailbox memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>

	<span class="n">vport_info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">static_vport_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vport_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0543 lpfc_create_static_vport failed to&quot;</span>
				<span class="s">&quot; allocate vport_info</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vport_buff</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">vport_info</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_dump_static_vport</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">LPFC_MBOX_TMO</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="o">||</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0544 lpfc_create_static_vport failed to&quot;</span>
				<span class="s">&quot; issue dump mailbox command ret 0x%x &quot;</span>
				<span class="s">&quot;status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rc</span><span class="p">,</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">byte_count</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
			<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">byte_count</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">static_vport_info</span><span class="p">)</span> <span class="o">-</span>
					<span class="n">offset</span><span class="p">)</span>
				<span class="n">byte_count</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">static_vport_info</span><span class="p">)</span>
					<span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">vport_buff</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">byte_count</span><span class="p">);</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">byte_count</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span> <span class="o">&gt;</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">static_vport_info</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>
				<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span> <span class="o">=</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">static_vport_info</span><span class="p">)</span>
						<span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
			<span class="n">byte_count</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span><span class="p">;</span>
			<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mb</span><span class="p">)</span> <span class="o">+</span> <span class="n">DMP_RSP_OFFSET</span><span class="p">,</span>
				<span class="n">vport_buff</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
				<span class="n">byte_count</span><span class="p">);</span>

			<span class="n">offset</span> <span class="o">+=</span> <span class="n">byte_count</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">byte_count</span> <span class="o">&amp;&amp;</span>
		<span class="n">offset</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">static_vport_info</span><span class="p">));</span>


	<span class="k">if</span> <span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">vport_info</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">)</span> <span class="o">!=</span> <span class="n">VPORT_INFO_SIG</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">vport_info</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">VPORT_INFO_REV_MASK</span><span class="p">)</span>
			<span class="o">!=</span> <span class="n">VPORT_INFO_REV</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0545 lpfc_create_static_vport bad&quot;</span>
			<span class="s">&quot; information header 0x%x 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">vport_info</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">),</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">vport_info</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">VPORT_INFO_REV_MASK</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_STATIC_VPORT_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vport_id</span><span class="p">));</span>
		<span class="n">vport_id</span><span class="p">.</span><span class="n">port_name</span> <span class="o">=</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">vport_info</span><span class="o">-&gt;</span><span class="n">vport_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wwpn</span><span class="p">);</span>
		<span class="n">vport_id</span><span class="p">.</span><span class="n">node_name</span> <span class="o">=</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">vport_info</span><span class="o">-&gt;</span><span class="n">vport_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wwnn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vport_id</span><span class="p">.</span><span class="n">port_name</span> <span class="o">||</span> <span class="o">!</span><span class="n">vport_id</span><span class="p">.</span><span class="n">node_name</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">vport_id</span><span class="p">.</span><span class="n">roles</span> <span class="o">=</span> <span class="n">FC_PORT_ROLE_FCP_INITIATOR</span><span class="p">;</span>
		<span class="n">vport_id</span><span class="p">.</span><span class="n">vport_type</span> <span class="o">=</span> <span class="n">FC_PORTTYPE_NPIV</span><span class="p">;</span>
		<span class="n">vport_id</span><span class="p">.</span><span class="n">disable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">new_fc_vport</span> <span class="o">=</span> <span class="n">fc_vport_create</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport_id</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_fc_vport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0546 lpfc_create_static_vport failed to&quot;</span>
				<span class="s">&quot; create vport</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">vport</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="p">)</span><span class="n">new_fc_vport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">vport_flag</span> <span class="o">|=</span> <span class="n">STATIC_VPORT</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vport_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
			<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine handles processing a Fabric REG_LOGIN mailbox</span>
<span class="cm"> * command upon completion. It is setup in the LPFC_MBOXQ</span>
<span class="cm"> * as the completion routine when the command is</span>
<span class="cm"> * handed off to the SLI layer.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_fabric_reg_login</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
				 <span class="s">&quot;0258 Register Fabric login error: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">);</span>
		<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* FLOGI failed, use loop map to make discovery list */</span>
			<span class="n">lpfc_disc_list_loopmap</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

			<span class="cm">/* Start discovery */</span>
			<span class="n">lpfc_disc_start</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="cm">/* Decrement the reference count to ndlp after the</span>
<span class="cm">			 * reference to the ndlp are done.</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
		<span class="cm">/* Decrement the reference count to ndlp after the reference</span>
<span class="cm">		 * to the ndlp are done.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_RPI_REGISTERED</span><span class="p">;</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">|=</span> <span class="n">NLP_FABRIC</span><span class="p">;</span>
	<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">LPFC_FABRIC_CFG_LINK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* when physical port receive logo donot start</span>
<span class="cm">		 * vport discovery */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_LOGO_RCVD_DID_CHNG</span><span class="p">))</span>
			<span class="n">lpfc_start_fdiscs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_LOGO_RCVD_DID_CHNG</span> <span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lpfc_do_scr_ns_plogi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="cm">/* Drop the reference count from the mbox at the end after</span>
<span class="cm">	 * all the current reference to the ndlp have been done.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine handles processing a NameServer REG_LOGIN mailbox</span>
<span class="cm"> * command upon completion. It is setup in the LPFC_MBOXQ</span>
<span class="cm"> * as the completion routine when the command is</span>
<span class="cm"> * handed off to the SLI layer.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_ns_reg_login</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>

	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">out:</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;0260 Register NameServer error: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">);</span>
		<span class="cm">/* decrement the node reference count held for this</span>
<span class="cm">		 * callback function.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

		<span class="cm">/* If no other thread is using the ndlp, free it */</span>
		<span class="n">lpfc_nlp_not_used</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * RegLogin failed, use loop map to make discovery</span>
<span class="cm">			 * list</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_disc_list_loopmap</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

			<span class="cm">/* Start discovery */</span>
			<span class="n">lpfc_disc_start</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_RPI_REGISTERED</span><span class="p">;</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">|=</span> <span class="n">NLP_FABRIC</span><span class="p">;</span>
	<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;</span> <span class="n">LPFC_VPORT_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Link up discovery requires Fabric registration. */</span>
		<span class="n">lpfc_ns_cmd</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">SLI_CTNS_RFF_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* Do this first! */</span>
		<span class="n">lpfc_ns_cmd</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">SLI_CTNS_RNN_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">lpfc_ns_cmd</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">SLI_CTNS_RSNN_NN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">lpfc_ns_cmd</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">SLI_CTNS_RSPN_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">lpfc_ns_cmd</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">SLI_CTNS_RFT_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Issue SCR just before NameServer GID_FT Query */</span>
		<span class="n">lpfc_issue_els_scr</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">SCR_DID</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_ns_retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Good status, issue CT Request to NameServer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_ns_cmd</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">SLI_CTNS_GID_FT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Cannot issue NameServer Query, so finish up discovery */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* decrement the node reference count held for this</span>
<span class="cm">	 * callback function.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_register_remote_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_rport</span>  <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport_identifiers</span> <span class="n">rport_ids</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="cm">/* Remote port has reappeared. Re-register w/ FC transport */</span>
	<span class="n">rport_ids</span><span class="p">.</span><span class="n">node_name</span> <span class="o">=</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">);</span>
	<span class="n">rport_ids</span><span class="p">.</span><span class="n">port_name</span> <span class="o">=</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">);</span>
	<span class="n">rport_ids</span><span class="p">.</span><span class="n">port_id</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">;</span>
	<span class="n">rport_ids</span><span class="p">.</span><span class="n">roles</span> <span class="o">=</span> <span class="n">FC_RPORT_ROLE_UNKNOWN</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We leave our node pointer in rport-&gt;dd_data when we unregister a</span>
<span class="cm">	 * FCP target port.  But fc_remote_port_add zeros the space to which</span>
<span class="cm">	 * rport-&gt;dd_data points.  So, if we&#39;re reusing a previously</span>
<span class="cm">	 * registered port, drop the reference that we took the last time we</span>
<span class="cm">	 * registered the port.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">&amp;&amp;</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">==</span> <span class="n">ndlp</span><span class="p">)</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_RPORT</span><span class="p">,</span>
		<span class="s">&quot;rport add:       did:x%x flg:x%x type x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t add the remote port if unloading. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">=</span> <span class="n">rport</span> <span class="o">=</span> <span class="n">fc_remote_port_add</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport_ids</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rport</span> <span class="o">||</span> <span class="o">!</span><span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;Warning: fc_remote_port_add failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize static port data */</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">maxframe_size</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_maxframe</span><span class="p">;</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">supported_classes</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_class_sup</span><span class="p">;</span>
	<span class="n">rdata</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">=</span> <span class="n">lpfc_nlp_get</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">&amp;</span> <span class="n">NLP_FCP_TARGET</span><span class="p">)</span>
		<span class="n">rport_ids</span><span class="p">.</span><span class="n">roles</span> <span class="o">|=</span> <span class="n">FC_RPORT_ROLE_FCP_TARGET</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">&amp;</span> <span class="n">NLP_FCP_INITIATOR</span><span class="p">)</span>
		<span class="n">rport_ids</span><span class="p">.</span><span class="n">roles</span> <span class="o">|=</span> <span class="n">FC_RPORT_ROLE_FCP_INITIATOR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rport_ids</span><span class="p">.</span><span class="n">roles</span> <span class="o">!=</span>  <span class="n">FC_RPORT_ROLE_UNKNOWN</span><span class="p">)</span>
		<span class="n">fc_remote_port_rolechg</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="n">rport_ids</span><span class="p">.</span><span class="n">roles</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">&lt;</span> <span class="n">LPFC_MAX_TARGET</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_sid</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_unregister_remote_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_RPORT</span><span class="p">,</span>
		<span class="s">&quot;rport delete:    did:x%x flg:x%x type x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span><span class="p">);</span>

	<span class="n">fc_remote_port_delete</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_nlp_counters</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NLP_STE_UNUSED_NODE</span>:
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_unused_cnt</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NLP_STE_PLOGI_ISSUE</span>:
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_plogi_cnt</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NLP_STE_ADISC_ISSUE</span>:
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_adisc_cnt</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NLP_STE_REG_LOGIN_ISSUE</span>:
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_reglogin_cnt</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NLP_STE_PRLI_ISSUE</span>:
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_prli_cnt</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NLP_STE_UNMAPPED_NODE</span>:
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_unmap_cnt</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NLP_STE_MAPPED_NODE</span>:
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_map_cnt</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NLP_STE_NPR_NODE</span>:
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_npr_cnt</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_nlp_state_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">old_state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">==</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_NODEV_REMOVE</span><span class="p">;</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">|=</span> <span class="n">NLP_FC_NODE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">==</span> <span class="n">NLP_STE_MAPPED_NODE</span><span class="p">)</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_NODEV_REMOVE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">==</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">)</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_RCV_PLOGI</span><span class="p">;</span>

	<span class="cm">/* Transport interface */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">old_state</span> <span class="o">==</span> <span class="n">NLP_STE_MAPPED_NODE</span> <span class="o">||</span>
			    <span class="n">old_state</span> <span class="o">==</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nport_event_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_unregister_remote_port</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">==</span>  <span class="n">NLP_STE_MAPPED_NODE</span> <span class="o">||</span>
	    <span class="n">new_state</span> <span class="o">==</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nport_event_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Tell the fc transport about the port, if we haven&#39;t</span>
<span class="cm">		 * already. If we have, and it&#39;s a scsi entity, be</span>
<span class="cm">		 * sure to unblock any attached scsi devices</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_register_remote_port</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">new_state</span> <span class="o">==</span>  <span class="n">NLP_STE_MAPPED_NODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_enabled</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * A new target is discovered, if there is no buffer for</span>
<span class="cm">		 * statistical data collection allocate buffer.</span>
<span class="cm">		 */</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">lat_data</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">LPFC_MAX_BUCKET_COUNT</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_scsicmd_bkt</span><span class="p">),</span>
					 <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">lat_data</span><span class="p">)</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
				<span class="s">&quot;0286 lpfc_nlp_state_cleanup failed to &quot;</span>
				<span class="s">&quot;allocate statistical data buffer DID &quot;</span>
				<span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * if we added to Mapped list, but the remote port</span>
<span class="cm">	 * registration failed or assigned a target id outside</span>
<span class="cm">	 * our presentable range - move the node to the</span>
<span class="cm">	 * Unmapped List</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">==</span> <span class="n">NLP_STE_MAPPED_NODE</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">||</span>
	     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span>
	     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">scsi_target_id</span> <span class="o">&gt;=</span> <span class="n">LPFC_MAX_TARGET</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_TGT_NO_SCSIID</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">lpfc_nlp_state_name</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">states</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">NLP_STE_UNUSED_NODE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;UNUSED&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">NLP_STE_PLOGI_ISSUE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;PLOGI&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">NLP_STE_ADISC_ISSUE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ADISC&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">NLP_STE_REG_LOGIN_ISSUE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;REGLOGIN&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">NLP_STE_PRLI_ISSUE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;PRLI&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;UNMAPPED&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">NLP_STE_MAPPED_NODE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;MAPPED&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">NLP_STE_NPR_NODE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;NPR&quot;</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">NLP_STE_MAX_STATE</span> <span class="o">&amp;&amp;</span> <span class="n">states</span><span class="p">[</span><span class="n">state</span><span class="p">])</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">states</span><span class="p">[</span><span class="n">state</span><span class="p">],</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;unknown (%d)&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">lpfc_nlp_set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="n">old_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name1</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">name2</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
			 <span class="s">&quot;0904 NPort state transition x%06x, %s -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span>
			 <span class="n">lpfc_nlp_state_name</span><span class="p">(</span><span class="n">name1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name1</span><span class="p">),</span> <span class="n">old_state</span><span class="p">),</span>
			 <span class="n">lpfc_nlp_state_name</span><span class="p">(</span><span class="n">name2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name2</span><span class="p">),</span> <span class="n">state</span><span class="p">));</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_NODE</span><span class="p">,</span>
		<span class="s">&quot;node statechg    did:x%x old:%d ste:%d&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">old_state</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_state</span> <span class="o">==</span> <span class="n">NLP_STE_NPR_NODE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">state</span> <span class="o">!=</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">)</span>
		<span class="n">lpfc_cancel_retry_delay_tmo</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_state</span> <span class="o">==</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_TGT_NO_SCSIID</span><span class="p">;</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_FC_NODE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_listp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_listp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">old_state</span><span class="p">)</span>
		<span class="n">lpfc_nlp_counters</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">old_state</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">lpfc_nlp_counters</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">lpfc_nlp_state_cleanup</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">old_state</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">lpfc_enqueue_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_listp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_listp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">lpfc_dequeue_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="n">lpfc_cancel_retry_delay_tmo</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_listp</span><span class="p">))</span>
		<span class="n">lpfc_nlp_counters</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_listp</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">lpfc_nlp_state_cleanup</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span>
				<span class="n">NLP_STE_UNUSED_NODE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_disable_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_cancel_retry_delay_tmo</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_listp</span><span class="p">))</span>
		<span class="n">lpfc_nlp_counters</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">lpfc_nlp_state_cleanup</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span>
				<span class="n">NLP_STE_UNUSED_NODE</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * lpfc_initialize_node - Initialize all fields of node object</span>
<span class="cm"> * @vport: Pointer to Virtual Port object.</span>
<span class="cm"> * @ndlp: Pointer to FC node object.</span>
<span class="cm"> * @did: FC_ID of the node.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is always called when node object need to be initialized.</span>
<span class="cm"> * It initializes all the fields of the node object. Although the reference</span>
<span class="cm"> * to phba from @ndlp can be obtained indirectly through it&#39;s reference to</span>
<span class="cm"> * @vport, a direct reference to phba is taken here by @ndlp. This is due</span>
<span class="cm"> * to the life-span of the @ndlp might go beyond the existence of @vport as</span>
<span class="cm"> * the final release of ndlp is determined by its reference count. And, the</span>
<span class="cm"> * operation on @ndlp needs the reference to phba.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">lpfc_initialize_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
	<span class="kt">uint32_t</span> <span class="n">did</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">els_retry_evt</span><span class="p">.</span><span class="n">evt_listp</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">dev_loss_evt</span><span class="p">.</span><span class="n">evt_listp</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_delayfunc</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_delayfunc</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_els_retry_delay</span><span class="p">;</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_delayfunc</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span> <span class="o">=</span> <span class="n">did</span><span class="p">;</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_sid</span> <span class="o">=</span> <span class="n">NLP_NO_SID</span><span class="p">;</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="n">NLP_INT_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">cmd_pending</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">cmd_qdepth</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_tgt_queue_depth</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span> <span class="o">=</span> <span class="n">lpfc_sli4_alloc_rpi</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span>
<span class="nf">lpfc_enable_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">did</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* The ndlp should not be in memory free mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NLP_CHK_FREE_REQ</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
				<span class="s">&quot;0277 lpfc_enable_node: ndlp:x%p &quot;</span>
				<span class="s">&quot;usgmap:x%x refcnt:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_usg_map</span><span class="p">,</span>
				<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* The ndlp should not already be in active mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
				<span class="s">&quot;0278 lpfc_enable_node: ndlp:x%p &quot;</span>
				<span class="s">&quot;usgmap:x%x refcnt:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_usg_map</span><span class="p">,</span>
				<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Keep the original DID */</span>
	<span class="n">did</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">;</span>

	<span class="cm">/* re-initialize ndlp except of ndlp linked list pointer */</span>
	<span class="n">memset</span><span class="p">((((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span>
		<span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">));</span>
	<span class="n">lpfc_initialize_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">)</span>
		<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_NODE</span><span class="p">,</span>
		<span class="s">&quot;node enable:       did:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">lpfc_drop_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Use of lpfc_drop_node and UNUSED list: lpfc_drop_node should</span>
<span class="cm">	 * be used if we wish to issue the &quot;last&quot; lpfc_nlp_put() to remove</span>
<span class="cm">	 * the ndlp from the vport. The ndlp marked as UNUSED on the list</span>
<span class="cm">	 * until ALL other outstanding threads have completed. We check</span>
<span class="cm">	 * that the ndlp not already in the UNUSED state before we proceed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">lpfc_cleanup_vports_rrqs</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start / ReStart rescue timer for Discovery / RSCN handling</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_set_disctmo</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">tmo</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">LPFC_LOCAL_CFG_LINK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* For FAN, timeout should be greater than edtov */</span>
		<span class="n">tmo</span> <span class="o">=</span> <span class="p">(((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_edtov</span> <span class="o">+</span> <span class="mi">999</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Normal discovery timeout should be &gt; than ELS/CT timeout</span>
<span class="cm">		 * FC spec states we need 3 * ratov for CT requests</span>
<span class="cm">		 */</span>
		<span class="n">tmo</span> <span class="o">=</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_disctmo</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
			<span class="s">&quot;set disc timer:  tmo:x%x state:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">tmo</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_disctmo</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">tmo</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_DISC_TMO</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="cm">/* Start Discovery Timer state &lt;hba_state&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			 <span class="s">&quot;0247 Start Discovery Timer state x%x &quot;</span>
			 <span class="s">&quot;Data: x%x x%lx x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">tmo</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_disctmo</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_plogi_cnt</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_adisc_cnt</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cancel rescue timer for Discovery / RSCN handling</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">lpfc_can_disctmo</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;can disc timer:  state:x%x rtry:x%x flg:x%x&quot;</span><span class="p">,</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_ns_retry</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">);</span>

	<span class="cm">/* Turn off discovery timer if its running */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_DISC_TMO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_DISC_TMO</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_disctmo</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">WORKER_DISC_TMO</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Cancel Discovery Timer state &lt;hba_state&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			 <span class="s">&quot;0248 Cancel Discovery Timer state x%x &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_plogi_cnt</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_adisc_cnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check specified ring for outstanding IOCB on the SLI queue</span>
<span class="cm"> * Return true if iocb matches the specified nport</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">lpfc_check_sli_ndlp</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span>    <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">!=</span> <span class="n">vport</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">LPFC_ELS_RING</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CMD_GEN_REQUEST64_CR</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">ndlp</span> <span class="o">==</span> <span class="n">ndlp</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CMD_ELS_REQUEST64_CR</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span> <span class="o">==</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CMD_XMIT_ELS_RSP64_CX</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">==</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">ndlp</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">extra_ring</span><span class="p">)</span> <span class="p">{</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">fcp_ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Skip match check if waiting to relogin to FCP target */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">&amp;</span> <span class="n">NLP_FCP_TARGET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_DELAY_TMO</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">==</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">ushort</span><span class="p">)</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">next_ring</span><span class="p">)</span> <span class="p">{</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free resources / clean up outstanding I/Os</span>
<span class="cm"> * associated with nlp_rpi in the LPFC_NODELIST entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_no_rpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="o">*</span><span class="n">next_iocb</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">lpfc_fabric_abort_nport</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Everything that matches on txcmplq will be returned</span>
<span class="cm">	 * by firmware with a no rpi error.</span>
<span class="cm">	 */</span>
	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_RPI_REGISTERED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Now process each ring */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">next_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span>
						 <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Check to see if iocb matches the nport we are</span>
<span class="cm">				 * looking for</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">lpfc_check_sli_ndlp</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span>
							 <span class="n">ndlp</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* It matches, so deque and call compl</span>
<span class="cm">					   with an error */</span>
					<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
					<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="o">--</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Cancel all the IOCBs from the completions list */</span>
	<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
			      <span class="n">IOERR_SLI_ABORTED</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free rpi associated with LPFC_NODELIST entry.</span>
<span class="cm"> * This routine is called from lpfc_freenode(), when we are removing</span>
<span class="cm"> * a LPFC_NODELIST entry. It is also called if the driver initiates a</span>
<span class="cm"> * LOGO that completes successfully, and we are waiting to PLOGI back</span>
<span class="cm"> * to the remote NPort. In addition, it is called after we receive</span>
<span class="cm"> * and unsolicated ELS cmd, send back a rsp, the rsp completes and</span>
<span class="cm"> * we are waiting to PLOGI back to the remote NPort.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">lpfc_unreg_rpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span>    <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">rpi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_RPI_REGISTERED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* SLI4 ports require the physical rpi value. */</span>
			<span class="n">rpi</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
				<span class="n">rpi</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">[</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">];</span>
			<span class="n">lpfc_unreg_login</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">,</span> <span class="n">rpi</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
				<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lpfc_no_rpi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">!=</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_RPI_REGISTERED</span><span class="p">;</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_NPR_ADISC</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_unreg_hba_rpis - Unregister rpis registered to the hba.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to unregister all the currently registered RPIs</span>
<span class="cm"> * to the HBA.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_unreg_hba_rpis</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vports</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			<span class="s">&quot;2884 Vport array allocation failed </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_RPI_REGISTERED</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* The mempool_alloc might sleep */</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">lpfc_unreg_rpi</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ndlp</span><span class="p">);</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">lpfc_unreg_all_rpis</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span>  <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span>     <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_sli4_unreg_all_rpis</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_unreg_login</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">,</span> <span class="n">LPFC_UNREG_ALL_RPIS_VPORT</span><span class="p">,</span>
				 <span class="n">mbox</span><span class="p">);</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_TMO</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">))</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_VPORT</span><span class="p">,</span>
				<span class="s">&quot;1836 Could not issue &quot;</span>
				<span class="s">&quot;unreg_login(all_rpis) status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">lpfc_unreg_default_rpis</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span>  <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span>     <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_unreg_did</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">,</span> <span class="n">LPFC_UNREG_ALL_DFLT_RPIS</span><span class="p">,</span>
			       <span class="n">mbox</span><span class="p">);</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_TMO</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">))</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_VPORT</span><span class="p">,</span>
					 <span class="s">&quot;1815 Could not issue &quot;</span>
					 <span class="s">&quot;unreg_did (default rpis) status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free resources associated with LPFC_NODELIST entry</span>
<span class="cm"> * so it can be freed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_cleanup_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mb</span><span class="p">,</span> <span class="o">*</span><span class="n">nextmb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>

	<span class="cm">/* Cleanup node for NPort &lt;nlp_DID&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
			 <span class="s">&quot;0900 Cleanup node for NPort x%x &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NLP_CHK_FREE_REQ</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
				<span class="s">&quot;0280 lpfc_cleanup_node: ndlp:x%p &quot;</span>
				<span class="s">&quot;usgmap:x%x refcnt:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_usg_map</span><span class="p">,</span>
				<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">));</span>
		<span class="n">lpfc_dequeue_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
				<span class="s">&quot;0281 lpfc_cleanup_node: ndlp:x%p &quot;</span>
				<span class="s">&quot;usgmap:x%x refcnt:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_usg_map</span><span class="p">,</span>
				<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">));</span>
		<span class="n">lpfc_disable_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* cleanup any ndlp on mbox q waiting for reglogin cmpl */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mb</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">==</span> <span class="n">MBX_REG_LOGIN64</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">ndlp</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/* Cleanup REG_LOGIN completions which are not yet processed */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mboxq_cmpl</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">!=</span> <span class="n">MBX_REG_LOGIN64</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">ndlp</span> <span class="o">!=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">mb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">nextmb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">==</span> <span class="n">MBX_REG_LOGIN64</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ndlp</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="cm">/* We shall not invoke the lpfc_nlp_put to decrement</span>
<span class="cm">			 * the ndlp reference count as we are in the process</span>
<span class="cm">			 * of lpfc_nlp_release.</span>
<span class="cm">			 */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">lpfc_els_abort</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_DELAY_TMO</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_last_elscmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_delayfunc</span><span class="p">);</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">els_retry_evt</span><span class="p">.</span><span class="n">evt_listp</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">dev_loss_evt</span><span class="p">.</span><span class="n">evt_listp</span><span class="p">);</span>
	<span class="n">lpfc_cleanup_vports_rrqs</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="n">lpfc_unreg_rpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check to see if we can free the nlp back to the freelist.</span>
<span class="cm"> * If we are in the middle of using the nlp in the discovery state</span>
<span class="cm"> * machine, defer the free till we reach the end of the state machine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_nlp_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">lpfc_cancel_retry_delay_tmo</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_DEFER_RM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_REG_LOGIN_SEND</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_RPI_REGISTERED</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* For this case we need to cleanup the default rpi</span>
<span class="cm">		 * allocated by the firmware.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
			<span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_reg_rpi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_flag</span> <span class="o">|=</span> <span class="n">LPFC_MBX_IMED_UNREG</span><span class="p">;</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_dflt_rpi</span><span class="p">;</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">rc</span> <span class="o">=</span><span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">lpfc_cleanup_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can get here with a non-NULL ndlp-&gt;rport because when we</span>
<span class="cm">	 * unregister a rport we don&#39;t break the rport/node linkage.  So if we</span>
<span class="cm">	 * do, make sure we don&#39;t leaving any dangling pointers behind.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rdata</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_matchdid</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
	      <span class="kt">uint32_t</span> <span class="n">did</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">D_ID</span> <span class="n">mydid</span><span class="p">,</span> <span class="n">ndlpdid</span><span class="p">,</span> <span class="n">matchdid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">did</span> <span class="o">==</span> <span class="n">Bcast_DID</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* First check for Direct match */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span> <span class="o">==</span> <span class="n">did</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Next check for area/domain identically equals 0 match */</span>
	<span class="n">mydid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mydid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">domain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mydid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">area</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">matchdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">did</span><span class="p">;</span>
	<span class="n">ndlpdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">matchdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">ndlpdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mydid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">matchdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">mydid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">area</span> <span class="o">==</span> <span class="n">matchdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">area</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ndlpdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">domain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">ndlpdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">area</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ndlpdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">matchdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mydid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">ndlpdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">mydid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">area</span> <span class="o">==</span> <span class="n">ndlpdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">area</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">matchdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">domain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">matchdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">area</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">matchdid</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Search for a nodelist entry */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span>
<span class="nf">__lpfc_findnode_did</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">did</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">data1</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_matchdid</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">did</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">data1</span> <span class="o">=</span> <span class="p">(((</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
				 <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_xri</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
				 <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
				 <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">));</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
					 <span class="s">&quot;0929 FIND node DID &quot;</span>
					 <span class="s">&quot;Data: x%p x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span>
					 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">data1</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* FIND node did &lt;did&gt; NOT FOUND */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
			 <span class="s">&quot;0932 FIND node did x%x NOT FOUND.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span>
<span class="nf">lpfc_findnode_did</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">did</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">__lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span>
<span class="nf">lpfc_setup_disc_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">did</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_RSCN_MODE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">lpfc_rscn_payload_check</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">did</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span>
		     <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nlp_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">lpfc_nlp_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
		<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_enable_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_RSCN_MODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_NDISC_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_rscn_payload_check</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">did</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* If we&#39;ve already received a PLOGI from this NPort</span>
<span class="cm">			 * we don&#39;t need to try to discover it again.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_RCV_PLOGI</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="cm">/* Since this node is marked for discovery,</span>
<span class="cm">			 * delay timeout is not needed.</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_cancel_retry_delay_tmo</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* If we&#39;ve already received a PLOGI from this NPort,</span>
<span class="cm">		 * or we are already in the process of discovery on it,</span>
<span class="cm">		 * we don&#39;t need to try to discover it again.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_ADISC_ISSUE</span> <span class="o">||</span>
		    <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_PLOGI_ISSUE</span> <span class="o">||</span>
		    <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_RCV_PLOGI</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Build a list of nodes to discover based on the loopmap */</span>
<span class="kt">void</span>
<span class="nf">lpfc_disc_list_loopmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">alpa</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_is_link_up</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">!=</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Check for loop map present or not */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">alpa_map</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">alpa_map</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">alpa</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">alpa_map</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="n">alpa</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">alpa</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">lpfc_setup_disc_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">alpa</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* No alpamap, so try all alpa&#39;s */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">FC_MAXLOOP</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If cfg_scan_down is set, start from highest</span>
<span class="cm">			 * ALPA (0xef) to lowest (0x1).</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_scan_down</span><span class="p">)</span>
				<span class="n">index</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">index</span> <span class="o">=</span> <span class="n">FC_MAXLOOP</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">alpa</span> <span class="o">=</span> <span class="n">lpfcAlpaArray</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="n">alpa</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">lpfc_setup_disc_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">alpa</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">lpfc_issue_clear_la</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">extra_ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">extra_ring</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">fcp_ring</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">fcp_ring</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">next_ring</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">next_ring</span><span class="p">];</span>
	<span class="kt">int</span>  <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if it&#39;s not a physical port or if we already send</span>
<span class="cm">	 * clear_la then don&#39;t send it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&gt;=</span> <span class="n">LPFC_CLEAR_LA</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">!=</span> <span class="n">LPFC_PHYSICAL_PORT</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

			<span class="cm">/* Link up discovery */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_CLEAR_LA</span><span class="p">;</span>
		<span class="n">lpfc_clear_la</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_clear_la</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="n">lpfc_disc_flush_list</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="n">extra_ring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>
			<span class="n">fcp_ring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>
			<span class="n">next_ring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Reg_vpi to tell firmware to resume normal operations */</span>
<span class="kt">void</span>
<span class="nf">lpfc_issue_reg_vpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">regvpimbox</span><span class="p">;</span>

	<span class="n">regvpimbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regvpimbox</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_reg_vpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">regvpimbox</span><span class="p">);</span>
		<span class="n">regvpimbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_reg_vpi</span><span class="p">;</span>
		<span class="n">regvpimbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">regvpimbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">)</span>
					<span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">regvpimbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Start Link up / RSCN discovery on NPR nodes */</span>
<span class="kt">void</span>
<span class="nf">lpfc_disc_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">num_sent</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">clear_la_pending</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">did_changed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_is_link_up</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_CLEAR_LA</span><span class="p">)</span>
		<span class="n">clear_la_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">clear_la_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;</span> <span class="n">LPFC_VPORT_READY</span><span class="p">)</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_DISC_AUTH</span><span class="p">;</span>

	<span class="n">lpfc_set_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_prevDID</span> <span class="o">==</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">)</span>
		<span class="n">did_changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">did_changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_prevDID</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Start Discovery state &lt;hba_state&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			 <span class="s">&quot;0202 Start Discovery hba state x%x &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_plogi_cnt</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_adisc_cnt</span><span class="p">);</span>

	<span class="cm">/* First do ADISCs - if any */</span>
	<span class="n">num_sent</span> <span class="o">=</span> <span class="n">lpfc_els_disc_adisc</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_sent</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Register the VPI for SLI3, NON-NPIV only. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PT2PT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_RSCN_MODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_issue_reg_vpi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For SLI2, we need to set port_state to READY and continue</span>
<span class="cm">	 * discovery.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;</span> <span class="n">LPFC_VPORT_READY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">clear_la_pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If we get here, there is nothing to ADISC */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_PHYSICAL_PORT</span><span class="p">)</span>
			<span class="n">lpfc_issue_clear_la</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_ABORT_DISCOVERY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* go thru NPR nodes and issue ELS PLOGIs */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_npr_cnt</span><span class="p">)</span>
				<span class="n">lpfc_els_disc_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_NDISC_ACTIVE</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">lpfc_can_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_VPORT_READY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Next do PLOGIs - if any */</span>
		<span class="n">num_sent</span> <span class="o">=</span> <span class="n">lpfc_els_disc_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">num_sent</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_RSCN_MODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Check to see if more RSCNs came in while we</span>
<span class="cm">			 * were processing this one.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_RSCN_DISCOVERY</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_RSCN_MODE</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">lpfc_can_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">lpfc_els_handle_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Ignore completion for all IOCBs on tx and txcmpl queue for ELS</span>
<span class="cm"> *  ring the match the sppecified nodelist.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_free_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="n">IOCB_t</span>     <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span>    <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="o">*</span><span class="n">next_iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>

	<span class="cm">/* Error matching iocb on txq or txcmplq</span>
<span class="cm">	 * First check the txq.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">next_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">!=</span> <span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_ELS_REQUEST64_CR</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_XMIT_ELS_RSP64_CX</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Next check the txcmplq */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">next_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">!=</span> <span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_ELS_REQUEST64_CR</span> <span class="o">||</span>
		    <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_XMIT_ELS_RSP64_CX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_sli_issue_abort_iotag</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">iocb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Cancel all the IOCBs from the completions list */</span>
	<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
			      <span class="n">IOERR_SLI_ABORTED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_disc_flush_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">*</span><span class="n">next_ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_plogi_cnt</span> <span class="o">||</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_adisc_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">next_ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span>
					 <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_PLOGI_ISSUE</span> <span class="o">||</span>
			    <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_ADISC_ISSUE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_free_tx</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">lpfc_cleanup_discovery_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_els_flush_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">lpfc_els_flush_cmd</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">lpfc_disc_flush_list</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/*</span>
<span class="cm"> * NAME:     lpfc_disc_timeout</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION: Fibre Channel driver discovery timeout routine.</span>
<span class="cm"> *</span>
<span class="cm"> * EXECUTION ENVIRONMENT: interrupt only</span>
<span class="cm"> *</span>
<span class="cm"> * CALLED FROM:</span>
<span class="cm"> *      Timer function</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> *      none</span>
<span class="cm"> */</span>
<span class="cm">/*****************************************************************************/</span>
<span class="kt">void</span>
<span class="nf">lpfc_disc_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">tmo_posted</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">tmo_posted</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_DISC_TMO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmo_posted</span><span class="p">)</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">|=</span> <span class="n">WORKER_DISC_TMO</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmo_posted</span><span class="p">)</span>
		<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_disc_timeout_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span>  <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">*</span><span class="n">next_ndlp</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">initlinkmbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">clrlaerr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_DISC_TMO</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_DISC_TMO</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;disc timeout:    state:x%x rtry:x%x flg:x%x&quot;</span><span class="p">,</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_ns_retry</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">LPFC_LOCAL_CFG_LINK</span>:
	<span class="cm">/* port_state is identically  LPFC_LOCAL_CFG_LINK while waiting for</span>
<span class="cm">	 * FAN</span>
<span class="cm">	 */</span>
				<span class="cm">/* FAN timeout */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				 <span class="s">&quot;0221 FAN timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* Start discovery by sending FLOGI, clean up old rpis */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">next_ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span>
					 <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">&amp;</span> <span class="n">NLP_FABRIC</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Clean up the ndlp on Fabric connections */</span>
				<span class="n">lpfc_drop_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>

			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_NPR_ADISC</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Fail outstanding IO now since device</span>
<span class="cm">				 * is marked for PLOGI.</span>
<span class="cm">				 */</span>
				<span class="n">lpfc_unreg_rpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">!=</span> <span class="n">LPFC_FLOGI</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;=</span> <span class="n">LPFC_SLI_REV3</span><span class="p">)</span>
				<span class="n">lpfc_initial_flogi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">lpfc_issue_init_vfi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LPFC_FDISC</span>:
	<span class="k">case</span> <span class="n">LPFC_FLOGI</span>:
	<span class="cm">/* port_state is identically LPFC_FLOGI while waiting for FLOGI cmpl */</span>
		<span class="cm">/* Initial FLOGI timeout */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				 <span class="s">&quot;0222 Initial %s timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">?</span> <span class="s">&quot;FDISC&quot;</span> <span class="o">:</span> <span class="s">&quot;FLOGI&quot;</span><span class="p">);</span>

		<span class="cm">/* Assume no Fabric and go on with discovery.</span>
<span class="cm">		 * Check for outstanding ELS FLOGI to abort.</span>
<span class="cm">		 */</span>

		<span class="cm">/* FLOGI failed, so just use loop map to make discovery list */</span>
		<span class="n">lpfc_disc_list_loopmap</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

		<span class="cm">/* Start discovery */</span>
		<span class="n">lpfc_disc_start</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LPFC_FABRIC_CFG_LINK</span>:
	<span class="cm">/* hba_state is identically LPFC_FABRIC_CFG_LINK while waiting for</span>
<span class="cm">	   NameServer login */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				 <span class="s">&quot;0223 Timeout while waiting for &quot;</span>
				 <span class="s">&quot;NameServer login</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* Next look for NameServer ndlp */</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">NameServer_DID</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
			<span class="n">lpfc_els_abort</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>

		<span class="cm">/* ReStart discovery */</span>
		<span class="k">goto</span> <span class="n">restart_disc</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LPFC_NS_QRY</span>:
	<span class="cm">/* Check for wait for NameServer Rsp timeout */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				 <span class="s">&quot;0224 NameServer Query timeout &quot;</span>
				 <span class="s">&quot;Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_ns_retry</span><span class="p">,</span> <span class="n">LPFC_MAX_NS_RETRY</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_ns_retry</span> <span class="o">&lt;</span> <span class="n">LPFC_MAX_NS_RETRY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Try it one more time */</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_ns_retry</span><span class="o">++</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_ns_cmd</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">SLI_CTNS_GID_FT</span><span class="p">,</span>
					 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_ns_retry</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_ns_retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">restart_disc:</span>
		<span class="cm">/*</span>
<span class="cm">		 * Discovery is over.</span>
<span class="cm">		 * set port_state to PORT_READY if SLI2.</span>
<span class="cm">		 * cmpl_reg_vpi will set port_state to READY for SLI3.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">)</span>
				<span class="n">lpfc_issue_reg_vpi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
			<span class="k">else</span>  <span class="p">{</span>
				<span class="n">lpfc_issue_clear_la</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
				<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_VPORT_READY</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Setup and issue mailbox INITIALIZE LINK command */</span>
		<span class="n">initlinkmbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">initlinkmbox</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
					 <span class="s">&quot;0206 Device Discovery &quot;</span>
					 <span class="s">&quot;completion error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lpfc_linkdown</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="n">lpfc_init_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">initlinkmbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_topology</span><span class="p">,</span>
			       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span><span class="p">);</span>
		<span class="n">initlinkmbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varInitLnk</span><span class="p">.</span><span class="n">lipsr_AL_PA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">initlinkmbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
		<span class="n">initlinkmbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">initlinkmbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
		<span class="n">lpfc_set_loopback_flag</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">initlinkmbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LPFC_DISC_AUTH</span>:
	<span class="cm">/* Node Authentication timeout */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				 <span class="s">&quot;0227 Node Authentication timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">lpfc_disc_flush_list</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * set port_state to PORT_READY if SLI2.</span>
<span class="cm">		 * cmpl_reg_vpi will set port_state to READY for SLI3.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">)</span>
				<span class="n">lpfc_issue_reg_vpi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
			<span class="k">else</span>  <span class="p">{</span>	<span class="cm">/* NPIV Not enabled */</span>
				<span class="n">lpfc_issue_clear_la</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
				<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_VPORT_READY</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LPFC_VPORT_READY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_RSCN_MODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
					 <span class="s">&quot;0231 RSCN timeout Data: x%x &quot;</span>
					 <span class="s">&quot;x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_ns_retry</span><span class="p">,</span> <span class="n">LPFC_MAX_NS_RETRY</span><span class="p">);</span>

			<span class="cm">/* Cleanup any outstanding ELS commands */</span>
			<span class="n">lpfc_els_flush_cmd</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

			<span class="n">lpfc_els_flush_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="n">lpfc_disc_flush_list</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				 <span class="s">&quot;0273 Unexpected discovery timeout, &quot;</span>
				 <span class="s">&quot;vport State x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_CLEAR_LA</span>:
				<span class="cm">/* CLEAR LA timeout */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				 <span class="s">&quot;0228 CLEAR LA timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">clrlaerr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LPFC_LINK_UP</span>:
		<span class="n">lpfc_issue_clear_la</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
		<span class="cm">/* Drop thru */</span>
	<span class="k">case</span> <span class="n">LPFC_LINK_UNKNOWN</span>:
	<span class="k">case</span> <span class="n">LPFC_WARM_START</span>:
	<span class="k">case</span> <span class="n">LPFC_INIT_START</span>:
	<span class="k">case</span> <span class="n">LPFC_INIT_MBX_CMDS</span>:
	<span class="k">case</span> <span class="n">LPFC_LINK_DOWN</span>:
	<span class="k">case</span> <span class="n">LPFC_HBA_ERROR</span>:
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				 <span class="s">&quot;0230 Unexpected timeout, hba link &quot;</span>
				 <span class="s">&quot;state x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">);</span>
		<span class="n">clrlaerr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LPFC_HBA_READY</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clrlaerr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_disc_flush_list</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">extra_ring</span><span class="p">)].</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">fcp_ring</span><span class="p">)].</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">next_ring</span><span class="p">)].</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_VPORT_READY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine handles processing a NameServer REG_LOGIN mailbox</span>
<span class="cm"> * command upon completion. It is setup in the LPFC_MBOXQ</span>
<span class="cm"> * as the completion routine when the command is</span>
<span class="cm"> * handed off to the SLI layer.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_fdmi_reg_login</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span>   <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span>    <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>

	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_RPI_REGISTERED</span><span class="p">;</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">|=</span> <span class="n">NLP_FABRIC</span><span class="p">;</span>
	<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start issuing Fabric-Device Management Interface (FDMI) command to</span>
<span class="cm">	 * 0xfffffa (FDMI well known port) or Delay issuing FDMI command if</span>
<span class="cm">	 * fdmi-on=2 (supporting RPA/hostnmae)</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_fdmi_on</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">lpfc_fdmi_cmd</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">SLI_MGMT_DHBA</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_fdmitmo</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="mi">60</span><span class="p">);</span>

	<span class="cm">/* decrement the node reference count held for this callback</span>
<span class="cm">	 * function.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_filter_by_rpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="o">*</span><span class="n">rpi</span> <span class="o">=</span> <span class="n">param</span><span class="p">;</span>

	<span class="cm">/* check for active node */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span> <span class="o">==</span> <span class="o">*</span><span class="n">rpi</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_filter_by_wwpn</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span>
		      <span class="k">sizeof</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span>
<span class="nf">__lpfc_find_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="n">node_filter</span> <span class="n">filter</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">param</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine looks up the ndlp lists for the given RPI. If rpi found it</span>
<span class="cm"> * returns the node list element pointer else return NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span>
<span class="nf">__lpfc_findnode_rpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">rpi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__lpfc_find_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_filter_by_rpi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rpi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine looks up the ndlp lists for the given WWPN. If WWPN found it</span>
<span class="cm"> * returns the node element list pointer else return NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span>
<span class="nf">lpfc_findnode_wwpn</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_name</span> <span class="o">*</span><span class="n">wwpn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">__lpfc_find_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_filter_by_wwpn</span><span class="p">,</span> <span class="n">wwpn</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine looks up the ndlp lists for the given RPI. If the rpi</span>
<span class="cm"> * is found, the routine returns the node element list pointer else</span>
<span class="cm"> * return NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span>
<span class="nf">lpfc_findnode_rpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">rpi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">__lpfc_findnode_rpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">rpi</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_find_vport_by_vpid - Find a vport on a HBA through vport identifier</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @vpi: the physical host virtual N_Port identifier.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine finds a vport on a HBA (referred by @phba) through a</span>
<span class="cm"> * @vpi. The function walks the HBA&#39;s vport list and returns the address</span>
<span class="cm"> * of the vport with the matching @vpi.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *    NULL - No vport with the matching @vpi found</span>
<span class="cm"> *    Otherwise - Address to the vport with the matching @vpi.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span>
<span class="nf">lpfc_find_vport_by_vpid</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">vpi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The physical ports are always vpi 0 - translate is unnecessary. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vpi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Translate the physical vpi to the logical vpi.  The</span>
<span class="cm">		 * vport stores the logical vpi.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vpi</span> <span class="o">==</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
					 <span class="s">&quot;2936 Could not find Vport mapped &quot;</span>
					 <span class="s">&quot;to vpi %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vpi</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">port_list</span><span class="p">,</span> <span class="n">listentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">vport</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">lpfc_nlp_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
	      <span class="kt">uint32_t</span> <span class="n">did</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span><span class="p">));</span>

	<span class="n">lpfc_initialize_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_listp</span><span class="p">);</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_NODE</span><span class="p">,</span>
		<span class="s">&quot;node init:       did:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This routine releases all resources associated with a specifc NPort&#39;s ndlp</span>
<span class="cm"> * and mempool_free&#39;s the nodelist.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_nlp_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span><span class="p">,</span>
						  <span class="n">kref</span><span class="p">);</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_NODE</span><span class="p">,</span>
		<span class="s">&quot;node release:    did:x%x flg:x%x type:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span><span class="p">);</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
			<span class="s">&quot;0279 lpfc_nlp_release: ndlp:x%p did %x &quot;</span>
			<span class="s">&quot;usgmap:x%x refcnt:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_usg_map</span><span class="p">,</span>
			<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">));</span>

	<span class="cm">/* remove ndlp from action. */</span>
	<span class="n">lpfc_nlp_remove</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>

	<span class="cm">/* clear the ndlp active flag for all release cases */</span>
	<span class="n">phba</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">NLP_CLR_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">lpfc_sli4_free_rpi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>

	<span class="cm">/* free ndlp memory for final ndlp release */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NLP_CHK_FREE_REQ</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">lat_data</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nlp_mem_pool</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This routine bumps the reference count for a ndlp structure to ensure</span>
<span class="cm"> * that one discovery thread won&#39;t free a ndlp while another discovery thread</span>
<span class="cm"> * is using it.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span>
<span class="nf">lpfc_nlp_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_NODE</span><span class="p">,</span>
			<span class="s">&quot;node get:        did:x%x flg:x%x refcnt:x%x&quot;</span><span class="p">,</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span>
			<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">));</span>
		<span class="cm">/* The check of ndlp usage to prevent incrementing the</span>
<span class="cm">		 * ndlp reference count that is in the process of being</span>
<span class="cm">		 * released.</span>
<span class="cm">		 */</span>
		<span class="n">phba</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">||</span> <span class="n">NLP_CHK_FREE_ACK</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
				<span class="s">&quot;0276 lpfc_nlp_get: ndlp:x%p &quot;</span>
				<span class="s">&quot;usgmap:x%x refcnt:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_usg_map</span><span class="p">,</span>
				<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">));</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This routine decrements the reference count for a ndlp structure. If the</span>
<span class="cm"> * count goes to 0, this indicates the the associated nodelist should be</span>
<span class="cm"> * freed. Returning 1 indicates the ndlp resource has been released; on the</span>
<span class="cm"> * other hand, returning 0 indicates the ndlp resource has not been released</span>
<span class="cm"> * yet.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">lpfc_nlp_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_NODE</span><span class="p">,</span>
	<span class="s">&quot;node put:        did:x%x flg:x%x refcnt:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span>
		<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">));</span>
	<span class="n">phba</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Check the ndlp memory free acknowledge flag to avoid the</span>
<span class="cm">	 * possible race condition that kref_put got invoked again</span>
<span class="cm">	 * after previous one has done ndlp memory free.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NLP_CHK_FREE_ACK</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
				<span class="s">&quot;0274 lpfc_nlp_put: ndlp:x%p &quot;</span>
				<span class="s">&quot;usgmap:x%x refcnt:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_usg_map</span><span class="p">,</span>
				<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check the ndlp inactivate log flag to avoid the possible</span>
<span class="cm">	 * race condition that kref_put got invoked again after ndlp</span>
<span class="cm">	 * is already in inactivating state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NLP_CHK_IACT_REQ</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_NODE</span><span class="p">,</span>
				<span class="s">&quot;0275 lpfc_nlp_put: ndlp:x%p &quot;</span>
				<span class="s">&quot;usgmap:x%x refcnt:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_usg_map</span><span class="p">,</span>
				<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* For last put, mark the ndlp usage flags to make sure no</span>
<span class="cm">	 * other kref_get and kref_put on the same ndlp shall get</span>
<span class="cm">	 * in between the process when the final kref_put has been</span>
<span class="cm">	 * invoked on this ndlp.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Indicate ndlp is put to inactive state. */</span>
		<span class="n">NLP_SET_IACT_REQ</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="cm">/* Acknowledge ndlp memory free has been seen. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NLP_CHK_FREE_REQ</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
			<span class="n">NLP_SET_FREE_ACK</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Note, the kref_put returns 1 when decrementing a reference</span>
<span class="cm">	 * count that was 1, it invokes the release callback function,</span>
<span class="cm">	 * but it still left the reference count as 1 (not actually</span>
<span class="cm">	 * performs the last decrementation). Otherwise, it actually</span>
<span class="cm">	 * decrements the reference count and returns 0.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">lpfc_nlp_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This routine free&#39;s the specified nodelist if it is not in use</span>
<span class="cm"> * by any other discovery thread. This routine returns 1 if the</span>
<span class="cm"> * ndlp has been freed. A return value of 0 indicates the ndlp is</span>
<span class="cm"> * not yet been released.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">lpfc_nlp_not_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_NODE</span><span class="p">,</span>
		<span class="s">&quot;node not used:   did:x%x flg:x%x refcnt:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span>
		<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fcf_inuse - Check if FCF can be unregistered.</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function iterate through all FC nodes associated</span>
<span class="cm"> * will all vports to check if there is any node with</span>
<span class="cm"> * fc_rports associated with it. If there is an fc_rport</span>
<span class="cm"> * associated with the node, then the node is either in</span>
<span class="cm"> * discovered state or its devloss_timer is pending.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_fcf_inuse</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span><span class="p">;</span>

	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* If driver cannot allocate memory, indicate fcf is in use */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vports</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * IF the CVL_RCVD bit is not set then we have sent the</span>
<span class="cm">		 * flogi.</span>
<span class="cm">		 * If dev_loss fires while we are waiting we do not want to</span>
<span class="cm">		 * unreg the fcf.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_VPORT_CVL_RCVD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span>  <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">&amp;&amp;</span>
			  <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">&amp;</span> <span class="n">FC_RPORT_ROLE_FCP_TARGET</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_RPI_REGISTERED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
						<span class="s">&quot;2624 RPI %x DID %x flag %x &quot;</span>
						<span class="s">&quot;still logged in</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span>
						<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_unregister_vfi_cmpl - Completion handler for unreg vfi.</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> * @mboxq: Pointer to mailbox object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function frees memory associated with the mailbox command.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_unregister_vfi_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="o">|</span><span class="n">LOG_MBOX</span><span class="p">,</span>
			<span class="s">&quot;2555 UNREG_VFI mbxStatus error x%x &quot;</span>
			<span class="s">&quot;HBA state x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VFI_REGISTERED</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_unregister_fcfi_cmpl - Completion handler for unreg fcfi.</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> * @mboxq: Pointer to mailbox object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function frees memory associated with the mailbox command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_unregister_fcfi_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="o">|</span><span class="n">LOG_MBOX</span><span class="p">,</span>
			<span class="s">&quot;2550 UNREG_FCFI mbxStatus error x%x &quot;</span>
			<span class="s">&quot;HBA state x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_unregister_fcf_prep - Unregister fcf record preparation</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function prepare the HBA for unregistering the currently registered</span>
<span class="cm"> * FCF from the HBA. It performs unregistering, in order, RPIs, VPIs, and</span>
<span class="cm"> * VFIs.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">lpfc_unregister_fcf_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Unregister RPIs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_fcf_inuse</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
		<span class="n">lpfc_unreg_hba_rpis</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* At this point, all discovery is aborted */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_VPORT_UNKNOWN</span><span class="p">;</span>

	<span class="cm">/* Unregister VPIs */</span>
	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">))</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Stop FLOGI/FDISC retries */</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Fabric_DID</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="p">)</span>
				<span class="n">lpfc_cancel_retry_delay_tmo</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ndlp</span><span class="p">);</span>
			<span class="n">lpfc_cleanup_pending_mbox</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
				<span class="n">lpfc_sli4_unreg_all_rpis</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">lpfc_mbx_unreg_vpi</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VPORT_NEEDS_INIT_VPI</span><span class="p">;</span>
			<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">vpi_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_VPI_REGISTERED</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>

	<span class="cm">/* Cleanup any outstanding ELS commands */</span>
	<span class="n">lpfc_els_flush_all_cmd</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Unregister the physical port VFI */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_issue_unreg_vfi</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_unregister_fcf - Unregister currently registered FCF record</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function issues synchronous unregister FCF mailbox command to HBA to</span>
<span class="cm"> * unregister the currently registered FCF record. The driver does not reset</span>
<span class="cm"> * the driver FCF usage state flags.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successfully issued, none-zero otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_unregister_fcf</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="o">|</span><span class="n">LOG_MBOX</span><span class="p">,</span>
				<span class="s">&quot;2551 UNREG_FCFI mbox allocation failed&quot;</span>
				<span class="s">&quot;HBA state x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_unreg_fcfi</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcfi</span><span class="p">);</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_unregister_fcfi_cmpl</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2552 Unregister FCFI command failed rc x%x &quot;</span>
				<span class="s">&quot;HBA state x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rc</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_unregister_fcf_rescan - Unregister currently registered fcf and rescan</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function unregisters the currently reigstered FCF. This function</span>
<span class="cm"> * also tries to find another FCF for discovery by rescan the HBA FCF table.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_unregister_fcf_rescan</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Preparation for unregistering fcf */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_unregister_fcf_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				<span class="s">&quot;2748 Failed to prepare for unregistering &quot;</span>
				<span class="s">&quot;HBA&#39;s FCF record: rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now, unregister FCF record and reset HBA FCF state */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_unregister_fcf</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* Reset HBA FCF states after successful unregister FCF */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If driver is not unloading, check if there is any other</span>
<span class="cm">	 * FCF record that can be used for discovery.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&lt;</span> <span class="n">LPFC_LINK_UP</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* This is considered as the initial FCF discovery scan */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">|=</span> <span class="n">FCF_INIT_DISC</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Reset FCF roundrobin bmask for new discovery */</span>
	<span class="n">lpfc_sli4_clear_fcf_rr_bmask</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_scan_read_fcf_rec</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_FCOE_FCF_GET_FIRST</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_INIT_DISC</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="o">|</span><span class="n">LOG_MBOX</span><span class="p">,</span>
				<span class="s">&quot;2553 lpfc_unregister_unused_fcf failed &quot;</span>
				<span class="s">&quot;to read FCF record HBA state x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_unregister_fcf - Unregister the currently registered fcf record</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function just unregisters the currently reigstered FCF. It does not</span>
<span class="cm"> * try to find another FCF for discovery.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_unregister_fcf</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Preparation for unregistering fcf */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_unregister_fcf_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				<span class="s">&quot;2749 Failed to prepare for unregistering &quot;</span>
				<span class="s">&quot;HBA&#39;s FCF record: rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now, unregister FCF record and reset HBA FCF state */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_unregister_fcf</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* Set proper HBA FCF states after successful unregister FCF */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_REGISTERED</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_unregister_unused_fcf - Unregister FCF if all devices are disconnected.</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function check if there are any connected remote port for the FCF and</span>
<span class="cm"> * if all the devices are disconnected, this function unregister FCFI.</span>
<span class="cm"> * This function also tries to use another FCF for discovery.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_unregister_unused_fcf</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If HBA is not running in FIP mode, if HBA does not support</span>
<span class="cm">	 * FCoE, if FCF discovery is ongoing, or if FCF has not been</span>
<span class="cm">	 * registered, do nothing.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FCOE_MODE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REGISTERED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FIP_SUPPORT</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_DISCOVERY</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">LPFC_FLOGI</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_fcf_inuse</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">lpfc_unregister_fcf_rescan</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_read_fcf_conn_tbl - Create driver FCF connection table.</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> * @buff: Buffer containing the FCF connection table as in the config</span>
<span class="cm"> *         region.</span>
<span class="cm"> * This function create driver data structure for the FCF connection</span>
<span class="cm"> * record table read from config region 23.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_read_fcf_conn_tbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_conn_entry</span> <span class="o">*</span><span class="n">conn_entry</span><span class="p">,</span> <span class="o">*</span><span class="n">next_conn_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_conn_hdr</span> <span class="o">*</span><span class="n">conn_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_conn_rec</span> <span class="o">*</span><span class="n">conn_rec</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">record_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Free the current connect table */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">conn_entry</span><span class="p">,</span> <span class="n">next_conn_entry</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf_conn_rec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">conn_entry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">conn_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fcf_conn_hdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">buff</span><span class="p">;</span>
	<span class="n">record_count</span> <span class="o">=</span> <span class="n">conn_hdr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="o">/</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fcf_conn_rec</span><span class="p">);</span>

	<span class="n">conn_rec</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fcf_conn_rec</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">(</span><span class="n">buff</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fcf_conn_hdr</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">record_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">conn_rec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCFCNCT_VALID</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">conn_entry</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fcf_conn_entry</span><span class="p">),</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">conn_entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2566 Failed to allocate connection&quot;</span>
				<span class="s">&quot; table entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn_rec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fcf_conn_rec</span><span class="p">));</span>
		<span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">vlan_tag</span> <span class="o">=</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">vlan_tag</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">;</span>
		<span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">conn_rec</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf_conn_rec_list</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_read_fcoe_param - Read FCoe parameters from conf region..</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> * @buff: Buffer containing the FCoE parameter data structure.</span>
<span class="cm"> *</span>
<span class="cm"> *  This function update driver data structure with config</span>
<span class="cm"> *  parameters read from config region 23.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_read_fcoe_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_fip_param_hdr</span> <span class="o">*</span><span class="n">fcoe_param_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fcoe_params</span> <span class="o">*</span><span class="n">fcoe_param</span><span class="p">;</span>

	<span class="n">fcoe_param_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fip_param_hdr</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">buff</span><span class="p">;</span>
	<span class="n">fcoe_param</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fcoe_params</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">(</span><span class="n">buff</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fip_param_hdr</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fcoe_param_hdr</span><span class="o">-&gt;</span><span class="n">parm_version</span> <span class="o">!=</span> <span class="n">FIPP_VERSION</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">fcoe_param_hdr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">!=</span> <span class="n">FCOE_PARAM_LENGTH</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fcoe_param_hdr</span><span class="o">-&gt;</span><span class="n">parm_flags</span> <span class="o">&amp;</span> <span class="n">FIPP_VLAN_VALID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">valid_vlan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vlan_id</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">fcoe_param</span><span class="o">-&gt;</span><span class="n">vlan_tag</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="mh">0xFFF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcoe_param</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcoe_param</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcoe_param</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_rec_conf23 - Get a record type in config region data.</span>
<span class="cm"> * @buff: Buffer containing config region 23 data.</span>
<span class="cm"> * @size: Size of the data buffer.</span>
<span class="cm"> * @rec_type: Record type to be searched.</span>
<span class="cm"> *</span>
<span class="cm"> * This function searches config region data to find the beginning</span>
<span class="cm"> * of the record specified by record_type. If record found, this</span>
<span class="cm"> * function return pointer to the record else return NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="o">*</span>
<span class="nf">lpfc_get_rec_conf23</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">rec_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rec_length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">LPFC_REGION23_LAST_REC</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rec_length</span> <span class="o">=</span> <span class="n">buff</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * One TLV record has one word header and number of data words</span>
<span class="cm">	 * specified in the rec_length field of the record header.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">rec_length</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">))</span>
		<span class="o">&lt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">==</span> <span class="n">rec_type</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">buff</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">==</span> <span class="n">LPFC_REGION23_LAST_REC</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">+=</span> <span class="n">rec_length</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
		<span class="n">rec_length</span> <span class="o">=</span> <span class="n">buff</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_parse_fcoe_conf - Parse FCoE config data read from config region 23.</span>
<span class="cm"> * @phba: Pointer to lpfc_hba data structure.</span>
<span class="cm"> * @buff: Buffer containing config region 23 data.</span>
<span class="cm"> * @size: Size of the data buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function parses the FCoE config parameters in config region 23 and</span>
<span class="cm"> * populate driver data structure with the parameters.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_parse_fcoe_conf</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span>
		<span class="kt">uint32_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rec_length</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">rec_ptr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If data size is less than 2 words signature and version cannot be</span>
<span class="cm">	 * verified.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Check the region signature first */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">LPFC_REGION23_SIGNATURE</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2567 Config region 23 has bad signature</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* Check the data structure version */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">!=</span> <span class="n">LPFC_REGION23_VERSION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2568 Config region 23 has bad version</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">offset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">rec_length</span> <span class="o">=</span> <span class="n">buff</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* Read FCoE param record */</span>
	<span class="n">rec_ptr</span> <span class="o">=</span> <span class="n">lpfc_get_rec_conf23</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buff</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span>
			<span class="n">size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">FCOE_PARAM_TYPE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rec_ptr</span><span class="p">)</span>
		<span class="n">lpfc_read_fcoe_param</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rec_ptr</span><span class="p">);</span>

	<span class="cm">/* Read FCF connection table */</span>
	<span class="n">rec_ptr</span> <span class="o">=</span> <span class="n">lpfc_get_rec_conf23</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buff</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span>
		<span class="n">size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">FCOE_CONN_TBL_TYPE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rec_ptr</span><span class="p">)</span>
		<span class="n">lpfc_read_fcf_conn_tbl</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rec_ptr</span><span class="p">);</span>

<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
