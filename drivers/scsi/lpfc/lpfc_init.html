<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › lpfc › lpfc_init.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>lpfc_init.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************</span>
<span class="cm"> * This file is part of the Emulex Linux Device Driver for         *</span>
<span class="cm"> * Fibre Channel Host Bus Adapters.                                *</span>
<span class="cm"> * Copyright (C) 2004-2012 Emulex.  All rights reserved.           *</span>
<span class="cm"> * EMULEX and SLI are trademarks of Emulex.                        *</span>
<span class="cm"> * www.emulex.com                                                  *</span>
<span class="cm"> * Portions Copyright (C) 2004-2005 Christoph Hellwig              *</span>
<span class="cm"> *                                                                 *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or   *</span>
<span class="cm"> * modify it under the terms of version 2 of the GNU General       *</span>
<span class="cm"> * Public License as published by the Free Software Foundation.    *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful. *</span>
<span class="cm"> * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *</span>
<span class="cm"> * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *</span>
<span class="cm"> * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *</span>
<span class="cm"> * TO BE LEGALLY INVALID.  See the GNU General Public License for  *</span>
<span class="cm"> * more details, a copy of which can be found in the file COPYING  *</span>
<span class="cm"> * included with this package.                                     *</span>
<span class="cm"> *******************************************************************/</span>

<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/aer.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_fc.h&gt;</span>

<span class="cp">#include &quot;lpfc_hw4.h&quot;</span>
<span class="cp">#include &quot;lpfc_hw.h&quot;</span>
<span class="cp">#include &quot;lpfc_sli.h&quot;</span>
<span class="cp">#include &quot;lpfc_sli4.h&quot;</span>
<span class="cp">#include &quot;lpfc_nl.h&quot;</span>
<span class="cp">#include &quot;lpfc_disc.h&quot;</span>
<span class="cp">#include &quot;lpfc_scsi.h&quot;</span>
<span class="cp">#include &quot;lpfc.h&quot;</span>
<span class="cp">#include &quot;lpfc_logmsg.h&quot;</span>
<span class="cp">#include &quot;lpfc_crtn.h&quot;</span>
<span class="cp">#include &quot;lpfc_vport.h&quot;</span>
<span class="cp">#include &quot;lpfc_version.h&quot;</span>

<span class="kt">char</span> <span class="o">*</span><span class="n">_dump_buf_data</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_dump_buf_data_order</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">_dump_buf_dif</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_dump_buf_dif_order</span><span class="p">;</span>
<span class="n">spinlock_t</span> <span class="n">_dump_buf_lock</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">lpfc_get_hba_model_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_post_rcv_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_sli4_queue_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_create_bootstrap_mbox</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_setup_endian_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lpfc_destroy_bootstrap_mbox</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lpfc_free_els_sgl_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lpfc_init_sgl_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_init_active_sgl_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lpfc_free_active_sgl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_hba_down_post_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_hba_down_post_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_sli4_cq_event_pool_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lpfc_sli4_cq_event_pool_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lpfc_sli4_cq_event_release_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span><span class="n">lpfc_transport_template</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span><span class="n">lpfc_vport_transport_template</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_IDR</span><span class="p">(</span><span class="n">lpfc_hba_index</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_config_port_prep - Perform lpfc initialization prior to config port</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will do LPFC initialization prior to issuing the CONFIG_PORT</span>
<span class="cm"> * mailbox command. It retrieves the revision information from the HBA and</span>
<span class="cm"> * collects the Vital Product Data (VPD) about the HBA for preparing the</span>
<span class="cm"> * configuration of the HBA.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *   0 - success.</span>
<span class="cm"> *   -ERESTART - requests the SLI layer to reset the HBA and try again.</span>
<span class="cm"> *   Any other value - indicates an error.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_config_port_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_vpd_t</span> <span class="o">*</span><span class="n">vp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">lpfc_vpd_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">licensed</span><span class="p">[</span><span class="mi">56</span><span class="p">]</span> <span class="o">=</span>
		    <span class="s">&quot;key unlock for use with gnu public licensed code only</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">init_key</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pmb</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_INIT_MBX_CMDS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_is_LC_HBA</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">init_key</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">ptext</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">licensed</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">56</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">),</span> <span class="n">ptext</span><span class="o">++</span><span class="p">)</span>
				<span class="o">*</span><span class="n">ptext</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="o">*</span><span class="n">ptext</span><span class="p">);</span>
			<span class="n">init_key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lpfc_read_nv</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRDnvp</span><span class="p">.</span><span class="n">rsvd3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="k">sizeof</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRDnvp</span><span class="p">.</span><span class="n">rsvd3</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRDnvp</span><span class="p">.</span><span class="n">rsvd3</span><span class="p">,</span> <span class="n">licensed</span><span class="p">,</span>
			 <span class="k">sizeof</span> <span class="p">(</span><span class="n">licensed</span><span class="p">));</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
					<span class="s">&quot;0324 Config Port initialization &quot;</span>
					<span class="s">&quot;error, mbxCmd x%x READ_NVPARM, &quot;</span>
					<span class="s">&quot;mbxStatus x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">);</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERESTART</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">wwnn</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRDnvp</span><span class="p">.</span><span class="n">nodename</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">wwnn</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">wwpn</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRDnvp</span><span class="p">.</span><span class="n">portname</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">wwpn</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="cm">/* Setup and issue mailbox READ REV command */</span>
	<span class="n">lpfc_read_rev</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0439 Adapter failed to init, mbxCmd x%x &quot;</span>
				<span class="s">&quot;READ_REV, mbxStatus x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERESTART</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/*</span>
<span class="cm">	 * The value of rr must be 1 since the driver set the cv field to 1.</span>
<span class="cm">	 * This setting requires the FW to set all revision fields.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">rr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">rBit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0440 Adapter failed to init, READ_REV has &quot;</span>
				<span class="s">&quot;missing revision information.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERESTART</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">v3rsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Save information as VPD data */</span>
	<span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">rBit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">sli3Feat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">sli3Feat</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
	<span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">sli1FwRev</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">sli1FwRev</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">sli1FwName</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">sli1FwName</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">sli2FwRev</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">sli2FwRev</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">sli2FwName</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">sli2FwName</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">biuRev</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">biuRev</span><span class="p">;</span>
	<span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">smRev</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">smRev</span><span class="p">;</span>
	<span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">smFwRev</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">smFwRev</span><span class="p">;</span>
	<span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">endecRev</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">endecRev</span><span class="p">;</span>
	<span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">fcphHigh</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">fcphHigh</span><span class="p">;</span>
	<span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">fcphLow</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">fcphLow</span><span class="p">;</span>
	<span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">feaLevelHigh</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">feaLevelHigh</span><span class="p">;</span>
	<span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">feaLevelLow</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">feaLevelLow</span><span class="p">;</span>
	<span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">postKernRev</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">postKernRev</span><span class="p">;</span>
	<span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">opFwRev</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdRev</span><span class="p">.</span><span class="n">opFwRev</span><span class="p">;</span>

	<span class="cm">/* If the sli feature level is less then 9, we must</span>
<span class="cm">	 * tear down all RPIs and VPIs on link down if NPIV</span>
<span class="cm">	 * is enabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">feaLevelHigh</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">|=</span> <span class="n">LPFC_SLI3_VPORT_TEARDOWN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_is_LC_HBA</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">))</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">RandomData</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">24</span><span class="p">],</span>
						<span class="k">sizeof</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">RandomData</span><span class="p">));</span>

	<span class="cm">/* Get adapter VPD information */</span>
	<span class="n">lpfc_vpd_data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">DMP_VPD_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_vpd_data</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">lpfc_dump_mem</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">DMP_REGION_VPD</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0441 VPD not present on adapter, &quot;</span>
					<span class="s">&quot;mbxCmd x%x DUMP VPD, mbxStatus x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">);</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* dump mem may return a zero when finished or we got a</span>
<span class="cm">		 * mailbox error, either way we are done.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span> <span class="o">&gt;</span> <span class="n">DMP_VPD_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span> <span class="o">=</span> <span class="n">DMP_VPD_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mb</span><span class="p">)</span> <span class="o">+</span> <span class="n">DMP_RSP_OFFSET</span><span class="p">,</span>
				      <span class="n">lpfc_vpd_data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
				      <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span> <span class="o">&amp;&amp;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">DMP_VPD_SIZE</span><span class="p">);</span>
	<span class="n">lpfc_parse_vpd</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_vpd_data</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">lpfc_vpd_data</span><span class="p">);</span>
<span class="nl">out_free_mbox:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_config_async_cmpl - Completion handler for config async event mbox cmd</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @pmboxq: pointer to the driver internal queue element for mailbox command.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the completion handler for driver&#39;s configuring asynchronous event</span>
<span class="cm"> * mailbox command to the device. If the mailbox command returns successfully,</span>
<span class="cm"> * it will set internal async event support flag to 1; otherwise, it will</span>
<span class="cm"> * set internal async event support flag to 0.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_config_async_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span> <span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span> <span class="n">pmboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span> <span class="o">==</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">temp_sensor_support</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">temp_sensor_support</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_dump_wakeup_param_cmpl - dump memory mailbox command completion handler</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @pmboxq: pointer to the driver internal queue element for mailbox command.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the completion handler for dump mailbox command for getting</span>
<span class="cm"> * wake up parameters. When this command complete, the response contain</span>
<span class="cm"> * Option rom version of the HBA. This function translate the version number</span>
<span class="cm"> * into a human readable string and store it in OptionROMVersion.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_dump_wakeup_param_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">prog_id</span> <span class="o">*</span><span class="n">prg</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">prog_id_word</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">dist</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
	<span class="cm">/* character array used for decoding dist type. */</span>
	<span class="kt">char</span> <span class="n">dist_char</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;nabx&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">prg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">prog_id</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">prog_id_word</span><span class="p">;</span>

	<span class="cm">/* word 7 contain option rom version */</span>
	<span class="n">prog_id_word</span> <span class="o">=</span> <span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>

	<span class="cm">/* Decode the Option rom version word to a readable string */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prg</span><span class="o">-&gt;</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">dist</span> <span class="o">=</span> <span class="n">dist_char</span><span class="p">[</span><span class="n">prg</span><span class="o">-&gt;</span><span class="n">dist</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">prg</span><span class="o">-&gt;</span><span class="n">dist</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prg</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">OptionROMVersion</span><span class="p">,</span> <span class="s">&quot;%d.%d%d&quot;</span><span class="p">,</span>
			<span class="n">prg</span><span class="o">-&gt;</span><span class="n">ver</span><span class="p">,</span> <span class="n">prg</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">,</span> <span class="n">prg</span><span class="o">-&gt;</span><span class="n">lev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">OptionROMVersion</span><span class="p">,</span> <span class="s">&quot;%d.%d%d%c%d&quot;</span><span class="p">,</span>
			<span class="n">prg</span><span class="o">-&gt;</span><span class="n">ver</span><span class="p">,</span> <span class="n">prg</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">,</span> <span class="n">prg</span><span class="o">-&gt;</span><span class="n">lev</span><span class="p">,</span>
			<span class="n">dist</span><span class="p">,</span> <span class="n">prg</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_update_vport_wwn - Updates the fc_nodename, fc_portname,</span>
<span class="cm"> *	cfg_soft_wwnn, cfg_soft_wwpn</span>
<span class="cm"> * @vport: pointer to lpfc vport data structure.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   None.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_update_vport_wwn</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If the soft name exists then update it using the service params */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwnn</span><span class="p">)</span>
		<span class="n">u64_to_wwn</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwnn</span><span class="p">,</span>
			   <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">.</span><span class="n">nodeName</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwpn</span><span class="p">)</span>
		<span class="n">u64_to_wwn</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwpn</span><span class="p">,</span>
			   <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">.</span><span class="n">portName</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the name is empty or there exists a soft name</span>
<span class="cm">	 * then copy the service params name, otherwise use the fc name</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwnn</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">.</span><span class="n">nodeName</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">.</span><span class="n">nodeName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwpn</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">.</span><span class="n">portName</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">.</span><span class="n">portName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_config_port_post - Perform lpfc initialization after config port</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will do LPFC initialization after the CONFIG_PORT mailbox</span>
<span class="cm"> * command call. It performs all internal resource and state setups on the</span>
<span class="cm"> * port: post IOCB buffers, enable appropriate host interrupt attentions,</span>
<span class="cm"> * ELS ring timers, etc.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - success.</span>
<span class="cm"> *   Any other value - error.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_config_port_post</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">,</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the Config port completed correctly the HBA is not</span>
<span class="cm">	 * over heated any more.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">over_temp_state</span> <span class="o">==</span> <span class="n">HBA_OVER_TEMP</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">over_temp_state</span> <span class="o">=</span> <span class="n">HBA_NORMAL_TEMP</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">pmb</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>

	<span class="cm">/* Get login parameters for NID.  */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_read_sparam</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0448 Adapter failed init, mbxCmd x%x &quot;</span>
				<span class="s">&quot;READ_SPARM mbxStatus x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span><span class="p">));</span>
	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lpfc_update_vport_wwn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/* Update the fc_host data structures with new wwn. */</span>
	<span class="n">fc_host_node_name</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">);</span>
	<span class="n">fc_host_port_name</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">);</span>
	<span class="n">fc_host_max_npiv_vports</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span><span class="p">;</span>

	<span class="cm">/* If no serial number in VPD data, use low 6 bytes of WWNN */</span>
	<span class="cm">/* This should be consolidated into parse_vpd ? - mr */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">SerialNumber</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">outptr</span><span class="p">;</span>

		<span class="n">outptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">IEEE</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">*</span><span class="n">outptr</span><span class="o">++</span><span class="p">;</span>
			<span class="n">j</span> <span class="o">=</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">)</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">SerialNumber</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				    <span class="p">(</span><span class="kt">char</span><span class="p">)((</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="mh">0x30</span> <span class="o">+</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="n">j</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">SerialNumber</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				    <span class="p">(</span><span class="kt">char</span><span class="p">)((</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="mh">0x61</span> <span class="o">+</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">10</span><span class="p">));</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">)</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">SerialNumber</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				    <span class="p">(</span><span class="kt">char</span><span class="p">)((</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="mh">0x30</span> <span class="o">+</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="n">j</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">SerialNumber</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				    <span class="p">(</span><span class="kt">char</span><span class="p">)((</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="mh">0x61</span> <span class="o">+</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">10</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">lpfc_read_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0453 Adapter failed to init, mbxCmd x%x &quot;</span>
				<span class="s">&quot;READ_CONFIG, mbxStatus x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="n">mempool_free</span><span class="p">(</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if the port is disabled */</span>
	<span class="n">lpfc_sli_read_link_ste</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Reset the DFT_HBA_Q_DEPTH to the max xri  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_hba_queue_depth</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdConfig</span><span class="p">.</span><span class="n">max_xri</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_hba_queue_depth</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdConfig</span><span class="p">.</span><span class="n">max_xri</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
					<span class="n">lpfc_sli4_get_els_iocb_cnt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdConfig</span><span class="p">.</span><span class="n">lmt</span><span class="p">;</span>

	<span class="cm">/* Get the default values for Model Name and Description */</span>
	<span class="n">lpfc_get_hba_model_desc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelName</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelDesc</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">;</span>

	<span class="cm">/* Only process IOCBs on ELS ring till hba_state is READY */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">extra_ring</span><span class="p">].</span><span class="n">cmdringaddr</span><span class="p">)</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">extra_ring</span><span class="p">].</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">fcp_ring</span><span class="p">].</span><span class="n">cmdringaddr</span><span class="p">)</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">fcp_ring</span><span class="p">].</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">next_ring</span><span class="p">].</span><span class="n">cmdringaddr</span><span class="p">)</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">next_ring</span><span class="p">].</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>

	<span class="cm">/* Post receive buffers for desired rings */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">lpfc_post_rcv_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Configure HBA MSI-X attention conditions to messages if MSI-X mode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">MSIX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_config_msi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
					<span class="s">&quot;0352 Config MSI mailbox command &quot;</span>
					<span class="s">&quot;failed, mbxCmd x%x, mbxStatus x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span>
					<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">);</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/* Initialize ERATT handling flag */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HBA_ERATT_HANDLED</span><span class="p">;</span>

	<span class="cm">/* Enable appropriate host interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">|=</span> <span class="n">HC_MBINT_ENA</span> <span class="o">|</span> <span class="n">HC_ERINT_ENA</span> <span class="o">|</span> <span class="n">HC_LAINT_ENA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="n">HC_R0INT_ENA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="n">HC_R1INT_ENA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="n">HC_R2INT_ENA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="n">HC_R3INT_ENA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">&amp;</span> <span class="n">ENABLE_FCP_RING_POLLING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">&amp;</span> <span class="n">DISABLE_FCP_RING_INT</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">HC_R0INT_ENA</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Set up ring-0 (ELS) timer */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">els_tmofunc</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">timeout</span><span class="p">);</span>
	<span class="cm">/* Set up heart beat (HB) timer */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">LPFC_HB_MBOX_INTERVAL</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_outstanding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="cm">/* Set up error attention (ERATT) polling timer */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">eratt_poll</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">LPFC_ERATT_POLL_INTERVAL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">LINK_DISABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
			<span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2598 Adapter Link is disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">lpfc_down_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
		<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_BUSY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
			<span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2599 Adapter failed to issue DOWN_LINK&quot;</span>
			<span class="s">&quot; mbox command rc 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

			<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_suppress_link_up</span> <span class="o">==</span> <span class="n">LPFC_INITIALIZE_LINK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_hba_init_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* MBOX buffer will be freed in mbox compl */</span>
	<span class="n">pmb</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_config_async</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">);</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_config_async_cmpl</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_BUSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
				<span class="n">KERN_ERR</span><span class="p">,</span>
				<span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0456 Adapter failed to issue &quot;</span>
				<span class="s">&quot;ASYNCEVT_ENABLE mbox status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rc</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Get Option rom version */</span>
	<span class="n">pmb</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_dump_wakeup_param</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_dump_wakeup_param_cmpl</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_BUSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span> <span class="s">&quot;0435 Adapter failed &quot;</span>
				<span class="s">&quot;to get Option ROM version status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hba_init_link - Initialize the FC link</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @flag: mailbox command issue mode - either MBX_POLL or MBX_NOWAIT</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will issue the INIT_LINK mailbox command call.</span>
<span class="cm"> * It is available to other drivers through the lpfc_hba data</span>
<span class="cm"> * structure for use as a delayed link up mechanism with the</span>
<span class="cm"> * module parameter lpfc_suppress_link_up.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *		0 - success</span>
<span class="cm"> *		Any other value - error</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_hba_init_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">lpfc_hba_init_link_fc_topology</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_topology</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hba_init_link_fc_topology - Initialize FC link with desired topology</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fc_topology: desired fc topology.</span>
<span class="cm"> * @flag: mailbox command issue mode - either MBX_POLL or MBX_NOWAIT</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will issue the INIT_LINK mailbox command call.</span>
<span class="cm"> * It is available to other drivers through the lpfc_hba data</span>
<span class="cm"> * structure for use as a delayed link up mechanism with the</span>
<span class="cm"> * module parameter lpfc_suppress_link_up.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *              0 - success</span>
<span class="cm"> *              Any other value - error</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_hba_init_link_fc_topology</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">fc_topology</span><span class="p">,</span>
			       <span class="kt">uint32_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">pmb</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span> <span class="o">&gt;</span> <span class="n">LPFC_USER_LINK_SPEED_MAX</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_1G</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_1Gb</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_2G</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_2Gb</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_4G</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_4Gb</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_8G</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_8Gb</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_10G</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_10Gb</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_16G</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_16Gb</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Reset link speed to auto */</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_LINK_EVENT</span><span class="p">,</span>
			<span class="s">&quot;1302 Invalid speed for this board:%d &quot;</span>
			<span class="s">&quot;Reset link speed to auto.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span> <span class="o">=</span> <span class="n">LPFC_USER_LINK_SPEED_AUTO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_init_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">fc_topology</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span><span class="p">);</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">lpfc_set_loopback_flag</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_BUSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0498 Adapter failed to init, mbxCmd x%x &quot;</span>
			<span class="s">&quot;INIT_LINK, mbxStatus x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;=</span> <span class="n">LPFC_SLI_REV3</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Clear all interrupt enable conditions */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
			<span class="cm">/* Clear all pending interrupts */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
		<span class="p">}</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_BUSY</span> <span class="o">||</span> <span class="n">flag</span> <span class="o">==</span> <span class="n">MBX_POLL</span><span class="p">)</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_suppress_link_up</span> <span class="o">=</span> <span class="n">LPFC_INITIALIZE_LINK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">MBX_POLL</span><span class="p">)</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hba_down_link - this routine downs the FC link</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @flag: mailbox command issue mode - either MBX_POLL or MBX_NOWAIT</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will issue the DOWN_LINK mailbox command call.</span>
<span class="cm"> * It is available to other drivers through the lpfc_hba data</span>
<span class="cm"> * structure for use to stop the link.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *		0 - success</span>
<span class="cm"> *		Any other value - error</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_hba_down_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">pmb</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
		<span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
		<span class="s">&quot;0491 Adapter Link is disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">lpfc_down_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_BUSY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
		<span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
		<span class="s">&quot;2522 Adapter failed to issue DOWN_LINK&quot;</span>
		<span class="s">&quot; mbox command rc 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">MBX_POLL</span><span class="p">)</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hba_down_prep - Perform lpfc uninitialization prior to HBA reset</span>
<span class="cm"> * @phba: pointer to lpfc HBA data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will do LPFC uninitialization before the HBA is reset when</span>
<span class="cm"> * bringing down the SLI Layer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - success.</span>
<span class="cm"> *   Any other value - error.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_hba_down_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;=</span> <span class="n">LPFC_SLI_REV3</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Disable interrupts */</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span>
		<span class="n">lpfc_cleanup_discovery_resources</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span>
				<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">lpfc_cleanup_discovery_resources</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hba_down_post_s3 - Perform lpfc uninitialization after HBA reset</span>
<span class="cm"> * @phba: pointer to lpfc HBA data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will do uninitialization after the HBA is reset when bring</span>
<span class="cm"> * down the SLI Layer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - success.</span>
<span class="cm"> *   Any other value - error.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_hba_down_post_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="o">*</span><span class="n">next_mp</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_HBQ_ENABLED</span><span class="p">)</span>
		<span class="n">lpfc_sli_hbqbuf_free_all</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Cleanup preposted buffers on the ELS ring */</span>
		<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">next_mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">postbufq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">postbufq_cnt</span><span class="o">--</span><span class="p">;</span>
			<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/* At this point in time the HBA is either reset or DOA. Either</span>
<span class="cm">		 * way, nothing should be on txcmplq as it will NEVER complete.</span>
<span class="cm">		 */</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

		<span class="cm">/* Cancel all the IOCBs from the completions list */</span>
		<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
				      <span class="n">IOERR_SLI_ABORTED</span><span class="p">);</span>

		<span class="n">lpfc_sli_abort_iocb_ring</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hba_down_post_s4 - Perform lpfc uninitialization after HBA reset</span>
<span class="cm"> * @phba: pointer to lpfc HBA data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will do uninitialization after the HBA is reset when bring</span>
<span class="cm"> * down the SLI Layer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - success.</span>
<span class="cm"> *   Any other value - error.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_hba_down_post_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">psb</span><span class="p">,</span> <span class="o">*</span><span class="n">psb_next</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">aborts</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">lpfc_hba_down_post_s3</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* At this point in time the HBA is either reset or DOA. Either</span>
<span class="cm">	 * way, nothing should be on lpfc_abts_els_sgl_list, it needs to be</span>
<span class="cm">	 * on the lpfc_sgl_list so that it can either be freed if the</span>
<span class="cm">	 * driver is unloading or reposted if the driver is restarting</span>
<span class="cm">	 * the port.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>  <span class="cm">/* required for lpfc_sgl_list and */</span>
					<span class="cm">/* scsl_buf_list */</span>
	<span class="cm">/* abts_sgl_list_lock required because worker thread uses this</span>
<span class="cm">	 * list.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_sgl_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sglq_entry</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_els_sgl_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SGL_FREED</span><span class="p">;</span>

	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_els_sgl_list</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sgl_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_sgl_list_lock</span><span class="p">);</span>
	<span class="cm">/* abts_scsi_buf_list_lock required because worker thread uses this</span>
<span class="cm">	 * list.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_scsi_buf_list_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_scsi_buf_list</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">aborts</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_scsi_buf_list_lock</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">psb</span><span class="p">,</span> <span class="n">psb_next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aborts</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">pCmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">IOSTAT_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aborts</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_buf_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hba_down_post - Wrapper func for hba down post routine</span>
<span class="cm"> * @phba: pointer to lpfc HBA data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine wraps the actual SLI3 or SLI4 routine for performing</span>
<span class="cm"> * uninitialization after the HBA is reset when bring down the SLI Layer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - success.</span>
<span class="cm"> *   Any other value - error.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_hba_down_post</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_hba_down_post</span><span class="p">)(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hb_timeout - The HBA-timer timeout handler</span>
<span class="cm"> * @ptr: unsigned long holds the pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the HBA-timer timeout handler registered to the lpfc driver. When</span>
<span class="cm"> * this timer fires, a HBA timeout event shall be posted to the lpfc driver</span>
<span class="cm"> * work-port-events bitmap and the worker thread is notified. This timeout</span>
<span class="cm"> * event will be used by the worker thread to invoke the actual timeout</span>
<span class="cm"> * handler routine, lpfc_hb_timeout_handler. Any periodical operations will</span>
<span class="cm"> * be performed in the timeout handler and the HBA timeout event bit shall</span>
<span class="cm"> * be cleared by the worker thread after it has taken the event bitmap out.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_hb_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">tmo_posted</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>

	<span class="n">phba</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>

	<span class="cm">/* Check for heart beat timeout conditions */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">tmo_posted</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_HB_TMO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmo_posted</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">|=</span> <span class="n">WORKER_HB_TMO</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>

	<span class="cm">/* Tell the worker thread there is work to do */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmo_posted</span><span class="p">)</span>
		<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_rrq_timeout - The RRQ-timer timeout handler</span>
<span class="cm"> * @ptr: unsigned long holds the pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the RRQ-timer timeout handler registered to the lpfc driver. When</span>
<span class="cm"> * this timer fires, a RRQ timeout event shall be posted to the lpfc driver</span>
<span class="cm"> * work-port-events bitmap and the worker thread is notified. This timeout</span>
<span class="cm"> * event will be used by the worker thread to invoke the actual timeout</span>
<span class="cm"> * handler routine, lpfc_rrq_handler. Any periodical operations will</span>
<span class="cm"> * be performed in the timeout handler and the RRQ timeout event bit shall</span>
<span class="cm"> * be cleared by the worker thread after it has taken the event bitmap out.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_rrq_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>

	<span class="n">phba</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_RRQ_ACTIVE</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hb_mbox_cmpl - The lpfc heart-beat mailbox command callback function</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @pmboxq: pointer to the driver internal queue element for mailbox command.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the callback function to the lpfc heart-beat mailbox command.</span>
<span class="cm"> * If configured, the lpfc driver issues the heart-beat mailbox command to</span>
<span class="cm"> * the HBA every LPFC_HB_MBOX_INTERVAL (current 5) seconds. At the time the</span>
<span class="cm"> * heart-beat mailbox command is issued, the driver shall set up heart-beat</span>
<span class="cm"> * timeout timer to LPFC_HB_MBOX_TIMEOUT (current 30) seconds and marks</span>
<span class="cm"> * heart-beat outstanding state. Once the mailbox command comes back and</span>
<span class="cm"> * no error conditions detected, the heart-beat mailbox command timer is</span>
<span class="cm"> * reset to LPFC_HB_MBOX_INTERVAL seconds and the heart-beat outstanding</span>
<span class="cm"> * state is cleared for the next heart-beat. If the timer expired with the</span>
<span class="cm"> * heart-beat outstanding state set, the driver will put the HBA offline.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_hb_mbox_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span> <span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span> <span class="n">pmboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">drvr_flag</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_outstanding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>

	<span class="cm">/* Check and reset heart-beat timer is necessary */</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">))</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">,</span>
			<span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">LPFC_HB_MBOX_INTERVAL</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hb_timeout_handler - The HBA-timer timeout handler</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the actual HBA-timer timeout handler to be invoked by the worker</span>
<span class="cm"> * thread whenever the HBA timer fired and HBA-timeout event posted. This</span>
<span class="cm"> * handler performs any periodic operations needed for the device. If such</span>
<span class="cm"> * periodic event has already been attended to either in the interrupt handler</span>
<span class="cm"> * or by processing slow-ring or fast-ring events within the HBA-timer</span>
<span class="cm"> * timeout window (LPFC_HB_MBOX_INTERVAL), this handler just simply resets</span>
<span class="cm"> * the timer for the next timeout period. If lpfc heart-beat mailbox command</span>
<span class="cm"> * is configured and there is no heart-beat mailbox command outstanding, a</span>
<span class="cm"> * heart-beat mailbox is issued and timer set properly. Otherwise, if there</span>
<span class="cm"> * has been a heart-beat mailbox command outstanding, the HBA shall be put</span>
<span class="cm"> * to offline.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_hb_timeout_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmboxq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">buf_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>

	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">lpfc_rcv_seq_check_edtov</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span> <span class="o">+</span> <span class="n">LPFC_HB_MBOX_INTERVAL</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
		<span class="n">jiffies</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_outstanding</span><span class="p">)</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">,</span>
				<span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">LPFC_HB_MBOX_INTERVAL</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">,</span>
				<span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">LPFC_HB_MBOX_TIMEOUT</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf_cnt</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf_cnt</span> <span class="o">==</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf_prev_cnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf_prev_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">completions</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">buf_ptr</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">buf_ptr</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">buf_ptr</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">buf_ptr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf_prev_cnt</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf_cnt</span><span class="p">;</span>

	<span class="cm">/* If there is no heart beat outstanding, issue a heartbeat command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_hba_heartbeat</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_outstanding</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">mboxq</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">pmboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span>
							<span class="n">GFP_KERNEL</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmboxq</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">,</span>
						 <span class="n">jiffies</span> <span class="o">+</span>
						 <span class="n">HZ</span> <span class="o">*</span> <span class="n">LPFC_HB_MBOX_INTERVAL</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">lpfc_heart_beat</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">);</span>
				<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_hb_mbox_cmpl</span><span class="p">;</span>
				<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">,</span>
						<span class="n">MBX_NOWAIT</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">MBX_BUSY</span> <span class="o">&amp;&amp;</span>
					<span class="n">retval</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span>
							<span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
					<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">,</span>
						<span class="n">jiffies</span> <span class="o">+</span>
						<span class="n">HZ</span> <span class="o">*</span> <span class="n">LPFC_HB_MBOX_INTERVAL</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">skipped_hb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_outstanding</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">time_before_eq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">skipped_hb</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2857 Last completion time not &quot;</span>
					<span class="s">&quot; updated in %d ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span>
						 <span class="o">-</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span><span class="p">));</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">skipped_hb</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">,</span>
				  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">LPFC_HB_MBOX_TIMEOUT</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			* If heart beat timeout called with hb_outstanding set</span>
<span class="cm">			* we need to give the hb mailbox cmd a chance to</span>
<span class="cm">			* complete or TMO.</span>
<span class="cm">			*/</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0459 Adapter heartbeat still out&quot;</span>
					<span class="s">&quot;standing:last compl time was %d ms.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span>
						 <span class="o">-</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span><span class="p">));</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">,</span>
				  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">LPFC_HB_MBOX_TIMEOUT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_offline_eratt - Bring lpfc offline on hardware error attention</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called to bring the HBA offline when HBA hardware error</span>
<span class="cm"> * other than Port Error 6 has been detected.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_offline_eratt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span>   <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_ACTIVE</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">lpfc_offline_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">lpfc_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_reset_barrier</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">lpfc_sli_brdreset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">lpfc_hba_down_post</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_sli_brdready</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">HS_MBRDY</span><span class="p">);</span>
	<span class="n">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_offline_eratt - Bring lpfc offline on SLI4 hardware error attention</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called to bring a SLI4 HBA offline when HBA hardware error</span>
<span class="cm"> * other than Port Error 6 has been detected.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_offline_eratt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_offline_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_sli4_brdreset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_hba_down_post</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_sli4_post_status_check</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_handle_deferred_eratt - The HBA hardware deferred error handler</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to handle the deferred HBA hardware error</span>
<span class="cm"> * conditions. This type of error is indicated by HBA by setting ER1</span>
<span class="cm"> * and another ER bit in the host status register. The driver will</span>
<span class="cm"> * wait until the ER1 bit clears before handling the error condition.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_handle_deferred_eratt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">old_host_status</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span>  <span class="o">*</span><span class="n">pring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>

	<span class="cm">/* If the pci channel is offline, ignore possible errors,</span>
<span class="cm">	 * since we cannot communicate with the pci card anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DEFER_ERATT</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
		<span class="s">&quot;0479 Deferred Adapter Hardware Error &quot;</span>
		<span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span><span class="p">,</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_ACTIVE</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>


	<span class="cm">/*</span>
<span class="cm">	 * Firmware stops when it triggred erratt. That could cause the I/Os</span>
<span class="cm">	 * dropped by the firmware. Error iocb (I/O) on txcmplq and let the</span>
<span class="cm">	 * SCSI layer retry it after re-establishing link.</span>
<span class="cm">	 */</span>
	<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">fcp_ring</span><span class="p">];</span>
	<span class="n">lpfc_sli_abort_iocb_ring</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * There was a firmware error. Take the hba offline and then</span>
<span class="cm">	 * attempt to restart it.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_offline_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Wait for the ER1 bit to clear.*/</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">&amp;</span> <span class="n">HS_FFER1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HSregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">=</span> <span class="n">UNPLUG_ERR</span> <span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* If driver is unloading let the worker thread continue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is to ptrotect against a race condition in which</span>
<span class="cm">	 * first write to the host attention register clear the</span>
<span class="cm">	 * host status register.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)))</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">=</span> <span class="n">old_host_status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HS_FFER1</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DEFER_ERATT</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="mh">0xa8</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="mh">0xac</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_board_errevt_to_mgmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_board_event_header</span> <span class="n">board_event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>

	<span class="n">board_event</span><span class="p">.</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">FC_REG_BOARD_EVENT</span><span class="p">;</span>
	<span class="n">board_event</span><span class="p">.</span><span class="n">subcategory</span> <span class="o">=</span> <span class="n">LPFC_EVENT_PORTINTERR</span><span class="p">;</span>
	<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">);</span>
	<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_get_event_number</span><span class="p">(),</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="n">board_event</span><span class="p">),</span>
				  <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">board_event</span><span class="p">,</span>
				  <span class="n">LPFC_NL_VENDOR_ID</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_handle_eratt_s3 - The SLI3 HBA hardware error handler</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to handle the following HBA hardware error</span>
<span class="cm"> * conditions:</span>
<span class="cm"> * 1 - HBA error attention interrupt</span>
<span class="cm"> * 2 - DMA ring index out of range</span>
<span class="cm"> * 3 - Mailbox command came back as unknown</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_handle_eratt_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span>   <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span>  <span class="o">*</span><span class="n">pring</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">event_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">temperature</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">temp_event</span> <span class="n">temp_event_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span><span class="p">;</span>

	<span class="cm">/* If the pci channel is offline, ignore possible errors,</span>
<span class="cm">	 * since we cannot communicate with the pci card anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DEFER_ERATT</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If resets are disabled then leave the HBA alone and return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_hba_reset</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Send an internal error event to mgmt application */</span>
	<span class="n">lpfc_board_errevt_to_mgmt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">DEFER_ERATT</span><span class="p">)</span>
		<span class="n">lpfc_handle_deferred_eratt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">&amp;</span> <span class="n">HS_FFER6</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">&amp;</span> <span class="n">HS_FFER8</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">&amp;</span> <span class="n">HS_FFER6</span><span class="p">)</span>
			<span class="cm">/* Re-establishing Link */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_LINK_EVENT</span><span class="p">,</span>
					<span class="s">&quot;1301 Re-establishing Link &quot;</span>
					<span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">&amp;</span> <span class="n">HS_FFER8</span><span class="p">)</span>
			<span class="cm">/* Device Zeroization */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_LINK_EVENT</span><span class="p">,</span>
					<span class="s">&quot;2861 Host Authentication device &quot;</span>
					<span class="s">&quot;zeroization Data:x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_ACTIVE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		* Firmware stops when it triggled erratt with HS_FFER6.</span>
<span class="cm">		* That could cause the I/Os dropped by the firmware.</span>
<span class="cm">		* Error iocb (I/O) on txcmplq and let the SCSI layer</span>
<span class="cm">		* retry it after re-establishing link.</span>
<span class="cm">		*/</span>
		<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">fcp_ring</span><span class="p">];</span>
		<span class="n">lpfc_sli_abort_iocb_ring</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * There was a firmware error.  Take the hba offline and then</span>
<span class="cm">		 * attempt to restart it.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_offline_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="n">lpfc_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_online</span><span class="p">(</span><span class="n">phba</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Initialize the HBA */</span>
			<span class="n">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">&amp;</span> <span class="n">HS_CRIT_TEMP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temperature</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="n">TEMPERATURE_OFFSET</span><span class="p">);</span>
		<span class="n">temp_event_data</span><span class="p">.</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">FC_REG_TEMPERATURE_EVENT</span><span class="p">;</span>
		<span class="n">temp_event_data</span><span class="p">.</span><span class="n">event_code</span> <span class="o">=</span> <span class="n">LPFC_CRIT_TEMP</span><span class="p">;</span>
		<span class="n">temp_event_data</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">temperature</span><span class="p">;</span>

		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0406 Adapter maximum temperature exceeded &quot;</span>
				<span class="s">&quot;(%ld), taking this port offline &quot;</span>
				<span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">temperature</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

		<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">);</span>
		<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_get_event_number</span><span class="p">(),</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="n">temp_event_data</span><span class="p">),</span>
					  <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">temp_event_data</span><span class="p">,</span>
					  <span class="n">SCSI_NL_VID_TYPE_PCI</span>
					  <span class="o">|</span> <span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">over_temp_state</span> <span class="o">=</span> <span class="n">HBA_OVER_TEMP</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">lpfc_offline_eratt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* The if clause above forces this code path when the status</span>
<span class="cm">		 * failure is a value other than FFER6. Do not call the offline</span>
<span class="cm">		 * twice. This is the adapter hardware error path.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0457 Adapter Hardware Error &quot;</span>
				<span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

		<span class="n">event_data</span> <span class="o">=</span> <span class="n">FC_REG_DUMP_EVENT</span><span class="p">;</span>
		<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_get_event_number</span><span class="p">(),</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">event_data</span><span class="p">),</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">event_data</span><span class="p">,</span>
				<span class="n">SCSI_NL_VID_TYPE_PCI</span> <span class="o">|</span> <span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">);</span>

		<span class="n">lpfc_offline_eratt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_handle_eratt_s4 - The SLI4 HBA hardware error handler</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to handle the SLI4 HBA hardware error attention</span>
<span class="cm"> * conditions.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_handle_eratt_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">event_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">if_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_register</span> <span class="n">portstat_reg</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="kt">uint32_t</span> <span class="n">reg_err1</span><span class="p">,</span> <span class="n">reg_err2</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">uerrlo_reg</span><span class="p">,</span> <span class="n">uemasklo_reg</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pci_rd_rc1</span><span class="p">,</span> <span class="n">pci_rd_rc2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* If the pci channel is offline, ignore possible errors, since</span>
<span class="cm">	 * we cannot communicate with the pci card anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* If resets are disabled then leave the HBA alone and return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_hba_reset</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">if_type</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">if_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_0</span>:
		<span class="n">pci_rd_rc1</span> <span class="o">=</span> <span class="n">lpfc_readl</span><span class="p">(</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type0</span><span class="p">.</span><span class="n">UERRLOregaddr</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">uerrlo_reg</span><span class="p">);</span>
		<span class="n">pci_rd_rc2</span> <span class="o">=</span> <span class="n">lpfc_readl</span><span class="p">(</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type0</span><span class="p">.</span><span class="n">UEMASKLOregaddr</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">uemasklo_reg</span><span class="p">);</span>
		<span class="cm">/* consider PCI bus read error as pci_channel_offline */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_rd_rc1</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">&amp;&amp;</span> <span class="n">pci_rd_rc2</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">lpfc_sli4_offline_eratt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_2</span>:
		<span class="n">pci_rd_rc1</span> <span class="o">=</span> <span class="n">lpfc_readl</span><span class="p">(</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">STATUSregaddr</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">portstat_reg</span><span class="p">.</span><span class="n">word0</span><span class="p">);</span>
		<span class="cm">/* consider PCI bus read error as pci_channel_offline */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_rd_rc1</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3151 PCI bus read access failure: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">STATUSregaddr</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">reg_err1</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">ERR1regaddr</span><span class="p">);</span>
		<span class="n">reg_err2</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">ERR2regaddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sliport_status_oti</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portstat_reg</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* TODO: Register for Overtemp async events. */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2889 Port Overtemperature event, &quot;</span>
				<span class="s">&quot;taking port offline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">over_temp_state</span> <span class="o">=</span> <span class="n">HBA_OVER_TEMP</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">lpfc_sli4_offline_eratt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg_err1</span> <span class="o">==</span> <span class="n">SLIPORT_ERR1_REG_ERR_CODE_2</span> <span class="o">&amp;&amp;</span>
		    <span class="n">reg_err2</span> <span class="o">==</span> <span class="n">SLIPORT_ERR2_REG_FW_RESTART</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;3143 Port Down: Firmware Restarted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg_err1</span> <span class="o">==</span> <span class="n">SLIPORT_ERR1_REG_ERR_CODE_2</span> <span class="o">&amp;&amp;</span>
			 <span class="n">reg_err2</span> <span class="o">==</span> <span class="n">SLIPORT_ERR2_REG_FORCED_DUMP</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;3144 Port Down: Debug Dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg_err1</span> <span class="o">==</span> <span class="n">SLIPORT_ERR1_REG_ERR_CODE_2</span> <span class="o">&amp;&amp;</span>
			 <span class="n">reg_err2</span> <span class="o">==</span> <span class="n">SLIPORT_ERR2_REG_FUNC_PROVISON</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;3145 Port Down: Provisioning</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * On error status condition, driver need to wait for port</span>
<span class="cm">		 * ready before performing reset.</span>
<span class="cm">		 */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_pdev_status_reg_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* need reset: attempt for port recovery */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2887 Reset Needed: Attempting Port &quot;</span>
					<span class="s">&quot;Recovery...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">lpfc_offline_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">lpfc_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_online</span><span class="p">(</span><span class="n">phba</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
				<span class="cm">/* don&#39;t report event on forced debug dump */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">reg_err1</span> <span class="o">==</span> <span class="n">SLIPORT_ERR1_REG_ERR_CODE_2</span> <span class="o">&amp;&amp;</span>
				    <span class="n">reg_err2</span> <span class="o">==</span> <span class="n">SLIPORT_ERR2_REG_FORCED_DUMP</span><span class="p">)</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* fall through for not able to recover */</span>
		<span class="p">}</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3152 Unrecoverable error, bring the port &quot;</span>
				<span class="s">&quot;offline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">lpfc_sli4_offline_eratt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_1</span>:
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;3123 Report dump event to upper layer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* Send an internal error event to mgmt application */</span>
	<span class="n">lpfc_board_errevt_to_mgmt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">event_data</span> <span class="o">=</span> <span class="n">FC_REG_DUMP_EVENT</span><span class="p">;</span>
	<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_get_event_number</span><span class="p">(),</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="n">event_data</span><span class="p">),</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">event_data</span><span class="p">,</span>
				  <span class="n">SCSI_NL_VID_TYPE_PCI</span> <span class="o">|</span> <span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_handle_eratt - Wrapper func for handling hba error attention</span>
<span class="cm"> * @phba: pointer to lpfc HBA data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine wraps the actual SLI3 or SLI4 hba error attention handling</span>
<span class="cm"> * routine from the API jump table function pointer from the lpfc_hba struct.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - success.</span>
<span class="cm"> *   Any other value - error.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_handle_eratt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="o">*</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_handle_eratt</span><span class="p">)(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_handle_latt - The HBA link event handler</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked from the worker thread to handle a HBA host</span>
<span class="cm"> * attention link event.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_handle_latt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span>   <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">control</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pmb</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">lpfc_handle_latt_err_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">lpfc_handle_latt_free_pmb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">lpfc_mbuf_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">lpfc_handle_latt_free_mp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Cleanup any outstanding ELS commands */</span>
	<span class="n">lpfc_els_flush_all_cmd</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">slistat</span><span class="p">.</span><span class="n">link_event</span><span class="o">++</span><span class="p">;</span>
	<span class="n">lpfc_read_topology</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_read_topology</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="cm">/* Block ELS IOCBs until we have processed this mbox command */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">].</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span> <span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">lpfc_handle_latt_free_mbuf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear Link Attention in HA REG */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">HA_LATT</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">lpfc_handle_latt_free_mbuf:</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">].</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>
	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
<span class="nl">lpfc_handle_latt_free_mp:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
<span class="nl">lpfc_handle_latt_free_pmb:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
<span class="nl">lpfc_handle_latt_err_exit:</span>
	<span class="cm">/* Enable Link attention interrupts */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_PROCESS_LA</span><span class="p">;</span>
	<span class="n">control</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">control</span> <span class="o">|=</span> <span class="n">HC_LAINT_ENA</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>

	<span class="cm">/* Clear Link Attention in HA REG */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">HA_LATT</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">lpfc_linkdown</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
		     <span class="s">&quot;0300 LATT: Cannot issue READ_LA: Data:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_parse_vpd - Parse VPD (Vital Product Data)</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @vpd: pointer to the vital product data.</span>
<span class="cm"> * @len: length of the vital product data in bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine parses the Vital Product Data (VPD). The VPD is treated as</span>
<span class="cm"> * an array of characters. In this routine, the ModelName, ProgramType, and</span>
<span class="cm"> * ModelDesc, etc. fields of the phba data structure will be populated.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - pointer to the VPD passed in is NULL</span>
<span class="cm"> *   1 - success</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_parse_vpd</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">vpd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">lenlo</span><span class="p">,</span> <span class="n">lenhi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">Length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">finished</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vpd</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Vital Product */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0455 Vital Product Data: x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">vpd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">vpd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">vpd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
			<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">vpd</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">finished</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x82</span>:
		<span class="k">case</span> <span class="mh">0x91</span>:
			<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">lenlo</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">lenhi</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">=</span> <span class="p">((((</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">lenhi</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">lenlo</span><span class="p">);</span>
			<span class="n">index</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x90</span>:
			<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">lenlo</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">lenhi</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">Length</span> <span class="o">=</span> <span class="p">((((</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">lenhi</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">lenlo</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Length</span> <span class="o">&gt;</span> <span class="n">len</span> <span class="o">-</span> <span class="n">index</span><span class="p">)</span>
				<span class="n">Length</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">index</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">Length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Look for Serial Number */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;S&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;N&#39;</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">Length</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
				<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">SerialNumber</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">];</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">31</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">SerialNumber</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;V&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd_flag</span> <span class="o">|=</span> <span class="n">VPD_MODEL_DESC</span><span class="p">;</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">Length</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
				<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelDesc</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">];</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelDesc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;V&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;2&#39;</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd_flag</span> <span class="o">|=</span> <span class="n">VPD_MODEL_NAME</span><span class="p">;</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">Length</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
				<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelName</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">];</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">79</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelName</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;V&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;3&#39;</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd_flag</span> <span class="o">|=</span> <span class="n">VPD_PROGRAM_TYPE</span><span class="p">;</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">Length</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
				<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">ProgramType</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">];</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">ProgramType</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;V&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;4&#39;</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd_flag</span> <span class="o">|=</span> <span class="n">VPD_PORT</span><span class="p">;</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">Length</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
				<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pport_name_sta</span> <span class="o">==</span>
					     <span class="n">LPFC_SLI4_PPNAME_GET</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">j</span><span class="o">++</span><span class="p">;</span>
						<span class="n">index</span><span class="o">++</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">Port</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">];</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">19</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">!=</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="o">||</span>
				    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pport_name_sta</span> <span class="o">==</span>
				     <span class="n">LPFC_SLI4_PPNAME_NON</span><span class="p">))</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">Port</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">vpd</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">Length</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">finished</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x78</span>:
			<span class="n">finished</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">index</span> <span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_hba_model_desc - Retrieve HBA device model name and description</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @mdp: pointer to the data structure to hold the derived model name.</span>
<span class="cm"> * @descp: pointer to the data structure to hold the derived description.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine retrieves HBA&#39;s description based on its registered PCI device</span>
<span class="cm"> * ID. The @descp passed into this function points to an array of 256 chars. It</span>
<span class="cm"> * shall be returned with the model name, maximum speed, and the host bus type.</span>
<span class="cm"> * The @mdp passed into this function points to an array of 80 chars. When the</span>
<span class="cm"> * function returns, the @mdp will be filled with the model name.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_get_hba_model_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">mdp</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">descp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_vpd_t</span> <span class="o">*</span><span class="n">vp</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">dev_id</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_speed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">GE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oneConnect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* default is not a oneConnect */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;&lt;Unknown&gt;&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mdp</span> <span class="o">&amp;&amp;</span> <span class="n">mdp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span>
		<span class="o">&amp;&amp;</span> <span class="n">descp</span> <span class="o">&amp;&amp;</span> <span class="n">descp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_16Gb</span><span class="p">)</span>
		<span class="n">max_speed</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_10Gb</span><span class="p">)</span>
		<span class="n">max_speed</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_8Gb</span><span class="p">)</span>
		<span class="n">max_speed</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_4Gb</span><span class="p">)</span>
		<span class="n">max_speed</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_2Gb</span><span class="p">)</span>
		<span class="n">max_speed</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">max_speed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">vp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dev_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_FIREFLY</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP6000&quot;</span><span class="p">,</span> <span class="s">&quot;PCI&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_SUPERFLY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">biuRev</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">biuRev</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP7000&quot;</span><span class="p">,</span> <span class="s">&quot;PCI&quot;</span><span class="p">,</span>
					<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">else</span>
			<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP7000E&quot;</span><span class="p">,</span> <span class="s">&quot;PCI&quot;</span><span class="p">,</span>
					<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_DRAGONFLY</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP8000&quot;</span><span class="p">,</span> <span class="s">&quot;PCI&quot;</span><span class="p">,</span>
				<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_CENTAUR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">FC_JEDEC_ID</span><span class="p">(</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">biuRev</span><span class="p">)</span> <span class="o">==</span> <span class="n">CENTAUR_2G_JEDEC_ID</span><span class="p">)</span>
			<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP9002&quot;</span><span class="p">,</span> <span class="s">&quot;PCI&quot;</span><span class="p">,</span>
					<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">else</span>
			<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP9000&quot;</span><span class="p">,</span> <span class="s">&quot;PCI&quot;</span><span class="p">,</span>
					<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_RFLY</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP952&quot;</span><span class="p">,</span> <span class="s">&quot;PCI&quot;</span><span class="p">,</span>
				<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_PEGASUS</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP9802&quot;</span><span class="p">,</span> <span class="s">&quot;PCI-X&quot;</span><span class="p">,</span>
				<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_THOR</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP10000&quot;</span><span class="p">,</span> <span class="s">&quot;PCI-X&quot;</span><span class="p">,</span>
				<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_VIPER</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPX1000&quot;</span><span class="p">,</span>  <span class="s">&quot;PCI-X&quot;</span><span class="p">,</span>
				<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_PFLY</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP982&quot;</span><span class="p">,</span> <span class="s">&quot;PCI-X&quot;</span><span class="p">,</span>
				<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_TFLY</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP1050&quot;</span><span class="p">,</span> <span class="s">&quot;PCI-X&quot;</span><span class="p">,</span>
				<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_HELIOS</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP11000&quot;</span><span class="p">,</span> <span class="s">&quot;PCI-X2&quot;</span><span class="p">,</span>
				<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_HELIOS_SCSP</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP11000-SP&quot;</span><span class="p">,</span> <span class="s">&quot;PCI-X2&quot;</span><span class="p">,</span>
				<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_HELIOS_DCSP</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP11002-SP&quot;</span><span class="p">,</span>  <span class="s">&quot;PCI-X2&quot;</span><span class="p">,</span>
				<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_NEPTUNE</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe1000&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_NEPTUNE_SCSP</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe1000-SP&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_NEPTUNE_DCSP</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe1002-SP&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_BMID</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP1150&quot;</span><span class="p">,</span> <span class="s">&quot;PCI-X2&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_BSMB</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP111&quot;</span><span class="p">,</span> <span class="s">&quot;PCI-X2&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_ZEPHYR</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe11000&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_ZEPHYR_SCSP</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe11000&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_ZEPHYR_DCSP</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP2105&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;FCoE Adapter&quot;</span><span class="p">};</span>
		<span class="n">GE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_ZMID</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe1150&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_ZSMB</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe111&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LP101</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP101&quot;</span><span class="p">,</span> <span class="s">&quot;PCI-X&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LP10000S</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP10000-S&quot;</span><span class="p">,</span> <span class="s">&quot;PCI&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LP11000S</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP11000-S&quot;</span><span class="p">,</span> <span class="s">&quot;PCI-X2&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LPE11000S</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe11000-S&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_SAT</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe12000&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_SAT_MID</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe1250&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_SAT_SMB</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe121&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_SAT_DCSP</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe12002-SP&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_SAT_SCSP</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe12000-SP&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_SAT_S</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe12000-S&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_HORNET</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LP21000&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;FCoE Adapter&quot;</span><span class="p">};</span>
		<span class="n">GE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_PROTEUS_VF</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPev12000&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe IOV&quot;</span><span class="p">,</span>
				<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_PROTEUS_PF</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPev12000&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe IOV&quot;</span><span class="p">,</span>
				<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_PROTEUS_S</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPemv12002-S&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe IOV&quot;</span><span class="p">,</span>
				<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_TIGERSHARK</span>:
		<span class="n">oneConnect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;OCe10100&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;FCoE&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_TOMCAT</span>:
		<span class="n">oneConnect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;OCe11100&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;FCoE&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_FALCON</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPSe12002-ML1-E&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span>
				<span class="s">&quot;EmulexSecure Fibre&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_BALIUS</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPVe12002&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe Shared I/O&quot;</span><span class="p">,</span>
				<span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LANCER_FC</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LANCER_FC_VF</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;LPe16000&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;Fibre Channel Adapter&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LANCER_FCOE</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LANCER_FCOE_VF</span>:
		<span class="n">oneConnect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;OCe15100&quot;</span><span class="p">,</span> <span class="s">&quot;PCIe&quot;</span><span class="p">,</span> <span class="s">&quot;FCoE&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)){</span><span class="s">&quot;Unknown&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mdp</span> <span class="o">&amp;&amp;</span> <span class="n">mdp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">mdp</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * oneConnect hba requires special processing, they are all initiators</span>
<span class="cm">	 * and we put the port number on the end</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">descp</span> <span class="o">&amp;&amp;</span> <span class="n">descp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oneConnect</span><span class="p">)</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">descp</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span>
				<span class="s">&quot;Emulex OneConnect %s, %s Initiator, Port %s&quot;</span><span class="p">,</span>
				<span class="n">m</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">function</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">Port</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">descp</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span>
				<span class="s">&quot;Emulex %s %d%s %s %s&quot;</span><span class="p">,</span>
				<span class="n">m</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">max_speed</span><span class="p">,</span> <span class="p">(</span><span class="n">GE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;GE&quot;</span> <span class="o">:</span> <span class="s">&quot;Gb&quot;</span><span class="p">,</span>
				<span class="n">m</span><span class="p">.</span><span class="n">bus</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">function</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_post_buffer - Post IOCB(s) with DMA buffer descriptor(s) to a IOCB ring</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @pring: pointer to a IOCB ring.</span>
<span class="cm"> * @cnt: the number of IOCBs to be posted to the IOCB ring.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine posts a given number of IOCBs with the associated DMA buffer</span>
<span class="cm"> * descriptors specified by the cnt argument to the given IOCB ring.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   The number of IOCBs NOT able to be posted to the IOCB ring.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_post_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp1</span><span class="p">,</span> <span class="o">*</span><span class="n">mp2</span><span class="p">;</span>

	<span class="n">cnt</span> <span class="o">+=</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">missbufcnt</span><span class="p">;</span>

	<span class="cm">/* While there are buffers to post */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Allocate buffer for  command iocb */</span>
		<span class="n">iocb</span> <span class="o">=</span> <span class="n">lpfc_sli_get_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">missbufcnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>

		<span class="cm">/* 2 buffers can be posted per command */</span>
		<span class="cm">/* Allocate buffer to post */</span>
		<span class="n">mp1</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp1</span><span class="p">)</span>
		    <span class="n">mp1</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">lpfc_mbuf_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">MEM_PRI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp1</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp1</span> <span class="o">||</span> <span class="o">!</span><span class="n">mp1</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">mp1</span><span class="p">);</span>
			<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">iocb</span><span class="p">);</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">missbufcnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp1</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="cm">/* Allocate buffer to post */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mp2</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp2</span><span class="p">)</span>
				<span class="n">mp2</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">lpfc_mbuf_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">MEM_PRI</span><span class="p">,</span>
							    <span class="o">&amp;</span><span class="n">mp2</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp2</span> <span class="o">||</span> <span class="o">!</span><span class="n">mp2</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">mp2</span><span class="p">);</span>
				<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp1</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp1</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">mp1</span><span class="p">);</span>
				<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">iocb</span><span class="p">);</span>
				<span class="n">pring</span><span class="o">-&gt;</span><span class="n">missbufcnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp2</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mp2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">cont64</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">mp1</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">cont64</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">putPaddrLow</span><span class="p">(</span><span class="n">mp1</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">cont64</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="n">FCELSSIZE</span><span class="p">;</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">cont64</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">mp2</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
			<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">cont64</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">putPaddrLow</span><span class="p">(</span><span class="n">mp2</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
			<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">cont64</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="n">FCELSSIZE</span><span class="p">;</span>
			<span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
			<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_QUE_RING_BUF64_CN</span><span class="p">;</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpLe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp1</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp1</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">mp1</span><span class="p">);</span>
			<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp2</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp2</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp2</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">mp2</span><span class="p">);</span>
				<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">iocb</span><span class="p">);</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">missbufcnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_sli_ringpostbuf_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">mp1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp2</span><span class="p">)</span>
			<span class="n">lpfc_sli_ringpostbuf_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">mp2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">missbufcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_post_rcv_buf - Post the initial receive IOCB buffers to ELS ring</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine posts initial receive IOCB buffers to the ELS ring. The</span>
<span class="cm"> * current number of initial IOCB buffers specified by LPFC_BUF_RING0 is</span>
<span class="cm"> * set to 64 IOCBs.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - success (currently always success)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_post_rcv_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>

	<span class="cm">/* Ring 0, ELS / CT buffers */</span>
	<span class="n">lpfc_post_buffer</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">],</span> <span class="n">LPFC_BUF_RING0</span><span class="p">);</span>
	<span class="cm">/* Ring 2 - FCP no buffers needed */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define S(N,V) (((V)&lt;&lt;(N))|((V)&gt;&gt;(32-(N))))</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sha_init - Set up initial array of hash table entries</span>
<span class="cm"> * @HashResultPointer: pointer to an array as hash table.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine sets up the initial values to the array of hash table entries</span>
<span class="cm"> * for the LC HBAs.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sha_init</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span> <span class="n">HashResultPointer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x67452301</span><span class="p">;</span>
	<span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xEFCDAB89</span><span class="p">;</span>
	<span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x98BADCFE</span><span class="p">;</span>
	<span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x10325476</span><span class="p">;</span>
	<span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xC3D2E1F0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sha_iterate - Iterate initial hash table with the working hash table</span>
<span class="cm"> * @HashResultPointer: pointer to an initial/result hash table.</span>
<span class="cm"> * @HashWorkingPointer: pointer to an working hash table.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine iterates an initial hash table pointed by @HashResultPointer</span>
<span class="cm"> * with the values from the working hash table pointeed by @HashWorkingPointer.</span>
<span class="cm"> * The results are putting back to the initial hash table, returned through</span>
<span class="cm"> * the @HashResultPointer as the result hash table.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sha_iterate</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span> <span class="n">HashResultPointer</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span> <span class="n">HashWorkingPointer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">TEMP</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">;</span>
	<span class="n">t</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">HashWorkingPointer</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
		      <span class="n">HashWorkingPointer</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">^</span> <span class="n">HashWorkingPointer</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span>
								     <span class="mi">8</span><span class="p">]</span> <span class="o">^</span>
		      <span class="n">HashWorkingPointer</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">14</span><span class="p">]</span> <span class="o">^</span> <span class="n">HashWorkingPointer</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">16</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">79</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">A</span> <span class="o">=</span> <span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">B</span> <span class="o">=</span> <span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">C</span> <span class="o">=</span> <span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">D</span> <span class="o">=</span> <span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">E</span> <span class="o">=</span> <span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">TEMP</span> <span class="o">=</span> <span class="p">((</span><span class="n">B</span> <span class="o">&amp;</span> <span class="n">C</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="o">~</span><span class="n">B</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">D</span><span class="p">))</span> <span class="o">+</span> <span class="mh">0x5A827999</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">TEMP</span> <span class="o">=</span> <span class="p">(</span><span class="n">B</span> <span class="o">^</span> <span class="n">C</span> <span class="o">^</span> <span class="n">D</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x6ED9EBA1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">TEMP</span> <span class="o">=</span> <span class="p">((</span><span class="n">B</span> <span class="o">&amp;</span> <span class="n">C</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">B</span> <span class="o">&amp;</span> <span class="n">D</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">C</span> <span class="o">&amp;</span> <span class="n">D</span><span class="p">))</span> <span class="o">+</span> <span class="mh">0x8F1BBCDC</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">TEMP</span> <span class="o">=</span> <span class="p">(</span><span class="n">B</span> <span class="o">^</span> <span class="n">C</span> <span class="o">^</span> <span class="n">D</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0xCA62C1D6</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">TEMP</span> <span class="o">+=</span> <span class="n">S</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="n">E</span> <span class="o">+</span> <span class="n">HashWorkingPointer</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>
		<span class="n">E</span> <span class="o">=</span> <span class="n">D</span><span class="p">;</span>
		<span class="n">D</span> <span class="o">=</span> <span class="n">C</span><span class="p">;</span>
		<span class="n">C</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
		<span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>
		<span class="n">A</span> <span class="o">=</span> <span class="n">TEMP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">79</span><span class="p">);</span>

	<span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">;</span>
	<span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">B</span><span class="p">;</span>
	<span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">C</span><span class="p">;</span>
	<span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">D</span><span class="p">;</span>
	<span class="n">HashResultPointer</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+=</span> <span class="n">E</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_challenge_key - Create challenge key based on WWPN of the HBA</span>
<span class="cm"> * @RandomChallenge: pointer to the entry of host challenge random number array.</span>
<span class="cm"> * @HashWorking: pointer to the entry of the working hash array.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine calculates the working hash array referred by @HashWorking</span>
<span class="cm"> * from the challenge random numbers associated with the host, referred by</span>
<span class="cm"> * @RandomChallenge. The result is put into the entry of the working hash</span>
<span class="cm"> * array and returned by reference through @HashWorking.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_challenge_key</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span> <span class="n">RandomChallenge</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span> <span class="n">HashWorking</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">HashWorking</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">RandomChallenge</span> <span class="o">^</span> <span class="o">*</span><span class="n">HashWorking</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hba_init - Perform special handling for LC HBA initialization</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @hbainit: pointer to an array of unsigned 32-bit integers.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine performs the special handling for LC HBA initialization.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_hba_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">hbainit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">HashWorking</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">pwwnn</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">wwnn</span><span class="p">;</span>

	<span class="n">HashWorking</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HashWorking</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">HashWorking</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">HashWorking</span><span class="p">[</span><span class="mi">78</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">pwwnn</span><span class="o">++</span><span class="p">;</span>
	<span class="n">HashWorking</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">HashWorking</span><span class="p">[</span><span class="mi">79</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">pwwnn</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span>
		<span class="n">lpfc_challenge_key</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">RandomData</span> <span class="o">+</span> <span class="n">t</span><span class="p">,</span> <span class="n">HashWorking</span> <span class="o">+</span> <span class="n">t</span><span class="p">);</span>

	<span class="n">lpfc_sha_init</span><span class="p">(</span><span class="n">hbainit</span><span class="p">);</span>
	<span class="n">lpfc_sha_iterate</span><span class="p">(</span><span class="n">hbainit</span><span class="p">,</span> <span class="n">HashWorking</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">HashWorking</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cleanup - Performs vport cleanups before deleting a vport</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine performs the necessary cleanups before deleting the @vport.</span>
<span class="cm"> * It invokes the discovery state machine to perform necessary state</span>
<span class="cm"> * transitions and to release the ndlps associated with the @vport. Note,</span>
<span class="cm"> * the physical port is treated as @vport 0.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">*</span><span class="n">next_ndlp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&gt;</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">)</span>
		<span class="n">lpfc_port_link_failure</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">next_ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_enable_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
						<span class="n">NLP_STE_UNUSED_NODE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">);</span>
			<span class="n">NLP_SET_FREE_REQ</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">);</span>
			<span class="cm">/* Trigger the release of the ndlp memory */</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NLP_CHK_FREE_REQ</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* The ndlp should not be in memory free mode already */</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* Indicate request for freeing ndlp memory */</span>
			<span class="n">NLP_SET_FREE_REQ</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">!=</span> <span class="n">LPFC_PHYSICAL_PORT</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span> <span class="o">==</span> <span class="n">Fabric_DID</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Just free up ndlp with Fabric_DID for vports */</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* take care of nodes in unused state before the state</span>
<span class="cm">		 * machine taking action.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">&amp;</span> <span class="n">NLP_FABRIC</span><span class="p">)</span>
			<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="n">NLP_EVT_DEVICE_RECOVERY</span><span class="p">);</span>

		<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					     <span class="n">NLP_EVT_DEVICE_RM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* At this point, ALL ndlp&#39;s should be gone</span>
<span class="cm">	 * because of the previous NLP_EVT_DEVICE_RM.</span>
<span class="cm">	 * Lets wait for this to happen, if needed.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">3000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				<span class="s">&quot;0233 Nodelist not empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">next_ndlp</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
						<span class="n">LOG_NODE</span><span class="p">,</span>
						<span class="s">&quot;0282 did:x%x ndlp:x%p &quot;</span>
						<span class="s">&quot;usgmap:x%x refcnt:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ndlp</span><span class="p">,</span>
						<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_usg_map</span><span class="p">,</span>
						<span class="n">atomic_read</span><span class="p">(</span>
							<span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Wait for any activity on ndlps to settle */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lpfc_cleanup_vports_rrqs</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_stop_vport_timers - Stop all the timers associated with a vport</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine stops all the timers associated with a @vport. This function</span>
<span class="cm"> * is invoked before disabling or deleting a @vport. Note that the physical</span>
<span class="cm"> * port is treated as @vport 0.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_stop_vport_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">els_tmofunc</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_fdmitmo</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">delayed_disc_tmo</span><span class="p">);</span>
	<span class="n">lpfc_can_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lpfc_sli4_stop_fcf_redisc_wait_timer - Stop FCF rediscovery wait timer</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine stops the SLI4 FCF rediscover wait timer if it&#39;s on. The</span>
<span class="cm"> * caller of this routine should already hold the host lock.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">__lpfc_sli4_stop_fcf_redisc_wait_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Clear pending FCF rediscovery wait flag */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_REDISC_PEND</span><span class="p">;</span>

	<span class="cm">/* Now, try to stop the timer */</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">redisc_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_stop_fcf_redisc_wait_timer - Stop FCF rediscovery wait timer</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine stops the SLI4 FCF rediscover wait timer if it&#39;s on. It</span>
<span class="cm"> * checks whether the FCF rediscovery wait timer is pending with the host</span>
<span class="cm"> * lock held before proceeding with disabling the timer and clearing the</span>
<span class="cm"> * wait timer pendig flag.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_stop_fcf_redisc_wait_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REDISC_PEND</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* FCF rediscovery timer already fired or stopped */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__lpfc_sli4_stop_fcf_redisc_wait_timer</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="cm">/* Clear failover in progress flags */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FCF_DEAD_DISC</span> <span class="o">|</span> <span class="n">FCF_ACVL_DISC</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_stop_hba_timers - Stop all the timers associated with an HBA</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine stops all the timers associated with a HBA. This function is</span>
<span class="cm"> * invoked before either putting a HBA offline or unloading the driver.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_stop_hba_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_stop_vport_timers</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_block_timer</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">eratt_poll</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">rrq_tmr</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HBA_RRQ_ACTIVE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_outstanding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_LP</span>:
		<span class="cm">/* Stop any LightPulse device specific driver timers */</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcp_poll_timer</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_OC</span>:
		<span class="cm">/* Stop any OneConnect device sepcific driver timers */</span>
		<span class="n">lpfc_sli4_stop_fcf_redisc_wait_timer</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0297 Invalid device group (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_block_mgmt_io - Mark a HBA&#39;s management interface as blocked</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine marks a HBA&#39;s management interface as blocked. Once the HBA&#39;s</span>
<span class="cm"> * management interface is marked as blocked, all the user space access to</span>
<span class="cm"> * the HBA, whether they are from sysfs interface or libdfc interface will</span>
<span class="cm"> * all be blocked. The HBA is set to block the management interface when the</span>
<span class="cm"> * driver prepares the HBA interface for online or offline.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_block_mgmt_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span> <span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">actcmd</span> <span class="o">=</span> <span class="n">MBX_HEARTBEAT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">LPFC_MBOX_TMO</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_BLOCK_MGMT_IO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">actcmd</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">;</span>
		<span class="cm">/* Determine how long we might wait for the active mailbox</span>
<span class="cm">		 * command to be gracefully completed by firmware.</span>
<span class="cm">		 */</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>

	<span class="cm">/* Wait for the outstnading mailbox command to complete */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check active mailbox complete status every 2ms */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2813 Mgmt IO is Blocked %x &quot;</span>
				<span class="s">&quot;- mbox cmd %x still active</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">actcmd</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_node_prep - Assign RPIs for active nodes.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate RPIs for all active remote nodes. This is needed whenever</span>
<span class="cm"> * an SLI4 adapter is reset and the driver is not unloading. Its purpose</span>
<span class="cm"> * is to fixup the temporary rpi assignments.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_node_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span>  <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">*</span><span class="n">next_ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">!=</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">next_ndlp</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span>
						 <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
					<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span> <span class="o">=</span>
						<span class="n">lpfc_sli4_alloc_rpi</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_online - Initialize and bring a HBA online</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine initializes the HBA and brings a HBA online. During this</span>
<span class="cm"> * process, the management interface is blocked to prevent user space access</span>
<span class="cm"> * to the HBA interfering with the driver initialization.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - successful</span>
<span class="cm"> *   1 - failed</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_online</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0458 Bring Adapter online</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">lpfc_block_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_sli_queue_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli4_hba_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* Initialize SLI4 HBA */</span>
			<span class="n">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_hba_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* Initialize SLI2/SLI3 HBA */</span>
			<span class="n">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
			<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_OFFLINE_MODE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">)</span>
				<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
				<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VPORT_NEEDS_INIT_VPI</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>

	<span class="n">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_unblock_mgmt_io - Mark a HBA&#39;s management interface to be not blocked</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine marks a HBA&#39;s management interface as not blocked. Once the</span>
<span class="cm"> * HBA&#39;s management interface is marked as not blocked, all the user space</span>
<span class="cm"> * access to the HBA, whether they are from sysfs interface or libdfc</span>
<span class="cm"> * interface will be allowed. The HBA is set to block the management interface</span>
<span class="cm"> * when the driver prepares the HBA interface for online or offline and then</span>
<span class="cm"> * set to unblock the management interface afterwards.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span> <span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_BLOCK_MGMT_IO</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_offline_prep - Prepare a HBA to be brought offline</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to prepare a HBA to be brought offline. It performs</span>
<span class="cm"> * unregistration login to all the nodes on all vports and flushes the mailbox</span>
<span class="cm"> * queue to make it ready to be brought offline.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_offline_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span> <span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span>  <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">*</span><span class="n">next_ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">lpfc_block_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">lpfc_linkdown</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Issue an unreg_login to all nodes on all vports */</span>
	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">vpi_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_VPI_REGISTERED</span><span class="p">;</span>
			<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">;</span>
			<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VFI_REGISTERED</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

			<span class="n">shost</span> <span class="o">=</span>	<span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">next_ndlp</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span>
						 <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">&amp;</span> <span class="n">NLP_FABRIC</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ndlp</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">,</span> <span class="n">NLP_EVT_DEVICE_RECOVERY</span><span class="p">);</span>
					<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ndlp</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">,</span> <span class="n">NLP_EVT_DEVICE_RM</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_NPR_ADISC</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * Whenever an SLI4 port goes offline, free the</span>
<span class="cm">				 * RPI. Get a new RPI when the adapter port</span>
<span class="cm">				 * comes back online.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
					<span class="n">lpfc_sli4_free_rpi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>
				<span class="n">lpfc_unreg_rpi</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ndlp</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>

	<span class="n">lpfc_sli_mbox_sys_shutdown</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_offline - Bring a HBA offline</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine actually brings a HBA offline. It stops all the timers</span>
<span class="cm"> * associated with the HBA, brings down the SLI layer, and eventually</span>
<span class="cm"> * marks the HBA as in offline state for the upper layer protocol.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_offline</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* stop port and all timers associated with this hba */</span>
	<span class="n">lpfc_stop_port</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">lpfc_stop_vport_timers</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0460 Bring Adapter offline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* Bring down the SLI Layer and cleanup.  The HBA is offline</span>
<span class="cm">	   now.  */</span>
	<span class="n">lpfc_sli_hba_down</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_scsi_free - Free all the SCSI buffers and IOCBs from driver lists</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to free all the SCSI buffers and IOCBs from the driver</span>
<span class="cm"> * list back to kernel. It is called from lpfc_pci_remove_one to free</span>
<span class="cm"> * the internal resources before the device is removed from the system.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_scsi_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="o">*</span><span class="n">sb_next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="o">*</span><span class="n">io_next</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/* Release all the lpfc_scsi_bufs maintained by this host. */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">sb_next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_dma_buf_pool</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			      <span class="n">sb</span><span class="o">-&gt;</span><span class="n">dma_handle</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">total_scsi_bufs</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">);</span>

	<span class="cm">/* Release all the lpfc_iocbq entries maintained by this host. */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">io_next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_iocb_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">total_iocbq_bufs</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_xri_sgl_update - update xri-sgl sizing and mapping</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine first calculates the sizes of the current els and allocated</span>
<span class="cm"> * scsi sgl lists, and then goes through all sgls to updates the physical</span>
<span class="cm"> * XRIs assigned due to port function reset. During port initialization, the</span>
<span class="cm"> * current els and allocated scsi sgl lists are 0s.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - successful (for now, it always returns 0)</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_xri_sgl_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">sglq_entry_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">psb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">psb_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">lxri</span><span class="p">,</span> <span class="n">xri_cnt</span><span class="p">,</span> <span class="n">els_xri_cnt</span><span class="p">,</span> <span class="n">scsi_xri_cnt</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">els_sgl_list</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">scsi_sgl_list</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * update on pci function&#39;s els xri-sgl list</span>
<span class="cm">	 */</span>
	<span class="n">els_xri_cnt</span> <span class="o">=</span> <span class="n">lpfc_sli4_get_els_iocb_cnt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">els_xri_cnt</span> <span class="o">&gt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_xri_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* els xri-sgl expanded */</span>
		<span class="n">xri_cnt</span> <span class="o">=</span> <span class="n">els_xri_cnt</span> <span class="o">-</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_xri_cnt</span><span class="p">;</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3157 ELS xri-sgl count increased from &quot;</span>
				<span class="s">&quot;%d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_xri_cnt</span><span class="p">,</span>
				<span class="n">els_xri_cnt</span><span class="p">);</span>
		<span class="cm">/* allocate the additional els sgls */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">xri_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sglq_entry</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sglq</span><span class="p">),</span>
					     <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sglq_entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
						<span class="s">&quot;2562 Failure to allocate an &quot;</span>
						<span class="s">&quot;ELS sgl entry:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_free_mem</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">buff_type</span> <span class="o">=</span> <span class="n">GEN_BUFF_TYPE</span><span class="p">;</span>
			<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">lpfc_mbuf_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							   <span class="o">&amp;</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">sglq_entry</span><span class="p">);</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
						<span class="s">&quot;2563 Failure to allocate an &quot;</span>
						<span class="s">&quot;ELS mbuf:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_free_mem</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">sgl</span> <span class="o">=</span> <span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LPFC_BPL_SIZE</span><span class="p">);</span>
			<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SGL_FREED</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">els_sgl_list</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">els_sgl_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sgl_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">els_xri_cnt</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_xri_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* els xri-sgl shrinked */</span>
		<span class="n">xri_cnt</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_xri_cnt</span> <span class="o">-</span> <span class="n">els_xri_cnt</span><span class="p">;</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3158 ELS xri-sgl count decreased from &quot;</span>
				<span class="s">&quot;%d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_xri_cnt</span><span class="p">,</span>
				<span class="n">els_xri_cnt</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sgl_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">els_sgl_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="cm">/* release extra els sgls from list */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">xri_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">els_sgl_list</span><span class="p">,</span>
					 <span class="n">sglq_entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sglq</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sglq_entry</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span>
					       <span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">sglq_entry</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">els_sgl_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sgl_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3163 ELS xri-sgl count unchanged: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">els_xri_cnt</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_xri_cnt</span> <span class="o">=</span> <span class="n">els_xri_cnt</span><span class="p">;</span>

	<span class="cm">/* update xris to els sgls on the list */</span>
	<span class="n">sglq_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sglq_entry_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sglq_entry</span><span class="p">,</span> <span class="n">sglq_entry_next</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sgl_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lxri</span> <span class="o">=</span> <span class="n">lpfc_sli4_next_xritag</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lxri</span> <span class="o">==</span> <span class="n">NO_XRI</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;2400 Failed to allocate xri for &quot;</span>
					<span class="s">&quot;ELS sgl</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free_mem</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">sli4_lxritag</span> <span class="o">=</span> <span class="n">lxri</span><span class="p">;</span>
		<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_ids</span><span class="p">[</span><span class="n">lxri</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * update on pci function&#39;s allocated scsi xri-sgl list</span>
<span class="cm">	 */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">total_scsi_bufs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* maximum number of xris available for scsi buffers */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">scsi_xri_max</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_xri</span> <span class="o">-</span>
				      <span class="n">els_xri_cnt</span><span class="p">;</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;2401 Current allocated SCSI xri-sgl count:%d, &quot;</span>
			<span class="s">&quot;maximum  SCSI xri count:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">scsi_xri_cnt</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">scsi_xri_max</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_buf_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scsi_sgl_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">scsi_xri_cnt</span> <span class="o">&gt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">scsi_xri_max</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* max scsi xri shrinked below the allocated scsi buffers */</span>
		<span class="n">scsi_xri_cnt</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">scsi_xri_cnt</span> <span class="o">-</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">scsi_xri_max</span><span class="p">;</span>
		<span class="cm">/* release the extra allocated scsi buffers */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">scsi_xri_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scsi_sgl_list</span><span class="p">,</span> <span class="n">psb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_dma_buf_pool</span><span class="p">,</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
				      <span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_handle</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">psb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">scsi_xri_cnt</span> <span class="o">-=</span> <span class="n">scsi_xri_cnt</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* update xris associated to remaining allocated scsi buffers */</span>
	<span class="n">psb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">psb_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">psb</span><span class="p">,</span> <span class="n">psb_next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scsi_sgl_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lxri</span> <span class="o">=</span> <span class="n">lpfc_sli4_next_xritag</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lxri</span> <span class="o">==</span> <span class="n">NO_XRI</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;2560 Failed to allocate xri for &quot;</span>
					<span class="s">&quot;scsi buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free_mem</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">sli4_lxritag</span> <span class="o">=</span> <span class="n">lxri</span><span class="p">;</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">sli4_xritag</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_ids</span><span class="p">[</span><span class="n">lxri</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scsi_sgl_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_buf_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_mem:</span>
	<span class="n">lpfc_free_els_sgl_list</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_scsi_free</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_create_port - Create an FC port</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @instance: a unique integer ID to this FC port.</span>
<span class="cm"> * @dev: pointer to the device data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine creates a FC port for the upper layer protocol. The FC port</span>
<span class="cm"> * can be created on top of either a physical port or a virtual port provided</span>
<span class="cm"> * by the HBA. This routine also allocates a SCSI host data structure (shost)</span>
<span class="cm"> * and associates the FC port created before adding the shost into the SCSI</span>
<span class="cm"> * layer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   @vport - pointer to the virtual N_Port data structure.</span>
<span class="cm"> *   NULL - port create failed.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span>
<span class="nf">lpfc_create_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">instance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpfc_vport_template</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpfc_template</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span> <span class="o">=</span> <span class="n">phba</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">|=</span> <span class="n">FC_LOADING</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lpfc_get_vport_cfgparam</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">unique_id</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="n">LPFC_MAX_TARGET</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_max_luns</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_boundary</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">sge_supp_len</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set initial can_queue value since 0 is no longer supported and</span>
<span class="cm">	 * scsi_add_host will fail. This will be adjusted later based on the</span>
<span class="cm">	 * max xri value determined in hba setup.</span>
<span class="cm">	 */</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_hba_queue_depth</span> <span class="o">-</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span> <span class="o">=</span> <span class="n">lpfc_vport_transport_template</span><span class="p">;</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">=</span> <span class="n">LPFC_NPIV_PORT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span> <span class="o">=</span> <span class="n">lpfc_transport_template</span><span class="p">;</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">=</span> <span class="n">LPFC_PHYSICAL_PORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize all internally managed lists. */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">rcv_buffer_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">);</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_disctmo</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_disctmo</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_disc_timeout</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_disctmo</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vport</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_fdmitmo</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_fdmitmo</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_fdmi_tmo</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_fdmitmo</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vport</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">els_tmofunc</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">els_tmofunc</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_els_timeout</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">els_tmofunc</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vport</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">delayed_disc_tmo</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">delayed_disc_tmo</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_delayed_disc_tmo</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">delayed_disc_tmo</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vport</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_add_host_with_dma</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put_shost</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">listentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">port_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vport</span><span class="p">;</span>

<span class="nl">out_put_shost:</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * destroy_port -  destroy an FC port</span>
<span class="cm"> * @vport: pointer to an lpfc virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine destroys a FC port from the upper layer protocol. All the</span>
<span class="cm"> * resources associated with the port are released.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">destroy_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_terminate</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">fc_remove_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">listentry</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">lpfc_cleanup</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_instance - Get a unique integer ID</span>
<span class="cm"> *</span>
<span class="cm"> * This routine allocates a unique integer ID from lpfc_hba_index pool. It</span>
<span class="cm"> * uses the kernel idr facility to perform the task.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *   instance - a unique integer ID allocated as the new instance.</span>
<span class="cm"> *   -1 - lpfc get instance failed.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_get_instance</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">instance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Assign an unused number */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpfc_hba_index</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idr_get_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpfc_hba_index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_scan_finished - method for SCSI layer to detect whether scan is done</span>
<span class="cm"> * @shost: pointer to SCSI host data structure.</span>
<span class="cm"> * @time: elapsed time of the scan in jiffies.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called by the SCSI layer with a SCSI host to determine</span>
<span class="cm"> * whether the scan host is finished.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: there is no scan_start function as adapter initialization will have</span>
<span class="cm"> * asynchronously kicked off the link initialization.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - SCSI host scan is not over yet.</span>
<span class="cm"> *   1 - SCSI host scan is over.</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">lpfc_scan_finished</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0461 Scanning longer than 30 &quot;</span>
				<span class="s">&quot;seconds.  Continuing initialization</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">stat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="mi">15</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">&amp;&amp;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&lt;=</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0465 Link down longer than 15 &quot;</span>
				<span class="s">&quot;seconds.  Continuing initialization</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">stat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">!=</span> <span class="n">LPFC_VPORT_READY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span> <span class="o">||</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_prli_sent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_map_cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">time</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>

	<span class="n">stat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">finished:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">stat</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_host_attrib_init - Initialize SCSI host attributes on a FC port</span>
<span class="cm"> * @shost: pointer to SCSI host data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine initializes a given SCSI host attributes on a FC port. The</span>
<span class="cm"> * SCSI host can be either on top of a physical port or a virtual port.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">lpfc_host_attrib_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set fixed host attributes.  Must done after lpfc_sli_hba_setup().</span>
<span class="cm">	 */</span>

	<span class="n">fc_host_node_name</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">);</span>
	<span class="n">fc_host_port_name</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">);</span>
	<span class="n">fc_host_supported_classes</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_COS_CLASS3</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">fc_host_supported_fc4s</span><span class="p">(</span><span class="n">shost</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host_supported_fc4s</span><span class="p">(</span><span class="n">shost</span><span class="p">)));</span>
	<span class="n">fc_host_supported_fc4s</span><span class="p">(</span><span class="n">shost</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">fc_host_supported_fc4s</span><span class="p">(</span><span class="n">shost</span><span class="p">)[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">lpfc_vport_symbolic_node_name</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">fc_host_symbolic_name</span><span class="p">(</span><span class="n">shost</span><span class="p">),</span>
				 <span class="k">sizeof</span> <span class="n">fc_host_symbolic_name</span><span class="p">(</span><span class="n">shost</span><span class="p">));</span>

	<span class="n">fc_host_supported_speeds</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_16Gb</span><span class="p">)</span>
		<span class="n">fc_host_supported_speeds</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">|=</span> <span class="n">FC_PORTSPEED_16GBIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_10Gb</span><span class="p">)</span>
		<span class="n">fc_host_supported_speeds</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">|=</span> <span class="n">FC_PORTSPEED_10GBIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_8Gb</span><span class="p">)</span>
		<span class="n">fc_host_supported_speeds</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">|=</span> <span class="n">FC_PORTSPEED_8GBIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_4Gb</span><span class="p">)</span>
		<span class="n">fc_host_supported_speeds</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">|=</span> <span class="n">FC_PORTSPEED_4GBIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_2Gb</span><span class="p">)</span>
		<span class="n">fc_host_supported_speeds</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">|=</span> <span class="n">FC_PORTSPEED_2GBIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_1Gb</span><span class="p">)</span>
		<span class="n">fc_host_supported_speeds</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">|=</span> <span class="n">FC_PORTSPEED_1GBIT</span><span class="p">;</span>

	<span class="n">fc_host_maxframe_size</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span>
		<span class="p">(((</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">.</span><span class="n">cmn</span><span class="p">.</span><span class="n">bbRcvSizeMsb</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">.</span><span class="n">cmn</span><span class="p">.</span><span class="n">bbRcvSizeLsb</span><span class="p">;</span>

	<span class="n">fc_host_dev_loss_tmo</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_devloss_tmo</span><span class="p">;</span>

	<span class="cm">/* This value is also unchanging */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fc_host_active_fc4s</span><span class="p">(</span><span class="n">shost</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">fc_host_active_fc4s</span><span class="p">(</span><span class="n">shost</span><span class="p">)));</span>
	<span class="n">fc_host_active_fc4s</span><span class="p">(</span><span class="n">shost</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">fc_host_active_fc4s</span><span class="p">(</span><span class="n">shost</span><span class="p">)[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">fc_host_max_npiv_vports</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_LOADING</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_stop_port_s3 - Stop SLI3 device port</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to stop an SLI3 device port, it stops the device</span>
<span class="cm"> * from generating interrupts and stops the device driver&#39;s timers for the</span>
<span class="cm"> * device.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_stop_port_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Clear all interrupt enable conditions */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="cm">/* Clear all pending interrupts */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>

	<span class="cm">/* Reset some HBA SLI setup states */</span>
	<span class="n">lpfc_stop_hba_timers</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_stop_port_s4 - Stop SLI4 device port</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to stop an SLI4 device port, it stops the device</span>
<span class="cm"> * from generating interrupts and stops the device driver&#39;s timers for the</span>
<span class="cm"> * device.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_stop_port_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Reset some HBA SLI4 setup states */</span>
	<span class="n">lpfc_stop_hba_timers</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_stop_port - Wrapper function for stopping hba port</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine wraps the actual SLI3 or SLI4 hba stop port routine from</span>
<span class="cm"> * the API jump table function pointer from the lpfc_hba struct.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_stop_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_stop_port</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fcf_redisc_wait_start_timer - Start fcf rediscover wait timer</span>
<span class="cm"> * @phba: Pointer to hba for which this call is being executed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine starts the timer waiting for the FCF rediscovery to complete.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_fcf_redisc_wait_start_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fcf_redisc_wait_tmo</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">LPFC_FCF_REDISCOVER_WAIT_TMO</span><span class="p">));</span>
	<span class="cm">/* Start fcf rediscovery wait period timer */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">redisc_wait</span><span class="p">,</span> <span class="n">fcf_redisc_wait_tmo</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/* Allow action to new fcf asynchronous event */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FCF_AVAILABLE</span> <span class="o">|</span> <span class="n">FCF_SCAN_DONE</span><span class="p">);</span>
	<span class="cm">/* Mark the FCF rediscovery pending state */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">|=</span> <span class="n">FCF_REDISC_PEND</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fcf_redisc_wait_tmo - FCF table rediscover wait timeout</span>
<span class="cm"> * @ptr: Map to lpfc_hba data structure pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked when waiting for FCF table rediscover has been</span>
<span class="cm"> * timed out. If new FCF record(s) has (have) been discovered during the</span>
<span class="cm"> * wait period, a new FCF event shall be added to the FCOE async event</span>
<span class="cm"> * list, and then worker thread shall be waked up for processing from the</span>
<span class="cm"> * worker thread context.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_fcf_redisc_wait_tmo</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t send FCF rediscovery event if timer cancelled */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REDISC_PEND</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Clear FCF rediscovery timer pending flag */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_REDISC_PEND</span><span class="p">;</span>
	<span class="cm">/* FCF rediscovery event to worker thread */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">|=</span> <span class="n">FCF_REDISC_EVT</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
			<span class="s">&quot;2776 FCF rediscover quiescent timer expired</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* wake up worker thread */</span>
	<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_parse_latt_fault - Parse sli4 link-attention link fault code</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @acqe_link: pointer to the async link completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to parse the SLI4 link-attention link fault code and</span>
<span class="cm"> * translate it into the base driver&#39;s read link attention mailbox command</span>
<span class="cm"> * status.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: Link-attention status in terms of base driver&#39;s coding.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint16_t</span>
<span class="nf">lpfc_sli4_parse_latt_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">lpfc_acqe_link</span> <span class="o">*</span><span class="n">acqe_link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">latt_fault</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_link_fault</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_ASYNC_LINK_FAULT_NONE</span>:
	<span class="k">case</span> <span class="n">LPFC_ASYNC_LINK_FAULT_LOCAL</span>:
	<span class="k">case</span> <span class="n">LPFC_ASYNC_LINK_FAULT_REMOTE</span>:
		<span class="n">latt_fault</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0398 Invalid link fault code: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_link_fault</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">));</span>
		<span class="n">latt_fault</span> <span class="o">=</span> <span class="n">MBXERR_ERROR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">latt_fault</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_parse_latt_type - Parse sli4 link attention type</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @acqe_link: pointer to the async link completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to parse the SLI4 link attention type and translate it</span>
<span class="cm"> * into the base driver&#39;s link attention type coding.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: Link attention type in terms of base driver&#39;s coding.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint8_t</span>
<span class="nf">lpfc_sli4_parse_latt_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">lpfc_acqe_link</span> <span class="o">*</span><span class="n">acqe_link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">att_type</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_link_status</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_ASYNC_LINK_STATUS_DOWN</span>:
	<span class="k">case</span> <span class="n">LPFC_ASYNC_LINK_STATUS_LOGICAL_DOWN</span>:
		<span class="n">att_type</span> <span class="o">=</span> <span class="n">LPFC_ATT_LINK_DOWN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_ASYNC_LINK_STATUS_UP</span>:
		<span class="cm">/* Ignore physical link up events - wait for logical link up */</span>
		<span class="n">att_type</span> <span class="o">=</span> <span class="n">LPFC_ATT_RESERVED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_ASYNC_LINK_STATUS_LOGICAL_UP</span>:
		<span class="n">att_type</span> <span class="o">=</span> <span class="n">LPFC_ATT_LINK_UP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0399 Invalid link attention type: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_link_status</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">));</span>
		<span class="n">att_type</span> <span class="o">=</span> <span class="n">LPFC_ATT_RESERVED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">att_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_parse_latt_link_speed - Parse sli4 link-attention link speed</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @acqe_link: pointer to the async link completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to parse the SLI4 link-attention link speed and translate</span>
<span class="cm"> * it into the base driver&#39;s link-attention link speed coding.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: Link-attention link speed in terms of base driver&#39;s coding.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint8_t</span>
<span class="nf">lpfc_sli4_parse_latt_link_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">lpfc_acqe_link</span> <span class="o">*</span><span class="n">acqe_link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">link_speed</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_link_speed</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_ASYNC_LINK_SPEED_ZERO</span>:
	<span class="k">case</span> <span class="n">LPFC_ASYNC_LINK_SPEED_10MBPS</span>:
	<span class="k">case</span> <span class="n">LPFC_ASYNC_LINK_SPEED_100MBPS</span>:
		<span class="n">link_speed</span> <span class="o">=</span> <span class="n">LPFC_LINK_SPEED_UNKNOWN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_ASYNC_LINK_SPEED_1GBPS</span>:
		<span class="n">link_speed</span> <span class="o">=</span> <span class="n">LPFC_LINK_SPEED_1GHZ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_ASYNC_LINK_SPEED_10GBPS</span>:
		<span class="n">link_speed</span> <span class="o">=</span> <span class="n">LPFC_LINK_SPEED_10GHZ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0483 Invalid link-attention link speed: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_link_speed</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">));</span>
		<span class="n">link_speed</span> <span class="o">=</span> <span class="n">LPFC_LINK_SPEED_UNKNOWN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">link_speed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_async_link_evt - Process the asynchronous FCoE link event</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @acqe_link: pointer to the async link completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to handle the SLI4 asynchronous FCoE link event.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_async_link_evt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lpfc_acqe_link</span> <span class="o">*</span><span class="n">acqe_link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_read_top</span> <span class="o">*</span><span class="n">la</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">att_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">att_type</span> <span class="o">=</span> <span class="n">lpfc_sli4_parse_latt_type</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">att_type</span> <span class="o">!=</span> <span class="n">LPFC_ATT_LINK_DOWN</span> <span class="o">&amp;&amp;</span> <span class="n">att_type</span> <span class="o">!=</span> <span class="n">LPFC_ATT_LINK_UP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_eventtag</span> <span class="o">=</span> <span class="n">acqe_link</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">;</span>
	<span class="n">pmb</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0395 The mboxq allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0396 The lpfc_dmabuf allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_pmb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">lpfc_mbuf_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0397 The mbuf allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_dmabuf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Cleanup any outstanding ELS commands */</span>
	<span class="n">lpfc_els_flush_all_cmd</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Block ELS IOCBs until we have done process link event */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">].</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>

	<span class="cm">/* Update link event statistics */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">slistat</span><span class="p">.</span><span class="n">link_event</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Create lpfc_handle_latt mailbox command from link ACQE */</span>
	<span class="n">lpfc_read_topology</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_read_topology</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>

	<span class="cm">/* Keep the link status for extra SLI4 state machine reference */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_link_speed</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">duplex</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_link_duplex</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_link_status</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_link_type</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">number</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_link_number</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">fault</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_link_fault</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">logical_speed</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_logical_link_speed</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">);</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;2900 Async FC/FCoE Link event - Speed:%dGBit &quot;</span>
			<span class="s">&quot;duplex:x%x LA Type:x%x Port Type:%d Port Number:%d &quot;</span>
			<span class="s">&quot;Logical speed:%dMbps Fault:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">speed</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">topology</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">status</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">type</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">number</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">logical_speed</span> <span class="o">*</span> <span class="mi">10</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">fault</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * For FC Mode: issue the READ_TOPOLOGY mailbox command to fetch</span>
<span class="cm">	 * topology info. Note: Optional for non FC-AL ports.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FCOE_MODE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free_dmabuf</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * For FCoE Mode: fill in all the topology information we need and call</span>
<span class="cm">	 * the READ_TOPOLOGY completion routine to continue without actually</span>
<span class="cm">	 * sending the READ_TOPOLOGY mailbox command to the port.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Parse and translate status field */</span>
	<span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span> <span class="o">=</span> <span class="n">lpfc_sli4_parse_latt_fault</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">);</span>

	<span class="cm">/* Parse and translate link attention fields */</span>
	<span class="n">la</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_read_top</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varReadTop</span><span class="p">;</span>
	<span class="n">la</span><span class="o">-&gt;</span><span class="n">eventTag</span> <span class="o">=</span> <span class="n">acqe_link</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_att_type</span><span class="p">,</span> <span class="n">la</span><span class="p">,</span> <span class="n">att_type</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_link_spd</span><span class="p">,</span> <span class="n">la</span><span class="p">,</span>
	       <span class="n">lpfc_sli4_parse_latt_link_speed</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">acqe_link</span><span class="p">));</span>

	<span class="cm">/* Fake the the following irrelvant fields */</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_topology</span><span class="p">,</span> <span class="n">la</span><span class="p">,</span> <span class="n">LPFC_TOPOLOGY_PT_PT</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_alpa_granted</span><span class="p">,</span> <span class="n">la</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_il</span><span class="p">,</span> <span class="n">la</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_pb</span><span class="p">,</span> <span class="n">la</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_fa</span><span class="p">,</span> <span class="n">la</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_read_top_mm</span><span class="p">,</span> <span class="n">la</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Invoke the lpfc_handle_latt mailbox command callback function */</span>
	<span class="n">lpfc_mbx_cmpl_read_topology</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">out_free_dmabuf:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
<span class="nl">out_free_pmb:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_async_fc_evt - Process the asynchronous FC link event</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @acqe_fc: pointer to the async fc completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to handle the SLI4 asynchronous FC event. It will simply log</span>
<span class="cm"> * that the event was received and then issue a read_topology mailbox command so</span>
<span class="cm"> * that the rest of the driver will treat it the same as SLI3.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_async_fc_evt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_acqe_fc_la</span> <span class="o">*</span><span class="n">acqe_fc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_trailer_type</span><span class="p">,</span> <span class="n">acqe_fc</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">LPFC_FC_LA_EVENT_TYPE_FC_LINK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2895 Non FC link Event detected.(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_trailer_type</span><span class="p">,</span> <span class="n">acqe_fc</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Keep the link status for extra SLI4 state machine reference */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_fc_la_speed</span><span class="p">,</span> <span class="n">acqe_fc</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">LPFC_ASYNC_LINK_DUPLEX_FULL</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">topology</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_fc_la_topology</span><span class="p">,</span> <span class="n">acqe_fc</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_fc_la_att_type</span><span class="p">,</span> <span class="n">acqe_fc</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_fc_la_port_type</span><span class="p">,</span> <span class="n">acqe_fc</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">number</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_fc_la_port_number</span><span class="p">,</span> <span class="n">acqe_fc</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">fault</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_link_fault</span><span class="p">,</span> <span class="n">acqe_fc</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">logical_speed</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_fc_la_llink_spd</span><span class="p">,</span> <span class="n">acqe_fc</span><span class="p">);</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;2896 Async FC event - Speed:%dGBaud Topology:x%x &quot;</span>
			<span class="s">&quot;LA Type:x%x Port Type:%d Port Number:%d Logical speed:&quot;</span>
			<span class="s">&quot;%dMbps Fault:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">speed</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">topology</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">status</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">type</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">number</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">logical_speed</span> <span class="o">*</span> <span class="mi">10</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">fault</span><span class="p">);</span>
	<span class="n">pmb</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2897 The mboxq allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2898 The lpfc_dmabuf allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_pmb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">lpfc_mbuf_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2899 The mbuf allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_dmabuf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Cleanup any outstanding ELS commands */</span>
	<span class="n">lpfc_els_flush_all_cmd</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Block ELS IOCBs until we have done process link event */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">].</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">;</span>

	<span class="cm">/* Update link event statistics */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">slistat</span><span class="p">.</span><span class="n">link_event</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Create lpfc_handle_latt mailbox command from link ACQE */</span>
	<span class="n">lpfc_read_topology</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_read_topology</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_dmabuf</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">out_free_dmabuf:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
<span class="nl">out_free_pmb:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_async_sli_evt - Process the asynchronous SLI link event</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @acqe_fc: pointer to the async SLI completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to handle the SLI4 asynchronous SLI events.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_async_sli_evt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_acqe_sli</span> <span class="o">*</span><span class="n">acqe_sli</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;2901 Async SLI event - Event Data1:x%08x Event Data2:&quot;</span>
			<span class="s">&quot;x%08x SLI Event Type:%d&quot;</span><span class="p">,</span>
			<span class="n">acqe_sli</span><span class="o">-&gt;</span><span class="n">event_data1</span><span class="p">,</span> <span class="n">acqe_sli</span><span class="o">-&gt;</span><span class="n">event_data2</span><span class="p">,</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_trailer_type</span><span class="p">,</span> <span class="n">acqe_sli</span><span class="p">));</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_perform_vport_cvl - Perform clear virtual link on a vport</span>
<span class="cm"> * @vport: pointer to vport data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to perform Clear Virtual Link (CVL) on a vport in</span>
<span class="cm"> * response to a CVL event.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the pointer to the ndlp with the vport if successful, otherwise</span>
<span class="cm"> * return NULL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span>
<span class="nf">lpfc_sli4_perform_vport_cvl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vport</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">Fabric_DID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Cannot find existing Fabric ndlp, so allocate a new one */</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nlp_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lpfc_nlp_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">Fabric_DID</span><span class="p">);</span>
		<span class="cm">/* Set the node type */</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">|=</span> <span class="n">NLP_FABRIC</span><span class="p">;</span>
		<span class="cm">/* Put ndlp onto node list */</span>
		<span class="n">lpfc_enqueue_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* re-setup ndlp without removing from node list */</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_enable_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;</span> <span class="n">LPFC_FLOGI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">!=</span> <span class="n">LPFC_VPORT_FAILED</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* If virtual link is not yet instantiated ignore CVL */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span> <span class="o">!=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;</span> <span class="n">LPFC_FDISC</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">!=</span> <span class="n">LPFC_VPORT_FAILED</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lpfc_linkdown_port</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">lpfc_cleanup_pending_mbox</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VPORT_CVL_RCVD</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_perform_all_vport_cvl - Perform clear virtual link on all vports</span>
<span class="cm"> * @vport: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to perform Clear Virtual Link (CVL) on all vports in</span>
<span class="cm"> * response to a FCF dead event.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_perform_all_vport_cvl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">lpfc_sli4_perform_vport_cvl</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_async_fip_evt - Process the asynchronous FCoE FIP event</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @acqe_link: pointer to the async fcoe completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to handle the SLI4 asynchronous fcoe event.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_async_fip_evt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_acqe_fip</span> <span class="o">*</span><span class="n">acqe_fip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">event_type</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_trailer_type</span><span class="p">,</span> <span class="n">acqe_fip</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">active_vlink_present</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span> <span class="o">=</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_eventtag</span> <span class="o">=</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">event_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_FIP_EVENT_TYPE_NEW_FCF</span>:
	<span class="k">case</span> <span class="n">LPFC_FIP_EVENT_TYPE_FCF_PARAM_MOD</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">event_type</span> <span class="o">==</span> <span class="n">LPFC_FIP_EVENT_TYPE_NEW_FCF</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span>
					<span class="n">LOG_DISCOVERY</span><span class="p">,</span>
					<span class="s">&quot;2546 New FCF event, evt_tag:x%x, &quot;</span>
					<span class="s">&quot;index:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">,</span>
					<span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span>
					<span class="n">LOG_DISCOVERY</span><span class="p">,</span>
					<span class="s">&quot;2788 FCF param modified event, &quot;</span>
					<span class="s">&quot;evt_tag:x%x, index:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">,</span>
					<span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_DISCOVERY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * During period of FCF discovery, read the FCF</span>
<span class="cm">			 * table record indexed by the event to update</span>
<span class="cm">			 * FCF roundrobin failover eligible FCF bmask.</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span>
					<span class="n">LOG_DISCOVERY</span><span class="p">,</span>
					<span class="s">&quot;2779 Read FCF (x%x) for updating &quot;</span>
					<span class="s">&quot;roundrobin FCF failover bmask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_read_fcf_rec</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* If the FCF discovery is in progress, do nothing. */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">FCF_TS_INPROG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* If fast FCF failover rescan event is pending, do nothing */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_REDISC_EVT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If the FCF has been in discovered state, do nothing. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_SCAN_DONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

		<span class="cm">/* Otherwise, scan the entire FCF table and re-discover SAN */</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				<span class="s">&quot;2770 Start FCF table scan per async FCF &quot;</span>
				<span class="s">&quot;event, evt_tag:x%x, index:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">,</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_scan_read_fcf_rec</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						     <span class="n">LPFC_FCOE_FCF_GET_FIRST</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
					<span class="s">&quot;2547 Issue FCF scan read FCF mailbox &quot;</span>
					<span class="s">&quot;command failed (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LPFC_FIP_EVENT_TYPE_FCF_TABLE_FULL</span>:
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;2548 FCF Table full count 0x%x tag 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_fip_fcf_count</span><span class="p">,</span> <span class="n">acqe_fip</span><span class="p">),</span>
			<span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LPFC_FIP_EVENT_TYPE_FCF_DEAD</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_cvl_eventtag</span> <span class="o">=</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">;</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			<span class="s">&quot;2549 FCF (x%x) disconnected from network, &quot;</span>
			<span class="s">&quot;tag:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we are in the middle of FCF failover process, clear</span>
<span class="cm">		 * the corresponding FCF bit in the roundrobin bitmap.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_DISCOVERY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="cm">/* Update FLOGI FCF failover eligible FCF bmask */</span>
			<span class="n">lpfc_sli4_fcf_rr_index_clear</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

		<span class="cm">/* If the event is not for currently used fcf do nothing */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span> <span class="o">!=</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Otherwise, request the port to rediscover the entire FCF</span>
<span class="cm">		 * table for a fast recovery from case that the current FCF</span>
<span class="cm">		 * is no longer valid as we are not in the middle of FCF</span>
<span class="cm">		 * failover process already.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="cm">/* Mark the fast failover process in progress */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">|=</span> <span class="n">FCF_DEAD_DISC</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				<span class="s">&quot;2771 Start FCF fast failover process due to &quot;</span>
				<span class="s">&quot;FCF DEAD event: evt_tag:x%x, fcf_index:x%x &quot;</span>
				<span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">,</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_redisc_fcf_table</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span>
					<span class="n">LOG_DISCOVERY</span><span class="p">,</span>
					<span class="s">&quot;2772 Issue FCF rediscover mabilbox &quot;</span>
					<span class="s">&quot;command failed, fail through to FCF &quot;</span>
					<span class="s">&quot;dead event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_DEAD_DISC</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Last resort will fail over by treating this</span>
<span class="cm">			 * as a link down to FCF registration.</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_sli4_fcf_dead_failthrough</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Reset FCF roundrobin bmask for new discovery */</span>
			<span class="n">lpfc_sli4_clear_fcf_rr_bmask</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Handling fast FCF failover to a DEAD FCF event is</span>
<span class="cm">			 * considered equalivant to receiving CVL to all vports.</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_sli4_perform_all_vport_cvl</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_FIP_EVENT_TYPE_CVL</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_cvl_eventtag</span> <span class="o">=</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">;</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			<span class="s">&quot;2718 Clear Virtual Link Received for VPI 0x%x&quot;</span>
			<span class="s">&quot; tag 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">);</span>

		<span class="n">vport</span> <span class="o">=</span> <span class="n">lpfc_find_vport_by_vpid</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_sli4_perform_vport_cvl</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">active_vlink_present</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vports</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span>
					<span class="n">FC_VPORT_CVL_RCVD</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&gt;</span> <span class="n">LPFC_FDISC</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">active_vlink_present</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">active_vlink_present</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If there are other active VLinks present,</span>
<span class="cm">			 * re-instantiate the Vlink using FDISC.</span>
<span class="cm">			 */</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_delayfunc</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">);</span>
			<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_DELAY_TMO</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_last_elscmd</span> <span class="o">=</span> <span class="n">ELS_CMD_FDISC</span><span class="p">;</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_FDISC</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Otherwise, we request port to rediscover</span>
<span class="cm">			 * the entire FCF table for a fast recovery</span>
<span class="cm">			 * from possible case that the current FCF</span>
<span class="cm">			 * is no longer valid if we are not already</span>
<span class="cm">			 * in the FCF failover process.</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_DISCOVERY</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Mark the fast failover process in progress */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">|=</span> <span class="n">FCF_ACVL_DISC</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span>
					<span class="n">LOG_DISCOVERY</span><span class="p">,</span>
					<span class="s">&quot;2773 Start FCF failover per CVL, &quot;</span>
					<span class="s">&quot;evt_tag:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_redisc_fcf_table</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span>
						<span class="n">LOG_DISCOVERY</span><span class="p">,</span>
						<span class="s">&quot;2774 Issue FCF rediscover &quot;</span>
						<span class="s">&quot;mabilbox command failed, &quot;</span>
						<span class="s">&quot;through to CVL event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_ACVL_DISC</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * Last resort will be re-try on the</span>
<span class="cm">				 * the current registered FCF entry.</span>
<span class="cm">				 */</span>
				<span class="n">lpfc_retry_pport_discovery</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="cm">/*</span>
<span class="cm">				 * Reset FCF roundrobin bmask for new</span>
<span class="cm">				 * discovery.</span>
<span class="cm">				 */</span>
				<span class="n">lpfc_sli4_clear_fcf_rr_bmask</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0288 Unknown FCoE event type 0x%x event tag &quot;</span>
			<span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">acqe_fip</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_async_dcbx_evt - Process the asynchronous dcbx event</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @acqe_link: pointer to the async dcbx completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to handle the SLI4 asynchronous dcbx event.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_async_dcbx_evt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lpfc_acqe_dcbx</span> <span class="o">*</span><span class="n">acqe_dcbx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span> <span class="o">=</span> <span class="n">acqe_dcbx</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">;</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0290 The SLI4 DCBX asynchronous event is not &quot;</span>
			<span class="s">&quot;handled yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_async_grp5_evt - Process the asynchronous group5 event</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @acqe_link: pointer to the async grp5 completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to handle the SLI4 asynchronous grp5 event. A grp5 event</span>
<span class="cm"> * is an asynchronous notified of a logical link speed change.  The Port</span>
<span class="cm"> * reports the logical link speed in units of 10Mbps.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_async_grp5_evt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lpfc_acqe_grp5</span> <span class="o">*</span><span class="n">acqe_grp5</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">prev_ll_spd</span><span class="p">;</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span> <span class="o">=</span> <span class="n">acqe_grp5</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_eventtag</span> <span class="o">=</span> <span class="n">acqe_grp5</span><span class="o">-&gt;</span><span class="n">event_tag</span><span class="p">;</span>
	<span class="n">prev_ll_spd</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">logical_speed</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">logical_speed</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_acqe_grp5_llink_spd</span><span class="p">,</span> <span class="n">acqe_grp5</span><span class="p">));</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;2789 GRP5 Async Event: Updating logical link speed &quot;</span>
			<span class="s">&quot;from %dMbps to %dMbps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">prev_ll_spd</span> <span class="o">*</span> <span class="mi">10</span><span class="p">),</span>
			<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">logical_speed</span><span class="o">*</span><span class="mi">10</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_async_event_proc - Process all the pending asynchronous event</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked by the worker thread to process all the pending</span>
<span class="cm"> * SLI4 asynchronous events.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">lpfc_sli4_async_event_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span><span class="n">cq_event</span><span class="p">;</span>

	<span class="cm">/* First, declare the async event has been handled */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ASYNC_EVENT</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/* Now, handle all the async events */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_asynce_work_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Get the first event from the head of the event queue */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_asynce_work_queue</span><span class="p">,</span>
				 <span class="n">cq_event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_cq_event</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="cm">/* Process the asynchronous event */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_trailer_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">cqe</span><span class="p">.</span><span class="n">mcqe_cmpl</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LPFC_TRAILER_CODE_LINK</span>:
			<span class="n">lpfc_sli4_async_link_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">cqe</span><span class="p">.</span><span class="n">acqe_link</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_TRAILER_CODE_FCOE</span>:
			<span class="n">lpfc_sli4_async_fip_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">cqe</span><span class="p">.</span><span class="n">acqe_fip</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_TRAILER_CODE_DCBX</span>:
			<span class="n">lpfc_sli4_async_dcbx_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">cqe</span><span class="p">.</span><span class="n">acqe_dcbx</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_TRAILER_CODE_GRP5</span>:
			<span class="n">lpfc_sli4_async_grp5_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">cqe</span><span class="p">.</span><span class="n">acqe_grp5</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_TRAILER_CODE_FC</span>:
			<span class="n">lpfc_sli4_async_fc_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">cqe</span><span class="p">.</span><span class="n">acqe_fc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_TRAILER_CODE_SLI</span>:
			<span class="n">lpfc_sli4_async_sli_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">cqe</span><span class="p">.</span><span class="n">acqe_sli</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;1804 Invalid asynchrous event code: &quot;</span>
					<span class="s">&quot;x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_trailer_code</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">cqe</span><span class="p">.</span><span class="n">mcqe_cmpl</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Free the completion event processed to the free pool */</span>
		<span class="n">lpfc_sli4_cq_event_release</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cq_event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fcf_redisc_event_proc - Process fcf table rediscovery event</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked by the worker thread to process FCF table</span>
<span class="cm"> * rediscovery pending completion event.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">lpfc_sli4_fcf_redisc_event_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/* Clear FCF rediscovery timeout event */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_REDISC_EVT</span><span class="p">;</span>
	<span class="cm">/* Clear driver fast failover FCF record flag */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">failover_rec</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Set state for FCF fast failover */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">|=</span> <span class="n">FCF_REDISC_FOV</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Scan FCF table from the first entry to re-discover SAN */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			<span class="s">&quot;2777 Start post-quiescent FCF table scan</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_scan_read_fcf_rec</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_FCOE_FCF_GET_FIRST</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
				<span class="s">&quot;2747 Issue FCF scan read FCF mailbox &quot;</span>
				<span class="s">&quot;command failed 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_api_table_setup - Set up per hba pci-device group func api jump table</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @dev_grp: The HBA PCI-Device group number.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to set up the per HBA PCI-Device group function</span>
<span class="cm"> * API jump table entries.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: 0 if success, otherwise -ENODEV</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_api_table_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">dev_grp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Set up lpfc PCI-device group */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span> <span class="o">=</span> <span class="n">dev_grp</span><span class="p">;</span>

	<span class="cm">/* The LPFC_PCI_DEV_OC uses SLI4 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_grp</span> <span class="o">==</span> <span class="n">LPFC_PCI_DEV_OC</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">=</span> <span class="n">LPFC_SLI_REV4</span><span class="p">;</span>

	<span class="cm">/* Set up device INIT API function jump table */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_init_api_table_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">dev_grp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="cm">/* Set up SCSI API function jump table */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_scsi_api_table_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">dev_grp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="cm">/* Set up SLI API function jump table */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_api_table_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">dev_grp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="cm">/* Set up MBOX API function jump table */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_mbox_api_table_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">dev_grp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_log_intr_mode - Log the active interrupt mode</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @intr_mode: active interrupt mode adopted.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine it invoked to log the currently used active interrupt mode</span>
<span class="cm"> * to the device.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lpfc_log_intr_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">intr_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">intr_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0470 Enable INTx interrupt mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0481 Enabled MSI interrupt mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0480 Enabled MSI-X interrupt mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0482 Illegal interrupt mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_enable_pci_dev - Enable a generic PCI device.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to enable the PCI device that is common to all</span>
<span class="cm"> * PCI devices.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> * 	other values - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_enable_pci_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bars</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Obtain PCI device reference */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">;</span>
	<span class="cm">/* Select PCI BARs */</span>
	<span class="n">bars</span> <span class="o">=</span> <span class="n">pci_select_bars</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">);</span>
	<span class="cm">/* Enable PCI device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
	<span class="cm">/* Request PCI resource for the device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_request_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bars</span><span class="p">,</span> <span class="n">LPFC_DRIVER_NAME</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_disable_device</span><span class="p">;</span>
	<span class="cm">/* Set up device as PCI master and save state for EEH */</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_try_set_mwi</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* PCIe EEH recovery on powerpc platforms needs fundamental reset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_find_capability</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_EXP</span><span class="p">))</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">needs_freset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_disable_device:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">out_error:</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;1401 Failed to enable pci device, bars:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bars</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_disable_pci_dev - Disable a generic PCI device.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to disable the PCI device that is common to all</span>
<span class="cm"> * PCI devices.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_disable_pci_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bars</span><span class="p">;</span>

	<span class="cm">/* Obtain PCI device reference */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">;</span>
	<span class="cm">/* Select PCI BARs */</span>
	<span class="n">bars</span> <span class="o">=</span> <span class="n">pci_select_bars</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">);</span>
	<span class="cm">/* Release PCI resource and disable PCI device */</span>
	<span class="n">pci_release_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bars</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="cm">/* Null out PCI private reference to driver */</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_reset_hba - Reset a hba</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to reset a hba device. It brings the HBA</span>
<span class="cm"> * offline, performs a board restart, and then brings the board back</span>
<span class="cm"> * online. The lpfc_offline calls lpfc_sli_hba_down which will clean up</span>
<span class="cm"> * on outstanding mailbox commands.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_reset_hba</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If resets are disabled then set error state and return. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_hba_reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_offline_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_online</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_sriov_nr_virtfn_get - Get the number of sr-iov virtual functions</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function enables the PCI SR-IOV virtual functions to a physical</span>
<span class="cm"> * function. It invokes the PCI SR-IOV api with the @nr_vfn provided to</span>
<span class="cm"> * enable the number of virtual functions to the physical function. As</span>
<span class="cm"> * not all devices support SR-IOV, the return code from the pci_enable_sriov()</span>
<span class="cm"> * API call does not considered as an error condition for most of the device.</span>
<span class="cm"> **/</span>
<span class="kt">uint16_t</span>
<span class="nf">lpfc_sli_sriov_nr_virtfn_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">nr_virtfn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_ext_capability</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_EXT_CAP_ID_SRIOV</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_SRIOV_TOTAL_VF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_virtfn</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nr_virtfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_probe_sriov_nr_virtfn - Enable a number of sr-iov virtual functions</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @nr_vfn: number of virtual functions to be enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * This function enables the PCI SR-IOV virtual functions to a physical</span>
<span class="cm"> * function. It invokes the PCI SR-IOV api with the @nr_vfn provided to</span>
<span class="cm"> * enable the number of virtual functions to the physical function. As</span>
<span class="cm"> * not all devices support SR-IOV, the return code from the pci_enable_sriov()</span>
<span class="cm"> * API call does not considered as an error condition for most of the device.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_probe_sriov_nr_virtfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_vfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">max_nr_vfn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">max_nr_vfn</span> <span class="o">=</span> <span class="n">lpfc_sli_sriov_nr_virtfn_get</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_vfn</span> <span class="o">&gt;</span> <span class="n">max_nr_vfn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3057 Requested vfs (%d) greater than &quot;</span>
				<span class="s">&quot;supported vfs (%d)&quot;</span><span class="p">,</span> <span class="n">nr_vfn</span><span class="p">,</span> <span class="n">max_nr_vfn</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_sriov</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">nr_vfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2806 Failed to enable sriov on this device &quot;</span>
				<span class="s">&quot;with vfn number nr_vf:%d, rc:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">nr_vfn</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2807 Successful enable sriov on this device &quot;</span>
				<span class="s">&quot;with vfn number nr_vf:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nr_vfn</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_driver_resource_setup - Setup driver internal resources for SLI3 dev.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to set up the driver internal resources specific to</span>
<span class="cm"> * support the SLI-3 HBA device it attached to.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> * 	other values - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_driver_resource_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize timers used by driver</span>
<span class="cm">	 */</span>

	<span class="cm">/* Heartbeat timer */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_hb_timeout</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">phba</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="cm">/* MBOX heartbeat timer */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_tmo</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_mbox_timeout</span><span class="p">;</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_tmo</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">phba</span><span class="p">;</span>
	<span class="cm">/* FCP polling mode timer */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcp_poll_timer</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcp_poll_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_poll_timeout</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcp_poll_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">phba</span><span class="p">;</span>
	<span class="cm">/* Fabric block timer */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_block_timer</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_block_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_fabric_block_timeout</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_block_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">phba</span><span class="p">;</span>
	<span class="cm">/* EA polling mode timer */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">eratt_poll</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">eratt_poll</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_poll_eratt</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">eratt_poll</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">phba</span><span class="p">;</span>

	<span class="cm">/* Host attention work mask setup */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">HA_ERATT</span> <span class="o">|</span> <span class="n">HA_MBATT</span> <span class="o">|</span> <span class="n">HA_LATT</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">HA_RXMASK</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">LPFC_ELS_RING</span> <span class="o">*</span> <span class="mi">4</span><span class="p">));</span>

	<span class="cm">/* Get all the module params for configuring this host */</span>
	<span class="n">lpfc_get_cfgparam</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_HORNET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">menlo_flag</span> <span class="o">|=</span> <span class="n">HBA_MENLO_SUPPORT</span><span class="p">;</span>
		<span class="cm">/* check for menlo minimum sg count */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span> <span class="o">&lt;</span> <span class="n">LPFC_DEFAULT_MENLO_SG_SEG_CNT</span><span class="p">)</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span> <span class="o">=</span> <span class="n">LPFC_DEFAULT_MENLO_SG_SEG_CNT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since the sg_tablesize is module parameter, the sg_dma_buf_size</span>
<span class="cm">	 * used to create the sg_dma_buf_pool must be dynamically calculated.</span>
<span class="cm">	 * 2 segments are added since the IOCB needs a command and response bde.</span>
<span class="cm">	 */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_dma_buf_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">)</span> <span class="o">+</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_rsp</span><span class="p">)</span> <span class="o">+</span>
			<span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_bg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span> <span class="o">=</span> <span class="n">LPFC_MAX_SG_SEG_CNT</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_dma_buf_size</span> <span class="o">+=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_prot_sg_seg_cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Also reinitialize the host templates with new values. */</span>
	<span class="n">lpfc_vport_template</span><span class="p">.</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span><span class="p">;</span>
	<span class="n">lpfc_template</span><span class="p">.</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span><span class="p">;</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span> <span class="o">=</span> <span class="n">LPFC_MAX_VPI</span><span class="p">;</span>
	<span class="cm">/* This will be set to correct value after config_port mbox */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the SLI Layer to run with lpfc HBAs.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_sli_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_sli_queue_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Allocate device driver memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_mem_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">BPL_ALIGN_SZ</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable sr-iov virtual functions if supported and configured</span>
<span class="cm">	 * through the module parameter.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_probe_sriov_nr_virtfn</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						 <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2808 Requested number of SR-IOV &quot;</span>
					<span class="s">&quot;virtual functions (%d) is not &quot;</span>
					<span class="s">&quot;supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_driver_resource_unset - Unset drvr internal resources for SLI3 dev</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to unset the driver internal resources set up</span>
<span class="cm"> * specific for supporting the SLI-3 HBA device it attached to.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_driver_resource_unset</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Free device driver memory allocated */</span>
	<span class="n">lpfc_mem_free_all</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_driver_resource_setup - Setup drvr internal resources for SLI4 dev</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to set up the driver internal resources specific to</span>
<span class="cm"> * support the SLI-4 HBA device it attached to.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> * 	other values - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_driver_resource_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">hbq_count</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">,</span> <span class="n">dma_buf_size</span><span class="p">,</span> <span class="n">max_buf_size</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">pn_page</span><span class="p">[</span><span class="n">LPFC_MAX_SUPPORTED_PAGES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="k">struct</span> <span class="n">lpfc_mqe</span> <span class="o">*</span><span class="n">mqe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">longs</span><span class="p">,</span> <span class="n">sli_family</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sges_per_segment</span><span class="p">;</span>

	<span class="cm">/* Before proceed, wait for POST done and device ready */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_post_status_check</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize timers used by driver</span>
<span class="cm">	 */</span>

	<span class="cm">/* Heartbeat timer */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_hb_timeout</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">rrq_tmr</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">rrq_tmr</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_rrq_timeout</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">rrq_tmr</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">phba</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="cm">/* MBOX heartbeat timer */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_tmo</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_mbox_timeout</span><span class="p">;</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_tmo</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">phba</span><span class="p">;</span>
	<span class="cm">/* Fabric block timer */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_block_timer</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_block_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_fabric_block_timeout</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_block_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">phba</span><span class="p">;</span>
	<span class="cm">/* EA polling mode timer */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">eratt_poll</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">eratt_poll</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_poll_eratt</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">eratt_poll</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">phba</span><span class="p">;</span>
	<span class="cm">/* FCF rediscover timer */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">redisc_wait</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">redisc_wait</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_redisc_wait_tmo</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">redisc_wait</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">phba</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Control structure for handling external multi-buffer mailbox</span>
<span class="cm">	 * command pass-through.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_ext_buf_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbox_ext_buf_ctx</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_ext_buf_ctx</span><span class="p">.</span><span class="n">ext_dmabuf_list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to do a READ_CONFIG mailbox command here before</span>
<span class="cm">	 * calling lpfc_get_cfgparam. For VFs this will report the</span>
<span class="cm">	 * MAX_XRI, MAX_VPI, MAX_RPI, MAX_IOCB, and MAX_VFI settings.</span>
<span class="cm">	 * All of the resources allocated</span>
<span class="cm">	 * for this Port are tied to these values.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Get all the module params for configuring this host */</span>
	<span class="n">lpfc_get_cfgparam</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span> <span class="o">=</span> <span class="n">LPFC_MAX_VPI</span><span class="p">;</span>
	<span class="cm">/* This will be set to correct value after the read_config mbox */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Program the default value of vlan_id and fc_map */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">valid_vlan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">LPFC_FCOE_FCF_MAP0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">LPFC_FCOE_FCF_MAP1</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">LPFC_FCOE_FCF_MAP2</span><span class="p">;</span>

	<span class="cm">/* With BlockGuard we can have multiple SGEs per Data Segemnt */</span>
	<span class="n">sges_per_segment</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_bg</span><span class="p">)</span>
		<span class="n">sges_per_segment</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since the sg_tablesize is module parameter, the sg_dma_buf_size</span>
<span class="cm">	 * used to create the sg_dma_buf_pool must be dynamically calculated.</span>
<span class="cm">	 * 2 segments are added since the IOCB needs a command and response bde.</span>
<span class="cm">	 * To insure that the scsi sgl does not cross a 4k page boundary only</span>
<span class="cm">	 * sgl sizes of must be a power of 2.</span>
<span class="cm">	 */</span>
	<span class="n">buf_size</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_rsp</span><span class="p">)</span> <span class="o">+</span>
		    <span class="p">(((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span> <span class="o">*</span> <span class="n">sges_per_segment</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sli4_sge</span><span class="p">)));</span>

	<span class="n">sli_family</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_sli_family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">);</span>
	<span class="n">max_buf_size</span> <span class="o">=</span> <span class="n">LPFC_SLI4_MAX_BUF_SIZE</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sli_family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_FAMILY_BE2</span>:
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_FAMILY_BE3</span>:
		<span class="cm">/* There is a single hint for BE - 2 pages per BPL. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_sli_hint1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">LPFC_SLI_INTF_SLI_HINT1_1</span><span class="p">)</span>
			<span class="n">max_buf_size</span> <span class="o">=</span> <span class="n">LPFC_SLI4_FL1_MAX_BUF_SIZE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_FAMILY_LNCR_A0</span>:
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_FAMILY_LNCR_B0</span>:
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">dma_buf_size</span> <span class="o">=</span> <span class="n">LPFC_SLI4_MIN_BUF_SIZE</span><span class="p">;</span>
	     <span class="n">dma_buf_size</span> <span class="o">&lt;</span> <span class="n">max_buf_size</span> <span class="o">&amp;&amp;</span> <span class="n">buf_size</span> <span class="o">&gt;</span> <span class="n">dma_buf_size</span><span class="p">;</span>
	     <span class="n">dma_buf_size</span> <span class="o">=</span> <span class="n">dma_buf_size</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_buf_size</span> <span class="o">==</span> <span class="n">max_buf_size</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_buf_size</span> <span class="o">-</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_rsp</span><span class="p">)</span> <span class="o">-</span>
			<span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sli4_sge</span><span class="p">)))</span> <span class="o">/</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sli4_sge</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_dma_buf_size</span> <span class="o">=</span> <span class="n">dma_buf_size</span><span class="p">;</span>

	<span class="cm">/* Initialize buffer queue management fields */</span>
	<span class="n">hbq_count</span> <span class="o">=</span> <span class="n">lpfc_sli_hbq_count</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hbq_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hbq_buffer_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">rb_pend_list</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">LPFC_ELS_HBQ</span><span class="p">].</span><span class="n">hbq_alloc_buffer</span> <span class="o">=</span> <span class="n">lpfc_sli4_rb_alloc</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">LPFC_ELS_HBQ</span><span class="p">].</span><span class="n">hbq_free_buffer</span> <span class="o">=</span> <span class="n">lpfc_sli4_rb_free</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the SLI Layer to run with lpfc SLI4 HBAs.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Initialize the Abort scsi buffer list used by driver */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_scsi_buf_list_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_scsi_buf_list</span><span class="p">);</span>
	<span class="cm">/* This abort list used by worker thread */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_sgl_list_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize driver internal slow-path work queues</span>
<span class="cm">	 */</span>

	<span class="cm">/* Driver internel slow-path CQ Event pool */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_cqe_event_pool</span><span class="p">);</span>
	<span class="cm">/* Response IOCB work queue list */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_queue_event</span><span class="p">);</span>
	<span class="cm">/* Asynchronous event CQ Event work queue list */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_asynce_work_queue</span><span class="p">);</span>
	<span class="cm">/* Fast-path XRI aborted CQ Event work queue list */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_fcp_xri_aborted_work_queue</span><span class="p">);</span>
	<span class="cm">/* Slow-path XRI aborted CQ Event work queue list */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_els_xri_aborted_work_queue</span><span class="p">);</span>
	<span class="cm">/* Receive queue CQ Event work queue list */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_unsol_work_queue</span><span class="p">);</span>

	<span class="cm">/* Initialize extent block lists. */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_rpi_blk_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_xri_blk_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_vfi_blk_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_vpi_blk_list</span><span class="p">);</span>

	<span class="cm">/* Initialize the driver internal SLI layer lists. */</span>
	<span class="n">lpfc_sli_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_sli_queue_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Allocate device driver memory */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_mem_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">SGL_ALIGN_SZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* IF Type 2 ports get initialized now. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">LPFC_SLI_INTF_IF_TYPE_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_pci_function_reset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Create the bootstrap mailbox command */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_create_bootstrap_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free_mem</span><span class="p">;</span>

	<span class="cm">/* Set up the host&#39;s endian order with the device. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_setup_endian_order</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free_bsmbx</span><span class="p">;</span>

	<span class="cm">/* Set up the hba&#39;s configuration parameters. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_read_config</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free_bsmbx</span><span class="p">;</span>

	<span class="cm">/* IF Type 0 ports get initialized now. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">LPFC_SLI_INTF_IF_TYPE_0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_pci_function_reset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_free_bsmbx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mboxq</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span>
						       <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_bsmbx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the Supported Pages if PORT_CAPABILITIES is supported by port. */</span>
	<span class="n">lpfc_supported_pages</span><span class="p">(</span><span class="n">mboxq</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mqe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pn_page</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">supp_pages</span><span class="p">.</span><span class="n">word3</span><span class="p">),</span>
		       <span class="n">LPFC_MAX_SUPPORTED_PAGES</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPFC_MAX_SUPPORTED_PAGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">pn_page</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">LPFC_SLI4_PARAMETERS</span>:
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">supported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Read the port&#39;s SLI4 Parameters capabilities if supported. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">supported</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_pc_sli4_params_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free_bsmbx</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get sli4 parameters that override parameters from Port capabilities.</span>
<span class="cm">	 * If this call fails, it isn&#39;t critical unless the SLI4 parameters come</span>
<span class="cm">	 * back in conflict.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_get_sli4_parameters</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">extents_in_use</span> <span class="o">&amp;&amp;</span>
		    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_hdrs_in_use</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2999 Unsupported SLI4 Parameters &quot;</span>
				<span class="s">&quot;Extents and RPI headers enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_bsmbx</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="cm">/* Verify all the SLI4 queues */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_queue_verify</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_bsmbx</span><span class="p">;</span>

	<span class="cm">/* Create driver internal CQE event pool */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_cq_event_pool_create</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_bsmbx</span><span class="p">;</span>

	<span class="cm">/* Initialize sgl lists per host */</span>
	<span class="n">lpfc_init_sgl_list</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Allocate and initialize active sgl array */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_init_active_sgl_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1430 Failed to initialize sgl list.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_destroy_cq_event_pool</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_init_rpi_hdrs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1432 Failed to initialize rpi headers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_active_sgl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate eligible FCF bmask memory for FCF roundrobin failover */</span>
	<span class="n">longs</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span> <span class="o">+</span> <span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">longs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
					 <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2759 Failed allocate memory for FCF round &quot;</span>
				<span class="s">&quot;robin failover bmask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_remove_rpi_hdrs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The cfg_fcp_eq_count can be zero whenever there is exactly one</span>
<span class="cm">	 * interrupt vector.  This is not an error</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_eq_hdl</span> <span class="o">=</span>
				<span class="n">kzalloc</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fcp_eq_hdl</span><span class="p">)</span> <span class="o">*</span>
				    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_eq_hdl</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2572 Failed allocate memory for &quot;</span>
					<span class="s">&quot;fast-path per-EQ handle array</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free_fcf_rr_bmask</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_entries</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msix_entry</span><span class="p">)</span> <span class="o">*</span>
				      <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">cfg_eqn</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2573 Failed allocate memory for msi-x &quot;</span>
				<span class="s">&quot;interrupt vector entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_fcp_eq_hdl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable sr-iov virtual functions if supported and configured</span>
<span class="cm">	 * through the module parameter.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_probe_sriov_nr_virtfn</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						 <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;3020 Requested number of SR-IOV &quot;</span>
					<span class="s">&quot;virtual functions (%d) is not &quot;</span>
					<span class="s">&quot;supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_fcp_eq_hdl:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_eq_hdl</span><span class="p">);</span>
<span class="nl">out_free_fcf_rr_bmask:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">);</span>
<span class="nl">out_remove_rpi_hdrs:</span>
	<span class="n">lpfc_sli4_remove_rpi_hdrs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_free_active_sgl:</span>
	<span class="n">lpfc_free_active_sgl</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_destroy_cq_event_pool:</span>
	<span class="n">lpfc_sli4_cq_event_pool_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_free_bsmbx:</span>
	<span class="n">lpfc_destroy_bootstrap_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_free_mem:</span>
	<span class="n">lpfc_mem_free</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_driver_resource_unset - Unset drvr internal resources for SLI4 dev</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to unset the driver internal resources set up</span>
<span class="cm"> * specific for supporting the SLI-4 HBA device it attached to.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_driver_resource_unset</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_conn_entry</span> <span class="o">*</span><span class="n">conn_entry</span><span class="p">,</span> <span class="o">*</span><span class="n">next_conn_entry</span><span class="p">;</span>

	<span class="cm">/* Free memory allocated for msi-x interrupt vector entries */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">);</span>

	<span class="cm">/* Free memory allocated for fast-path work queue handles */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_eq_hdl</span><span class="p">);</span>

	<span class="cm">/* Free the allocated rpi headers. */</span>
	<span class="n">lpfc_sli4_remove_rpi_hdrs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_sli4_remove_rpis</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Free eligible FCF index bmask */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">);</span>

	<span class="cm">/* Free the ELS sgl list */</span>
	<span class="n">lpfc_free_active_sgl</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_free_els_sgl_list</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Free the completion queue EQ event pool */</span>
	<span class="n">lpfc_sli4_cq_event_release_all</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_sli4_cq_event_pool_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Release resource identifiers. */</span>
	<span class="n">lpfc_sli4_dealloc_resource_identifiers</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Free the bsmbx region. */</span>
	<span class="n">lpfc_destroy_bootstrap_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Free the SLI Layer memory with SLI4 HBAs */</span>
	<span class="n">lpfc_mem_free_all</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Free the current connect table */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">conn_entry</span><span class="p">,</span> <span class="n">next_conn_entry</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf_conn_rec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn_entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">conn_entry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_init_api_table_setup - Set up init api function jump table</span>
<span class="cm"> * @phba: The hba struct for which this call is being executed.</span>
<span class="cm"> * @dev_grp: The HBA PCI-Device group number.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine sets up the device INIT interface API function jump table</span>
<span class="cm"> * in @phba struct.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 - success, -ENODEV - failure.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_init_api_table_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">dev_grp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_hba_init_link</span> <span class="o">=</span> <span class="n">lpfc_hba_init_link</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_hba_down_link</span> <span class="o">=</span> <span class="n">lpfc_hba_down_link</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_selective_reset</span> <span class="o">=</span> <span class="n">lpfc_selective_reset</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dev_grp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_LP</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_hba_down_post</span> <span class="o">=</span> <span class="n">lpfc_hba_down_post_s3</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_handle_eratt</span> <span class="o">=</span> <span class="n">lpfc_handle_eratt_s3</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_stop_port</span> <span class="o">=</span> <span class="n">lpfc_stop_port_s3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_OC</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_hba_down_post</span> <span class="o">=</span> <span class="n">lpfc_hba_down_post_s4</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_handle_eratt</span> <span class="o">=</span> <span class="n">lpfc_handle_eratt_s4</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_stop_port</span> <span class="o">=</span> <span class="n">lpfc_stop_port_s4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1431 Invalid HBA PCI-device group: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev_grp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_setup_driver_resource_phase1 - Phase1 etup driver internal resources.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to set up the driver internal resources before the</span>
<span class="cm"> * device specific resource setup to support the HBA device it attached to.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *	0 - successful</span>
<span class="cm"> *	other values - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_setup_driver_resource_phase1</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Driver resources common to all SLI revisions</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fast_event_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Initialize ndlp management spinlock */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">port_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">wait_4_mlo_m_q</span><span class="p">);</span>

	<span class="cm">/* Initialize the wait queue head for the kernel thread */</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_waitq</span><span class="p">);</span>

	<span class="cm">/* Initialize the scsi buffer list used by driver for scsi IO */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_buf_list</span><span class="p">);</span>

	<span class="cm">/* Initialize the fabric iocb list */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_list</span><span class="p">);</span>

	<span class="cm">/* Initialize list to save ELS buffers */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf</span><span class="p">);</span>

	<span class="cm">/* Initialize FCF connection rec list */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf_conn_rec_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_setup_driver_resource_phase2 - Phase2 setup driver internal resources.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to set up the driver internal resources after the</span>
<span class="cm"> * device specific resource setup to support the HBA device it attached to.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> * 	other values - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_setup_driver_resource_phase2</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* Startup the kernel thread for this host adapter. */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">lpfc_do_work</span><span class="p">,</span> <span class="n">phba</span><span class="p">,</span>
					  <span class="s">&quot;lpfc_worker_%d&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">brd_no</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_unset_driver_resource_phase2 - Phase2 unset driver internal resources.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to unset the driver internal resources set up after</span>
<span class="cm"> * the device specific resource setup for supporting the HBA device it</span>
<span class="cm"> * attached to.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_unset_driver_resource_phase2</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Stop kernel worker thread */</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_free_iocb_list - Free iocb list.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to free the driver&#39;s IOCB list and memory.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_free_iocb_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">iocbq_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">iocbq_entry</span><span class="p">,</span> <span class="n">iocbq_next</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_iocb_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocbq_entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iocbq_entry</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">total_iocbq_bufs</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_init_iocb_list - Allocate and initialize iocb list.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to allocate and initizlize the driver&#39;s IOCB</span>
<span class="cm"> * list and set up the IOCB tag array accordingly.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *	0 - successful</span>
<span class="cm"> *	other values - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_init_iocb_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iocb_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">iotag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Initialize and populate the iocb list per host.  */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_iocb_list</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iocb_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iocbq_entry</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_iocbq</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iocbq_entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: only allocated %d iocbs of &quot;</span>
				<span class="s">&quot;expected %d count. Unloading driver.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">LPFC_IOCB_LIST_CNT</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_iocbq</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">iotag</span> <span class="o">=</span> <span class="n">lpfc_sli_next_iotag</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">iocbq_entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iotag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">iocbq_entry</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: failed to allocate IOTAG. &quot;</span>
				<span class="s">&quot;Unloading driver.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_iocbq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iocbq_entry</span><span class="o">-&gt;</span><span class="n">sli4_lxritag</span> <span class="o">=</span> <span class="n">NO_XRI</span><span class="p">;</span>
		<span class="n">iocbq_entry</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span> <span class="o">=</span> <span class="n">NO_XRI</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocbq_entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_iocb_list</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">total_iocbq_bufs</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_iocbq:</span>
	<span class="n">lpfc_free_iocb_list</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_free_sgl_list - Free a given sgl list.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @sglq_list: pointer to the head of sgl list.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to free a give sgl list and memory.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_free_sgl_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">sglq_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">sglq_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sglq_entry</span><span class="p">,</span> <span class="n">sglq_next</span><span class="p">,</span> <span class="n">sglq_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sglq_entry</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_free_els_sgl_list - Free els sgl list.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to free the driver&#39;s els sgl list and memory.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_free_els_sgl_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">sglq_list</span><span class="p">);</span>

	<span class="cm">/* Retrieve all els sgls from driver list */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sgl_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sglq_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Now free the sgl list */</span>
	<span class="n">lpfc_free_sgl_list</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sglq_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_init_active_sgl_array - Allocate the buf to track active ELS XRIs.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to allocate the driver&#39;s active sgl memory.</span>
<span class="cm"> * This array will hold the sglq_entry&#39;s for active IOs.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_init_active_sgl_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">*=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_xri</span><span class="p">;</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sglq_active_list</span> <span class="o">=</span>
		<span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sglq_active_list</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_free_active_sgl - Free the buf that tracks active ELS XRIs.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to walk through the array of active sglq entries</span>
<span class="cm"> * and free all of the resources.</span>
<span class="cm"> * This is just a place holder for now.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_free_active_sgl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sglq_active_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_init_sgl_list - Allocate and initialize sgl list.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to allocate and initizlize the driver&#39;s sgl</span>
<span class="cm"> * list and set up the sgl xritag tag array accordingly.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_init_sgl_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Initialize and populate the sglq list per host/VF. */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sgl_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_els_sgl_list</span><span class="p">);</span>

	<span class="cm">/* els xri-sgl book keeping */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_xri_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* scsi xri-buffer book keeping */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">scsi_xri_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_init_rpi_hdrs - Post the rpi header memory region to the port</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to post rpi header templates to the</span>
<span class="cm"> * port for those SLI4 ports that do not support extents.  This routine</span>
<span class="cm"> * posts a PAGE_SIZE memory region to the port to hold up to</span>
<span class="cm"> * PAGE_SIZE modulo 64 rpi context headers.  This is an initialization routine</span>
<span class="cm"> * and should be called only when interrupts are disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> *	-ERROR - otherwise.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_init_rpi_hdrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rpi_hdr</span> <span class="o">*</span><span class="n">rpi_hdr</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_rpi_hdr_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_hdrs_in_use</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">extents_in_use</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">rpi_hdr</span> <span class="o">=</span> <span class="n">lpfc_sli4_create_rpi_hdr</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rpi_hdr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0391 Error during rpi post operation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">lpfc_sli4_remove_rpis</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_create_rpi_hdr - Allocate an rpi header memory region</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to allocate a single 4KB memory region to</span>
<span class="cm"> * support rpis and stores them in the phba.  This single region</span>
<span class="cm"> * provides support for up to 64 rpis.  The region is used globally</span>
<span class="cm"> * by the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   A valid rpi hdr on success.</span>
<span class="cm"> *   A NULL pointer on any failure.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_rpi_hdr</span> <span class="o">*</span>
<span class="nf">lpfc_sli4_create_rpi_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">rpi_limit</span><span class="p">,</span> <span class="n">curr_rpi_range</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rpi_hdr</span> <span class="o">*</span><span class="n">rpi_hdr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">rpi_count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the SLI4 port supports extents, posting the rpi header isn&#39;t</span>
<span class="cm">	 * required.  Set the expected maximum count and let the actual value</span>
<span class="cm">	 * get set when extents are fully allocated.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_hdrs_in_use</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">extents_in_use</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* The limit on the logical index is just the max_rpi count. */</span>
	<span class="n">rpi_limit</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">rpi_base</span> <span class="o">+</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_rpi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Establish the starting RPI in this header block.  The starting</span>
<span class="cm">	 * rpi is normalized to a zero base because the physical rpi is</span>
<span class="cm">	 * port based.</span>
<span class="cm">	 */</span>
	<span class="n">curr_rpi_range</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">next_rpi</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The port has a limited number of rpis. The increment here</span>
<span class="cm">	 * is LPFC_RPI_HDR_COUNT - 1 to account for the starting value</span>
<span class="cm">	 * and to allow the full max_rpi range per port.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">curr_rpi_range</span> <span class="o">+</span> <span class="p">(</span><span class="n">LPFC_RPI_HDR_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">rpi_limit</span><span class="p">)</span>
		<span class="n">rpi_count</span> <span class="o">=</span> <span class="n">rpi_limit</span> <span class="o">-</span> <span class="n">curr_rpi_range</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rpi_count</span> <span class="o">=</span> <span class="n">LPFC_RPI_HDR_COUNT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rpi_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * First allocate the protocol header region for the port.  The</span>
<span class="cm">	 * port expects a 4KB DMA-mapped memory region that is 4K aligned.</span>
<span class="cm">	 */</span>
	<span class="n">dmabuf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					  <span class="n">LPFC_HDR_TEMPLATE_SIZE</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">,</span>
					  <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rpi_hdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_free_dmabuf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LPFC_HDR_TEMPLATE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">,</span> <span class="n">LPFC_HDR_TEMPLATE_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rpi_hdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_free_coherent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Save the rpi header data for cleanup later. */</span>
	<span class="n">rpi_hdr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_rpi_hdr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rpi_hdr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_coherent</span><span class="p">;</span>

	<span class="n">rpi_hdr</span><span class="o">-&gt;</span><span class="n">dmabuf</span> <span class="o">=</span> <span class="n">dmabuf</span><span class="p">;</span>
	<span class="n">rpi_hdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">LPFC_HDR_TEMPLATE_SIZE</span><span class="p">;</span>
	<span class="n">rpi_hdr</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* The rpi_hdr stores the logical index only. */</span>
	<span class="n">rpi_hdr</span><span class="o">-&gt;</span><span class="n">start_rpi</span> <span class="o">=</span> <span class="n">curr_rpi_range</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpi_hdr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_rpi_hdr_list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The next_rpi stores the next logical module-64 rpi value used</span>
<span class="cm">	 * to post physical rpis in subsequent rpi postings.</span>
<span class="cm">	 */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">next_rpi</span> <span class="o">+=</span> <span class="n">rpi_count</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rpi_hdr</span><span class="p">;</span>

 <span class="nl">err_free_coherent:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">LPFC_HDR_TEMPLATE_SIZE</span><span class="p">,</span>
			  <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
 <span class="nl">err_free_dmabuf:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_remove_rpi_hdrs - Remove all rpi header memory regions</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to remove all memory resources allocated</span>
<span class="cm"> * to support rpis for SLI4 ports not supporting extents. This routine</span>
<span class="cm"> * presumes the caller has released all rpis consumed by fabric or port</span>
<span class="cm"> * logins and is prepared to have the header pages removed.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_remove_rpi_hdrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_rpi_hdr</span> <span class="o">*</span><span class="n">rpi_hdr</span><span class="p">,</span> <span class="o">*</span><span class="n">next_rpi_hdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_hdrs_in_use</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rpi_hdr</span><span class="p">,</span> <span class="n">next_rpi_hdr</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_rpi_hdr_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpi_hdr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rpi_hdr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				  <span class="n">rpi_hdr</span><span class="o">-&gt;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">rpi_hdr</span><span class="o">-&gt;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rpi_hdr</span><span class="o">-&gt;</span><span class="n">dmabuf</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rpi_hdr</span><span class="p">);</span>
	<span class="p">}</span>
 <span class="nl">exit:</span>
	<span class="cm">/* There are no rpis available to the port now. */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">next_rpi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hba_alloc - Allocate driver hba data structure for a device.</span>
<span class="cm"> * @pdev: pointer to pci device data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to allocate the driver hba data structure for an</span>
<span class="cm"> * HBA device. If the allocation is successful, the phba reference to the</span>
<span class="cm"> * PCI device data structure is set.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *      pointer to @phba - successful</span>
<span class="cm"> *      NULL - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span>
<span class="nf">lpfc_hba_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>

	<span class="cm">/* Allocate memory for HBA structure */</span>
	<span class="n">phba</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to allocate hba struct</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set reference to PCI device in HBA structure */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/* Assign an unused board number */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">brd_no</span> <span class="o">=</span> <span class="n">lpfc_get_instance</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">brd_no</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ct_ev_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ct_ev_waiters</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">phba</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hba_free - Free driver hba data structure with a device.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to free the driver hba data structure with an</span>
<span class="cm"> * HBA device.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_hba_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Release the driver assigned board number */</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpfc_hba_index</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">brd_no</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_create_shost - Create hba physical port with associated scsi host.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to create HBA physical port and associate a SCSI</span>
<span class="cm"> * host with it.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *      0 - successful</span>
<span class="cm"> *      other values - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_create_shost</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span><span class="p">;</span>

	<span class="cm">/* Initialize HBA FC structure */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_edtov</span> <span class="o">=</span> <span class="n">FF_DEF_EDTOV</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">=</span> <span class="n">FF_DEF_RATOV</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_altov</span> <span class="o">=</span> <span class="n">FF_DEF_ALTOV</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_arbtov</span> <span class="o">=</span> <span class="n">FF_DEF_ARBTOV</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sdev_cnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vport</span> <span class="o">=</span> <span class="n">lpfc_create_port</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">brd_no</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vport</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="n">lpfc_debugfs_initialize</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="cm">/* Put reference to SCSI host to driver&#39;s device private data */</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_destroy_shost - Destroy hba physical port with associated scsi host.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to destroy HBA physical port and the associated</span>
<span class="cm"> * SCSI host.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_destroy_shost</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>

	<span class="cm">/* Destroy physical port that associated with the SCSI host */</span>
	<span class="n">destroy_port</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_setup_bg - Setup Block guard structures and debug areas.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @shost: the shost to be used to detect Block guard settings.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine sets up the local Block guard protocol settings for @shost.</span>
<span class="cm"> * This routine also allocates memory for debugging bg buffers.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_setup_bg</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pagecnt</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_prot_mask</span> <span class="o">&amp;&amp;</span> <span class="n">lpfc_prot_guard</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1478 Registering BlockGuard with the &quot;</span>
				<span class="s">&quot;SCSI layer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">scsi_host_set_prot</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">lpfc_prot_mask</span><span class="p">);</span>
		<span class="n">scsi_host_set_guard</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">lpfc_prot_guard</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_dump_buf_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">pagecnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_dump_buf_lock</span><span class="p">);</span>
			<span class="n">_dump_buf_data</span> <span class="o">=</span>
				<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">pagecnt</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">_dump_buf_data</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9043 BLKGRD: allocated %d pages for &quot;</span>
				       <span class="s">&quot;_dump_buf_data at 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pagecnt</span><span class="p">),</span> <span class="n">_dump_buf_data</span><span class="p">);</span>
				<span class="n">_dump_buf_data_order</span> <span class="o">=</span> <span class="n">pagecnt</span><span class="p">;</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">_dump_buf_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				       <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">pagecnt</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="o">--</span><span class="n">pagecnt</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_dump_buf_data_order</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
				<span class="s">&quot;9044 BLKGRD: ERROR unable to allocate &quot;</span>
			       <span class="s">&quot;memory for hexdump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
			<span class="s">&quot;9045 BLKGRD: already allocated _dump_buf_data=0x%p&quot;</span>
		       <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">_dump_buf_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_dump_buf_dif</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">pagecnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">_dump_buf_dif</span> <span class="o">=</span>
				<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">pagecnt</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">_dump_buf_dif</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9046 BLKGRD: allocated %d pages for &quot;</span>
				       <span class="s">&quot;_dump_buf_dif at 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pagecnt</span><span class="p">),</span> <span class="n">_dump_buf_dif</span><span class="p">);</span>
				<span class="n">_dump_buf_dif_order</span> <span class="o">=</span> <span class="n">pagecnt</span><span class="p">;</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">_dump_buf_dif</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				       <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">pagecnt</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="o">--</span><span class="n">pagecnt</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_dump_buf_dif_order</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
			<span class="s">&quot;9047 BLKGRD: ERROR unable to allocate &quot;</span>
			       <span class="s">&quot;memory for hexdump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
			<span class="s">&quot;9048 BLKGRD: already allocated _dump_buf_dif=0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">_dump_buf_dif</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_post_init_setup - Perform necessary device post initialization setup.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to perform all the necessary post initialization</span>
<span class="cm"> * setup for the device.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_post_init_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_adapter_event_header</span> <span class="n">adapter_event</span><span class="p">;</span>

	<span class="cm">/* Get the default values for Model Name and Description */</span>
	<span class="n">lpfc_get_hba_model_desc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelName</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelDesc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * hba setup may have changed the hba_queue_depth so we need to</span>
<span class="cm">	 * adjust the value of can_queue.</span>
<span class="cm">	 */</span>
	<span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_hba_queue_depth</span> <span class="o">-</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_BG_ENABLED</span><span class="p">)</span>
		<span class="n">lpfc_setup_bg</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>

	<span class="n">lpfc_host_attrib_init</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">&amp;</span> <span class="n">DISABLE_FCP_RING_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">lpfc_poll_start_timer</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0428 Perform SCSI scan</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* Send board arrival event to upper layer */</span>
	<span class="n">adapter_event</span><span class="p">.</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">FC_REG_ADAPTER_EVENT</span><span class="p">;</span>
	<span class="n">adapter_event</span><span class="p">.</span><span class="n">subcategory</span> <span class="o">=</span> <span class="n">LPFC_EVENT_ARRIVAL</span><span class="p">;</span>
	<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_get_event_number</span><span class="p">(),</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="n">adapter_event</span><span class="p">),</span>
				  <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">adapter_event</span><span class="p">,</span>
				  <span class="n">LPFC_NL_VENDOR_ID</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_pci_mem_setup - Setup SLI3 HBA PCI memory space.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to set up the PCI device memory space for device</span>
<span class="cm"> * with SLI-3 interface spec.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> * 	other values - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_pci_mem_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bar0map_len</span><span class="p">,</span> <span class="n">bar2map_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">hbq_count</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* Obtain PCI device reference */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">;</span>

	<span class="cm">/* Set the device DMA mask size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span>
	 <span class="o">||</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span><span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span>
		 <span class="o">||</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span><span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Get the bus address of Bar0 and Bar2 and the number of bytes</span>
<span class="cm">	 * required by each mapping.</span>
<span class="cm">	 */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_bar0_map</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bar0map_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_bar2_map</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">bar2map_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* Map HBA SLIM to a kernel virtual address. */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim_memmap_p</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_bar0_map</span><span class="p">,</span> <span class="n">bar0map_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim_memmap_p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;ioremap failed for SLIM memory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Map HBA Control Registers to a kernel virtual address. */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">ctrl_regs_memmap_p</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_bar2_map</span><span class="p">,</span> <span class="n">bar2map_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ctrl_regs_memmap_p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;ioremap failed for HBA control registers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_iounmap_slim</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate memory for SLI-2 structures */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim2p</span><span class="p">.</span><span class="n">virt</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					       <span class="n">SLI2_SLIM_SIZE</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim2p</span><span class="p">.</span><span class="n">phys</span><span class="p">,</span>
					       <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim2p</span><span class="p">.</span><span class="n">virt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_iounmap</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim2p</span><span class="p">.</span><span class="n">virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLI2_SLIM_SIZE</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim2p</span><span class="p">.</span><span class="n">virt</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli2_slim</span><span class="p">,</span> <span class="n">mbx</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_ext</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim2p</span><span class="p">.</span><span class="n">virt</span> <span class="o">+</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli2_slim</span><span class="p">,</span> <span class="n">mbx_ext_words</span><span class="p">));</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcb</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim2p</span><span class="p">.</span><span class="n">virt</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli2_slim</span><span class="p">,</span> <span class="n">pcb</span><span class="p">));</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">IOCBs</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim2p</span><span class="p">.</span><span class="n">virt</span> <span class="o">+</span>
		       <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli2_slim</span><span class="p">,</span> <span class="n">IOCBs</span><span class="p">));</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqslimp</span><span class="p">.</span><span class="n">virt</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						 <span class="n">lpfc_sli_hbq_size</span><span class="p">(),</span>
						 <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqslimp</span><span class="p">.</span><span class="n">phys</span><span class="p">,</span>
						 <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqslimp</span><span class="p">.</span><span class="n">virt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_slim</span><span class="p">;</span>

	<span class="n">hbq_count</span> <span class="o">=</span> <span class="n">lpfc_sli_hbq_count</span><span class="p">();</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqslimp</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hbq_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hbq_virt</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hbq_buffer_list</span><span class="p">);</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">lpfc_hbq_defs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entry_count</span> <span class="o">*</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hbq_entry</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">LPFC_ELS_HBQ</span><span class="p">].</span><span class="n">hbq_alloc_buffer</span> <span class="o">=</span> <span class="n">lpfc_els_hbq_alloc</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">LPFC_ELS_HBQ</span><span class="p">].</span><span class="n">hbq_free_buffer</span> <span class="o">=</span> <span class="n">lpfc_els_hbq_free</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqslimp</span><span class="p">.</span><span class="n">virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lpfc_sli_hbq_size</span><span class="p">());</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">rb_pend_list</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim_memmap_p</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ctrl_regs_memmap_p</span> <span class="o">+</span> <span class="n">HA_REG_OFFSET</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">CAregaddr</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ctrl_regs_memmap_p</span> <span class="o">+</span> <span class="n">CA_REG_OFFSET</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">HSregaddr</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ctrl_regs_memmap_p</span> <span class="o">+</span> <span class="n">HS_REG_OFFSET</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ctrl_regs_memmap_p</span> <span class="o">+</span> <span class="n">HC_REG_OFFSET</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_slim:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">SLI2_SLIM_SIZE</span><span class="p">,</span>
			  <span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim2p</span><span class="p">.</span><span class="n">virt</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim2p</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>
<span class="nl">out_iounmap:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ctrl_regs_memmap_p</span><span class="p">);</span>
<span class="nl">out_iounmap_slim:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim_memmap_p</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_pci_mem_unset - Unset SLI3 HBA PCI memory space.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to unset the PCI device memory space for device</span>
<span class="cm"> * with SLI-3 interface spec.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_pci_mem_unset</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/* Obtain PCI device reference */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">;</span>

	<span class="cm">/* Free coherent DMA memory allocated */</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">lpfc_sli_hbq_size</span><span class="p">(),</span>
			  <span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqslimp</span><span class="p">.</span><span class="n">virt</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqslimp</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">SLI2_SLIM_SIZE</span><span class="p">,</span>
			  <span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim2p</span><span class="p">.</span><span class="n">virt</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim2p</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>

	<span class="cm">/* I/O memory unmap */</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ctrl_regs_memmap_p</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim_memmap_p</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_post_status_check - Wait for SLI4 POST done and check status</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to wait for SLI4 device Power On Self Test (POST)</span>
<span class="cm"> * done and check status.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful, otherwise -ENODEV.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_post_status_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_register</span> <span class="n">portsmphr_reg</span><span class="p">,</span> <span class="n">uerrlo_reg</span><span class="p">,</span> <span class="n">uerrhi_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_register</span> <span class="n">reg_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">port_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">if_type</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">portsmphr_reg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">portsmphr_reg</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">reg_data</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">PSMPHRregaddr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* Wait up to 30 seconds for the SLI Port POST done and ready */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">PSMPHRregaddr</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">portsmphr_reg</span><span class="p">.</span><span class="n">word0</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_port_smphr_perr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portsmphr_reg</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* Port has a fatal POST error, break out */</span>
			<span class="n">port_error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">LPFC_POST_STAGE_PORT_READY</span> <span class="o">==</span>
		    <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_port_smphr_port_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portsmphr_reg</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there was a port error during POST, then don&#39;t proceed with</span>
<span class="cm">	 * other register reads as the data may not be valid.  Just exit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;1408 Port Failed POST - portsmphr=0x%x, &quot;</span>
			<span class="s">&quot;perr=x%x, sfi=x%x, nip=x%x, ipc=x%x, scr1=x%x, &quot;</span>
			<span class="s">&quot;scr2=x%x, hscratch=x%x, pstatus=x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">portsmphr_reg</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_port_smphr_perr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portsmphr_reg</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_port_smphr_sfi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portsmphr_reg</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_port_smphr_nip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portsmphr_reg</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_port_smphr_ipc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portsmphr_reg</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_port_smphr_scr1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portsmphr_reg</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_port_smphr_scr2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portsmphr_reg</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_port_smphr_host_scratch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portsmphr_reg</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_port_smphr_port_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portsmphr_reg</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2534 Device Info: SLIFamily=0x%x, &quot;</span>
				<span class="s">&quot;SLIRev=0x%x, IFType=0x%x, SLIHint_1=0x%x, &quot;</span>
				<span class="s">&quot;SLIHint_2=0x%x, FT=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_sli_family</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">),</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_slirev</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">),</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">),</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_sli_hint1</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">),</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_sli_hint2</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">),</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_func_type</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check for other Port errors during the initialization</span>
<span class="cm">		 * process.  Fail the load if the port did not come up</span>
<span class="cm">		 * correctly.</span>
<span class="cm">		 */</span>
		<span class="n">if_type</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">if_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_0</span>:
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ue_mask_lo</span> <span class="o">=</span>
			      <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type0</span><span class="p">.</span><span class="n">UEMASKLOregaddr</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ue_mask_hi</span> <span class="o">=</span>
			      <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type0</span><span class="p">.</span><span class="n">UEMASKHIregaddr</span><span class="p">);</span>
			<span class="n">uerrlo_reg</span><span class="p">.</span><span class="n">word0</span> <span class="o">=</span>
			      <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type0</span><span class="p">.</span><span class="n">UERRLOregaddr</span><span class="p">);</span>
			<span class="n">uerrhi_reg</span><span class="p">.</span><span class="n">word0</span> <span class="o">=</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type0</span><span class="p">.</span><span class="n">UERRHIregaddr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">~</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ue_mask_lo</span> <span class="o">&amp;</span> <span class="n">uerrlo_reg</span><span class="p">.</span><span class="n">word0</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="o">~</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ue_mask_hi</span> <span class="o">&amp;</span> <span class="n">uerrhi_reg</span><span class="p">.</span><span class="n">word0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
						<span class="s">&quot;1422 Unrecoverable Error &quot;</span>
						<span class="s">&quot;Detected during POST &quot;</span>
						<span class="s">&quot;uerr_lo_reg=0x%x, &quot;</span>
						<span class="s">&quot;uerr_hi_reg=0x%x, &quot;</span>
						<span class="s">&quot;ue_mask_lo_reg=0x%x, &quot;</span>
						<span class="s">&quot;ue_mask_hi_reg=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">uerrlo_reg</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span>
						<span class="n">uerrhi_reg</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ue_mask_lo</span><span class="p">,</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ue_mask_hi</span><span class="p">);</span>
				<span class="n">port_error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_2</span>:
			<span class="cm">/* Final checks.  The port status should be clean. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">STATUSregaddr</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">reg_data</span><span class="p">.</span><span class="n">word0</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sliport_status_err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_data</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="o">!</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sliport_status_rn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_data</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span>
					      <span class="n">ERR1regaddr</span><span class="p">);</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span>
					      <span class="n">ERR2regaddr</span><span class="p">);</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2888 Unrecoverable port error &quot;</span>
					<span class="s">&quot;following POST: port status reg &quot;</span>
					<span class="s">&quot;0x%x, port_smphr reg 0x%x, &quot;</span>
					<span class="s">&quot;error 1=0x%x, error 2=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">reg_data</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span>
					<span class="n">portsmphr_reg</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="n">port_error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_1</span>:
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">port_error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_bar0_register_memmap - Set up SLI4 BAR0 register memory map.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @if_type:  The SLI4 interface type getting configured.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to set up SLI4 BAR0 PCI config space register</span>
<span class="cm"> * memory map.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_bar0_register_memmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">if_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">if_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_0</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type0</span><span class="p">.</span><span class="n">UERRLOregaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span> <span class="n">LPFC_UERR_STATUS_LO</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type0</span><span class="p">.</span><span class="n">UERRHIregaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span> <span class="n">LPFC_UERR_STATUS_HI</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type0</span><span class="p">.</span><span class="n">UEMASKLOregaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span> <span class="n">LPFC_UE_MASK_LO</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type0</span><span class="p">.</span><span class="n">UEMASKHIregaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span> <span class="n">LPFC_UE_MASK_HI</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">SLIINTFregaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span> <span class="n">LPFC_SLI_INTF</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_2</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">ERR1regaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span>
						<span class="n">LPFC_CTL_PORT_ER1_OFFSET</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">ERR2regaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span>
						<span class="n">LPFC_CTL_PORT_ER2_OFFSET</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">CTRLregaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span>
						<span class="n">LPFC_CTL_PORT_CTL_OFFSET</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">STATUSregaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span>
						<span class="n">LPFC_CTL_PORT_STA_OFFSET</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">SLIINTFregaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span> <span class="n">LPFC_SLI_INTF</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">PSMPHRregaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span>
						<span class="n">LPFC_CTL_PORT_SEM_OFFSET</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">RQDBregaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span> <span class="n">LPFC_RQ_DOORBELL</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">WQDBregaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span> <span class="n">LPFC_WQ_DOORBELL</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">EQCQDBregaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span> <span class="n">LPFC_EQCQ_DOORBELL</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">MQDBregaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span> <span class="n">LPFC_MQ_DOORBELL</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">BMBXregaddr</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span> <span class="n">LPFC_BMBX</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_1</span>:
	<span class="nl">default:</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;FATAL - unsupported SLI4 interface type - %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">if_type</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_bar1_register_memmap - Set up SLI4 BAR1 register memory map.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to set up SLI4 BAR1 control status register (CSR)</span>
<span class="cm"> * memory map.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_bar1_register_memmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">PSMPHRregaddr</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ctrl_regs_memmap_p</span> <span class="o">+</span>
		<span class="n">LPFC_SLIPORT_IF0_SMPHR</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ISRregaddr</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ctrl_regs_memmap_p</span> <span class="o">+</span>
		<span class="n">LPFC_HST_ISR0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">IMRregaddr</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ctrl_regs_memmap_p</span> <span class="o">+</span>
		<span class="n">LPFC_HST_IMR0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ISCRregaddr</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ctrl_regs_memmap_p</span> <span class="o">+</span>
		<span class="n">LPFC_HST_ISCR0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_bar2_register_memmap - Set up SLI4 BAR2 register memory map.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @vf: virtual function number</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to set up SLI4 BAR2 doorbell register memory map</span>
<span class="cm"> * based on the given viftual function number, @vf.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful, otherwise -ENODEV.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_bar2_register_memmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vf</span> <span class="o">&gt;</span> <span class="n">LPFC_VIR_FUNC_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">RQDBregaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">drbl_regs_memmap_p</span> <span class="o">+</span>
				<span class="n">vf</span> <span class="o">*</span> <span class="n">LPFC_VFR_PAGE_SIZE</span> <span class="o">+</span> <span class="n">LPFC_RQ_DOORBELL</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">WQDBregaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">drbl_regs_memmap_p</span> <span class="o">+</span>
				<span class="n">vf</span> <span class="o">*</span> <span class="n">LPFC_VFR_PAGE_SIZE</span> <span class="o">+</span> <span class="n">LPFC_WQ_DOORBELL</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">EQCQDBregaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">drbl_regs_memmap_p</span> <span class="o">+</span>
				<span class="n">vf</span> <span class="o">*</span> <span class="n">LPFC_VFR_PAGE_SIZE</span> <span class="o">+</span> <span class="n">LPFC_EQCQ_DOORBELL</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">MQDBregaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">drbl_regs_memmap_p</span> <span class="o">+</span>
				<span class="n">vf</span> <span class="o">*</span> <span class="n">LPFC_VFR_PAGE_SIZE</span> <span class="o">+</span> <span class="n">LPFC_MQ_DOORBELL</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">BMBXregaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">drbl_regs_memmap_p</span> <span class="o">+</span>
				<span class="n">vf</span> <span class="o">*</span> <span class="n">LPFC_VFR_PAGE_SIZE</span> <span class="o">+</span> <span class="n">LPFC_BMBX</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_create_bootstrap_mbox - Create the bootstrap mailbox</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to create the bootstrap mailbox</span>
<span class="cm"> * region consistent with the SLI-4 interface spec.  This</span>
<span class="cm"> * routine allocates all memory necessary to communicate</span>
<span class="cm"> * mailbox commands to the port and sets up all alignment</span>
<span class="cm"> * needs.  No locks are expected to be held when calling</span>
<span class="cm"> * this routine.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> * 	-ENOMEM - could not allocated memory.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_create_bootstrap_mbox</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">bmbx_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_address</span> <span class="o">*</span><span class="n">dma_address</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pa_addr</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">phys_addr</span><span class="p">;</span>

	<span class="n">dmabuf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The bootstrap mailbox region is comprised of 2 parts</span>
<span class="cm">	 * plus an alignment restriction of 16 bytes.</span>
<span class="cm">	 */</span>
	<span class="n">bmbx_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_bmbx_create</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">LPFC_ALIGN_16_BYTE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					  <span class="n">bmbx_size</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">,</span>
					  <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bmbx_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the bootstrap mailbox pointers now so that the register</span>
<span class="cm">	 * operations are simple later.  The mailbox dma address is required</span>
<span class="cm">	 * to be 16-byte aligned.  Also align the virtual memory as each</span>
<span class="cm">	 * maibox is copied into the bmbx mailbox region before issuing the</span>
<span class="cm">	 * command to the port.</span>
<span class="cm">	 */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">dmabuf</span> <span class="o">=</span> <span class="n">dmabuf</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">bmbx_size</span> <span class="o">=</span> <span class="n">bmbx_size</span><span class="p">;</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">avirt</span> <span class="o">=</span> <span class="n">PTR_ALIGN</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span>
					      <span class="n">LPFC_ALIGN_16_BYTE</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">aphys</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">,</span>
					      <span class="n">LPFC_ALIGN_16_BYTE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the high and low physical addresses now.  The SLI4 alignment</span>
<span class="cm">	 * requirement is 16 bytes and the mailbox is posted to the port</span>
<span class="cm">	 * as two 30-bit addresses.  The other data is a bit marking whether</span>
<span class="cm">	 * the 30-bit address is the high or low address.</span>
<span class="cm">	 * Upcast bmbx aphys to 64bits so shift instruction compiles</span>
<span class="cm">	 * clean on 32 bit machines.</span>
<span class="cm">	 */</span>
	<span class="n">dma_address</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">dma_address</span><span class="p">;</span>
	<span class="n">phys_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">aphys</span><span class="p">;</span>
	<span class="n">pa_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="p">((</span><span class="n">phys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">34</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3fffffff</span><span class="p">);</span>
	<span class="n">dma_address</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="p">((</span><span class="n">pa_addr</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
					   <span class="n">LPFC_BMBX_BIT1_ADDR_HI</span><span class="p">);</span>

	<span class="n">pa_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">aphys</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3fffffff</span><span class="p">);</span>
	<span class="n">dma_address</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="p">((</span><span class="n">pa_addr</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
					   <span class="n">LPFC_BMBX_BIT1_ADDR_LO</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_destroy_bootstrap_mbox - Destroy all bootstrap mailbox resources</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to teardown the bootstrap mailbox</span>
<span class="cm"> * region and release all host resources. This routine requires</span>
<span class="cm"> * the caller to ensure all mailbox commands recovered, no</span>
<span class="cm"> * additional mailbox comands are sent, and interrupts are disabled</span>
<span class="cm"> * before calling this routine.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_destroy_bootstrap_mbox</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">bmbx_size</span><span class="p">,</span>
			  <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span>
			  <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">dmabuf</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_bmbx</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_read_config - Get the config parameters.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to read the configuration parameters from the HBA.</span>
<span class="cm"> * The configuration parameters are used to set the base and maximum values</span>
<span class="cm"> * for RPI&#39;s XRI&#39;s VPI&#39;s VFI&#39;s and FCFIs. These values also affect the resource</span>
<span class="cm"> * allocation for the port.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> * 	-ENOMEM - No available memory</span>
<span class="cm"> *      -EIO - The mailbox failed to complete successfully.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_read_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_read_config</span> <span class="o">*</span><span class="n">rd_config</span><span class="p">;</span>
	<span class="k">union</span>  <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_get_func_cfg</span> <span class="o">*</span><span class="n">get_func_cfg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rsrc_desc_fcfcoe</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">desc_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pmb</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2011 Unable to allocate memory for issuing &quot;</span>
				<span class="s">&quot;SLI_CONFIG_SPECIAL mailbox command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_read_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;2012 Mailbox failed , mbxCmd x%x &quot;</span>
			<span class="s">&quot;READ_CONFIG, mbxStatus x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rd_config</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">rd_config</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_lnk_ldv</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_dv</span> <span class="o">=</span> <span class="n">LPFC_LNK_DAT_VAL</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_tp</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_lnk_type</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_no</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_lnk_numb</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;3081 lnk_type:%d, lnk_numb:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_tp</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_no</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;3082 Mailbox (x%x) returned ldv:x0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">));</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">extents_in_use</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_extnts_inuse</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_xri</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_xri_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">xri_base</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_xri_base</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_vpi</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_vpi_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">vpi_base</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_vpi_base</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_rpi</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_rpi_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">rpi_base</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_rpi_base</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_vfi</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_vfi_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">vfi_base</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_vfi_base</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_fcfi</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_fcfi_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_eq</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_eq_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_rq</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_rq_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_wq</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_wq_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_cq</span> <span class="o">=</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_cq_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_lmt</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">next_xri</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">xri_base</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_base</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">vpi_base</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vfi_base</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">vfi_base</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_vpi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
				<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_vpi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span><span class="p">;</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2003 cfg params Extents? %d &quot;</span>
				<span class="s">&quot;XRI(B:%d M:%d), &quot;</span>
				<span class="s">&quot;VPI(B:%d M:%d) &quot;</span>
				<span class="s">&quot;VFI(B:%d M:%d) &quot;</span>
				<span class="s">&quot;RPI(B:%d M:%d) &quot;</span>
				<span class="s">&quot;FCFI(Count:%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">extents_in_use</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">xri_base</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_xri</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">vpi_base</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_vpi</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">vfi_base</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_vfi</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">rpi_base</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_rpi</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_fcfi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">read_cfg_out</span><span class="p">;</span>

	<span class="cm">/* Reset the DFT_HBA_Q_DEPTH to the max xri  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_hba_queue_depth</span> <span class="o">&gt;</span>
		<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_xri</span> <span class="o">-</span>
			<span class="n">lpfc_sli4_get_els_iocb_cnt</span><span class="p">(</span><span class="n">phba</span><span class="p">)))</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_hba_queue_depth</span> <span class="o">=</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_xri</span> <span class="o">-</span>
				<span class="n">lpfc_sli4_get_els_iocb_cnt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">LPFC_SLI_INTF_IF_TYPE_2</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">read_cfg_out</span><span class="p">;</span>

	<span class="cm">/* get the pf# and vf# for SLI4 if_type 2 port */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_get_func_cfg</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_GET_FUNCTION_CONFIG</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span>
				<span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_config</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">||</span> <span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3026 Mailbox failed , mbxCmd x%x &quot;</span>
				<span class="s">&quot;GET_FUNCTION_CONFIG, mbxStatus x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">),</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">read_cfg_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* search for fc_fcoe resrouce descriptor */</span>
	<span class="n">get_func_cfg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">get_func_cfg</span><span class="p">;</span>
	<span class="n">desc_count</span> <span class="o">=</span> <span class="n">get_func_cfg</span><span class="o">-&gt;</span><span class="n">func_cfg</span><span class="p">.</span><span class="n">rsrc_desc_count</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPFC_RSRC_DESC_MAX_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_rsrc_desc_fcfcoe</span> <span class="o">*</span><span class="p">)</span>
			<span class="o">&amp;</span><span class="n">get_func_cfg</span><span class="o">-&gt;</span><span class="n">func_cfg</span><span class="p">.</span><span class="n">desc</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">LPFC_RSRC_DESC_TYPE_FCFCOE</span> <span class="o">==</span>
		    <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_rsrc_desc_pcie_type</span><span class="p">,</span> <span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">iov</span><span class="p">.</span><span class="n">pf_number</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_rsrc_desc_fcfcoe_pfnum</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">iov</span><span class="p">.</span><span class="n">vf_number</span> <span class="o">=</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_rsrc_desc_fcfcoe_vfnum</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPFC_RSRC_DESC_MAX_NUM</span><span class="p">)</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3027 GET_FUNCTION_CONFIG: pf_number:%d, &quot;</span>
				<span class="s">&quot;vf_number:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">iov</span><span class="p">.</span><span class="n">pf_number</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">iov</span><span class="p">.</span><span class="n">vf_number</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3028 GET_FUNCTION_CONFIG: failed to find &quot;</span>
				<span class="s">&quot;Resrouce Descriptor:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">LPFC_RSRC_DESC_TYPE_FCFCOE</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">read_cfg_out:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_setup_endian_order - Write endian order to an SLI4 if_type 0 port.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to setup the port-side endian order when</span>
<span class="cm"> * the port if_type is 0.  This routine has no function for other</span>
<span class="cm"> * if_types.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> * 	-ENOMEM - No available memory</span>
<span class="cm"> *      -EIO - The mailbox failed to complete successfully.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_setup_endian_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">if_type</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">endian_mb_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">HOST_ENDIAN_LOW_WORD0</span><span class="p">,</span>
				      <span class="n">HOST_ENDIAN_HIGH_WORD1</span><span class="p">};</span>

	<span class="n">if_type</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">if_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_0</span>:
		<span class="n">mboxq</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span>
						       <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0492 Unable to allocate memory for &quot;</span>
					<span class="s">&quot;issuing SLI_CONFIG_SPECIAL mailbox &quot;</span>
					<span class="s">&quot;command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The SLI4_CONFIG_SPECIAL mailbox command requires the first</span>
<span class="cm">		 * two words to contain special data values and no other data.</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LPFC_MBOXQ_t</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endian_mb_data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">endian_mb_data</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0493 SLI_CONFIG_SPECIAL mailbox &quot;</span>
					<span class="s">&quot;failed with status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">rc</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_2</span>:
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_1</span>:
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_queue_verify - Verify and update EQ and CQ counts</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to check the user settable queue counts for EQs and</span>
<span class="cm"> * CQs. after this routine is called the counts will be set to valid values that</span>
<span class="cm"> * adhere to the constraints of the system&#39;s interrupt vectors and the port&#39;s</span>
<span class="cm"> * queue resources.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *      0 - successful</span>
<span class="cm"> *      -ENOMEM - No available memory</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_queue_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cfg_fcp_wq_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cfg_fcp_eq_count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sanity check for confiugred queue parameters against the run-time</span>
<span class="cm">	 * device parameters</span>
<span class="cm">	 */</span>

	<span class="cm">/* Sanity check on FCP fast-path WQ parameters */</span>
	<span class="n">cfg_fcp_wq_count</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_wq_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg_fcp_wq_count</span> <span class="o">&gt;</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_wq</span> <span class="o">-</span> <span class="n">LPFC_SP_WQN_DEF</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cfg_fcp_wq_count</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_wq</span> <span class="o">-</span>
				   <span class="n">LPFC_SP_WQN_DEF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfg_fcp_wq_count</span> <span class="o">&lt;</span> <span class="n">LPFC_FP_WQN_MIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2581 Not enough WQs (%d) from &quot;</span>
					<span class="s">&quot;the pci function for supporting &quot;</span>
					<span class="s">&quot;FCP WQs (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_wq</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_wq_count</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2582 Not enough WQs (%d) from the pci &quot;</span>
				<span class="s">&quot;function for supporting the requested &quot;</span>
				<span class="s">&quot;FCP WQs (%d), the actual FCP WQs can &quot;</span>
				<span class="s">&quot;be supported: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_wq</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_wq_count</span><span class="p">,</span> <span class="n">cfg_fcp_wq_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* The actual number of FCP work queues adopted */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_wq_count</span> <span class="o">=</span> <span class="n">cfg_fcp_wq_count</span><span class="p">;</span>

	<span class="cm">/* Sanity check on FCP fast-path EQ parameters */</span>
	<span class="n">cfg_fcp_eq_count</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg_fcp_eq_count</span> <span class="o">&gt;</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_eq</span> <span class="o">-</span> <span class="n">LPFC_SP_EQN_DEF</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cfg_fcp_eq_count</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_eq</span> <span class="o">-</span>
				   <span class="n">LPFC_SP_EQN_DEF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfg_fcp_eq_count</span> <span class="o">&lt;</span> <span class="n">LPFC_FP_EQN_MIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2574 Not enough EQs (%d) from the &quot;</span>
					<span class="s">&quot;pci function for supporting FCP &quot;</span>
					<span class="s">&quot;EQs (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_eq</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2575 Not enough EQs (%d) from the pci &quot;</span>
				<span class="s">&quot;function for supporting the requested &quot;</span>
				<span class="s">&quot;FCP EQs (%d), the actual FCP EQs can &quot;</span>
				<span class="s">&quot;be supported: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_eq</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">,</span> <span class="n">cfg_fcp_eq_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* It does not make sense to have more EQs than WQs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg_fcp_eq_count</span> <span class="o">&gt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_wq_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2593 The FCP EQ count(%d) cannot be greater &quot;</span>
				<span class="s">&quot;than the FCP WQ count(%d), limiting the &quot;</span>
				<span class="s">&quot;FCP EQ count to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfg_fcp_eq_count</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_wq_count</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_wq_count</span><span class="p">);</span>
		<span class="n">cfg_fcp_eq_count</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_wq_count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* The actual number of FCP event queues adopted */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span> <span class="o">=</span> <span class="n">cfg_fcp_eq_count</span><span class="p">;</span>
	<span class="cm">/* The overall number of event queues used */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">cfg_eqn</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span> <span class="o">+</span> <span class="n">LPFC_SP_EQN_DEF</span><span class="p">;</span>

	<span class="cm">/* Get EQ depth from module parameter, fake the default for now */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">eq_esize</span> <span class="o">=</span> <span class="n">LPFC_EQE_SIZE_4B</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">eq_ecount</span> <span class="o">=</span> <span class="n">LPFC_EQE_DEF_COUNT</span><span class="p">;</span>

	<span class="cm">/* Get CQ depth from module parameter, fake the default for now */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">cq_esize</span> <span class="o">=</span> <span class="n">LPFC_CQE_SIZE</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">cq_ecount</span> <span class="o">=</span> <span class="n">LPFC_CQE_DEF_COUNT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_error:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_queue_create - Create all the SLI4 queues</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to allocate all the SLI4 queues for the FCoE HBA</span>
<span class="cm"> * operation. For each SLI4 queue type, the parameters such as queue entry</span>
<span class="cm"> * count (queue depth) shall be taken from the module parameter. For now,</span>
<span class="cm"> * we just use some constant number as place holder.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *      0 - sucessful</span>
<span class="cm"> *      -ENOMEM - No availble memory</span>
<span class="cm"> *      -EIO - The mailbox failed to complete successfully.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_queue_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">qdesc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fcp_eqidx</span><span class="p">,</span> <span class="n">fcp_cqidx</span><span class="p">,</span> <span class="n">fcp_wqidx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create Event Queues (EQs)</span>
<span class="cm">	 */</span>

	<span class="cm">/* Create slow path event queue */</span>
	<span class="n">qdesc</span> <span class="o">=</span> <span class="n">lpfc_sli4_queue_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">eq_esize</span><span class="p">,</span>
				      <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">eq_ecount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qdesc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0496 Failed allocate slow-path EQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span> <span class="o">=</span> <span class="n">qdesc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create fast-path FCP Event Queue(s).  The cfg_fcp_eq_count can be</span>
<span class="cm">	 * zero whenever there is exactly one interrupt vector.  This is not</span>
<span class="cm">	 * an error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span>
				       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2576 Failed allocate memory for &quot;</span>
					<span class="s">&quot;fast-path EQ record array</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_sp_eq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fcp_eqidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_eqidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">;</span> <span class="n">fcp_eqidx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qdesc</span> <span class="o">=</span> <span class="n">lpfc_sli4_queue_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">eq_esize</span><span class="p">,</span>
					      <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">eq_ecount</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qdesc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0497 Failed allocate fast-path EQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_fp_eq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">[</span><span class="n">fcp_eqidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">qdesc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create Complete Queues (CQs)</span>
<span class="cm">	 */</span>

	<span class="cm">/* Create slow-path Mailbox Command Complete Queue */</span>
	<span class="n">qdesc</span> <span class="o">=</span> <span class="n">lpfc_sli4_queue_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">cq_esize</span><span class="p">,</span>
				      <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">cq_ecount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qdesc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0500 Failed allocate slow-path mailbox CQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_fp_eq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_cq</span> <span class="o">=</span> <span class="n">qdesc</span><span class="p">;</span>

	<span class="cm">/* Create slow-path ELS Complete Queue */</span>
	<span class="n">qdesc</span> <span class="o">=</span> <span class="n">lpfc_sli4_queue_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">cq_esize</span><span class="p">,</span>
				      <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">cq_ecount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qdesc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0501 Failed allocate slow-path ELS CQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_mbx_cq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span> <span class="o">=</span> <span class="n">qdesc</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * Create fast-path FCP Completion Queue(s), one-to-one with FCP EQs.</span>
<span class="cm">	 * If there are no FCP EQs then create exactly one FCP CQ.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span>
						 <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">),</span>
						<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="p">),</span>
						<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2577 Failed allocate memory for fast-path &quot;</span>
				<span class="s">&quot;CQ record array</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_els_cq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fcp_cqidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">qdesc</span> <span class="o">=</span> <span class="n">lpfc_sli4_queue_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">cq_esize</span><span class="p">,</span>
					      <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">cq_ecount</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qdesc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0499 Failed allocate fast-path FCP &quot;</span>
					<span class="s">&quot;CQ (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcp_cqidx</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_fcp_cq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">[</span><span class="n">fcp_cqidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">qdesc</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">fcp_cqidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">);</span>

	<span class="cm">/* Create Mailbox Command Queue */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mq_esize</span> <span class="o">=</span> <span class="n">LPFC_MQE_SIZE</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mq_ecount</span> <span class="o">=</span> <span class="n">LPFC_MQE_DEF_COUNT</span><span class="p">;</span>

	<span class="n">qdesc</span> <span class="o">=</span> <span class="n">lpfc_sli4_queue_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mq_esize</span><span class="p">,</span>
				      <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mq_ecount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qdesc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0505 Failed allocate slow-path MQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_fcp_cq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_wq</span> <span class="o">=</span> <span class="n">qdesc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create all the Work Queues (WQs)</span>
<span class="cm">	 */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">wq_esize</span> <span class="o">=</span> <span class="n">LPFC_WQE_SIZE</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">wq_ecount</span> <span class="o">=</span> <span class="n">LPFC_WQE_DEF_COUNT</span><span class="p">;</span>

	<span class="cm">/* Create slow-path ELS Work Queue */</span>
	<span class="n">qdesc</span> <span class="o">=</span> <span class="n">lpfc_sli4_queue_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">wq_esize</span><span class="p">,</span>
				      <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">wq_ecount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qdesc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0504 Failed allocate slow-path ELS WQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_mbx_wq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span> <span class="o">=</span> <span class="n">qdesc</span><span class="p">;</span>

	<span class="cm">/* Create fast-path FCP Work Queue(s) */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_wq_count</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2578 Failed allocate memory for fast-path &quot;</span>
				<span class="s">&quot;WQ record array</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_els_wq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fcp_wqidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_wqidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_wq_count</span><span class="p">;</span> <span class="n">fcp_wqidx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qdesc</span> <span class="o">=</span> <span class="n">lpfc_sli4_queue_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">wq_esize</span><span class="p">,</span>
					      <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">wq_ecount</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qdesc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0503 Failed allocate fast-path FCP &quot;</span>
					<span class="s">&quot;WQ (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcp_wqidx</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_fcp_wq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">[</span><span class="n">fcp_wqidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">qdesc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create Receive Queue (RQ)</span>
<span class="cm">	 */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rq_esize</span> <span class="o">=</span> <span class="n">LPFC_RQE_SIZE</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rq_ecount</span> <span class="o">=</span> <span class="n">LPFC_RQE_DEF_COUNT</span><span class="p">;</span>

	<span class="cm">/* Create Receive Queue for header */</span>
	<span class="n">qdesc</span> <span class="o">=</span> <span class="n">lpfc_sli4_queue_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rq_esize</span><span class="p">,</span>
				      <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rq_ecount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qdesc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0506 Failed allocate receive HRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_fcp_wq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">hdr_rq</span> <span class="o">=</span> <span class="n">qdesc</span><span class="p">;</span>

	<span class="cm">/* Create Receive Queue for data */</span>
	<span class="n">qdesc</span> <span class="o">=</span> <span class="n">lpfc_sli4_queue_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rq_esize</span><span class="p">,</span>
				      <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rq_ecount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qdesc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0507 Failed allocate receive DRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_hdr_rq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">dat_rq</span> <span class="o">=</span> <span class="n">qdesc</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_hdr_rq:</span>
	<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">hdr_rq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">hdr_rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out_free_fcp_wq:</span>
	<span class="k">for</span> <span class="p">(</span><span class="o">--</span><span class="n">fcp_wqidx</span><span class="p">;</span> <span class="n">fcp_wqidx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_wqidx</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">[</span><span class="n">fcp_wqidx</span><span class="p">]);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">[</span><span class="n">fcp_wqidx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out_free_els_wq:</span>
	<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out_free_mbx_wq:</span>
	<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_wq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_wq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out_free_fcp_cq:</span>
	<span class="k">for</span> <span class="p">(</span><span class="o">--</span><span class="n">fcp_cqidx</span><span class="p">;</span> <span class="n">fcp_cqidx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_cqidx</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">[</span><span class="n">fcp_cqidx</span><span class="p">]);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">[</span><span class="n">fcp_cqidx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out_free_els_cq:</span>
	<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out_free_mbx_cq:</span>
	<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_cq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_cq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out_free_fp_eq:</span>
	<span class="k">for</span> <span class="p">(</span><span class="o">--</span><span class="n">fcp_eqidx</span><span class="p">;</span> <span class="n">fcp_eqidx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_eqidx</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">[</span><span class="n">fcp_eqidx</span><span class="p">]);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">[</span><span class="n">fcp_eqidx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out_free_sp_eq:</span>
	<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out_error:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_queue_destroy - Destroy all the SLI4 queues</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to release all the SLI4 queues with the FCoE HBA</span>
<span class="cm"> * operation.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *      0 - successful</span>
<span class="cm"> *      -ENOMEM - No available memory</span>
<span class="cm"> *      -EIO - The mailbox failed to complete successfully.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_queue_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fcp_qidx</span><span class="p">;</span>

	<span class="cm">/* Release mailbox command work queue */</span>
	<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_wq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_wq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Release ELS work queue */</span>
	<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Release FCP work queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">fcp_qidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_qidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_wq_count</span><span class="p">;</span>
		     <span class="n">fcp_qidx</span><span class="o">++</span><span class="p">)</span>
			<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">[</span><span class="n">fcp_qidx</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Release unsolicited receive queue */</span>
	<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">hdr_rq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">hdr_rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">dat_rq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">dat_rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Release ELS complete queue */</span>
	<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Release mailbox command complete queue */</span>
	<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_cq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_cq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Release FCP response complete queue */</span>
	<span class="n">fcp_qidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">do</span>
			<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">[</span><span class="n">fcp_qidx</span><span class="p">]);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">fcp_qidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Release fast-path event queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">fcp_qidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_qidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">;</span>
		     <span class="n">fcp_qidx</span><span class="o">++</span><span class="p">)</span>
			<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">[</span><span class="n">fcp_qidx</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Release slow-path event queue */</span>
	<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_queue_setup - Set up all the SLI4 queues</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to set up all the SLI4 queues for the FCoE HBA</span>
<span class="cm"> * operation.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *      0 - successful</span>
<span class="cm"> *      -ENOMEM - No available memory</span>
<span class="cm"> *      -EIO - The mailbox failed to complete successfully.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_queue_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fcp_eqidx</span><span class="p">,</span> <span class="n">fcp_cqidx</span><span class="p">,</span> <span class="n">fcp_wqidx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fcp_cq_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up Event Queues (EQs)</span>
<span class="cm">	 */</span>

	<span class="cm">/* Set up slow-path event queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0520 Slow-path EQ not allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_eq_create</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="p">,</span>
			    <span class="n">LPFC_SP_DEF_IMAX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0521 Failed setup of slow-path EQ: &quot;</span>
				<span class="s">&quot;rc = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2583 Slow-path EQ setup: queue-id=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>

	<span class="cm">/* Set up fast-path event queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3147 Fast-path EQs not allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_destroy_sp_eq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fcp_eqidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_eqidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">;</span> <span class="n">fcp_eqidx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">[</span><span class="n">fcp_eqidx</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0522 Fast-path EQ (%d) not &quot;</span>
					<span class="s">&quot;allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcp_eqidx</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_destroy_fp_eq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_eq_create</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">[</span><span class="n">fcp_eqidx</span><span class="p">],</span>
				    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_imax</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0523 Failed setup of fast-path EQ &quot;</span>
					<span class="s">&quot;(%d), rc = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcp_eqidx</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_destroy_fp_eq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2584 Fast-path EQ setup: &quot;</span>
				<span class="s">&quot;queue[%d]-id=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcp_eqidx</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">[</span><span class="n">fcp_eqidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up Complete Queues (CQs)</span>
<span class="cm">	 */</span>

	<span class="cm">/* Set up slow-path MBOX Complete Queue as the first CQ */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_cq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0528 Mailbox CQ not allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_destroy_fp_eq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_cq_create</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_cq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="p">,</span>
			    <span class="n">LPFC_MCQ</span><span class="p">,</span> <span class="n">LPFC_MBOX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0529 Failed setup of slow-path mailbox CQ: &quot;</span>
				<span class="s">&quot;rc = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_destroy_fp_eq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2585 MBX CQ setup: cq-id=%d, parent eq-id=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>

	<span class="cm">/* Set up slow-path ELS Complete Queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0530 ELS CQ not allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_destroy_mbx_cq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_cq_create</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="p">,</span>
			    <span class="n">LPFC_WCQ</span><span class="p">,</span> <span class="n">LPFC_ELS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0531 Failed setup of slow-path ELS CQ: &quot;</span>
				<span class="s">&quot;rc = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_destroy_mbx_cq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2586 ELS CQ setup: cq-id=%d, parent eq-id=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>

	<span class="cm">/* Set up fast-path FCP Response Complete Queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3148 Fast-path FCP CQ array not &quot;</span>
				<span class="s">&quot;allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_destroy_els_cq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fcp_cqidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">[</span><span class="n">fcp_cqidx</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0526 Fast-path FCP CQ (%d) not &quot;</span>
					<span class="s">&quot;allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcp_cqidx</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_destroy_fcp_cq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_cq_create</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
					    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">[</span><span class="n">fcp_cqidx</span><span class="p">],</span>
					    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">[</span><span class="n">fcp_cqidx</span><span class="p">],</span>
					    <span class="n">LPFC_WCQ</span><span class="p">,</span> <span class="n">LPFC_FCP</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_cq_create</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
					    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">[</span><span class="n">fcp_cqidx</span><span class="p">],</span>
					    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="p">,</span>
					    <span class="n">LPFC_WCQ</span><span class="p">,</span> <span class="n">LPFC_FCP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0527 Failed setup of fast-path FCP &quot;</span>
					<span class="s">&quot;CQ (%d), rc = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcp_cqidx</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_destroy_fcp_cq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2588 FCP CQ setup: cq[%d]-id=%d, &quot;</span>
				<span class="s">&quot;parent %seq[%d]-id=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">fcp_cqidx</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">[</span><span class="n">fcp_cqidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">,</span>
				<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;sp_&quot;</span><span class="p">,</span>
				<span class="n">fcp_cqidx</span><span class="p">,</span>
				<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">)</span> <span class="o">?</span>
				   <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">[</span><span class="n">fcp_cqidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">:</span>
				   <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">fcp_cqidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up all the Work Queues (WQs)</span>
<span class="cm">	 */</span>

	<span class="cm">/* Set up Mailbox Command Queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0538 Slow-path MQ not allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_destroy_fcp_cq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_mq_create</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_wq</span><span class="p">,</span>
			    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_cq</span><span class="p">,</span> <span class="n">LPFC_MBOX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0539 Failed setup of slow-path MQ: &quot;</span>
				<span class="s">&quot;rc = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_destroy_fcp_cq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2589 MBX MQ setup: wq-id=%d, parent cq-id=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_wq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>

	<span class="cm">/* Set up slow-path ELS Work Queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0536 Slow-path ELS WQ not allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_destroy_mbx_wq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_wq_create</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span><span class="p">,</span>
			    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span><span class="p">,</span> <span class="n">LPFC_ELS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0537 Failed setup of slow-path ELS WQ: &quot;</span>
				<span class="s">&quot;rc = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_destroy_mbx_wq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2590 ELS WQ setup: wq-id=%d, parent cq-id=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>

	<span class="cm">/* Set up fast-path FCP Work Queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3149 Fast-path FCP WQ array not &quot;</span>
				<span class="s">&quot;allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_destroy_els_wq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fcp_wqidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_wqidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_wq_count</span><span class="p">;</span> <span class="n">fcp_wqidx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">[</span><span class="n">fcp_wqidx</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0534 Fast-path FCP WQ (%d) not &quot;</span>
					<span class="s">&quot;allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcp_wqidx</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_destroy_fcp_wq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_wq_create</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">[</span><span class="n">fcp_wqidx</span><span class="p">],</span>
				    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">[</span><span class="n">fcp_cq_index</span><span class="p">],</span>
				    <span class="n">LPFC_FCP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0535 Failed setup of fast-path FCP &quot;</span>
					<span class="s">&quot;WQ (%d), rc = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcp_wqidx</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_destroy_fcp_wq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2591 FCP WQ setup: wq[%d]-id=%d, &quot;</span>
				<span class="s">&quot;parent cq[%d]-id=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">fcp_wqidx</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">[</span><span class="n">fcp_wqidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">,</span>
				<span class="n">fcp_cq_index</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">[</span><span class="n">fcp_cq_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
		<span class="cm">/* Round robin FCP Work Queue&#39;s Completion Queue assignment */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">)</span>
			<span class="n">fcp_cq_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">fcp_cq_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create Receive Queue (RQ)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">hdr_rq</span> <span class="o">||</span> <span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">dat_rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0540 Receive Queue not allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_destroy_fcp_wq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_rq_adjust_repost</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">hdr_rq</span><span class="p">,</span> <span class="n">LPFC_ELS_HBQ</span><span class="p">);</span>
	<span class="n">lpfc_rq_adjust_repost</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">dat_rq</span><span class="p">,</span> <span class="n">LPFC_ELS_HBQ</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_rq_create</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">hdr_rq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">dat_rq</span><span class="p">,</span>
			    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span><span class="p">,</span> <span class="n">LPFC_USOL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0541 Failed setup of Receive Queue: &quot;</span>
				<span class="s">&quot;rc = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_destroy_fcp_wq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2592 USL RQ setup: hdr-rq-id=%d, dat-rq-id=%d &quot;</span>
			<span class="s">&quot;parent cq-id=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">hdr_rq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">dat_rq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_destroy_fcp_wq:</span>
	<span class="k">for</span> <span class="p">(</span><span class="o">--</span><span class="n">fcp_wqidx</span><span class="p">;</span> <span class="n">fcp_wqidx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_wqidx</span><span class="o">--</span><span class="p">)</span>
		<span class="n">lpfc_wq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">[</span><span class="n">fcp_wqidx</span><span class="p">]);</span>
<span class="nl">out_destroy_els_wq:</span>
	<span class="n">lpfc_wq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span><span class="p">);</span>
<span class="nl">out_destroy_mbx_wq:</span>
	<span class="n">lpfc_mq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_wq</span><span class="p">);</span>
<span class="nl">out_destroy_fcp_cq:</span>
	<span class="k">for</span> <span class="p">(</span><span class="o">--</span><span class="n">fcp_cqidx</span><span class="p">;</span> <span class="n">fcp_cqidx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_cqidx</span><span class="o">--</span><span class="p">)</span>
		<span class="n">lpfc_cq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">[</span><span class="n">fcp_cqidx</span><span class="p">]);</span>
<span class="nl">out_destroy_els_cq:</span>
	<span class="n">lpfc_cq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span><span class="p">);</span>
<span class="nl">out_destroy_mbx_cq:</span>
	<span class="n">lpfc_cq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_cq</span><span class="p">);</span>
<span class="nl">out_destroy_fp_eq:</span>
	<span class="k">for</span> <span class="p">(</span><span class="o">--</span><span class="n">fcp_eqidx</span><span class="p">;</span> <span class="n">fcp_eqidx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_eqidx</span><span class="o">--</span><span class="p">)</span>
		<span class="n">lpfc_eq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">[</span><span class="n">fcp_eqidx</span><span class="p">]);</span>
<span class="nl">out_destroy_sp_eq:</span>
	<span class="n">lpfc_eq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="p">);</span>
<span class="nl">out_error:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_queue_unset - Unset all the SLI4 queues</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to unset all the SLI4 queues with the FCoE HBA</span>
<span class="cm"> * operation.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *      0 - successful</span>
<span class="cm"> *      -ENOMEM - No available memory</span>
<span class="cm"> *      -EIO - The mailbox failed to complete successfully.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_queue_unset</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fcp_qidx</span><span class="p">;</span>

	<span class="cm">/* Unset mailbox command work queue */</span>
	<span class="n">lpfc_mq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_wq</span><span class="p">);</span>
	<span class="cm">/* Unset ELS work queue */</span>
	<span class="n">lpfc_wq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span><span class="p">);</span>
	<span class="cm">/* Unset unsolicited receive queue */</span>
	<span class="n">lpfc_rq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">hdr_rq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">dat_rq</span><span class="p">);</span>
	<span class="cm">/* Unset FCP work queue */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fcp_qidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_qidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_wq_count</span><span class="p">;</span> <span class="n">fcp_qidx</span><span class="o">++</span><span class="p">)</span>
		<span class="n">lpfc_wq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">[</span><span class="n">fcp_qidx</span><span class="p">]);</span>
	<span class="cm">/* Unset mailbox command complete queue */</span>
	<span class="n">lpfc_cq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_cq</span><span class="p">);</span>
	<span class="cm">/* Unset ELS complete queue */</span>
	<span class="n">lpfc_cq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span><span class="p">);</span>
	<span class="cm">/* Unset FCP response complete queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fcp_qidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">lpfc_cq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">[</span><span class="n">fcp_qidx</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">fcp_qidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Unset fast-path event queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">fcp_qidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_qidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">;</span>
		     <span class="n">fcp_qidx</span><span class="o">++</span><span class="p">)</span>
			<span class="n">lpfc_eq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">[</span><span class="n">fcp_qidx</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="cm">/* Unset slow-path event queue */</span>
	<span class="n">lpfc_eq_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_cq_event_pool_create - Create completion-queue event free pool</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to allocate and set up a pool of completion queue</span>
<span class="cm"> * events. The body of the completion queue event is a completion queue entry</span>
<span class="cm"> * CQE. For now, this pool is used for the interrupt service routine to queue</span>
<span class="cm"> * the following HBA completion queue events for the worker thread to process:</span>
<span class="cm"> *   - Mailbox asynchronous events</span>
<span class="cm"> *   - Receive queue completion unsolicited events</span>
<span class="cm"> * Later, this can be used for all the slow-path events.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *      0 - successful</span>
<span class="cm"> *      -ENOMEM - No available memory</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_cq_event_pool_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span><span class="n">cq_event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">cq_ecount</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cq_event</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_cq_event</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cq_event</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_pool_create_fail</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_cqe_event_pool</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_pool_create_fail:</span>
	<span class="n">lpfc_sli4_cq_event_pool_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_cq_event_pool_destroy - Free completion-queue event free pool</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to free the pool of completion queue events at</span>
<span class="cm"> * driver unload time. Note that, it is the responsibility of the driver</span>
<span class="cm"> * cleanup routine to free all the outstanding completion-queue events</span>
<span class="cm"> * allocated from this pool back into the pool before invoking this routine</span>
<span class="cm"> * to destroy the pool.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_cq_event_pool_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span><span class="n">cq_event</span><span class="p">,</span> <span class="o">*</span><span class="n">next_cq_event</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cq_event</span><span class="p">,</span> <span class="n">next_cq_event</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_cqe_event_pool</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cq_event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lpfc_sli4_cq_event_alloc - Allocate a completion-queue event from free pool</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the lock free version of the API invoked to allocate a</span>
<span class="cm"> * completion-queue event from the free pool.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: Pointer to the newly allocated completion-queue event if successful</span>
<span class="cm"> *         NULL otherwise.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span>
<span class="nf">__lpfc_sli4_cq_event_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span><span class="n">cq_event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_cqe_event_pool</span><span class="p">,</span> <span class="n">cq_event</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lpfc_cq_event</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cq_event</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_cq_event_alloc - Allocate a completion-queue event from free pool</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the lock version of the API invoked to allocate a</span>
<span class="cm"> * completion-queue event from the free pool.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: Pointer to the newly allocated completion-queue event if successful</span>
<span class="cm"> *         NULL otherwise.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span>
<span class="nf">lpfc_sli4_cq_event_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span><span class="n">cq_event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">cq_event</span> <span class="o">=</span> <span class="n">__lpfc_sli4_cq_event_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cq_event</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lpfc_sli4_cq_event_release - Release a completion-queue event to free pool</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cq_event: pointer to the completion queue event to be freed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the lock free version of the API invoked to release a</span>
<span class="cm"> * completion-queue event back into the free pool.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">__lpfc_sli4_cq_event_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span><span class="n">cq_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_cqe_event_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_cq_event_release - Release a completion-queue event to free pool</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cq_event: pointer to the completion queue event to be freed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the lock version of the API invoked to release a</span>
<span class="cm"> * completion-queue event back into the free pool.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_cq_event_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span><span class="n">cq_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">__lpfc_sli4_cq_event_release</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cq_event</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_cq_event_release_all - Release all cq events to the free pool</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to free all the pending completion-queue events to the</span>
<span class="cm"> * back into the free pool for device reset.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_cq_event_release_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">cqelist</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span><span class="n">cqe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="cm">/* Retrieve all the pending WCQEs from pending WCQE lists */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="cm">/* Pending FCP XRI abort events */</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_fcp_xri_aborted_work_queue</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">cqelist</span><span class="p">);</span>
	<span class="cm">/* Pending ELS XRI abort events */</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_els_xri_aborted_work_queue</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">cqelist</span><span class="p">);</span>
	<span class="cm">/* Pending asynnc events */</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_asynce_work_queue</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">cqelist</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqelist</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqelist</span><span class="p">,</span> <span class="n">cqe</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_cq_event</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">lpfc_sli4_cq_event_release</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_pci_function_reset - Reset pci function.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to request a PCI function reset. It will destroys</span>
<span class="cm"> * all resources assigned to the PCI function which originates this request.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *      0 - successful</span>
<span class="cm"> *      -ENOMEM - No available memory</span>
<span class="cm"> *      -EIO - The mailbox failed to complete successfully.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_pci_function_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">if_type</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">rdy_chk</span><span class="p">,</span> <span class="n">num_resets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reset_again</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_register</span> <span class="n">reg_data</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">devid</span><span class="p">;</span>

	<span class="n">if_type</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">if_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_0</span>:
		<span class="n">mboxq</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span>
						       <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0494 Unable to allocate memory for &quot;</span>
					<span class="s">&quot;issuing SLI_FUNCTION_RESET mailbox &quot;</span>
					<span class="s">&quot;command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Setup PCI function reset mailbox-ioctl command */</span>
		<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
				 <span class="n">LPFC_MBOX_OPCODE_FUNCTION_RESET</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
		<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span>
			<span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_config</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
		<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
		<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0495 SLI_FUNCTION_RESET mailbox &quot;</span>
					<span class="s">&quot;failed with status x%x add_status x%x,&quot;</span>
					<span class="s">&quot; mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_2</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">num_resets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">num_resets</span> <span class="o">&lt;</span> <span class="n">MAX_IF_TYPE_2_RESETS</span><span class="p">;</span>
		     <span class="n">num_resets</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reg_data</span><span class="p">.</span><span class="n">word0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sliport_ctrl_end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_data</span><span class="p">,</span>
			       <span class="n">LPFC_SLIPORT_LITTLE_ENDIAN</span><span class="p">);</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sliport_ctrl_ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_data</span><span class="p">,</span>
			       <span class="n">LPFC_SLIPORT_INIT_PORT</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">reg_data</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span>
			       <span class="n">CTRLregaddr</span><span class="p">);</span>
			<span class="cm">/* flush */</span>
			<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span>
					     <span class="n">PCI_DEVICE_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devid</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Poll the Port Status Register and wait for RDY for</span>
<span class="cm">			 * up to 10 seconds.  If the port doesn&#39;t respond, treat</span>
<span class="cm">			 * it as an error.  If the port responds with RN, start</span>
<span class="cm">			 * the loop again.</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">rdy_chk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rdy_chk</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">rdy_chk</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span>
					      <span class="n">STATUSregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_data</span><span class="p">.</span><span class="n">word0</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sliport_status_rn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_data</span><span class="p">))</span>
					<span class="n">reset_again</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sliport_status_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_data</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the port responds to the init request with</span>
<span class="cm">			 * reset needed, delay for a bit and restart the loop.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reset_again</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rdy_chk</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
				<span class="n">reset_again</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Detect any port errors. */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sliport_status_err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_data</span><span class="p">))</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">rdy_chk</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">ERR1regaddr</span><span class="p">);</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">ERR2regaddr</span><span class="p">);</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2890 Port error detected during port &quot;</span>
					<span class="s">&quot;reset(%d): wait_tmo:%d ms, &quot;</span>
					<span class="s">&quot;port status reg 0x%x, &quot;</span>
					<span class="s">&quot;error 1=0x%x, error 2=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">num_resets</span><span class="p">,</span> <span class="n">rdy_chk</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span>
					<span class="n">reg_data</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Terminate the outer loop provided the Port indicated</span>
<span class="cm">			 * ready within 10 seconds.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rdy_chk</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* delay driver action following IF_TYPE_2 function reset */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_1</span>:
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="cm">/* Catch the not-ready port failure after a port reset. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_resets</span> <span class="o">&gt;=</span> <span class="n">MAX_IF_TYPE_2_RESETS</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_send_nop_mbox_cmds - Send sli-4 nop mailbox commands</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cnt: number of nop mailbox commands to send.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to send a number @cnt of NOP mailbox command and</span>
<span class="cm"> * wait for each command to complete.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: the number of NOP mailbox command completed.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_send_nop_mbox_cmds</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="n">cmdsent</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mbox_tmo</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2518 Requested to send 0 NOP mailbox cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mboxq</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2519 Unable to allocate memory for issuing &quot;</span>
				<span class="s">&quot;NOP mailbox command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up NOP SLI4_CONFIG mailbox-ioctl command */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_nop</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_NOP</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cmdsent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cmdsent</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">cmdsent</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">mbox_tmo</span> <span class="o">=</span> <span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">mbox_tmo</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* Check return status */</span>
		<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span>
			<span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_config</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
		<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
		<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2520 NOP mailbox command failed &quot;</span>
					<span class="s">&quot;status x%x add_status x%x mbx &quot;</span>
					<span class="s">&quot;status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shdr_status</span><span class="p">,</span>
					<span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cmdsent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_pci_mem_setup - Setup SLI4 HBA PCI memory space.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to set up the PCI device memory space for device</span>
<span class="cm"> * with SLI-4 interface spec.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> * 	other values - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_pci_mem_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bar0map_len</span><span class="p">,</span> <span class="n">bar1map_len</span><span class="p">,</span> <span class="n">bar2map_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">if_type</span><span class="p">;</span>

	<span class="cm">/* Obtain PCI device reference */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">;</span>

	<span class="cm">/* Set the device DMA mask size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span>
	 <span class="o">||</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span><span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span>
		 <span class="o">||</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span><span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The BARs and register set definitions and offset locations are</span>
<span class="cm">	 * dependent on the if_type.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">LPFC_SLI_INTF</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">.</span><span class="n">word0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* There is no SLI3 failback for SLI4 devices. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_valid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">LPFC_SLI_INTF_VALID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2894 SLI_INTF reg contents invalid &quot;</span>
				<span class="s">&quot;sli_intf reg 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">.</span><span class="n">word0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">if_type</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the bus address of SLI4 device Bar regions and the</span>
<span class="cm">	 * number of bytes required by each mapping. The mapping of the</span>
<span class="cm">	 * particular PCI BARs regions is dependent on the type of</span>
<span class="cm">	 * SLI4 device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_bar0_map</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bar0map_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Map SLI4 PCI Config Space Register base to a kernel virtual</span>
<span class="cm">		 * addr</span>
<span class="cm">		 */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">=</span>
			<span class="n">ioremap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_bar0_map</span><span class="p">,</span> <span class="n">bar0map_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				   <span class="s">&quot;ioremap failed for SLI4 PCI config &quot;</span>
				   <span class="s">&quot;registers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Set up BAR0 PCI config space register memory map */</span>
		<span class="n">lpfc_sli4_bar0_register_memmap</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">if_type</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_bar0_map</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bar0map_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">if_type</span> <span class="o">==</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;FATAL - No BAR0 mapping for SLI4, if_type 2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">=</span>
				<span class="n">ioremap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_bar0_map</span><span class="p">,</span> <span class="n">bar0map_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;ioremap failed for SLI4 PCI config &quot;</span>
				<span class="s">&quot;registers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_sli4_bar0_register_memmap</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">if_type</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">if_type</span> <span class="o">==</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Map SLI4 if type 0 HBA Control Register base to a kernel</span>
<span class="cm">		 * virtual address and setup the registers.</span>
<span class="cm">		 */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_bar1_map</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">bar1map_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ctrl_regs_memmap_p</span> <span class="o">=</span>
				<span class="n">ioremap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_bar1_map</span><span class="p">,</span> <span class="n">bar1map_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ctrl_regs_memmap_p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;ioremap failed for SLI4 HBA control registers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_iounmap_conf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_sli4_bar1_register_memmap</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">if_type</span> <span class="o">==</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Map SLI4 if type 0 HBA Doorbell Register base to a kernel</span>
<span class="cm">		 * virtual address and setup the registers.</span>
<span class="cm">		 */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_bar2_map</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">bar2map_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">drbl_regs_memmap_p</span> <span class="o">=</span>
				<span class="n">ioremap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_bar2_map</span><span class="p">,</span> <span class="n">bar2map_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">drbl_regs_memmap_p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;ioremap failed for SLI4 HBA doorbell registers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_iounmap_ctrl</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_sli4_bar2_register_memmap</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_VF0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_iounmap_all</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_iounmap_all:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">drbl_regs_memmap_p</span><span class="p">);</span>
<span class="nl">out_iounmap_ctrl:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ctrl_regs_memmap_p</span><span class="p">);</span>
<span class="nl">out_iounmap_conf:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_pci_mem_unset - Unset SLI4 HBA PCI memory space.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to unset the PCI device memory space for device</span>
<span class="cm"> * with SLI-4 interface spec.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_pci_mem_unset</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">if_type</span><span class="p">;</span>
	<span class="n">if_type</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">if_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_0</span>:
		<span class="n">iounmap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">drbl_regs_memmap_p</span><span class="p">);</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ctrl_regs_memmap_p</span><span class="p">);</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_2</span>:
		<span class="n">iounmap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_1</span>:
	<span class="nl">default:</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;FATAL - unsupported SLI4 interface type - %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">if_type</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_enable_msix - Enable MSI-X interrupt mode on SLI-3 device</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to enable the MSI-X interrupt vectors to device</span>
<span class="cm"> * with SLI-3 interface specs. The kernel function pci_enable_msix() is</span>
<span class="cm"> * called to enable the MSI-X vectors. Note that pci_enable_msix(), once</span>
<span class="cm"> * invoked, enables either all or nothing, depending on the current</span>
<span class="cm"> * availability of PCI vector resources. The device driver is responsible</span>
<span class="cm"> * for calling the individual request_irq() to register each MSI-X vector</span>
<span class="cm"> * with a interrupt handler, which is done in this function. Note that</span>
<span class="cm"> * later when device is unloading, the driver should always call free_irq()</span>
<span class="cm"> * on all MSI-X vectors it has done request_irq() on before calling</span>
<span class="cm"> * pci_disable_msix(). Failure to do so results in a BUG_ON() and a device</span>
<span class="cm"> * will be left with MSI-X enabled and leaks its vectors.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - successful</span>
<span class="cm"> *   other values - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_enable_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>

	<span class="cm">/* Set up MSI-X multi-message vectors */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPFC_MSIX_VECTORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Configure MSI-X capability structure */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">,</span>
				<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0420 PCI enable MSI-X failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">msi_fail_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPFC_MSIX_VECTORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0477 MSI-X entry[%d]: vector=x%x &quot;</span>
				<span class="s">&quot;message=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Assign MSI-X vectors to interrupt handlers</span>
<span class="cm">	 */</span>

	<span class="cm">/* vector-0 is associated to slow-path handler */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">lpfc_sli_sp_intr_handler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			 <span class="n">LPFC_SP_DRIVER_HANDLER_NAME</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0421 MSI-X slow-path request_irq failed &quot;</span>
				<span class="s">&quot;(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">msi_fail_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* vector-1 is associated to fast-path handler */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">lpfc_sli_fp_intr_handler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			 <span class="n">LPFC_FP_DRIVER_HANDLER_NAME</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0429 MSI-X fast-path request_irq failed &quot;</span>
				<span class="s">&quot;(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">irq_fail_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Configure HBA MSI-X attention conditions to messages</span>
<span class="cm">	 */</span>
	<span class="n">pmb</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0474 Unable to allocate memory for issuing &quot;</span>
				<span class="s">&quot;MBOX_CONFIG_MSI command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">mem_fail_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_config_msi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">mbx_fail_out</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
				<span class="s">&quot;0351 Config MSI mailbox command failed, &quot;</span>
				<span class="s">&quot;mbxCmd x%x, mbxStatus x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">mbx_fail_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Free memory allocated for mailbox command */</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="nl">mbx_fail_out:</span>
	<span class="cm">/* Free memory allocated for mailbox command */</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

<span class="nl">mem_fail_out:</span>
	<span class="cm">/* free the irq already requested */</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>

<span class="nl">irq_fail_out:</span>
	<span class="cm">/* free the irq already requested */</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>

<span class="nl">msi_fail_out:</span>
	<span class="cm">/* Unconfigure MSI-X capability structure */</span>
	<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_disable_msix - Disable MSI-X interrupt mode on SLI-3 device.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to release the MSI-X vectors and then disable the</span>
<span class="cm"> * MSI-X interrupt mode to device with SLI-3 interface spec.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_disable_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Free up MSI-X multi-message vectors */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPFC_MSIX_VECTORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>
	<span class="cm">/* Disable MSI-X */</span>
	<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_enable_msi - Enable MSI interrupt mode on SLI-3 device.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to enable the MSI interrupt mode to device with</span>
<span class="cm"> * SLI-3 interface spec. The kernel function pci_enable_msi() is called to</span>
<span class="cm"> * enable the MSI vector. The device driver is responsible for calling the</span>
<span class="cm"> * request_irq() to register MSI vector with a interrupt the handler, which</span>
<span class="cm"> * is done in this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> * 	other values - error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_enable_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0462 PCI enable MSI mode success.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0471 PCI enable MSI mode failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">lpfc_sli_intr_handler</span><span class="p">,</span>
			 <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">LPFC_DRIVER_NAME</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0478 MSI request_irq failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_disable_msi - Disable MSI interrupt mode to SLI-3 device.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to disable the MSI interrupt mode to device with</span>
<span class="cm"> * SLI-3 interface spec. The driver calls free_irq() on MSI vector it has</span>
<span class="cm"> * done request_irq() on before calling pci_disable_msi(). Failure to do so</span>
<span class="cm"> * results in a BUG_ON() and a device will be left with MSI enabled and leaks</span>
<span class="cm"> * its vector.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_disable_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>
	<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_enable_intr - Enable device interrupt to SLI-3 device.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to enable device interrupt and associate driver&#39;s</span>
<span class="cm"> * interrupt handler(s) to interrupt vector(s) to device with SLI-3 interface</span>
<span class="cm"> * spec. Depends on the interrupt mode configured to the driver, the driver</span>
<span class="cm"> * will try to fallback from the configured interrupt mode to an interrupt</span>
<span class="cm"> * mode which is supported by the platform, kernel, and device in the order</span>
<span class="cm"> * of:</span>
<span class="cm"> * MSI-X -&gt; MSI -&gt; IRQ.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - successful</span>
<span class="cm"> *   other values - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">lpfc_sli_enable_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cfg_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">intr_mode</span> <span class="o">=</span> <span class="n">LPFC_INTR_ERROR</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfg_mode</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Need to issue conf_port mbox cmd before conf_msi mbox cmd */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">lpfc_sli_config_port</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_SLI_REV3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Now, try to enable MSI-X interrupt mode */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">lpfc_sli_enable_msix</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Indicate initialization to MSI-X mode */</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">=</span> <span class="n">MSIX</span><span class="p">;</span>
				<span class="n">intr_mode</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Fallback to MSI if MSI-X initialization failed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg_mode</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">lpfc_sli_enable_msi</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Indicate initialization to MSI mode */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">=</span> <span class="n">MSI</span><span class="p">;</span>
			<span class="n">intr_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Fallback to INTx if both MSI-X/MSI initalization failed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">lpfc_sli_intr_handler</span><span class="p">,</span>
				     <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">LPFC_DRIVER_NAME</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Indicate initialization to INTx mode */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">=</span> <span class="n">INTx</span><span class="p">;</span>
			<span class="n">intr_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">intr_mode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_disable_intr - Disable device interrupt to SLI-3 device.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to disable device interrupt and disassociate the</span>
<span class="cm"> * driver&#39;s interrupt handler(s) from interrupt vector(s) to device with</span>
<span class="cm"> * SLI-3 interface spec. Depending on the interrupt mode, the driver will</span>
<span class="cm"> * release the interrupt vector(s) for the message signaled interrupt.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_disable_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable the currently initialized interrupt mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">MSIX</span><span class="p">)</span>
		<span class="n">lpfc_sli_disable_msix</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">MSI</span><span class="p">)</span>
		<span class="n">lpfc_sli_disable_msi</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">INTx</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Reset interrupt management states */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">=</span> <span class="n">NONE</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">slistat</span><span class="p">.</span><span class="n">sli_intr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_enable_msix - Enable MSI-X interrupt mode to SLI-4 device</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to enable the MSI-X interrupt vectors to device</span>
<span class="cm"> * with SLI-4 interface spec. The kernel function pci_enable_msix() is called</span>
<span class="cm"> * to enable the MSI-X vectors. Note that pci_enable_msix(), once invoked,</span>
<span class="cm"> * enables either all or nothing, depending on the current availability of</span>
<span class="cm"> * PCI vector resources. The device driver is responsible for calling the</span>
<span class="cm"> * individual request_irq() to register each MSI-X vector with a interrupt</span>
<span class="cm"> * handler, which is done in this function. Note that later when device is</span>
<span class="cm"> * unloading, the driver should always call free_irq() on all MSI-X vectors</span>
<span class="cm"> * it has done request_irq() on before calling pci_disable_msix(). Failure</span>
<span class="cm"> * to do so results in a BUG_ON() and a device will be left with MSI-X</span>
<span class="cm"> * enabled and leaks its vectors.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 0 - successful</span>
<span class="cm"> * other values - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_enable_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">vectors</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* Set up MSI-X multi-message vectors */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">cfg_eqn</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* Configure MSI-X capability structure */</span>
	<span class="n">vectors</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">cfg_eqn</span><span class="p">;</span>
<span class="nl">enable_msix_vectors:</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">,</span>
			     <span class="n">vectors</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vectors</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">enable_msix_vectors</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0484 PCI enable MSI-X failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">msi_fail_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Log MSI-X vector assignment */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">vectors</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0489 MSI-X entry[%d]: vector=x%x &quot;</span>
				<span class="s">&quot;message=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">entry</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Assign MSI-X vectors to interrupt handlers</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vectors</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">lpfc_sli4_sp_intr_handler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
				 <span class="n">LPFC_SP_DRIVER_HANDLER_NAME</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/* All Interrupts need to be handled by one EQ */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">lpfc_sli4_intr_handler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
				 <span class="n">LPFC_DRIVER_NAME</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0485 MSI-X slow-path request_irq failed &quot;</span>
				<span class="s">&quot;(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">msi_fail_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The rest of the vector(s) are associated to fast-path handler(s) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">vectors</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_eq_hdl</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">idx</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_eq_hdl</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">phba</span> <span class="o">=</span> <span class="n">phba</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">lpfc_sli4_fp_intr_handler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
				 <span class="n">LPFC_FP_DRIVER_HANDLER_NAME</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_eq_hdl</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0486 MSI-X fast-path (%d) &quot;</span>
					<span class="s">&quot;request_irq failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cfg_fail_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_vec_nr</span> <span class="o">=</span> <span class="n">vectors</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="nl">cfg_fail_out:</span>
	<span class="cm">/* free the irq already requested */</span>
	<span class="k">for</span> <span class="p">(</span><span class="o">--</span><span class="n">index</span><span class="p">;</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">index</span><span class="o">--</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_eq_hdl</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>

	<span class="cm">/* free the irq already requested */</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>

<span class="nl">msi_fail_out:</span>
	<span class="cm">/* Unconfigure MSI-X capability structure */</span>
	<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_disable_msix - Disable MSI-X interrupt mode to SLI-4 device</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to release the MSI-X vectors and then disable the</span>
<span class="cm"> * MSI-X interrupt mode to device with SLI-4 interface spec.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_disable_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* Free up MSI-X multi-message vectors */</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_vec_nr</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_eq_hdl</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>

	<span class="cm">/* Disable MSI-X */</span>
	<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_enable_msi - Enable MSI interrupt mode to SLI-4 device</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to enable the MSI interrupt mode to device with</span>
<span class="cm"> * SLI-4 interface spec. The kernel function pci_enable_msi() is called</span>
<span class="cm"> * to enable the MSI vector. The device driver is responsible for calling</span>
<span class="cm"> * the request_irq() to register MSI vector with a interrupt the handler,</span>
<span class="cm"> * which is done in this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> * 	other values - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_enable_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0487 PCI enable MSI mode success.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0488 PCI enable MSI mode failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">lpfc_sli4_intr_handler</span><span class="p">,</span>
			 <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">LPFC_DRIVER_NAME</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0490 MSI request_irq failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_eq_hdl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">idx</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_eq_hdl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">phba</span> <span class="o">=</span> <span class="n">phba</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_disable_msi - Disable MSI interrupt mode to SLI-4 device</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to disable the MSI interrupt mode to device with</span>
<span class="cm"> * SLI-4 interface spec. The driver calls free_irq() on MSI vector it has</span>
<span class="cm"> * done request_irq() on before calling pci_disable_msi(). Failure to do so</span>
<span class="cm"> * results in a BUG_ON() and a device will be left with MSI enabled and leaks</span>
<span class="cm"> * its vector.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_disable_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>
	<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_enable_intr - Enable device interrupt to SLI-4 device</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to enable device interrupt and associate driver&#39;s</span>
<span class="cm"> * interrupt handler(s) to interrupt vector(s) to device with SLI-4</span>
<span class="cm"> * interface spec. Depends on the interrupt mode configured to the driver,</span>
<span class="cm"> * the driver will try to fallback from the configured interrupt mode to an</span>
<span class="cm"> * interrupt mode which is supported by the platform, kernel, and device in</span>
<span class="cm"> * the order of:</span>
<span class="cm"> * MSI-X -&gt; MSI -&gt; IRQ.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> * 	other values - error</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">lpfc_sli4_enable_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cfg_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">intr_mode</span> <span class="o">=</span> <span class="n">LPFC_INTR_ERROR</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfg_mode</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Preparation before conf_msi mbox cmd */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Now, try to enable MSI-X interrupt mode */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">lpfc_sli4_enable_msix</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Indicate initialization to MSI-X mode */</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">=</span> <span class="n">MSIX</span><span class="p">;</span>
				<span class="n">intr_mode</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Fallback to MSI if MSI-X initialization failed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg_mode</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">lpfc_sli4_enable_msi</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Indicate initialization to MSI mode */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">=</span> <span class="n">MSI</span><span class="p">;</span>
			<span class="n">intr_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Fallback to INTx if both MSI-X/MSI initalization failed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">lpfc_sli4_intr_handler</span><span class="p">,</span>
				     <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">LPFC_DRIVER_NAME</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Indicate initialization to INTx mode */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">=</span> <span class="n">INTx</span><span class="p">;</span>
			<span class="n">intr_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">;</span>
			     <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_eq_hdl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">idx</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_eq_hdl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">phba</span> <span class="o">=</span> <span class="n">phba</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">intr_mode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_disable_intr - Disable device interrupt to SLI-4 device</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to disable device interrupt and disassociate</span>
<span class="cm"> * the driver&#39;s interrupt handler(s) from interrupt vector(s) to device</span>
<span class="cm"> * with SLI-4 interface spec. Depending on the interrupt mode, the driver</span>
<span class="cm"> * will release the interrupt vector(s) for the message signaled interrupt.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_disable_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable the currently initialized interrupt mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">MSIX</span><span class="p">)</span>
		<span class="n">lpfc_sli4_disable_msix</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">MSI</span><span class="p">)</span>
		<span class="n">lpfc_sli4_disable_msi</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">INTx</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Reset interrupt management states */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">=</span> <span class="n">NONE</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">slistat</span><span class="p">.</span><span class="n">sli_intr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_unset_hba - Unset SLI3 hba device initialization</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to unset the HBA device initialization steps to</span>
<span class="cm"> * a device with SLI-3 interface spec.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_unset_hba</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">|=</span> <span class="n">FC_UNLOADING</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">);</span>

	<span class="n">lpfc_stop_hba_timers</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lpfc_sli_hba_down</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">lpfc_sli_disable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_unset_hba - Unset SLI4 hba device initialization.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to unset the HBA device initialization steps to</span>
<span class="cm"> * a device with SLI-4 interface spec.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_unset_hba</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">|=</span> <span class="n">FC_UNLOADING</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Stop the SLI4 device port */</span>
	<span class="n">lpfc_stop_port</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">lpfc_sli4_disable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Reset SLI4 HBA FCoE function */</span>
	<span class="n">lpfc_pci_function_reset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_sli4_queue_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_xri_exchange_busy_wait - Wait for device XRI exchange busy</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called in the SLI4 code path to wait for completion</span>
<span class="cm"> * of device&#39;s XRIs exchange busy. It will check the XRI exchange busy</span>
<span class="cm"> * on outstanding FCP and ELS I/Os every 10ms for up to 10 seconds; after</span>
<span class="cm"> * that, it will check the XRI exchange busy on outstanding FCP and ELS</span>
<span class="cm"> * I/Os every 30 seconds, log error message, and wait forever. Only when</span>
<span class="cm"> * all XRI exchange busy complete, the driver unload shall proceed with</span>
<span class="cm"> * invoking the function reset ioctl mailbox command to the CNA and the</span>
<span class="cm"> * the rest of the driver unload resource release.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_xri_exchange_busy_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">wait_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fcp_xri_cmpl</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_scsi_buf_list</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">els_xri_cmpl</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_els_sgl_list</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">fcp_xri_cmpl</span> <span class="o">||</span> <span class="o">!</span><span class="n">els_xri_cmpl</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_time</span> <span class="o">&gt;</span> <span class="n">LPFC_XRI_EXCH_BUSY_WAIT_TMO</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcp_xri_cmpl</span><span class="p">)</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
						<span class="s">&quot;2877 FCP XRI exchange busy &quot;</span>
						<span class="s">&quot;wait time: %d seconds.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">wait_time</span><span class="o">/</span><span class="mi">1000</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">els_xri_cmpl</span><span class="p">)</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
						<span class="s">&quot;2878 ELS XRI exchange busy &quot;</span>
						<span class="s">&quot;wait time: %d seconds.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">wait_time</span><span class="o">/</span><span class="mi">1000</span><span class="p">);</span>
			<span class="n">msleep</span><span class="p">(</span><span class="n">LPFC_XRI_EXCH_BUSY_WAIT_T2</span><span class="p">);</span>
			<span class="n">wait_time</span> <span class="o">+=</span> <span class="n">LPFC_XRI_EXCH_BUSY_WAIT_T2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="n">LPFC_XRI_EXCH_BUSY_WAIT_T1</span><span class="p">);</span>
			<span class="n">wait_time</span> <span class="o">+=</span> <span class="n">LPFC_XRI_EXCH_BUSY_WAIT_T1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fcp_xri_cmpl</span> <span class="o">=</span>
			<span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_scsi_buf_list</span><span class="p">);</span>
		<span class="n">els_xri_cmpl</span> <span class="o">=</span>
			<span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_els_sgl_list</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_hba_unset - Unset the fcoe hba</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called in the SLI4 code path to reset the HBA&#39;s FCoE</span>
<span class="cm"> * function. The caller is not required to hold any lock. This routine</span>
<span class="cm"> * issues PCI function reset mailbox command to reset the FCoE function.</span>
<span class="cm"> * At the end of the function, it calls lpfc_hba_down_post function to</span>
<span class="cm"> * free any pending commands.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_hba_unset</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">wait_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">;</span>

	<span class="n">lpfc_stop_hba_timers</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Gracefully wait out the potential current outstanding asynchronous</span>
<span class="cm">	 * mailbox command.</span>
<span class="cm">	 */</span>

	<span class="cm">/* First, block any pending async mailbox command from posted */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_SLI_ASYNC_MBX_BLK</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/* Now, trying to wait it out if we can */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">wait_cnt</span> <span class="o">&gt;</span> <span class="n">LPFC_ACTIVE_MBOX_WAIT_CNT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Forcefully release the outstanding mailbox command if timed out */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">mboxq</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">;</span>
		<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span> <span class="o">=</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">;</span>
		<span class="n">__lpfc_mbox_cmpl_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Abort all iocbs associated with the hba */</span>
	<span class="n">lpfc_sli_hba_iocb_abort</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Wait for completion of device XRI exchange busy */</span>
	<span class="n">lpfc_sli4_xri_exchange_busy_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Disable PCI subsystem interrupt */</span>
	<span class="n">lpfc_sli4_disable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Disable SR-IOV if enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span><span class="p">)</span>
		<span class="n">pci_disable_sriov</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Stop kthread signal shall trigger work_done one more time */</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span><span class="p">);</span>

	<span class="cm">/* Reset SLI4 HBA FCoE function */</span>
	<span class="n">lpfc_pci_function_reset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_sli4_queue_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Stop the SLI4 device port */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

 <span class="cm">/**</span>
<span class="cm"> * lpfc_pc_sli4_params_get - Get the SLI4_PARAMS port capabilities.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @mboxq: Pointer to the mailboxq memory for the mailbox command response.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called in the SLI4 code path to read the port&#39;s</span>
<span class="cm"> * sli4 capabilities.</span>
<span class="cm"> *</span>
<span class="cm"> * This function may be be called from any context that can block-wait</span>
<span class="cm"> * for the completion.  The expectation is that this routine is called</span>
<span class="cm"> * typically from probe_one or from the online routine.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_pc_sli4_params_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mqe</span> <span class="o">*</span><span class="n">mqe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_pc_sli4_params</span> <span class="o">*</span><span class="n">sli4_params</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mbox_tmo</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mqe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">;</span>

	<span class="cm">/* Read the port&#39;s SLI4 Parameters port capabilities */</span>
	<span class="n">lpfc_pc_sli4_params</span><span class="p">(</span><span class="n">mboxq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mbox_tmo</span> <span class="o">=</span> <span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">sli4_params</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">;</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">if_type</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">sli_rev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">sli_family</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">sli_family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">featurelevel_1</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">featurelevel_1</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">featurelevel_2</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">featurelevel_2</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">proto_types</span> <span class="o">=</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">.</span><span class="n">word3</span><span class="p">;</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">sge_supp_len</span> <span class="o">=</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">.</span><span class="n">sge_supp_len</span><span class="p">;</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">if_page_sz</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">if_page_sz</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">rq_db_window</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">rq_db_window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">loopbk_scope</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">loopbk_scope</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">eq_pages_max</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">eq_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">eqe_size</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">eqe_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">cq_pages_max</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cq_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">cqe_size</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cqe_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">mq_pages_max</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">mq_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">mqe_size</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">mqe_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">mq_elem_cnt</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">mq_elem_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">wq_pages_max</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">wq_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">wqe_size</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">wqe_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">rq_pages_max</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">rq_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">rqe_size</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">rqe_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">hdr_pages_max</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">hdr_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">hdr_size</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">hdr_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">hdr_pp_align</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">hdr_pp_align</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">sgl_pages_max</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">sgl_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">sgl_pp_align</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">sgl_pp_align</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">sli4_params</span><span class="p">);</span>

	<span class="cm">/* Make sure that sge_supp_len can be handled by the driver */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">sge_supp_len</span> <span class="o">&gt;</span> <span class="n">LPFC_MAX_SGE_SIZE</span><span class="p">)</span>
		<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">sge_supp_len</span> <span class="o">=</span> <span class="n">LPFC_MAX_SGE_SIZE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_sli4_parameters - Get the SLI4 Config PARAMETERS.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @mboxq: Pointer to the mailboxq memory for the mailbox command response.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called in the SLI4 code path to read the port&#39;s</span>
<span class="cm"> * sli4 capabilities.</span>
<span class="cm"> *</span>
<span class="cm"> * This function may be be called from any context that can block-wait</span>
<span class="cm"> * for the completion.  The expectation is that this routine is called</span>
<span class="cm"> * typically from probe_one or from the online routine.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_get_sli4_parameters</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mqe</span> <span class="o">*</span><span class="n">mqe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_pc_sli4_params</span> <span class="o">*</span><span class="n">sli4_params</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mbox_tmo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli4_parameters</span> <span class="o">*</span><span class="n">mbx_sli4_parameters</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * By default, the driver assumes the SLI4 port requires RPI</span>
<span class="cm">	 * header postings.  The SLI4_PARAM response will correct this</span>
<span class="cm">	 * assumption.</span>
<span class="cm">	 */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_hdrs_in_use</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Read the port&#39;s SLI4 Config Parameters */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_get_sli4_parameters</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_GET_SLI4_PARAMETERS</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mbox_tmo</span> <span class="o">=</span> <span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">sli4_params</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">;</span>
	<span class="n">mbx_sli4_parameters</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">get_sli4_parameters</span><span class="p">.</span><span class="n">sli4_parameters</span><span class="p">;</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">if_type</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cfg_if_type</span><span class="p">,</span> <span class="n">mbx_sli4_parameters</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cfg_sli_rev</span><span class="p">,</span> <span class="n">mbx_sli4_parameters</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">sli_family</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cfg_sli_family</span><span class="p">,</span> <span class="n">mbx_sli4_parameters</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">featurelevel_1</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cfg_sli_hint_1</span><span class="p">,</span>
					     <span class="n">mbx_sli4_parameters</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">featurelevel_2</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cfg_sli_hint_2</span><span class="p">,</span>
					     <span class="n">mbx_sli4_parameters</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">cfg_phwq</span><span class="p">,</span> <span class="n">mbx_sli4_parameters</span><span class="p">))</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">|=</span> <span class="n">LPFC_SLI4_PHWQ_ENABLED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI4_PHWQ_ENABLED</span><span class="p">;</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">sge_supp_len</span> <span class="o">=</span> <span class="n">mbx_sli4_parameters</span><span class="o">-&gt;</span><span class="n">sge_supp_len</span><span class="p">;</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">loopbk_scope</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">loopbk_scope</span><span class="p">,</span> <span class="n">mbx_sli4_parameters</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">cqv</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cfg_cqv</span><span class="p">,</span> <span class="n">mbx_sli4_parameters</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">mqv</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cfg_mqv</span><span class="p">,</span> <span class="n">mbx_sli4_parameters</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">wqv</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cfg_wqv</span><span class="p">,</span> <span class="n">mbx_sli4_parameters</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">rqv</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cfg_rqv</span><span class="p">,</span> <span class="n">mbx_sli4_parameters</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">sgl_pages_max</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cfg_sgl_page_cnt</span><span class="p">,</span>
					    <span class="n">mbx_sli4_parameters</span><span class="p">);</span>
	<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">sgl_pp_align</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cfg_sgl_pp_align</span><span class="p">,</span>
					   <span class="n">mbx_sli4_parameters</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">extents_in_use</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cfg_ext</span><span class="p">,</span> <span class="n">mbx_sli4_parameters</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_hdrs_in_use</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">cfg_hdrr</span><span class="p">,</span> <span class="n">mbx_sli4_parameters</span><span class="p">);</span>

	<span class="cm">/* Make sure that sge_supp_len can be handled by the driver */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">sge_supp_len</span> <span class="o">&gt;</span> <span class="n">LPFC_MAX_SGE_SIZE</span><span class="p">)</span>
		<span class="n">sli4_params</span><span class="o">-&gt;</span><span class="n">sge_supp_len</span> <span class="o">=</span> <span class="n">LPFC_MAX_SGE_SIZE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_pci_probe_one_s3 - PCI probe func to reg SLI-3 device to PCI subsystem.</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> * @pid: pointer to PCI device identifier</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to be called to attach a device with SLI-3 interface spec</span>
<span class="cm"> * to the PCI subsystem. When an Emulex HBA with SLI-3 interface spec is</span>
<span class="cm"> * presented on PCI bus, the kernel PCI subsystem looks at PCI device-specific</span>
<span class="cm"> * information of the device and driver to see if the driver state that it can</span>
<span class="cm"> * support this kind of device. If the match is successful, the driver core</span>
<span class="cm"> * invokes this routine. If this routine determines it can claim the HBA, it</span>
<span class="cm"> * does all the initialization that it needs to do to handle the HBA properly.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> * 	0 - driver can claim the device</span>
<span class="cm"> * 	negative value - driver can not claim the device</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">lpfc_pci_probe_one_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_mode</span><span class="p">,</span> <span class="n">intr_mode</span><span class="p">;</span>

	<span class="cm">/* Allocate memory for HBA structure */</span>
	<span class="n">phba</span> <span class="o">=</span> <span class="n">lpfc_hba_alloc</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Perform generic PCI device enabling operation */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_enable_pci_dev</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_phba</span><span class="p">;</span>

	<span class="cm">/* Set up SLI API function jump table for PCI-device group-0 HBAs */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_api_table_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_PCI_DEV_LP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_disable_pci_dev</span><span class="p">;</span>

	<span class="cm">/* Set up SLI-3 specific device PCI memory space */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_sli_pci_mem_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1402 Failed to set up pci memory space.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_disable_pci_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up phase-1 common device driver resources */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_setup_driver_resource_phase1</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1403 Failed to set up driver resource.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unset_pci_mem_s3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up SLI-3 specific device driver resources */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_sli_driver_resource_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1404 Failed to set up driver resource.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unset_pci_mem_s3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize and populate the iocb list per host */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_init_iocb_list</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_IOCB_LIST_CNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1405 Failed to initialize iocb list.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unset_driver_resource_s3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up common device driver resources */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_setup_driver_resource_phase2</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1406 Failed to set up driver resource.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_iocb_list</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the default values for Model Name and Description */</span>
	<span class="n">lpfc_get_hba_model_desc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelName</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelDesc</span><span class="p">);</span>

	<span class="cm">/* Create SCSI host to the physical port */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_create_shost</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1407 Failed to create scsi host.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unset_driver_resource</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Configure sysfs attributes */</span>
	<span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_alloc_sysfs_attr</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1476 Failed to allocate sysfs attr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_destroy_shost</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span> <span class="cm">/* save shost for error cleanup */</span>
	<span class="cm">/* Now, trying to enable interrupt and bring up the device */</span>
	<span class="n">cfg_mode</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_use_msi</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Put device to a known state before enabling interrupt */</span>
		<span class="n">lpfc_stop_port</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="cm">/* Configure and enable interrupt */</span>
		<span class="n">intr_mode</span> <span class="o">=</span> <span class="n">lpfc_sli_enable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cfg_mode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intr_mode</span> <span class="o">==</span> <span class="n">LPFC_INTR_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0431 Failed to enable interrupt.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free_sysfs_attr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* SLI-3 HBA setup */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_hba_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;1477 Failed to set up hba</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_remove_device</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Wait 50ms for the interrupts of previous mailbox commands */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="cm">/* Check active interrupts on message signaled interrupts */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intr_mode</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">slistat</span><span class="p">.</span><span class="n">sli_intr</span> <span class="o">&gt;</span> <span class="n">LPFC_MSIX_VECTORS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Log the current active interrupt mode */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_mode</span> <span class="o">=</span> <span class="n">intr_mode</span><span class="p">;</span>
			<span class="n">lpfc_log_intr_mode</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">intr_mode</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0447 Configure interrupt mode (%d) &quot;</span>
					<span class="s">&quot;failed active interrupt test.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">intr_mode</span><span class="p">);</span>
			<span class="cm">/* Disable the current interrupt mode */</span>
			<span class="n">lpfc_sli_disable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="cm">/* Try next level of interrupt mode */</span>
			<span class="n">cfg_mode</span> <span class="o">=</span> <span class="o">--</span><span class="n">intr_mode</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Perform post initialization setup */</span>
	<span class="n">lpfc_post_init_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Check if there are static vports to be created. */</span>
	<span class="n">lpfc_create_static_vport</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_remove_device:</span>
	<span class="n">lpfc_unset_hba</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_free_sysfs_attr:</span>
	<span class="n">lpfc_free_sysfs_attr</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
<span class="nl">out_destroy_shost:</span>
	<span class="n">lpfc_destroy_shost</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_unset_driver_resource:</span>
	<span class="n">lpfc_unset_driver_resource_phase2</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_free_iocb_list:</span>
	<span class="n">lpfc_free_iocb_list</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_unset_driver_resource_s3:</span>
	<span class="n">lpfc_sli_driver_resource_unset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_unset_pci_mem_s3:</span>
	<span class="n">lpfc_sli_pci_mem_unset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_disable_pci_dev:</span>
	<span class="n">lpfc_disable_pci_dev</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="p">)</span>
		<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
<span class="nl">out_free_phba:</span>
	<span class="n">lpfc_hba_free</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_pci_remove_one_s3 - PCI func to unreg SLI-3 device from PCI subsystem.</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to be called to disattach a device with SLI-3 interface</span>
<span class="cm"> * spec from PCI subsystem. When an Emulex HBA with SLI-3 interface spec is</span>
<span class="cm"> * removed from PCI bus, it performs all the necessary cleanup for the HBA</span>
<span class="cm"> * device to be removed from the PCI subsystem properly.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span>
<span class="nf">lpfc_pci_remove_one_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bars</span> <span class="o">=</span> <span class="n">pci_select_bars</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">|=</span> <span class="n">FC_UNLOADING</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">lpfc_free_sysfs_attr</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/* Release all the vports against this physical port */</span>
	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_PHYSICAL_PORT</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">fc_vport_terminate</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_vport</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>

	<span class="cm">/* Remove FC host and then SCSI host with the physical port */</span>
	<span class="n">fc_remove_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">lpfc_cleanup</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bring down the SLI Layer. This step disable all interrupts,</span>
<span class="cm">	 * clears the rings, discards all mailbox commands, and resets</span>
<span class="cm">	 * the HBA.</span>
<span class="cm">	 */</span>

	<span class="cm">/* HBA interrupt will be disabled after this call */</span>
	<span class="n">lpfc_sli_hba_down</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="cm">/* Stop kthread signal shall trigger work_done one more time */</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span><span class="p">);</span>
	<span class="cm">/* Final cleanup of txcmplq and reset the HBA */</span>
	<span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">);</span>

	<span class="n">lpfc_stop_hba_timers</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">listentry</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">lpfc_debugfs_terminate</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/* Disable SR-IOV if enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span><span class="p">)</span>
		<span class="n">pci_disable_sriov</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Disable interrupt */</span>
	<span class="n">lpfc_sli_disable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call scsi_free before mem_free since scsi bufs are released to their</span>
<span class="cm">	 * corresponding pools here.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_scsi_free</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_mem_free_all</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">lpfc_sli_hbq_size</span><span class="p">(),</span>
			  <span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqslimp</span><span class="p">.</span><span class="n">virt</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqslimp</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>

	<span class="cm">/* Free resources associated with SLI2 interface */</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">SLI2_SLIM_SIZE</span><span class="p">,</span>
			  <span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim2p</span><span class="p">.</span><span class="n">virt</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim2p</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>

	<span class="cm">/* unmap adapter SLIM and Control Registers */</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ctrl_regs_memmap_p</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">slim_memmap_p</span><span class="p">);</span>

	<span class="n">lpfc_hba_free</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">pci_release_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bars</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_pci_suspend_one_s3 - PCI func to suspend SLI-3 device for power mgmnt</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> * @msg: power management message</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to be called from the kernel&#39;s PCI subsystem to support</span>
<span class="cm"> * system Power Management (PM) to device with SLI-3 interface spec. When</span>
<span class="cm"> * PM invokes this method, it quiesces the device by stopping the driver&#39;s</span>
<span class="cm"> * worker thread for the device, turning off device&#39;s interrupt and DMA,</span>
<span class="cm"> * and bring the device offline. Note that as the driver implements the</span>
<span class="cm"> * minimum PM requirements to a power-aware driver&#39;s PM support for the</span>
<span class="cm"> * suspend/resume -- all the possible PM messages (SUSPEND, HIBERNATE, FREEZE)</span>
<span class="cm"> * to the suspend() method call will be treated as SUSPEND and the driver will</span>
<span class="cm"> * fully reinitialize its device during resume() method call, the driver will</span>
<span class="cm"> * set device to PCI_D3hot state in PCI config space instead of setting it</span>
<span class="cm"> * according to the @msg provided by the PM.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> * 	0 - driver suspended the device</span>
<span class="cm"> * 	Error otherwise</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_pci_suspend_one_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0473 PCI device Power Management suspend.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Bring down the device */</span>
	<span class="n">lpfc_offline_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span><span class="p">);</span>

	<span class="cm">/* Disable interrupt from device */</span>
	<span class="n">lpfc_sli_disable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Save device state to PCI config space */</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_pci_resume_one_s3 - PCI func to resume SLI-3 device for power mgmnt</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to be called from the kernel&#39;s PCI subsystem to support</span>
<span class="cm"> * system Power Management (PM) to device with SLI-3 interface spec. When PM</span>
<span class="cm"> * invokes this method, it restores the device&#39;s PCI config space state and</span>
<span class="cm"> * fully reinitializes the device and brings it online. Note that as the</span>
<span class="cm"> * driver implements the minimum PM requirements to a power-aware driver&#39;s</span>
<span class="cm"> * PM for suspend/resume -- all the possible PM messages (SUSPEND, HIBERNATE,</span>
<span class="cm"> * FREEZE) to the suspend() method call will be treated as SUSPEND and the</span>
<span class="cm"> * driver will fully reinitialize its device during resume() method call,</span>
<span class="cm"> * the device will be set to PCI_D0 directly in PCI config space before</span>
<span class="cm"> * restoring the state.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> * 	0 - driver suspended the device</span>
<span class="cm"> * 	Error otherwise</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_pci_resume_one_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">intr_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0452 PCI device Power Management resume.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Restore device state from PCI config space */</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * As the new kernel behavior of pci_restore_state() API call clears</span>
<span class="cm">	 * device saved_state flag, need to save the restored state again.</span>
<span class="cm">	 */</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">is_busmaster</span><span class="p">)</span>
		<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Startup the kernel thread for this host adapter. */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">lpfc_do_work</span><span class="p">,</span> <span class="n">phba</span><span class="p">,</span>
					<span class="s">&quot;lpfc_worker_%d&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">brd_no</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span><span class="p">);</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0434 PM resume failed to start worker &quot;</span>
				<span class="s">&quot;thread: error=x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Configure and enable interrupt */</span>
	<span class="n">intr_mode</span> <span class="o">=</span> <span class="n">lpfc_sli_enable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr_mode</span> <span class="o">==</span> <span class="n">LPFC_INTR_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0430 PM resume Failed to enable interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_mode</span> <span class="o">=</span> <span class="n">intr_mode</span><span class="p">;</span>

	<span class="cm">/* Restart HBA and bring it online */</span>
	<span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_online</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Log the current active interrupt mode */</span>
	<span class="n">lpfc_log_intr_mode</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_prep_dev_for_recover - Prepare SLI3 device for pci slot recover</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called to prepare the SLI3 device for PCI slot recover. It</span>
<span class="cm"> * aborts all the outstanding SCSI I/Os to the pci device.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_prep_dev_for_recover</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span>  <span class="o">*</span><span class="n">pring</span><span class="p">;</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2723 PCI channel I/O abort preparing for recovery</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * There may be errored I/Os through HBA, abort all I/Os on txcmplq</span>
<span class="cm">	 * and let the SCSI mid-layer to retry them to recover.</span>
<span class="cm">	 */</span>
	<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">fcp_ring</span><span class="p">];</span>
	<span class="n">lpfc_sli_abort_iocb_ring</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_prep_dev_for_reset - Prepare SLI3 device for pci slot reset</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called to prepare the SLI3 device for PCI slot reset. It</span>
<span class="cm"> * disables the device interrupt and pci device, and aborts the internal FCP</span>
<span class="cm"> * pending I/Os.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_prep_dev_for_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2710 PCI channel disable preparing for reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Block any management I/Os to the device */</span>
	<span class="n">lpfc_block_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Block all SCSI devices&#39; I/Os on the host */</span>
	<span class="n">lpfc_scsi_dev_block</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* stop all timers */</span>
	<span class="n">lpfc_stop_hba_timers</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Disable interrupt and pci device */</span>
	<span class="n">lpfc_sli_disable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>

	<span class="cm">/* Flush all driver&#39;s outstanding SCSI I/Os as we are to reset */</span>
	<span class="n">lpfc_sli_flush_fcp_rings</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_prep_dev_for_perm_failure - Prepare SLI3 dev for pci slot disable</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called to prepare the SLI3 device for PCI slot permanently</span>
<span class="cm"> * disabling. It blocks the SCSI transport layer traffic and flushes the FCP</span>
<span class="cm"> * pending I/Os.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_prep_dev_for_perm_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2711 PCI channel permanent disable for failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* Block all SCSI devices&#39; I/Os on the host */</span>
	<span class="n">lpfc_scsi_dev_block</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* stop all timers */</span>
	<span class="n">lpfc_stop_hba_timers</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Clean up all driver&#39;s outstanding SCSI I/Os */</span>
	<span class="n">lpfc_sli_flush_fcp_rings</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_io_error_detected_s3 - Method for handling SLI-3 device PCI I/O error</span>
<span class="cm"> * @pdev: pointer to PCI device.</span>
<span class="cm"> * @state: the current PCI connection state.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called from the PCI subsystem for I/O error handling to</span>
<span class="cm"> * device with SLI-3 interface spec. This function is called by the PCI</span>
<span class="cm"> * subsystem after a PCI bus error affecting this device has been detected.</span>
<span class="cm"> * When this function is invoked, it will need to stop all the I/Os and</span>
<span class="cm"> * interrupt(s) to the device. Once that is done, it will return</span>
<span class="cm"> * PCI_ERS_RESULT_NEED_RESET for the PCI subsystem to perform proper recovery</span>
<span class="cm"> * as desired.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	PCI_ERS_RESULT_CAN_RECOVER - can be recovered with reset_link</span>
<span class="cm"> * 	PCI_ERS_RESULT_NEED_RESET - need to reset before recovery</span>
<span class="cm"> * 	PCI_ERS_RESULT_DISCONNECT - device could not be recovered</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span>
<span class="nf">lpfc_io_error_detected_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_channel_state_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">pci_channel_io_normal</span>:
		<span class="cm">/* Non-fatal error, prepare for recovery */</span>
		<span class="n">lpfc_sli_prep_dev_for_recover</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_CAN_RECOVER</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">pci_channel_io_frozen</span>:
		<span class="cm">/* Fatal error, prepare for slot reset */</span>
		<span class="n">lpfc_sli_prep_dev_for_reset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">pci_channel_io_perm_failure</span>:
		<span class="cm">/* Permanent failure, prepare for device down */</span>
		<span class="n">lpfc_sli_prep_dev_for_perm_failure</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Unknown state, prepare and request slot reset */</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0472 Unknown PCI error state: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="n">lpfc_sli_prep_dev_for_reset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_io_slot_reset_s3 - Method for restarting PCI SLI-3 device from scratch.</span>
<span class="cm"> * @pdev: pointer to PCI device.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called from the PCI subsystem for error handling to</span>
<span class="cm"> * device with SLI-3 interface spec. This is called after PCI bus has been</span>
<span class="cm"> * reset to restart the PCI card from scratch, as if from a cold-boot.</span>
<span class="cm"> * During the PCI subsystem error recovery, after driver returns</span>
<span class="cm"> * PCI_ERS_RESULT_NEED_RESET, the PCI subsystem will perform proper error</span>
<span class="cm"> * recovery and then call this routine before calling the .resume method</span>
<span class="cm"> * to recover the device. This function will initialize the HBA device,</span>
<span class="cm"> * enable the interrupt, but it will just put the HBA to offline state</span>
<span class="cm"> * without passing any I/O traffic.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	PCI_ERS_RESULT_RECOVERED - the device has been recovered</span>
<span class="cm"> * 	PCI_ERS_RESULT_DISCONNECT - device could not be recovered</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span>
<span class="nf">lpfc_io_slot_reset_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">intr_mode</span><span class="p">;</span>

	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;recovering from a slot reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;lpfc: Cannot re-enable &quot;</span>
			<span class="s">&quot;PCI device after reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * As the new kernel behavior of pci_restore_state() API call clears</span>
<span class="cm">	 * device saved_state flag, need to save the restored state again.</span>
<span class="cm">	 */</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">is_busmaster</span><span class="p">)</span>
		<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_ACTIVE</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Configure and enable interrupt */</span>
	<span class="n">intr_mode</span> <span class="o">=</span> <span class="n">lpfc_sli_enable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr_mode</span> <span class="o">==</span> <span class="n">LPFC_INTR_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0427 Cannot re-enable interrupt after &quot;</span>
				<span class="s">&quot;slot reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_mode</span> <span class="o">=</span> <span class="n">intr_mode</span><span class="p">;</span>

	<span class="cm">/* Take device offline, it will perform cleanup */</span>
	<span class="n">lpfc_offline_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Log the current active interrupt mode */</span>
	<span class="n">lpfc_log_intr_mode</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">PCI_ERS_RESULT_RECOVERED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_io_resume_s3 - Method for resuming PCI I/O operation on SLI-3 device.</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called from the PCI subsystem for error handling to device</span>
<span class="cm"> * with SLI-3 interface spec. It is called when kernel error recovery tells</span>
<span class="cm"> * the lpfc driver that it is ok to resume normal PCI operation after PCI bus</span>
<span class="cm"> * error recovery. After this call, traffic can start to flow from this device</span>
<span class="cm"> * again.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_io_resume_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="cm">/* Bring device online, it will be no-op for non-fatal error resume */</span>
	<span class="n">lpfc_online</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Clean up Advanced Error Reporting (AER) if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_AER_ENABLED</span><span class="p">)</span>
		<span class="n">pci_cleanup_aer_uncorrect_error_status</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_get_els_iocb_cnt - Calculate the # of ELS IOCBs to reserve</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * returns the number of ELS/CT IOCBs to reserve</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_get_els_iocb_cnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max_xri</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_xri</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_xri</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">max_xri</span> <span class="o">&lt;=</span> <span class="mi">256</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">25</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">max_xri</span> <span class="o">&lt;=</span> <span class="mi">512</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">50</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">max_xri</span> <span class="o">&lt;=</span> <span class="mi">1024</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">100</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">max_xri</span> <span class="o">&lt;=</span> <span class="mi">1536</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">150</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">max_xri</span> <span class="o">&lt;=</span> <span class="mi">2048</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">200</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="mi">250</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_write_firmware - attempt to write a firmware image to the port</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fw: pointer to firmware image returned from request_firmware.</span>
<span class="cm"> *</span>
<span class="cm"> * returns the number of bytes written if write is successful.</span>
<span class="cm"> * returns a negative error value if there were errors.</span>
<span class="cm"> * returns 0 if firmware matches currently active firmware on port.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_write_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">fwrev</span><span class="p">[</span><span class="n">FW_REV_STR_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lpfc_grp_hdr</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_grp_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dma_buffer_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temp_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_buffer_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">magic_number</span><span class="p">)</span> <span class="o">!=</span> <span class="n">LPFC_GROUP_OJECT_MAGIC_NUM</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">bf_get_be32</span><span class="p">(</span><span class="n">lpfc_grp_hdr_file_type</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="o">!=</span>
	     <span class="n">LPFC_FILE_TYPE_GROUP</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">bf_get_be32</span><span class="p">(</span><span class="n">lpfc_grp_hdr_id</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="o">!=</span> <span class="n">LPFC_FILE_ID_GROUP</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">!=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3022 Invalid FW image found. &quot;</span>
				<span class="s">&quot;Magic:%x Type:%x ID:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">magic_number</span><span class="p">),</span>
				<span class="n">bf_get_be32</span><span class="p">(</span><span class="n">lpfc_grp_hdr_file_type</span><span class="p">,</span> <span class="n">image</span><span class="p">),</span>
				<span class="n">bf_get_be32</span><span class="p">(</span><span class="n">lpfc_grp_hdr_id</span><span class="p">,</span> <span class="n">image</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_decode_firmware_rev</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fwrev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">fwrev</span><span class="p">,</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">,</span> <span class="n">strnlen</span><span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">,</span> <span class="mi">16</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3023 Updating Firmware. Current Version:%s &quot;</span>
				<span class="s">&quot;New Version:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">fwrev</span><span class="p">,</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPFC_MBX_WR_CONFIG_MAX_BDE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dmabuf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">),</span>
					 <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
							  <span class="n">SLI4_PAGE_SIZE</span><span class="p">,</span>
							  <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">,</span>
							  <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_buffer_list</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">temp_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_buffer_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">temp_offset</span> <span class="o">+</span> <span class="n">SLI4_PAGE_SIZE</span> <span class="o">&gt;</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">memcpy</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span>
					       <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">temp_offset</span><span class="p">,</span>
					       <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">temp_offset</span><span class="p">);</span>
					<span class="n">temp_offset</span> <span class="o">=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">temp_offset</span><span class="p">,</span>
				       <span class="n">SLI4_PAGE_SIZE</span><span class="p">);</span>
				<span class="n">temp_offset</span> <span class="o">+=</span> <span class="n">SLI4_PAGE_SIZE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_wr_object</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_buffer_list</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
						<span class="s">&quot;3024 Firmware update failed. &quot;</span>
						<span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_buffer_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">SLI4_PAGE_SIZE</span><span class="p">,</span>
				  <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_pci_probe_one_s4 - PCI probe func to reg SLI-4 device to PCI subsys</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> * @pid: pointer to PCI device identifier</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called from the kernel&#39;s PCI subsystem to device with</span>
<span class="cm"> * SLI-4 interface spec. When an Emulex HBA with SLI-4 interface spec is</span>
<span class="cm"> * presented on PCI bus, the kernel PCI subsystem looks at PCI device-specific</span>
<span class="cm"> * information of the device and driver to see if the driver state that it</span>
<span class="cm"> * can support this kind of device. If the match is successful, the driver</span>
<span class="cm"> * core invokes this routine. If this routine determines it can claim the HBA,</span>
<span class="cm"> * it does all the initialization that it needs to do to handle the HBA</span>
<span class="cm"> * properly.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> * 	0 - driver can claim the device</span>
<span class="cm"> * 	negative value - driver can not claim the device</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">lpfc_pci_probe_one_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_mode</span><span class="p">,</span> <span class="n">intr_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mcnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">adjusted_fcp_eq_count</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">file_name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="cm">/* Allocate memory for HBA structure */</span>
	<span class="n">phba</span> <span class="o">=</span> <span class="n">lpfc_hba_alloc</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Perform generic PCI device enabling operation */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_enable_pci_dev</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_phba</span><span class="p">;</span>

	<span class="cm">/* Set up SLI API function jump table for PCI-device group-1 HBAs */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_api_table_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_PCI_DEV_OC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_disable_pci_dev</span><span class="p">;</span>

	<span class="cm">/* Set up SLI-4 specific device PCI memory space */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_sli4_pci_mem_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1410 Failed to set up pci memory space.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_disable_pci_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up phase-1 common device driver resources */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_setup_driver_resource_phase1</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1411 Failed to set up driver resource.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unset_pci_mem_s4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up SLI-4 Specific device driver resources */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_sli4_driver_resource_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1412 Failed to set up driver resource.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unset_pci_mem_s4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize and populate the iocb list per host */</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2821 initialize iocb list %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_iocb_cnt</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_init_iocb_list</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_iocb_cnt</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1413 Failed to initialize iocb list.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unset_driver_resource_s4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">active_rrq_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri_list</span><span class="p">);</span>

	<span class="cm">/* Set up common device driver resources */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_setup_driver_resource_phase2</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1414 Failed to set up driver resource.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_iocb_list</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the default values for Model Name and Description */</span>
	<span class="n">lpfc_get_hba_model_desc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelName</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelDesc</span><span class="p">);</span>

	<span class="cm">/* Create SCSI host to the physical port */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_create_shost</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1415 Failed to create scsi host.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unset_driver_resource</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Configure sysfs attributes */</span>
	<span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lpfc_alloc_sysfs_attr</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1416 Failed to allocate sysfs attr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_destroy_shost</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span> <span class="cm">/* save shost for error cleanup */</span>
	<span class="cm">/* Now, trying to enable interrupt and bring up the device */</span>
	<span class="n">cfg_mode</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_use_msi</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Put device to a known state before enabling interrupt */</span>
		<span class="n">lpfc_stop_port</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="cm">/* Configure and enable interrupt */</span>
		<span class="n">intr_mode</span> <span class="o">=</span> <span class="n">lpfc_sli4_enable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cfg_mode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intr_mode</span> <span class="o">==</span> <span class="n">LPFC_INTR_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0426 Failed to enable interrupt.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free_sysfs_attr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Default to single EQ for non-MSI-X */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">!=</span> <span class="n">MSIX</span><span class="p">)</span>
			<span class="n">adjusted_fcp_eq_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_vec_nr</span> <span class="o">&lt;</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">adjusted_fcp_eq_count</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">msix_vec_nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">adjusted_fcp_eq_count</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span> <span class="o">=</span> <span class="n">adjusted_fcp_eq_count</span><span class="p">;</span>
		<span class="cm">/* Set up SLI-4 HBA */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli4_hba_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;1421 Failed to set up hba</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_disable_intr</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Send NOP mbx cmds for non-INTx mode active interrupt test */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intr_mode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mcnt</span> <span class="o">=</span> <span class="n">lpfc_sli4_send_nop_mbox_cmds</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
							    <span class="n">LPFC_ACT_INTR_CNT</span><span class="p">);</span>

		<span class="cm">/* Check active interrupts received only for MSI/MSI-X */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intr_mode</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">slistat</span><span class="p">.</span><span class="n">sli_intr</span> <span class="o">&gt;=</span> <span class="n">LPFC_ACT_INTR_CNT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Log the current active interrupt mode */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_mode</span> <span class="o">=</span> <span class="n">intr_mode</span><span class="p">;</span>
			<span class="n">lpfc_log_intr_mode</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">intr_mode</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0451 Configure interrupt mode (%d) &quot;</span>
				<span class="s">&quot;failed active interrupt test.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">intr_mode</span><span class="p">);</span>
		<span class="cm">/* Unset the previous SLI-4 HBA setup. */</span>
		<span class="cm">/*</span>
<span class="cm">		 * TODO:  Is this operation compatible with IF TYPE 2</span>
<span class="cm">		 * devices?  All port state is deleted and cleared.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_sli4_unset_hba</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="cm">/* Try next level of interrupt mode */</span>
		<span class="n">cfg_mode</span> <span class="o">=</span> <span class="o">--</span><span class="n">intr_mode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Perform post initialization setup */</span>
	<span class="n">lpfc_post_init_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* check for firmware upgrade or downgrade (if_type 2 only) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">LPFC_SLI_INTF_IF_TYPE_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="s">&quot;%s.grp&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelName</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">request_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_write_firmware</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fw</span><span class="p">);</span>
			<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check if there are static vports to be created. */</span>
	<span class="n">lpfc_create_static_vport</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_disable_intr:</span>
	<span class="n">lpfc_sli4_disable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_free_sysfs_attr:</span>
	<span class="n">lpfc_free_sysfs_attr</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
<span class="nl">out_destroy_shost:</span>
	<span class="n">lpfc_destroy_shost</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_unset_driver_resource:</span>
	<span class="n">lpfc_unset_driver_resource_phase2</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_free_iocb_list:</span>
	<span class="n">lpfc_free_iocb_list</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_unset_driver_resource_s4:</span>
	<span class="n">lpfc_sli4_driver_resource_unset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_unset_pci_mem_s4:</span>
	<span class="n">lpfc_sli4_pci_mem_unset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_disable_pci_dev:</span>
	<span class="n">lpfc_disable_pci_dev</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="p">)</span>
		<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
<span class="nl">out_free_phba:</span>
	<span class="n">lpfc_hba_free</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_pci_remove_one_s4 - PCI func to unreg SLI-4 device from PCI subsystem</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called from the kernel&#39;s PCI subsystem to device with</span>
<span class="cm"> * SLI-4 interface spec. When an Emulex HBA with SLI-4 interface spec is</span>
<span class="cm"> * removed from PCI bus, it performs all the necessary cleanup for the HBA</span>
<span class="cm"> * device to be removed from the PCI subsystem properly.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span>
<span class="nf">lpfc_pci_remove_one_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Mark the device unloading flag */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">|=</span> <span class="n">FC_UNLOADING</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Free the HBA sysfs attributes */</span>
	<span class="n">lpfc_free_sysfs_attr</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/* Release all the vports against this physical port */</span>
	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_PHYSICAL_PORT</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">fc_vport_terminate</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_vport</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>

	<span class="cm">/* Remove FC host and then SCSI host with the physical port */</span>
	<span class="n">fc_remove_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="cm">/* Perform cleanup on the physical port */</span>
	<span class="n">lpfc_cleanup</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bring down the SLI Layer. This step disables all interrupts,</span>
<span class="cm">	 * clears the rings, discards all mailbox commands, and resets</span>
<span class="cm">	 * the HBA FCoE function.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_debugfs_terminate</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">lpfc_sli4_hba_unset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">listentry</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Perform scsi free before driver resource_unset since scsi</span>
<span class="cm">	 * buffers are released to their corresponding pools here.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_scsi_free</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_sli4_driver_resource_unset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Unmap adapter Control and Doorbell registers */</span>
	<span class="n">lpfc_sli4_pci_mem_unset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Release PCI resources and disable device&#39;s PCI function */</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">lpfc_disable_pci_dev</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Finally, free the driver&#39;s device data structure */</span>
	<span class="n">lpfc_hba_free</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_pci_suspend_one_s4 - PCI func to suspend SLI-4 device for power mgmnt</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> * @msg: power management message</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called from the kernel&#39;s PCI subsystem to support system</span>
<span class="cm"> * Power Management (PM) to device with SLI-4 interface spec. When PM invokes</span>
<span class="cm"> * this method, it quiesces the device by stopping the driver&#39;s worker</span>
<span class="cm"> * thread for the device, turning off device&#39;s interrupt and DMA, and bring</span>
<span class="cm"> * the device offline. Note that as the driver implements the minimum PM</span>
<span class="cm"> * requirements to a power-aware driver&#39;s PM support for suspend/resume -- all</span>
<span class="cm"> * the possible PM messages (SUSPEND, HIBERNATE, FREEZE) to the suspend()</span>
<span class="cm"> * method call will be treated as SUSPEND and the driver will fully</span>
<span class="cm"> * reinitialize its device during resume() method call, the driver will set</span>
<span class="cm"> * device to PCI_D3hot state in PCI config space instead of setting it</span>
<span class="cm"> * according to the @msg provided by the PM.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> * 	0 - driver suspended the device</span>
<span class="cm"> * 	Error otherwise</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_pci_suspend_one_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2843 PCI device Power Management suspend.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Bring down the device */</span>
	<span class="n">lpfc_offline_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span><span class="p">);</span>

	<span class="cm">/* Disable interrupt from device */</span>
	<span class="n">lpfc_sli4_disable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_sli4_queue_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Save device state to PCI config space */</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_pci_resume_one_s4 - PCI func to resume SLI-4 device for power mgmnt</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called from the kernel&#39;s PCI subsystem to support system</span>
<span class="cm"> * Power Management (PM) to device with SLI-4 interface spac. When PM invokes</span>
<span class="cm"> * this method, it restores the device&#39;s PCI config space state and fully</span>
<span class="cm"> * reinitializes the device and brings it online. Note that as the driver</span>
<span class="cm"> * implements the minimum PM requirements to a power-aware driver&#39;s PM for</span>
<span class="cm"> * suspend/resume -- all the possible PM messages (SUSPEND, HIBERNATE, FREEZE)</span>
<span class="cm"> * to the suspend() method call will be treated as SUSPEND and the driver</span>
<span class="cm"> * will fully reinitialize its device during resume() method call, the device</span>
<span class="cm"> * will be set to PCI_D0 directly in PCI config space before restoring the</span>
<span class="cm"> * state.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> * 	0 - driver suspended the device</span>
<span class="cm"> * 	Error otherwise</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_pci_resume_one_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">intr_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0292 PCI device Power Management resume.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Restore device state from PCI config space */</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * As the new kernel behavior of pci_restore_state() API call clears</span>
<span class="cm">	 * device saved_state flag, need to save the restored state again.</span>
<span class="cm">	 */</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">is_busmaster</span><span class="p">)</span>
		<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	 <span class="cm">/* Startup the kernel thread for this host adapter. */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">lpfc_do_work</span><span class="p">,</span> <span class="n">phba</span><span class="p">,</span>
					<span class="s">&quot;lpfc_worker_%d&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">brd_no</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">worker_thread</span><span class="p">);</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0293 PM resume failed to start worker &quot;</span>
				<span class="s">&quot;thread: error=x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Configure and enable interrupt */</span>
	<span class="n">intr_mode</span> <span class="o">=</span> <span class="n">lpfc_sli4_enable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr_mode</span> <span class="o">==</span> <span class="n">LPFC_INTR_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0294 PM resume Failed to enable interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_mode</span> <span class="o">=</span> <span class="n">intr_mode</span><span class="p">;</span>

	<span class="cm">/* Restart HBA and bring it online */</span>
	<span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_online</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Log the current active interrupt mode */</span>
	<span class="n">lpfc_log_intr_mode</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_prep_dev_for_recover - Prepare SLI4 device for pci slot recover</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called to prepare the SLI4 device for PCI slot recover. It</span>
<span class="cm"> * aborts all the outstanding SCSI I/Os to the pci device.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_prep_dev_for_recover</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span>  <span class="o">*</span><span class="n">pring</span><span class="p">;</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2828 PCI channel I/O abort preparing for recovery</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * There may be errored I/Os through HBA, abort all I/Os on txcmplq</span>
<span class="cm">	 * and let the SCSI mid-layer to retry them to recover.</span>
<span class="cm">	 */</span>
	<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">fcp_ring</span><span class="p">];</span>
	<span class="n">lpfc_sli_abort_iocb_ring</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_prep_dev_for_reset - Prepare SLI4 device for pci slot reset</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called to prepare the SLI4 device for PCI slot reset. It</span>
<span class="cm"> * disables the device interrupt and pci device, and aborts the internal FCP</span>
<span class="cm"> * pending I/Os.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_prep_dev_for_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2826 PCI channel disable preparing for reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Block any management I/Os to the device */</span>
	<span class="n">lpfc_block_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Block all SCSI devices&#39; I/Os on the host */</span>
	<span class="n">lpfc_scsi_dev_block</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* stop all timers */</span>
	<span class="n">lpfc_stop_hba_timers</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Disable interrupt and pci device */</span>
	<span class="n">lpfc_sli4_disable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_sli4_queue_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>

	<span class="cm">/* Flush all driver&#39;s outstanding SCSI I/Os as we are to reset */</span>
	<span class="n">lpfc_sli_flush_fcp_rings</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_prep_dev_for_perm_failure - Prepare SLI4 dev for pci slot disable</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called to prepare the SLI4 device for PCI slot permanently</span>
<span class="cm"> * disabling. It blocks the SCSI transport layer traffic and flushes the FCP</span>
<span class="cm"> * pending I/Os.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_prep_dev_for_perm_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2827 PCI channel permanent disable for failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Block all SCSI devices&#39; I/Os on the host */</span>
	<span class="n">lpfc_scsi_dev_block</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* stop all timers */</span>
	<span class="n">lpfc_stop_hba_timers</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Clean up all driver&#39;s outstanding SCSI I/Os */</span>
	<span class="n">lpfc_sli_flush_fcp_rings</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_io_error_detected_s4 - Method for handling PCI I/O error to SLI-4 device</span>
<span class="cm"> * @pdev: pointer to PCI device.</span>
<span class="cm"> * @state: the current PCI connection state.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called from the PCI subsystem for error handling to device</span>
<span class="cm"> * with SLI-4 interface spec. This function is called by the PCI subsystem</span>
<span class="cm"> * after a PCI bus error affecting this device has been detected. When this</span>
<span class="cm"> * function is invoked, it will need to stop all the I/Os and interrupt(s)</span>
<span class="cm"> * to the device. Once that is done, it will return PCI_ERS_RESULT_NEED_RESET</span>
<span class="cm"> * for the PCI subsystem to perform proper recovery as desired.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	PCI_ERS_RESULT_NEED_RESET - need to reset before recovery</span>
<span class="cm"> * 	PCI_ERS_RESULT_DISCONNECT - device could not be recovered</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span>
<span class="nf">lpfc_io_error_detected_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_channel_state_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">pci_channel_io_normal</span>:
		<span class="cm">/* Non-fatal error, prepare for recovery */</span>
		<span class="n">lpfc_sli4_prep_dev_for_recover</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_CAN_RECOVER</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">pci_channel_io_frozen</span>:
		<span class="cm">/* Fatal error, prepare for slot reset */</span>
		<span class="n">lpfc_sli4_prep_dev_for_reset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">pci_channel_io_perm_failure</span>:
		<span class="cm">/* Permanent failure, prepare for device down */</span>
		<span class="n">lpfc_sli4_prep_dev_for_perm_failure</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Unknown state, prepare and request slot reset */</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2825 Unknown PCI error state: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="n">lpfc_sli4_prep_dev_for_reset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_io_slot_reset_s4 - Method for restart PCI SLI-4 device from scratch</span>
<span class="cm"> * @pdev: pointer to PCI device.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called from the PCI subsystem for error handling to device</span>
<span class="cm"> * with SLI-4 interface spec. It is called after PCI bus has been reset to</span>
<span class="cm"> * restart the PCI card from scratch, as if from a cold-boot. During the</span>
<span class="cm"> * PCI subsystem error recovery, after the driver returns</span>
<span class="cm"> * PCI_ERS_RESULT_NEED_RESET, the PCI subsystem will perform proper error</span>
<span class="cm"> * recovery and then call this routine before calling the .resume method to</span>
<span class="cm"> * recover the device. This function will initialize the HBA device, enable</span>
<span class="cm"> * the interrupt, but it will just put the HBA to offline state without</span>
<span class="cm"> * passing any I/O traffic.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	PCI_ERS_RESULT_RECOVERED - the device has been recovered</span>
<span class="cm"> * 	PCI_ERS_RESULT_DISCONNECT - device could not be recovered</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span>
<span class="nf">lpfc_io_slot_reset_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">intr_mode</span><span class="p">;</span>

	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;recovering from a slot reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;lpfc: Cannot re-enable &quot;</span>
			<span class="s">&quot;PCI device after reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * As the new kernel behavior of pci_restore_state() API call clears</span>
<span class="cm">	 * device saved_state flag, need to save the restored state again.</span>
<span class="cm">	 */</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">is_busmaster</span><span class="p">)</span>
		<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_ACTIVE</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Configure and enable interrupt */</span>
	<span class="n">intr_mode</span> <span class="o">=</span> <span class="n">lpfc_sli4_enable_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr_mode</span> <span class="o">==</span> <span class="n">LPFC_INTR_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2824 Cannot re-enable interrupt after &quot;</span>
				<span class="s">&quot;slot reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_mode</span> <span class="o">=</span> <span class="n">intr_mode</span><span class="p">;</span>

	<span class="cm">/* Log the current active interrupt mode */</span>
	<span class="n">lpfc_log_intr_mode</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_mode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">PCI_ERS_RESULT_RECOVERED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_io_resume_s4 - Method for resuming PCI I/O operation to SLI-4 device</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called from the PCI subsystem for error handling to device</span>
<span class="cm"> * with SLI-4 interface spec. It is called when kernel error recovery tells</span>
<span class="cm"> * the lpfc driver that it is ok to resume normal PCI operation after PCI bus</span>
<span class="cm"> * error recovery. After this call, traffic can start to flow from this device</span>
<span class="cm"> * again.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_io_resume_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case of slot reset, as function reset is performed through</span>
<span class="cm">	 * mailbox command which needs DMA to be enabled, this operation</span>
<span class="cm">	 * has to be moved to the io resume phase. Taking device offline</span>
<span class="cm">	 * will perform the necessary cleanup.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Perform device reset */</span>
		<span class="n">lpfc_offline_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="n">lpfc_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="cm">/* Bring the device back online */</span>
		<span class="n">lpfc_online</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Clean up Advanced Error Reporting (AER) if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_AER_ENABLED</span><span class="p">)</span>
		<span class="n">pci_cleanup_aer_uncorrect_error_status</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_pci_probe_one - lpfc PCI probe func to reg dev to PCI subsystem</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> * @pid: pointer to PCI device identifier</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to be registered to the kernel&#39;s PCI subsystem. When an</span>
<span class="cm"> * Emulex HBA device is presented on PCI bus, the kernel PCI subsystem looks</span>
<span class="cm"> * at PCI device-specific information of the device and driver to see if the</span>
<span class="cm"> * driver state that it can support this kind of device. If the match is</span>
<span class="cm"> * successful, the driver core invokes this routine. This routine dispatches</span>
<span class="cm"> * the action to the proper SLI-3 or SLI-4 device probing routine, which will</span>
<span class="cm"> * do all the initialization that it needs to do to handle the HBA device</span>
<span class="cm"> * properly.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> * 	0 - driver can claim the device</span>
<span class="cm"> * 	negative value - driver can not claim the device</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">lpfc_pci_probe_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_intf</span> <span class="n">intf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">LPFC_SLI_INTF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intf</span><span class="p">.</span><span class="n">word0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_valid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intf</span><span class="p">)</span> <span class="o">==</span> <span class="n">LPFC_SLI_INTF_VALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_slirev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intf</span><span class="p">)</span> <span class="o">==</span> <span class="n">LPFC_SLI_INTF_REV_SLI4</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_pci_probe_one_s4</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_pci_probe_one_s3</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_pci_remove_one - lpfc PCI func to unreg dev from PCI subsystem</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to be registered to the kernel&#39;s PCI subsystem. When an</span>
<span class="cm"> * Emulex HBA is removed from PCI bus, the driver core invokes this routine.</span>
<span class="cm"> * This routine dispatches the action to the proper SLI-3 or SLI-4 device</span>
<span class="cm"> * remove routine, which will perform all the necessary cleanup for the</span>
<span class="cm"> * device to be removed from the PCI subsystem properly.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span>
<span class="nf">lpfc_pci_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_LP</span>:
		<span class="n">lpfc_pci_remove_one_s3</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_OC</span>:
		<span class="n">lpfc_pci_remove_one_s4</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1424 Invalid PCI device group: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_pci_suspend_one - lpfc PCI func to suspend dev for power management</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> * @msg: power management message</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to be registered to the kernel&#39;s PCI subsystem to support</span>
<span class="cm"> * system Power Management (PM). When PM invokes this method, it dispatches</span>
<span class="cm"> * the action to the proper SLI-3 or SLI-4 device suspend routine, which will</span>
<span class="cm"> * suspend the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> * 	0 - driver suspended the device</span>
<span class="cm"> * 	Error otherwise</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_pci_suspend_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_LP</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_pci_suspend_one_s3</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_OC</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_pci_suspend_one_s4</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1425 Invalid PCI device group: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_pci_resume_one - lpfc PCI func to resume dev for power management</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to be registered to the kernel&#39;s PCI subsystem to support</span>
<span class="cm"> * system Power Management (PM). When PM invokes this method, it dispatches</span>
<span class="cm"> * the action to the proper SLI-3 or SLI-4 device resume routine, which will</span>
<span class="cm"> * resume the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> * 	0 - driver suspended the device</span>
<span class="cm"> * 	Error otherwise</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_pci_resume_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_LP</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_pci_resume_one_s3</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_OC</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_pci_resume_one_s4</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1426 Invalid PCI device group: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_io_error_detected - lpfc method for handling PCI I/O error</span>
<span class="cm"> * @pdev: pointer to PCI device.</span>
<span class="cm"> * @state: the current PCI connection state.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is registered to the PCI subsystem for error handling. This</span>
<span class="cm"> * function is called by the PCI subsystem after a PCI bus error affecting</span>
<span class="cm"> * this device has been detected. When this routine is invoked, it dispatches</span>
<span class="cm"> * the action to the proper SLI-3 or SLI-4 device error detected handling</span>
<span class="cm"> * routine, which will perform the proper error detected operation.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	PCI_ERS_RESULT_NEED_RESET - need to reset before recovery</span>
<span class="cm"> * 	PCI_ERS_RESULT_DISCONNECT - device could not be recovered</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span>
<span class="nf">lpfc_io_error_detected</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_channel_state_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">pci_ers_result_t</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_LP</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_io_error_detected_s3</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_OC</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_io_error_detected_s4</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1427 Invalid PCI device group: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_io_slot_reset - lpfc method for restart PCI dev from scratch</span>
<span class="cm"> * @pdev: pointer to PCI device.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is registered to the PCI subsystem for error handling. This</span>
<span class="cm"> * function is called after PCI bus has been reset to restart the PCI card</span>
<span class="cm"> * from scratch, as if from a cold-boot. When this routine is invoked, it</span>
<span class="cm"> * dispatches the action to the proper SLI-3 or SLI-4 device reset handling</span>
<span class="cm"> * routine, which will perform the proper device reset.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	PCI_ERS_RESULT_RECOVERED - the device has been recovered</span>
<span class="cm"> * 	PCI_ERS_RESULT_DISCONNECT - device could not be recovered</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span>
<span class="nf">lpfc_io_slot_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">pci_ers_result_t</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_LP</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_io_slot_reset_s3</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_OC</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_io_slot_reset_s4</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1428 Invalid PCI device group: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_io_resume - lpfc method for resuming PCI I/O operation</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is registered to the PCI subsystem for error handling. It</span>
<span class="cm"> * is called when kernel error recovery tells the lpfc driver that it is</span>
<span class="cm"> * OK to resume normal PCI operation after PCI bus error recovery. When</span>
<span class="cm"> * this routine is invoked, it dispatches the action to the proper SLI-3</span>
<span class="cm"> * or SLI-4 device io_resume routine, which will resume the device operation.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_io_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_LP</span>:
		<span class="n">lpfc_io_resume_s3</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_OC</span>:
		<span class="n">lpfc_io_resume_s4</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1429 Invalid PCI device group: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pci_dev_grp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mgmt_open - method called when &#39;lpfcmgmt&#39; is opened from userspace</span>
<span class="cm"> * @inode: pointer to the inode representing the lpfcmgmt device</span>
<span class="cm"> * @filep: pointer to the file representing the open lpfcmgmt device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine puts a reference count on the lpfc module whenever the</span>
<span class="cm"> * character device is opened</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_mgmt_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">try_module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mgmt_release - method called when &#39;lpfcmgmt&#39; is closed in userspace</span>
<span class="cm"> * @inode: pointer to the inode representing the lpfcmgmt device</span>
<span class="cm"> * @filep: pointer to the file representing the open lpfcmgmt device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine removes a reference count from the lpfc module when the</span>
<span class="cm"> * character device is closed</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_mgmt_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">lpfc_id_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIPER</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_FIREFLY</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_THOR</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_PEGASUS</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_CENTAUR</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_DRAGONFLY</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SUPERFLY</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_RFLY</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_PFLY</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NEPTUNE</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NEPTUNE_SCSP</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NEPTUNE_DCSP</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_HELIOS</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_HELIOS_SCSP</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_HELIOS_DCSP</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_BMID</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_BSMB</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ZEPHYR</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_HORNET</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ZEPHYR_SCSP</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ZEPHYR_DCSP</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ZMID</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ZSMB</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_TFLY</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LP101</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LP10000S</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LP11000S</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LPE11000S</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SAT</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SAT_MID</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SAT_SMB</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SAT_DCSP</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SAT_SCSP</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SAT_S</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_PROTEUS_VF</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_PROTEUS_PF</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_PROTEUS_S</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_SERVERENGINE</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_TIGERSHARK</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_SERVERENGINE</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_TOMCAT</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_FALCON</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_BALIUS</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LANCER_FC</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LANCER_FCOE</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LANCER_FC_VF</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_EMULEX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LANCER_FCOE_VF</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">lpfc_id_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_error_handlers</span> <span class="n">lpfc_err_handler</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">error_detected</span> <span class="o">=</span> <span class="n">lpfc_io_error_detected</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slot_reset</span> <span class="o">=</span> <span class="n">lpfc_io_slot_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">lpfc_io_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">lpfc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">LPFC_DRIVER_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">lpfc_id_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">lpfc_pci_probe_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">lpfc_pci_remove_one</span><span class="p">),</span>
	<span class="p">.</span><span class="n">suspend</span>        <span class="o">=</span> <span class="n">lpfc_pci_suspend_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">lpfc_pci_resume_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">err_handler</span>    <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpfc_err_handler</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">lpfc_mgmt_fop</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">lpfc_mgmt_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">lpfc_mgmt_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">lpfc_mgmt_dev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="n">MISC_DYNAMIC_MINOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;lpfcmgmt&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpfc_mgmt_fop</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_init - lpfc module initialization routine</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to be invoked when the lpfc module is loaded into the</span>
<span class="cm"> * kernel. The special kernel macro module_init() is used to indicate the</span>
<span class="cm"> * role of this routine to the kernel as lpfc module entry point.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - successful</span>
<span class="cm"> *   -ENOMEM - FC attach transport failed</span>
<span class="cm"> *   all others - failed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">lpfc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">LPFC_MODULE_DESC</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">LPFC_COPYRIGHT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpfc_mgmt_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Could not register lpfcmgmt device, &quot;</span>
			<span class="s">&quot;misc_register returned with status %d&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_enable_npiv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_transport_functions</span><span class="p">.</span><span class="n">vport_create</span> <span class="o">=</span> <span class="n">lpfc_vport_create</span><span class="p">;</span>
		<span class="n">lpfc_transport_functions</span><span class="p">.</span><span class="n">vport_delete</span> <span class="o">=</span> <span class="n">lpfc_vport_delete</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_transport_template</span> <span class="o">=</span>
				<span class="n">fc_attach_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpfc_transport_functions</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_transport_template</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_enable_npiv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_vport_transport_template</span> <span class="o">=</span>
			<span class="n">fc_attach_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpfc_vport_transport_functions</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_vport_transport_template</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fc_release_transport</span><span class="p">(</span><span class="n">lpfc_transport_template</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpfc_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc_release_transport</span><span class="p">(</span><span class="n">lpfc_transport_template</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_enable_npiv</span><span class="p">)</span>
			<span class="n">fc_release_transport</span><span class="p">(</span><span class="n">lpfc_vport_transport_template</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_exit - lpfc module removal routine</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked when the lpfc module is removed from the kernel.</span>
<span class="cm"> * The special kernel macro module_exit() is used to indicate the role of</span>
<span class="cm"> * this routine to the kernel as lpfc module exit point.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span>
<span class="nf">lpfc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpfc_mgmt_dev</span><span class="p">);</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpfc_driver</span><span class="p">);</span>
	<span class="n">fc_release_transport</span><span class="p">(</span><span class="n">lpfc_transport_template</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_enable_npiv</span><span class="p">)</span>
		<span class="n">fc_release_transport</span><span class="p">(</span><span class="n">lpfc_vport_transport_template</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_dump_buf_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>	<span class="s">&quot;9062 BLKGRD: freeing %lu pages for &quot;</span>
				<span class="s">&quot;_dump_buf_data at 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">_dump_buf_data_order</span><span class="p">),</span> <span class="n">_dump_buf_data</span><span class="p">);</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_dump_buf_data</span><span class="p">,</span> <span class="n">_dump_buf_data_order</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_dump_buf_dif</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>	<span class="s">&quot;9049 BLKGRD: freeing %lu pages for &quot;</span>
				<span class="s">&quot;_dump_buf_dif at 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">_dump_buf_dif_order</span><span class="p">),</span> <span class="n">_dump_buf_dif</span><span class="p">);</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_dump_buf_dif</span><span class="p">,</span> <span class="n">_dump_buf_dif_order</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">lpfc_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">lpfc_exit</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">LPFC_MODULE_DESC</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Emulex Corporation - tech.support@emulex.com&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="s">&quot;0:&quot;</span> <span class="n">LPFC_DRIVER_VERSION</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
